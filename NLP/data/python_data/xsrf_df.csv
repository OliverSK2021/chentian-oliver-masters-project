,id,code,label
0,59fdbf02dac752fd22cb87eb4bea59d599b333dd,"grab-monorail.py/n/n#!/usr/bin/env python3
import argparse
import glob
import logging
import os
import re
import requests
import subprocess
import sys

OSS_FUZZ_BUGURL = ""https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=""
DOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='

testcase_pattern = re.compile(r'https://oss-fuzz\.com/testcase\?key=(\d+)')
proto_pattern = r'\\nFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\\n'

parser = argparse.ArgumentParser()
parser.add_argument(""--debug"", action=""store_true"", help=""Enable verbose logging"")
parser.add_argument(""--cookie-file"", ""-c"", help=""File containing cookie value"")

# Pass through options
reporter_params = [
    (""report"", None),
    (""timeout"", int),
    (""memlimit"", int),
    (""memleaks"", None),
]
for name, arg_type in reporter_params:
    args = [""--"" + name]
    kwargs = {}
    if arg_type:
        kwargs[""type""] = arg_type
    else:
        kwargs[""action""] = ""store_true""
    kwargs[""default""] = None
    kwargs[""help""] = ""Option is passed to the reporter""
    parser.add_argument(*args, **kwargs)
parser.add_argument(""--reporter-args"", ""-r"", help=""Options to pass through"")


parser.add_argument(""issue_id"", type=int)
args = parser.parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG)

def fatal(*args):
    logging.error(*args)
    sys.exit(1)

def parse_cookies(text):
    cookies = {}
    for m in re.finditer(r'(SACSID)\s+(~[0-9a-zA-Z_-]+)\s+([a-z.-]+)(?:\s|$)', text):
        key, value, domain = m.groups()
        cookies[domain] = (key, value)
    # compatibility with Netscape cookie jar
    garbage = r'(?:TRUE|FALSE)\s+/\s+(?:TRUE|FALSE)\s+\d+\s+'
    cj_pattern = r'([a-z.-]+)\s+' + garbage + r'(SACSID)\s+(~[0-9a-zA-Z_-]+)(?:\s+|$)'
    for m in re.finditer(cj_pattern, text):
        domain, key, value = m.groups()
        cookies[domain] = (key, value)
    if any(not d in cookies for d in [""bugs.chromium.org"", ""oss-fuzz.com""]):
        fatal(""Missing domains, got: %s"", "" "".join(cookies.keys()))
    return cookies

cookie_file = args.cookie_file
if not cookie_file:
    # TODO maybe fallback to a default location?
    parser.error(""Missing cookie file"")
sid_cookies = parse_cookies(open(cookie_file).read().strip())

session = requests.Session()
for domain, (key, value) in sid_cookies.items():
    session.cookies.set(key, value, domain=domain)

# Fetch bug contents
issue_id = str(args.issue_id)
bugurl = OSS_FUZZ_BUGURL + issue_id
r = session.get(bugurl)
r.raise_for_status()

# Look for ID
pat = re.search(testcase_pattern, r.text)
if not pat:
    fatal('Cannot find testcase ID')
testcase_id = pat.group(1)

# Look for type (IP, etc.)
pat = re.search(proto_pattern, r.text)
if not pat:
    # XXX maybe assume IP?
    fatal('Protocol not found')
protocol = pat.group(1)

attachment_name = None
# Try to locate existing file
for prefix in [""clusterfuzz-testcase-minimized-"", ""clusterfuzz-testcase-""]:
    for suffix in ['', '.pcap']:
        name = prefix + testcase_id + suffix
        if os.path.exists(name):
            attachment_name = name
            break

# Download the attachment if missing
if attachment_name is None:
    att_url = DOWNLOAD_URL + testcase_id
    r = session.get(att_url, stream=True)
    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])
    if not pat:
        fatal('Cannot parse header: %s', r.headers['content-disposition'])
    attachment_name = pat.group(1)
    try:
        # Open without overwriting existing contents.
        with open(attachment_name, 'xb') as f:
            for chunk in r.iter_content(chunk_size=4096):
                f.write(chunk)
        logging.info(""Downloaded: %s"", attachment_name)
    except FileExistsError:
        # Ignore existing file.
        pass

cmd = [
    ""oss-fuzz-report.py"",
    ""--proto"", protocol,
    attachment_name,
    issue_id
]
if args.reporter_args:
    cmd += args.reporter_args.split()
for name, arg_type in reporter_params:
    value = getattr(args, name)
    if value is not None:
        cmd.append(""--"" + name)
        if arg_type:
            cmd.append(str(value))
print(' '.join(cmd))

os.execvp(cmd[0], cmd)
/n/n/n",0
1,59fdbf02dac752fd22cb87eb4bea59d599b333dd,"/grab-monorail.py/n/n#!/usr/bin/env python3
import argparse
import glob
import logging
import os
import re
import requests
import subprocess
import sys

OSS_FUZZ_BUGURL = ""https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=""
DOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='

testcase_pattern = re.compile(r'https://oss-fuzz\.com/testcase\?key=(\d+)')
proto_pattern = r'\bFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\b'

parser = argparse.ArgumentParser()
parser.add_argument(""--debug"", action=""store_true"", help=""Enable verbose logging"")
parser.add_argument(""--cookie-file"", ""-c"", help=""File containing cookie value"")

# Pass through options
reporter_params = [
    (""report"", None),
    (""timeout"", int),
    (""memlimit"", int),
    (""memleaks"", None),
]
for name, arg_type in reporter_params:
    args = [""--"" + name]
    kwargs = {}
    if arg_type:
        kwargs[""type""] = arg_type
    else:
        kwargs[""action""] = ""store_true""
    kwargs[""default""] = None
    kwargs[""help""] = ""Option is passed to the reporter""
    parser.add_argument(*args, **kwargs)
parser.add_argument(""--reporter-args"", ""-r"", help=""Options to pass through"")


parser.add_argument(""issue_id"", type=int)
args = parser.parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG)

def fatal(*args):
    logging.error(*args)
    sys.exit(1)

def parse_cookies(text):
    cookies = {}
    for m in re.finditer(r'(SACSID)\s+(~[0-9a-zA-Z_-]+)\s+([a-z.-]+)(?:\s|$)', text):
        key, value, domain = m.groups()
        cookies[domain] = (key, value)
    # compatibility with Netscape cookie jar
    garbage = r'(?:TRUE|FALSE)\s+/\s+(?:TRUE|FALSE)\s+\d+\s+'
    cj_pattern = r'([a-z.-]+)\s+' + garbage + r'(SACSID)\s+(~[0-9a-zA-Z_-]+)(?:\s+|$)'
    for m in re.finditer(cj_pattern, text):
        domain, key, value = m.groups()
        cookies[domain] = (key, value)
    if any(not d in cookies for d in [""bugs.chromium.org"", ""oss-fuzz.com""]):
        fatal(""Missing domains, got: %s"", "" "".join(cookies.keys()))
    return cookies

cookie_file = args.cookie_file
if not cookie_file:
    # TODO maybe fallback to a default location?
    parser.error(""Missing cookie file"")
sid_cookies = parse_cookies(open(cookie_file).read().strip())

session = requests.Session()
for domain, (key, value) in sid_cookies.items():
    session.cookies.set(key, value, domain=domain)

# Fetch bug contents
issue_id = str(args.issue_id)
bugurl = OSS_FUZZ_BUGURL + issue_id
r = session.get(bugurl)
r.raise_for_status()

# Look for ID
pat = re.search(testcase_pattern, r.text)
if not pat:
    fatal('Cannot find testcase ID')
testcase_id = pat.group(1)

# Look for type (IP, etc.)
pat = re.search(proto_pattern, r.text)
if not pat:
    # XXX maybe assume IP?
    fatal('Protocol not found')
protocol = pat.group(1)

attachment_name = None
# Try to locate existing file
for prefix in [""clusterfuzz-testcase-minimized-"", ""clusterfuzz-testcase-""]:
    for suffix in ['', '.pcap']:
        name = prefix + testcase_id + suffix
        if os.path.exists(name):
            attachment_name = name
            break

# Download the attachment if missing
if attachment_name is None:
    att_url = DOWNLOAD_URL + testcase_id
    r = session.get(att_url, stream=True)
    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])
    if not pat:
        fatal('Cannot parse header: %s', r.headers['content-disposition'])
    attachment_name = pat.group(1)
    try:
        # Open without overwriting existing contents.
        with open(attachment_name, 'xb') as f:
            for chunk in r.iter_content(chunk_size=4096):
                f.write(chunk)
        logging.info(""Downloaded: %s"", attachment_name)
    except FileExistsError:
        # Ignore existing file.
        pass

cmd = [
    ""oss-fuzz-report.py"",
    ""--proto"", protocol,
    attachment_name,
    issue_id
]
if args.reporter_args:
    cmd += args.reporter_args.split()
for name, arg_type in reporter_params:
    value = getattr(args, name)
    if value is not None:
        cmd.append(""--"" + name)
        if arg_type:
            cmd.append(str(value))
print(' '.join(cmd))

os.execvp(cmd[0], cmd)
/n/n/n",1
2,398ed11584313a371763240392c4dda1cf986deb,"core/logger.py/n/n#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-::-:-:#
#    XSRF Probe     #
#-:-:-:-:-:-:-::-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

import os
from core.colors import *
from files.config import *
from core.verbout import verbout
from files.discovered import INTERNAL_URLS, FILES_EXEC, SCAN_ERRORS
from files.discovered import VULN_LIST, FORMS_TESTED, REQUEST_TOKENS, STRENGTH_LIST

def logger(filename, content):
    '''
    This module is for logging all the stuff we found
            while crawling and scanning.
    '''
    output_file = OUTPUT_DIR + filename + '.log'
    with open(output_file, 'w+', encoding='utf8') as f:
        if type(content) is tuple or type(content) is list:
            for m in content:  # if it is list or tuple, it is iterable
                f.write(m+'\n')
        else:
            f.write(content)  # else we write out as it is... ;)
        f.write('\n')

def pheaders(tup):
    '''
    This module prints out the headers as received in the
                    requests normally.
    '''
    verbout(GR, 'Receiving headers...\n')
    verbout(color.GREY,'  '+color.UNDERLINE+'HEADERS'+color.END+color.GREY+':'+'\n')
    for key, val in tup.items():
        verbout('  ',color.CYAN+key+': '+color.ORANGE+val)
    verbout('','')

def GetLogger():
    if INTERNAL_URLS:
        logger('internal-links', INTERNAL_URLS)
    if SCAN_ERRORS:
        logger('errored', SCAN_ERRORS)
    if FILES_EXEC:
        logger('files-found', FILES_EXEC)
    if REQUEST_TOKENS:
        logger('anti-csrf-tokens', REQUEST_TOKENS)
    if FORMS_TESTED:
        logger('forms-tested', FORMS_TESTED)
    if VULN_LIST:
        logger('vulnerabilities', VULN_LIST)
    if STRENGTH_LIST:
        logger('strengths', STRENGTH_LIST)

def ErrorLogger(url, error):
    con = '(i) '+url+' -> '+error.__str__()
    SCAN_ERRORS.append(con)

def VulnLogger(url, vuln):
    tent = '[!] '+url+' -> '+vuln
    VULN_LIST.append(tent)

def NovulLogger(url, strength):
    tent = '[+] '+url+' -> '+strength
    STRENGTH_LIST.append(tent)
/n/n/ncore/main.py/n/n#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-:-:-:#
#    XSRFProbe     #
#-:-:-:-:-:-:-:-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

# Standard Package imports
import os
import re
import time
import warnings
import difflib
import http.cookiejar
from bs4 import BeautifulSoup
try:
    from urllib.parse import urlencode
    from urllib.error import HTTPError, URLError
    from urllib.request import build_opener, HTTPCookieProcessor
except ImportError:  # Throws exception in Case of Python2
    print(""\033[1;91m [-] \033[1;93mXSRFProbe\033[0m isn't compatible with Python 2.x versions.\n\033[1;91m [-] \033[0mUse Python 3.x to run \033[1;93mXSRFProbe."")
    quit()
try:
    import requests, stringdist, lxml, bs4
except ImportError:
    print(' [-] Required dependencies are not installed.\n [-] Run \033[1;93mpip3 install -r requirements.txt\033[0m to fix it.')

# Imports from core
from core.options import *
from core.colors import *
from core.inputin import inputin
from core.request import Get, Post
from core.verbout import verbout
from core.forms import form10, form20
from core.banner import banner, banabout
from core.logger import ErrorLogger, GetLogger
from core.logger import VulnLogger, NovulLogger

# Imports from files
from files.config import *
from files.discovered import FORMS_TESTED

# Imports from modules
from modules import Debugger
from modules import Parser
from modules import Crawler
from modules.Origin import Origin
from modules.Cookie import Cookie
from modules.Tamper import Tamper
from modules.Entropy import Entropy
from modules.Referer import Referer
from modules.Encoding import Encoding
from modules.Analysis import Analysis
from modules.Checkpost import PostBased
# Import Ends

# First rule, remove the warnings!
warnings.filterwarnings('ignore')

def Engine():  # lets begin it!

    os.system('clear')  # Clear shit from terminal :p
    banner()  # Print the banner
    banabout()  # The second banner
    web, fld = inputin()  # Take the input
    form1 = form10()  # Get the form 1 ready
    form2 = form20()  # Get the form 2 ready

    # For the cookies that we encounter during requests...
    Cookie0 = http.cookiejar.CookieJar()  # First as User1
    Cookie1 = http.cookiejar.CookieJar()  # Then as User2
    resp1 = build_opener(HTTPCookieProcessor(Cookie0))  # Process cookies
    resp2 = build_opener(HTTPCookieProcessor(Cookie1))  # Process cookies

    actionDone = []  # init to the done stuff

    csrf = ''  # no token initialise / invalid token
    ref_detect = 0x00  # Null Char Flag
    ori_detect = 0x00  # Null Char Flags
    form = Debugger.Form_Debugger()  # init to the form parser+token generator

    bs1 = BeautifulSoup(form1).findAll('form',action=True)[0]  # make sure the stuff works properly
    bs2 = BeautifulSoup(form2).findAll('form',action=True)[0]  # same as above

    init1 = web  # First init
    resp1.open(init1)  # Makes request as User2
    resp2.open(init1)  # Make request as User1

    # Now there are 2 different modes of scanning and crawling here.
    # 1st -> Testing a single endpoint without the --crawl flag.
    # 2nd -> Testing all endpoints with the --crawl flag.
    try:
        # Implementing the first mode. [NO CRAWL]
        if not CRAWL_SITE:
            url = web
            response = Get(url).text
            try:
                verbout(O,'Trying to parse response...')
                soup = BeautifulSoup(response)  # Parser init
            except HTMLParser.HTMLParseError:
                verbout(R,'BeautifulSoup Error: '+url)
            i = 0 # Init user number
            if REFERER_ORIGIN_CHECKS:
                # Referer Based Checks if True...
                verbout(O, 'Checking endpoint request validation via '+color.GREY+'Referer'+color.END+' Checks...')
                if Referer(url):
                    ref_detect = 0x01
                verbout(O, 'Confirming the vulnerability...')

                # We have finished with Referer Based Checks, lets go for Origin Based Ones...
                verbout(O, 'Confirming endpoint request validation via '+color.GREY+'Origin'+color.END+' Checks...')
                if Origin(url):
                    ori_detect = 0x01
            if COOKIE_BASED:
                Cookie(url)
            # Now lets get the forms...
            verbout(O, 'Retrieving all forms on ' +color.GREY+url+color.END+'...')
            for m in Debugger.getAllForms(soup):  # iterating over all forms extracted
                verbout(O,'Testing form:\n\n'+color.CYAN+' %s' % (m.prettify()))
                FORMS_TESTED.append('(i) '+url+':\n\n'+m.prettify()+'\n')
                try:
                    if m['action']:
                        pass
                except KeyError:
                    m['action'] = '/' + url.rsplit('/', 1)[1]
                    ErrorLogger(url, 'No standard form ""action"".')
                action = Parser.buildAction(url, m['action'])  # get all forms which have 'action' attribute
                if not action in actionDone and action!='':  # if url returned is not a null value nor duplicate...
                    # If form submission is kept to True
                    if FORM_SUBMISSION:
                        try:
                            # NOTE: Slow connections may cause read timeouts which may result in AttributeError
                            result, genpoc = form.prepareFormInputs(m)  # prepare inputs
                            r1 = Post(url, action, result).text  # make request with token values generated as user1
                            result, genpoc = form.prepareFormInputs(m)  # prepare the input types
                            r2 = Post(url, action, result).text  # again make request with token values generated as user2
                            # Go for token based entropy checks...
                            try:
                                if m['name']:
                                    query, token = Entropy(result, url, m['action'], m['name'])
                            except KeyError:
                                query, token = Entropy(result, url, m['action'])
                            # Now its time to detect the encoding type (if any) of the Anti-CSRF token.
                            fnd = Encoding(token)
                            if fnd == 0x01:
                                VulnLogger(url, 'Token is a string encoded value which can be probably decrypted.')
                            else:
                                NovulLogger(url, 'Anti-CSRF token is not a string encoded value.')
                            # Go for token parameter tamper checks.
                            if (query and token):
                                Tamper(url, action, result, r2, query, token)
                            o2 = resp2.open(url).read()  # make request as user2
                            try:
                                form2 = Debugger.getAllForms(BeautifulSoup(o2))[i]  # user2 gets his form
                            except IndexError:
                                verbout(R, 'Form Error')
                                ErrorLogger(url, 'Form Index Error.')
                                continue  # making sure program won't end here (dirty fix :( )
                            verbout(GR, 'Preparing form inputs...')
                            contents2, genpoc = form.prepareFormInputs(form2)  # prepare for form 2 as user2
                            r3 = Post(url,action,contents2).text  # make request as user3 with user2's form
                            if POST_BASED and not query and not token:
                                try:
                                    if m['name']:
                                        PostBased(url, r1, r2, r3, m['action'], result, genpoc, m['name'])
                                except KeyError:
                                    PostBased(url, r1, r2, r3, m['action'], result, genpoc)
                            else:
                                print(color.GREEN+' [+] The form was requested with a Anti-CSRF token.')
                                print(color.GREEN+' [+] Endpoint '+color.BG+' NOT VULNERABLE '+color.END+color.GREEN+' to POST-Based CSRF Attacks!')
                                NovulLogger(url, 'Not vulnerable to POST-Based CSRF Attacks.')
                        except HTTPError as msg:  # if runtime exception...
                            verbout(R, 'Exception : '+msg.__str__())  # again exception :(
                            ErrorLogger(url, msg)

                actionDone.append(action)  # add the stuff done
                i+=1  # Increase user iteration

        else:
            # Implementing the 2nd mode [CRAWLING AND SCANNING].
            verbout(GR, ""Initializing crawling and scanning..."")
            crawler = Crawler.Handler(init1, resp1)  # Init to the Crawler handler

            while crawler.noinit():  # Until 0 urls left
                url = next(crawler)  # Go for next!

                print(C+'Testing :> '+color.CYAN+url)  # Display what url its crawling

                try:
                    soup = crawler.process(fld)  # Start the parser
                    if not soup:
                        continue  # Making sure not to end the program yet...
                    i = 0  # Set count = 0 (user number 0, which will be subsequently incremented)
                    if REFERER_ORIGIN_CHECKS:
                        # Referer Based Checks if True...
                        verbout(O, 'Checking endpoint request validation via '+color.GREY+'Referer'+color.END+' Checks...')
                        if Referer(url):
                            ref_detect = 0x01
                        verbout(O, 'Confirming the vulnerability...')

                        # We have finished with Referer Based Checks, lets go for Origin Based Ones...
                        verbout(O, 'Confirming endpoint request validation via '+color.GREY+'Origin'+color.END+' Checks...')
                        if Origin(url):
                            ori_detect = 0x01

                    if COOKIE_BASED:
                        Cookie(url)

                    # Now lets get the forms...
                    verbout(O, 'Retrieving all forms on ' +color.GREY+url+color.END+'...')
                    for m in Debugger.getAllForms(soup):  # iterating over all forms extracted
                        FORMS_TESTED.append('(i) '+url+':\n\n'+m.prettify()+'\n')
                        try:
                            if m['action']:
                                pass
                        except KeyError:
                            m['action'] = '/' + url.rsplit('/', 1)[1]
                            ErrorLogger(url, 'No standard ""action"" attribute.')
                        action = Parser.buildAction(url, m['action'])  # get all forms which have 'action' attribute
                        if not action in actionDone and action != '':  # if url returned is not a null value nor duplicate...
                            # If form submission is kept to True
                            if FORM_SUBMISSION:
                                try:
                                    result, genpoc = form.prepareFormInputs(m)  # prepare inputs
                                    r1 = Post(url, action, result).text  # make request with token values generated as user1
                                    result, genpoc = form.prepareFormInputs(m)  # prepare the input types
                                    r2 = Post(url, action, result).text  # again make request with token values generated as user2
                                    # Go for token based entropy checks...
                                    try:
                                        if m['name']:
                                            query, token = Entropy(result, url, m['action'], m['name'])
                                    except KeyError:
                                        query, token = Entropy(result, url, m['action'])
                                        ErrorLogger(url, 'No standard form ""name"".')
                                    # Now its time to detect the encoding type (if any) of the Anti-CSRF token.
                                    fnd = Encoding(token)
                                    if fnd == 0x01:
                                        VulnLogger(url, 'String encoded token value. Token might be decrypted.')
                                    else:
                                        NovulLogger(url, 'Anti-CSRF token is not a string encoded value.')
                                    # Go for token parameter tamper checks.
                                    if (query and token):
                                        Tamper(url, action, result, r2, query, token)
                                    o2 = resp2.open(url).read()  # make request as user2
                                    try:
                                        form2 = Debugger.getAllForms(BeautifulSoup(o2))[i]  # user2 gets his form
                                    except IndexError:
                                        verbout(R, 'Form Error')
                                        ErrorLogger(url, 'Form Index Error.')
                                        continue  # making sure program won't end here (dirty fix :( )
                                    verbout(GR, 'Preparing form inputs...')
                                    contents2, genpoc = form.prepareFormInputs(form2)  # prepare for form 2 as user2
                                    r3 = Post(url,action,contents2).text  # make request as user3 with user2's form
                                    if POST_BASED and not query and not token:
                                        try:
                                            if m['name']:
                                                PostBased(url, r1, r2, r3, m['action'], result, genpoc, m['name'])
                                        except KeyError:
                                            PostBased(url, r1, r2, r3, m['action'], result, genpoc)
                                    else:
                                        print(color.GREEN+' [+] The form was requested with a Anti-CSRF token.')
                                        print(color.GREEN+' [+] Endpoint '+color.BG+' NOT VULNERABLE '+color.END+color.GREEN+' to P0ST-Based CSRF Attacks!')
                                        NovulLogger(url, 'Not vulnerable to POST-Based CSRF Attacks.')
                                except HTTPError as msg:  # if runtime exception...
                                    verbout(color.RED, ' [-] Exception : '+color.END+msg.__str__())  # again exception :(
                                    ErrorLogger(url, msg)
                        actionDone.append(action)  # add the stuff done
                        i+=1  # Increase user iteration
                except URLError as e:  # if again...
                    verbout(R, 'Exception at : '+url)  # again exception -_-
                    time.sleep(0.4)
                    verbout(O, 'Moving on...')
                    ErrorLogger(url, e)
                    continue  # make sure it doesn't stop at exceptions
                # This error usually happens when some sites are protected by some load balancer
                # example Cloudflare. These domains return a 403 forbidden response in various
                # contexts. For example when making reverse DNS queries.
                except HTTPError as e:
                    if str(e.code) == '403':
                        verbout(R, 'HTTP Authentication Error!')
                        verbout(R, 'Error Code : ' +O+ str(e.code))
                        ErrorLogger(url, e)
                        quit()
        GetLogger()  # The scanning has finished, so now we can log out all the links ;)
        print('\n'+G+""Scan completed!""+'\n')
        Analysis()  # For Post Scan Analysis
    except KeyboardInterrupt as e:  # Incase user wants to exit :') (while crawling)
        verbout(R, 'User Interrupt!')
        time.sleep(1.5)
        Analysis()  # For Post scan Analysis
        print(R+'Aborted!')  # say goodbye
        ErrorLogger('KeyBoard Interrupt', 'Aborted')
        quit()
    except Exception as e:
        verbout(R, e.__str__())
        ErrorLogger(url, e)
/n/n/ncore/options.py/n/n#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-::-:-:#
#    XSRF Probe     #
#-:-:-:-:-:-:-::-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

# Importing stuff
import argparse, sys, tld
import urllib.parse, os
from files import config
from core.colors import R, G
from core.updater import updater

# Processing command line arguments
parser = argparse.ArgumentParser('python3 xsrfprobe.py')
parser._action_groups.pop()

# A simple hack to have required argumentsa and optional arguments separately
required = parser.add_argument_group('Required Arguments')
optional = parser.add_argument_group('Optional Arguments')

# Required Options
required.add_argument('-u', '--url', help='Main URL to test', dest='url')

# Optional Arguments (main stuff and necessary)
optional.add_argument('-c', '--cookie', help='Cookie value to be requested with each successive request. If there are multiple cookies, separate them with commas. For example: `-c PHPSESSID=i837c5n83u4, _gid=jdhfbuysf`.', dest='cookie')
optional.add_argument('-o', '--output', help='Output directory where files to be stored. Default is the`files` folder where all files generated will be stored.', dest='output')
optional.add_argument('-d', '--delay', help='Time delay between requests in seconds. Default is zero.', dest='delay', type=float)
optional.add_argument('-q', '--quiet', help='Set the DEBUG mode to quiet. Report only when vulnerabilities are found. Minimal output will be printed on screen. ', dest='quiet', action='store_true')
optional.add_argument('-v', '--verbose', help='Increase the verbosity of the output (e.g., -vv is more than -v). ', dest='verbose', action='store_true')

# Other Options
# optional.add_argument('-h', '--help', help='Show this help message and exit', dest='disp', default=argparse.SUPPRESS, action='store_true')
optional.add_argument('--user-agent', help='Custom user-agent to be used. Only one user-agent can be specified.', dest='user_agent', type=str)
optional.add_argument('--headers', help='Comma separated list of custom headers you\'d want to use. For example: ``--headers ""Accept=text/php, X-Requested-With=Dumb""``.', dest='headers', type=str)
optional.add_argument('--exclude', help='Comma separated list of paths or directories to be excluded which are not in scope. These paths/dirs won\'t be scanned. For example: `--exclude somepage/, sensitive-dir/, pleasedontscan/`', dest='exclude', type=str)
optional.add_argument('--timeout', help='HTTP request timeout value in seconds. The entered value must be in floating point decimal. Example: ``--timeout 10.0``', dest='timeout', type=float)
optional.add_argument('--max-chars', help='Maximum allowed character length for the custom token value to be generated. For example: `--max-chars 5`. Default value is 6.', dest='maxchars', type=int)
optional.add_argument('--crawl', help=""Crawl the whole site and simultaneously test all discovered endpoints for CSRF."", dest='crawl', action='store_true')
optional.add_argument('--skip-analysis', help='Skip the Post-Scan Analysis of Tokens which were gathered during requests', dest='skipal', action='store_true')
optional.add_argument('--skip-poc', help='Skip the PoC Form Generation of POST-Based Cross Site Request Forgeries.', dest='skippoc', action='store_true')
optional.add_argument('--display', help='Print out response headers of requests while making requests.', dest='disphead', action='store_true')
optional.add_argument('--update', help='Update XSRFProbe to latest version on GitHub via git.', dest='update', action='store_true')
optional.add_argument('--random-agent', help='Use random user-agents for making requests.', dest='randagent', action='store_true')
optional.add_argument('--version', help='Display the version of XSRFProbe and exit.', dest='version', action='store_true')
args = parser.parse_args()

if not len(sys.argv) > 1:
    print('''
    \033[1;91mXSRFProbe\033[0m, \033[1;97mA \033[1;93mCross Site Request Forgery \033[1;97mAudit Toolkit\033[0m
''')
    parser.print_help()
    quit('')

# Update XSRFProbe to latest version
if args.update:
    updater()
    quit('')

# Print out XSRFProbe version
if args.version:
    print('\n\033[1;97m [+] \033[1;91mXSRFProbe Version\033[0m : \033[1;97m'+open('files/VersionNum').read())
    quit()

# Now lets update some global config variables
if args.maxchars:
    config.TOKEN_GENERATION_LENGTH = args.maxchars

# Setting custom user-agent
if args.user_agent:
    config.USER_AGENT = args.user_agent

# Option to skip analysis
if args.skipal:
    config.SCAN_ANALYSIS = False

# Option to skip poc generation
if args.skippoc:
    config.POC_GENERATION = False

# Updating main root url
if not args.version and not args.update:
    if args.url: # and not args.help:
        if 'http' in args.url:
            config.SITE_URL = args.url
        else:
            config.SITE_URL = 'http://'+args.url
    else:
        print(R+'You must supply a url/endpoint.')

# Crawl the site if --crawl supplied.
if args.crawl:
    config.CRAWL_SITE = True
    # Turning off the display header feature due to too much log generation.
    config.DISPLAY_HEADERS = False

if args.cookie:
    # Assigning Cookie
    if ',' in args.cookie:
        for cook in args.cookie.split(','):
            config.COOKIE_VALUE.append(cook.strip())
            # This is necessary when a cookie value is supplied
            # Since if the user-agent used to make the request changes
            # from time to time, the remote site might trigger up
            # security mechanisms (or worse, perhaps block your ip?)
            config.USER_AGENT_RANDOM = False

# Set the headers displayer to 1 (actively display headers)
if args.disphead:
    config.DISPLAY_HEADERS = True

# Timeout value
if args.timeout:
    config.TIMEOUT_VALUE = args.timeout

# Custom header values if specified
if args.headers:
    # NOTE: As a default idea, when the user supplies custom headers, we
    # simply add the custom headers to a list of existing headers in
    # files/config.py.
    # Uncomment the following lines to just reinitialise the headers everytime
    # they make a request.
    #
    #config.HEADER_VALUES = {}
    for m in args.headers.split(','):
        config.HEADER_VALUES[m.split('=')[0]] = m.split('=')[1]  # nice hack ;)

if args.exclude:
    exc = args.exclude
    #config.EXCLUDE_URLS = [s for s in exc.split(',').strip()]
    m = exc.split(',').strip()
    for s in m:
        config.EXCLUDE_DIRS.append(urllib.parse.urljoin(config.SITE_URL, s))

if args.randagent:
    # If random-agent argument supplied...
    config.USER_AGENT_RANDOM = True
    # Turn off a single User-Agent mechanism...
    config.USER_AGENT = ''

if config.SITE_URL:
    if args.output:
        # If output directory is mentioned...
        try:
            if not os.path.exists(args.output+tld.get_fld(config.SITE_URL)):
                os.makedirs(args.output+tld.get_fld(config.SITE_URL))
        except FileExistsError:
            pass
        config.OUTPUT_DIR = args.output+tld.get_fld(config.SITE_URL) + '/'
    else:
        try:
            os.makedirs(tld.get_fld(config.SITE_URL))
        except FileExistsError:
            pass
        config.OUTPUT_DIR = tld.get_fld(config.SITE_URL) + '/'

if args.quiet:
    config.DEBUG = False
/n/n/ncore/utils.py/n/n#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-:-:-:#
#    XSRFProbe     #
#-:-:-:-:-:-:-:-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

from difflib import SequenceMatcher

def sameSequence(str1,str2):
    '''
    This function is intended to find same sequence
                between str1 and str2.
    '''
    # Initialize SequenceMatcher object with
    # Input string
    seqMatch = SequenceMatcher(None, str1, str2)

    # Find match of longest sub-string
    # Output will be like Match(a=0, b=0, size=5)
    match = seqMatch.find_longest_match(0, len(str1), 0, len(str2))

    # Print longest substring
    if (match.size!=0):
        return (str1[match.a: match.a + match.size])
    else:
        return ''

def replaceStrIndex(text, index=0, replacement=''):
    '''
    This method returns a tampered string by
                    replacement
    '''
    return '%s%s%s' % (text[:index], replacement, text[index+1:])

def checkDuplicates(iterable):
    '''
    This function works as a byte sequence checker for
            tuples passed onto this function.
    '''
    seen = set()
    for x in iterable:
        if x in seen:
            return True
        seen.add(x)
    return False

def byteString(s, encoding='utf8'):
    """"""
    Return a byte-string version of 's',
            Encoded as utf-8.
    """"""
    try:
        s = s.encode(encoding)
    except (UnicodeEncodeError, UnicodeDecodeError):
        s = str(s)
    return s

def subSequence(str1,str2):
    '''
    Returns whether 'str1' and 'str2' are subsequence
                    of one another.
    '''
    j = 0    # Index of str1
    i = 0    # Index of str2

    # Traverse both str1 and str2
    # Compare current character of str2 with
    # First unmatched character of str1
    # If matched, then move ahead in str1
    m = len(str1)
    n = len(str2)
    while j<m and i<n:
        if str1[j] == str2[i]:
            j = j+1
        i = i + 1

    # If all characters of str1 matched, then j is equal to m
    return j==m
/n/n/n",0
3,398ed11584313a371763240392c4dda1cf986deb,"/core/logger.py/n/n#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-::-:-:#
#    XSRF Probe     #
#-:-:-:-:-:-:-::-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

import os
from core.colors import *
from files.config import *
from core.verbout import verbout
from files.discovered import INTERNAL_URLS, FILES_EXEC, SCAN_ERRORS
from files.discovered import VULN_LIST, FORMS_TESTED, REQUEST_TOKENS

def logger(filename, content):
    '''
    This module is for logging all the stuff we found
            while crawling and scanning.
    '''
    output_file = OUTPUT_DIR + filename + '.log'
    with open(output_file, 'w+', encoding='utf8') as f:
        if type(content) is tuple or type(content) is list:
            for m in content:  # if it is list or tuple, it is iterable
                f.write(m+'\n')
        else:
            f.write(content)  # else we write out as it is... ;)
        f.write('\n')

def pheaders(tup):
    '''
    This module prints out the headers as received in the
                    requests normally.
    '''
    verbout(GR, 'Receiving headers...\n')
    verbout(color.GREY,'  '+color.UNDERLINE+'HEADERS'+color.END+color.GREY+':'+'\n')
    for key, val in tup.items():
        verbout('  ',color.CYAN+key+': '+color.ORANGE+val)
    verbout('','')

def GetLogger():
    if INTERNAL_URLS:
        logger('internal-links', INTERNAL_URLS)
    if SCAN_ERRORS:
        logger('errored', SCAN_ERRORS)
    if FILES_EXEC:
        logger('files-found', FILES_EXEC)
    if REQUEST_TOKENS:
        logger('anti-csrf-tokens', REQUEST_TOKENS)
    if FORMS_TESTED:
        logger('forms-tested', FORMS_TESTED)
    if VULN_LIST:
        logger('vulnerabilities', VULN_LIST)

def ErrorLogger(url, error):
    con = '(i) '+url+' -> '+error.__str__()
    SCAN_ERRORS.append(con)

def VulnLogger(url, vuln):
    tent = '[!] '+url+' -> '+vuln
    VULN_LIST.append(tent)
/n/n/n/core/options.py/n/n#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#-:-:-:-:-:-:-::-:-:#
#    XSRF Probe     #
#-:-:-:-:-:-:-::-:-:#

# Author: 0xInfection
# This module requires XSRFProbe
# https://github.com/0xInfection/XSRFProbe

# Importing stuff
import argparse, sys, tld
import urllib.parse, os
from files import config
from core.colors import R, G
from core.updater import updater

# Processing command line arguments
parser = argparse.ArgumentParser('python3 xsrfprobe.py')
parser._action_groups.pop()

# A simple hack to have required argumentsa and optional arguments separately
required = parser.add_argument_group('Required Arguments')
optional = parser.add_argument_group('Optional Arguments')

# Required Options
required.add_argument('-u', '--url', help='Main URL to test', dest='url')

# Optional Arguments (main stuff and necessary)
optional.add_argument('-c', '--cookie', help='Cookie value to be requested with each successive request. If there are multiple cookies, separate them with commas. For example: `-c PHPSESSID=i837c5n83u4, _gid=jdhfbuysf`.', dest='cookie')
optional.add_argument('-o', '--output', help='Output directory where files to be stored. Default is the`files` folder where all files generated will be stored.', dest='output')
optional.add_argument('-d', '--delay', help='Time delay between requests in seconds. Default is zero.', dest='delay', type=float)
optional.add_argument('-q', '--quiet', help='Set the DEBUG mode to quiet. Report only when vulnerabilities are found. Minimal output will be printed on screen. ', dest='quiet', action='store_true')
optional.add_argument('-v', '--verbose', help='Increase the verbosity of the output (e.g., -vv is more than -v). ', dest='verbose', action='store_true')

# Other Options
# optional.add_argument('-h', '--help', help='Show this help message and exit', dest='disp', default=argparse.SUPPRESS, action='store_true')
optional.add_argument('--user-agent', help='Custom user-agent to be used. Only one user-agent can be specified.', dest='user_agent', type=str)
optional.add_argument('--headers', help='Comma separated list of custom headers you\'d want to use. For example: ``--headers ""Accept=text/php, X-Requested-With=Dumb""``.', dest='headers', type=str)
optional.add_argument('--exclude', help='Comma separated list of paths or directories to be excluded which are not in scope. These paths/dirs won\'t be scanned. For example: `--exclude somepage/, sensitive-dir/, pleasedontscan/`', dest='exclude', type=str)
optional.add_argument('--timeout', help='HTTP request timeout value in seconds. The entered value must be in floating point decimal. Example: ``--timeout 10.0``', dest='timeout', type=float)
optional.add_argument('--max-chars', help='Maximum allowed character length for the custom token value to be generated. For example: `--max-chars 5`. Default value is 6.', dest='maxchars', type=int)
optional.add_argument('--crawl', help=""Crawl the whole site and simultaneously test all discovered endpoints for CSRF."", dest='crawl', action='store_true')
optional.add_argument('--skip-analysis', help='Skip the Post-Scan Analysis of Tokens which were gathered during requests', dest='skipal', action='store_true')
optional.add_argument('--skip-poc', help='Skip the PoC Form Generation of POST-Based Cross Site Request Forgeries.', dest='skippoc', action='store_true')
optional.add_argument('--update', help='Update XSRFProbe to latest version on GitHub via git.', dest='update', action='store_true')
optional.add_argument('--random-agent', help='Use random user-agents for making requests.', dest='randagent', action='store_true')
optional.add_argument('--version', help='Display the version of XSRFProbe and exit.', dest='version', action='store_true')
args = parser.parse_args()

if not len(sys.argv) > 1:
    print('''
    \033[1;91mXSRFProbe\033[0m, \033[1;97mA \033[1;93mCross Site Request Forgery \033[1;97mAudit Toolkit\033[0m
''')
    parser.print_help()
    quit('')

# Update XSRFProbe to latest version
if args.update:
    updater()
    quit('')

# Print out XSRFProbe version
if args.version:
    print('\n\033[1;97m [+] \033[1;91mXSRFProbe Version\033[0m : \033[1;97m'+open('files/VersionNum').read())
    quit()

# Now lets update some global config variables
if args.maxchars:
    config.TOKEN_GENERATION_LENGTH = args.maxchars

# Setting custom user-agent
if args.user_agent:
    config.USER_AGENT = args.user_agent

# Option to skip analysis
if args.skipal:
    config.SCAN_ANALYSIS = False

# Option to skip poc generation
if args.skippoc:
    config.POC_GENERATION = False

# Updating main root url
if not args.version and not args.update:
    if args.url: # and not args.help:
        if 'http' in args.url:
            config.SITE_URL = args.url
        else:
            config.SITE_URL = 'http://'+args.url
    else:
        print(R+'You must supply a url/endpoint.')

# Crawl the site if --crawl supplied.
if args.crawl:
    config.CRAWL_SITE = True

if args.cookie:
    # Assigning Cookie
    if ',' in args.cookie:
        for cook in args.cookie.split(','):
            config.COOKIE_VALUE.append(cook.strip())
            # This is necessary when a cookie value is supplied
            # Since if the user-agent used to make the request changes
            # from time to time, the remote site might trigger up
            # security mechanisms (or worse, perhaps block your ip?)
            config.USER_AGENT_RANDOM = False

# Timeout value
if args.timeout:
    config.TIMEOUT_VALUE = args.timeout

# Custom header values if specified
if args.headers:
    # NOTE: As a default idea, when the user supplies custom headers, we
    # simply add the custom headers to a list of existing headers in
    # files/config.py.
    # Uncomment the following lines to just reinitialise the headers everytime
    # they make a request.
    #
    #config.HEADER_VALUES = {}
    for m in args.headers.split(','):
        config.HEADER_VALUES[m.split('=')[0]] = m.split('=')[1]

if args.exclude:
    exc = args.exclude
    #config.EXCLUDE_URLS = [s for s in exc.split(',').strip()]
    m = exc.split(',').strip()
    for s in m:
        config.EXCLUDE_DIRS.append(urllib.parse.urljoin(config.SITE_URL, s))

if args.randagent:
    # If random-agent argument supplied...
    config.USER_AGENT_RANDOM = True
    # Turn off a single User-Agent mechanism...
    config.USER_AGENT = ''

if config.SITE_URL:
    if args.output:
        # If output directory is mentioned...
        try:
            if not os.path.exists(args.output+tld.get_fld(config.SITE_URL)):
                os.makedirs(args.output+tld.get_fld(config.SITE_URL))
        except FileExistsError:
            pass
        config.OUTPUT_DIR = args.output+tld.get_fld(config.SITE_URL) + '/'
    else:
        try:
            os.makedirs(tld.get_fld(config.SITE_URL))
        except FileExistsError:
            pass
        config.OUTPUT_DIR = tld.get_fld(config.SITE_URL) + '/'

if args.quiet:
    config.DEBUG = False
/n/n/n",1
4,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
5,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
6,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
7,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
8,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
9,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
10,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
11,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
12,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
13,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
14,ae7e50d52016e4c9471e39bb4ac03b4c7dfe33bb,"bzs/core.py/n/n
import socket
import threading
import tornado

import tornado.concurrent
import tornado.httputil
import tornado.httpserver
import tornado.gen
import tornado.ioloop
import tornado.process
import tornado.web

from bzs import const
from bzs import db
from bzs import files

from bzs import module_error404
from bzs import module_files
from bzs import module_home
from bzs import module_index
from bzs import module_static

WEB_PORT = 80

def main():
    # Creating web application
    web_app = tornado.web.Application([
            (r'^/$', module_index.MainframeHandler),
            (r'/static/(.*)$', module_static.StaticHandler),
            # (r'/static/(.*)', tornado.web.StaticFileHandler, {
            #     ""path"": ""./static/"" # Optimized static file handler with cache
            # }),
            (r'^/home', module_home.HomeHandler),
            (r'^/files/?()$', module_files.FilesListHandler),
            (r'^/files/list/(.*)', module_files.FilesListHandler),
            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),
            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),
            (r'^/files/operation/?', module_files.FilesOperationHandler),
            (r'.*', module_error404.Error404Handler)
        ],
        xsrf_cookies=False # True to prevent CSRF third party attacks
    )
    # Starting server
    web_sockets = tornado.netutil.bind_sockets(
        const.get_const('server-port'),
        family=socket.AF_INET)
    if const.get_const('server-threads') > 1:
        if hasattr(os, 'fork'):
            # os.fork() operation unavailable on Windows.
            tornado.process.fork_processes(const.get_const('server-threads') - 1)
    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)
    web_server.add_sockets(web_sockets)
    # Boot I/O thread for asynchronous purposes
    tornado.ioloop.IOLoop.instance().start()
    return
/n/n/nbzs/module_error404.py/n/n
import re
import tornado

from bzs import files
from bzs import const

class Error404Handler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        try:
            file_data = files.get_static_data('./static/404.html')
        except Exception:
            file_data = '404 Not Found'
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/nbzs/module_files.py/n/n
import base64
import binascii
import cgi
import io
import json
import re
import time
import tornado
import urllib

from bzs import const
from bzs import db
from bzs import files
from bzs import preproc
from bzs import users

def encode_str_to_hexed_b64(data):
    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')
def decode_hexed_b64_to_str(data):
    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')

################################################################################

class FilesListHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, target_path):
        """"""/files/list/HEXED_BASE64_STRING_OF_PATH/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async(target_path):
            # Getting file template.
            file_temp = files.get_static_data('./static/files.html')

            # Retrieving list operation target.
            try:
                target_path = decode_hexed_b64_to_str(target_path)
            except:
                target_path = '/'
            if not target_path:
                target_path = '/'

            # Getting hierarchical file path
            files_hierarchy = target_path.split('/')
            files_hierarchy_list = list()
            while '' in files_hierarchy:
                files_hierarchy.remove('')
            files_hierarchy = [''] + files_hierarchy
            files_hierarchy_cwd = ''
            for i in range(0, len(files_hierarchy)):
                files_hierarchy[i] += '/'
                files_hierarchy_cwd += files_hierarchy[i]
                files_hierarchy_list.append(dict(
                    folder_name=files_hierarchy[i],
                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),
                    disabled=(i == len(files_hierarchy) - 1)))
                continue

            # Getting current directory content
            files_attrib_list = list()
            for f_handle in db.Filesystem.listdir(target_path):
                # try:
                    file_name = f_handle['file-name']
                    actual_path = target_path + file_name
                    attrib = dict()
                    attrib['file-name'] = file_name
                    attrib['file-name-url'] = urllib.parse.quote(file_name)
                    attrib['file-name-escaped'] = cgi.escape(file_name)
                    attrib['size'] = f_handle['file-size']
                    attrib['size-str'] = files.format_file_size(attrib['size'])
                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!
                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))
                    # Encoding MIME types
                    if f_handle['is-dir']:
                        attrib['mime-type'] = 'directory/folder'
                    else:
                        attrib['mime-type'] = files.guess_mime_type(file_name)
                    # Encoding hyperlinks
                    if attrib['mime-type'] == 'directory/folder':
                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')
                    else:
                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])
                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)
                    files_attrib_list.append(attrib)
                # except Exception:
                #     pass
            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)

            # File actually exists, sending data
            working_user = users.get_user_by_cookie(
                self.get_cookie('user_active_login', default=''))
            file_temp = preproc.preprocess_webpage(file_temp, working_user,
                files_attrib_list=files_attrib_list,
                files_hierarchy_list=files_hierarchy_list,
                cwd_uuid=cwd_uuid)
            future.set_result(file_temp)
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,
            target_path)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_temp)
        self.flush()
        self.finish()
        return self

    head=get
    pass

################################################################################

class FilesDownloadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path, file_name):
        """"""/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME""""""
        # Something that I do not wish to write too many times..
        def invoke_404():
            self.set_status(404, ""Not Found"")
            self.add_header('Content-Length', '0')
            self.flush()
            return

        # Get file location (exactly...)
        try:
            file_path = decode_hexed_b64_to_str(file_path)
        except Exception:
            file_path = ''
        if not file_path:
            invoke_404()
            return

        # Asynchronous web request...
        file_block_size = 64 * 1024 # 64 KiB / Chunk
        file_block = bytes()
        file_data = None

        future = tornado.concurrent.Future()
        def inquire_data_async():
            _tf_data = db.Filesystem.get_content(file_path)
            future.set_result(_tf_data)
        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)
        file_data = yield future
        file_stream = io.BytesIO(file_data)

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'application/x-download')
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        while file_stream.tell() < len(file_data):
            byte_pos = file_stream.tell()
            # Entry to the concurrency worker
            future = tornado.concurrent.Future()
            # Concurrent worker
            def retrieve_data_async():
                block = file_stream.read(file_block_size)
                future.set_result(block)
            # Injection and pending
            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)
            # Reset or read
            file_block = yield future
            self.write(file_block)
            file_block = None
            self.flush()
        file_block = None
        self.finish()

        # Release memory...
        file_stream = None
        file_data = None
        return self

    head=get
    pass

################################################################################

class FilesOperationHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self):
        """"""/files/operation/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async():
            operation_content_raw = self.request.body
            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))
            action = operation_content['action']
            sources = operation_content['source']
            if type(sources) == list:
                for i in range(0, len(sources)):
                    try:
                        sources[i] = decode_hexed_b64_to_str(sources[i])
                    except:
                        pass
            else:
                sources = decode_hexed_b64_to_str(sources)
            if action in ['copy', 'move']:
                try:
                    target = decode_hexed_b64_to_str(operation_content['target'])
                except:
                    target = '/'
            elif action in ['rename', 'new-folder']:
                try:
                    target = operation_content['target']
                except:
                    target = sources # I am not handling more exceptions as this is brutal enough
            # Done assigning values, now attempting to perform operation
            if action == 'copy':
                for source in sources:
                    db.Filesystem.copy(source, target, new_owner='user-cp')
            elif action == 'move':
                for source in sources:
                    db.Filesystem.move(source, target)
            elif action == 'delete':
                for source in sources:
                    db.Filesystem.remove(source)
            elif action == 'rename':
                db.Filesystem.rename(sources, target)
            elif action == 'new-folder':
                db.Filesystem.mkdir(sources, target, 'user-nf')
            future.set_result('')
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_temp)
        self.flush()
        self.finish()
        return self
    pass

################################################################################

class FilesUploadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self, target_path, file_name):
        """"""/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()
        working_user = users.get_user_by_cookie(
            self.get_cookie('user_active_login', default=''))

        def save_file_async(alter_ego, target_path, file_name, working_user):
            upload_data = alter_ego.request.body
            # Crucial, to release data.
            alter_ego.request.body = None
            target_path = decode_hexed_b64_to_str(target_path)
            # Committing changes to database
            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)
            # Final return
            future.set_result('bzs_upload_success')
        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,
            self, target_path, file_name, working_user)

        response_temp = yield future
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(response_temp)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(response_temp)
        self.flush()
        self.finish()
        return self
    pass
/n/n/nbzs/module_home.py/n/n
import re
import tornado

from bzs import files
from bzs import const
from bzs import users
from bzs import preproc

class HomeHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_index_html_async():
                file_data = files.get_static_data('./static/home.html')
                working_user = users.get_user_by_cookie(
                    self.get_cookie('user_active_login', default=''))
                file_data = preproc.preprocess_webpage(file_data, working_user)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)
            file_data = yield future
        except Exception:
            self.set_status(404, ""Not Found"")
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/nbzs/module_index.py/n/n
import re
import tornado

from bzs import files
from bzs import const
from bzs import users
from bzs import preproc

class MainframeHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_index_html_async():
                file_data = files.get_static_data('./static/index.html')
                working_user = users.get_user_by_cookie(
                    self.get_cookie('user_active_login', default=''))
                file_data = preproc.preprocess_webpage(file_data, working_user)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)
            file_data = yield future
        except Exception:
            print(Exception)
            self.set_status(404, ""Not Found"")
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        # File actually exists, sending data
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/nbzs/module_static.py/n/n
import re
import tornado

from bzs import files
from bzs import const

class StaticHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path):
        """"""/static/PATH""""""
        file_path = './static/' + file_path
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_file_data_async():
                file_data = files.get_static_data(file_path)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_file_data_async)
            file_data = yield future
        except Exception:
            self.set_status(404, ""Not Found"")
            self._headers = tornado.httputil.HTTPHeaders()
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        # File actually exists, sending data
        self.set_status(200, ""OK"")
        self._headers = tornado.httputil.HTTPHeaders()
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', files.guess_mime_type(file_path))
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/n",0
15,ae7e50d52016e4c9471e39bb4ac03b4c7dfe33bb,"/bzs/core.py/n/n
import socket
import threading
import tornado

import tornado.concurrent
import tornado.httputil
import tornado.httpserver
import tornado.gen
import tornado.ioloop
import tornado.process
import tornado.web

from bzs import const
from bzs import db
from bzs import files

from bzs import module_error404
from bzs import module_files
from bzs import module_home
from bzs import module_index
from bzs import module_static

WEB_PORT = 80

def main():
    # Creating web application
    web_app = tornado.web.Application([
            (r'^/$', module_index.MainframeHandler),
            (r'/static/.*', module_static.StaticHandler),
            # (r'/static/(.*)', tornado.web.StaticFileHandler, {
            #     ""path"": ""./static/"" # Optimized static file handler with cache
            # }),
            (r'^/home', module_home.HomeHandler),
            (r'^/files/?()$', module_files.FilesListHandler),
            (r'^/files/list/(.*)', module_files.FilesListHandler),
            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),
            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),
            (r'^/files/operation/?', module_files.FilesOperationHandler),
            (r'.*', module_error404.Error404Handler)
        ],
        xsrf_cookies=False # True to prevent CSRF third party attacks
    )
    # Starting server
    web_sockets = tornado.netutil.bind_sockets(
        const.get_const('server-port'),
        family=socket.AF_INET)
    if const.get_const('server-threads') > 1:
        if hasattr(os, 'fork'):
            # os.fork() operation unavailable on Windows.
            tornado.process.fork_processes(const.get_const('server-threads') - 1)
    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)
    web_server.add_sockets(web_sockets)
    # Boot I/O thread for asynchronous purposes
    tornado.ioloop.IOLoop.instance().start()
    return
/n/n/n/bzs/module_error404.py/n/n
import re
import tornado

from bzs import files
from bzs import const

class Error404Handler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        try:
            file_data = files.get_static_data('./static/404.html')
        except Exception:
            file_data = '404 Not Found'
        self.set_status(200, ""OK"")
        self._headers = tornado.httputil.HTTPHeaders()
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/n/bzs/module_files.py/n/n
import base64
import binascii
import cgi
import io
import json
import re
import time
import tornado
import urllib

from bzs import const
from bzs import db
from bzs import files
from bzs import preproc
from bzs import users

def encode_str_to_hexed_b64(data):
    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')
def decode_hexed_b64_to_str(data):
    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')

################################################################################

class FilesListHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, target_path):
        """"""/files/list/HEXED_BASE64_STRING_OF_PATH/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async(target_path):
            # Getting file template.
            file_temp = files.get_static_data('./static/files.html')

            # Retrieving list operation target.
            try:
                target_path = decode_hexed_b64_to_str(target_path)
            except:
                target_path = '/'
            if not target_path:
                target_path = '/'

            # Getting hierarchical file path
            files_hierarchy = target_path.split('/')
            files_hierarchy_list = list()
            while '' in files_hierarchy:
                files_hierarchy.remove('')
            files_hierarchy = [''] + files_hierarchy
            files_hierarchy_cwd = ''
            for i in range(0, len(files_hierarchy)):
                files_hierarchy[i] += '/'
                files_hierarchy_cwd += files_hierarchy[i]
                files_hierarchy_list.append(dict(
                    folder_name=files_hierarchy[i],
                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),
                    disabled=(i == len(files_hierarchy) - 1)))
                continue

            # Getting current directory content
            files_attrib_list = list()
            for f_handle in db.Filesystem.listdir(target_path):
                # try:
                    file_name = f_handle['file-name']
                    actual_path = target_path + file_name
                    attrib = dict()
                    attrib['file-name'] = file_name
                    attrib['file-name-url'] = urllib.parse.quote(file_name)
                    attrib['file-name-escaped'] = cgi.escape(file_name)
                    attrib['size'] = f_handle['file-size']
                    attrib['size-str'] = files.format_file_size(attrib['size'])
                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!
                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))
                    # Encoding MIME types
                    if f_handle['is-dir']:
                        attrib['mime-type'] = 'directory/folder'
                    else:
                        attrib['mime-type'] = files.guess_mime_type(file_name)
                    # Encoding hyperlinks
                    if attrib['mime-type'] == 'directory/folder':
                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')
                    else:
                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])
                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)
                    files_attrib_list.append(attrib)
                # except Exception:
                #     pass
            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)

            # File actually exists, sending data
            working_user = users.get_user_by_cookie(
                self.get_cookie('user_active_login', default=''))
            file_temp = preproc.preprocess_webpage(file_temp, working_user,
                files_attrib_list=files_attrib_list,
                files_hierarchy_list=files_hierarchy_list,
                cwd_uuid=cwd_uuid)
            future.set_result(file_temp)
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,
            target_path)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.write(file_temp)
        self.flush()
        self.finish()
        return self

    head=get
    pass

################################################################################

class FilesDownloadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path, file_name):
        """"""/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME""""""
        # Something that I do not wish to write too many times..
        def invoke_404():
            self.set_status(404, ""Not Found"")
            self._headers = tornado.httputil.HTTPHeaders()
            self.add_header('Content-Length', '0')
            self.flush()
            return

        # Get file location (exactly...)
        try:
            file_path = decode_hexed_b64_to_str(file_path)
        except Exception:
            file_path = ''
        if not file_path:
            invoke_404()
            return

        # Asynchronous web request...
        file_block_size = 64 * 1024 # 64 KiB / Chunk
        file_block = bytes()
        file_data = None

        future = tornado.concurrent.Future()
        def inquire_data_async():
            _tf_data = db.Filesystem.get_content(file_path)
            future.set_result(_tf_data)
        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)
        file_data = yield future
        file_stream = io.BytesIO(file_data)

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'application/x-download')
        self.add_header('Content-Length', str(len(file_data)))

        while file_stream.tell() < len(file_data):
            byte_pos = file_stream.tell()
            # Entry to the concurrency worker
            future = tornado.concurrent.Future()
            # Concurrent worker
            def retrieve_data_async():
                block = file_stream.read(file_block_size)
                future.set_result(block)
            # Injection and pending
            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)
            # Reset or read
            file_block = yield future
            self.write(file_block)
            file_block = None
            self.flush()
        file_block = None
        self.finish()

        # Release memory...
        file_stream = None
        file_data = None
        return self

    head=get
    pass

################################################################################

class FilesOperationHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self):
        """"""/files/operation/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async():
            operation_content_raw = self.request.body
            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))
            action = operation_content['action']
            sources = operation_content['source']
            if type(sources) == list:
                for i in range(0, len(sources)):
                    try:
                        sources[i] = decode_hexed_b64_to_str(sources[i])
                    except:
                        pass
            else:
                sources = decode_hexed_b64_to_str(sources)
            if action in ['copy', 'move']:
                try:
                    target = decode_hexed_b64_to_str(operation_content['target'])
                except:
                    target = '/'
            elif action in ['rename', 'new-folder']:
                try:
                    target = operation_content['target']
                except:
                    target = sources # I am not handling more exceptions as this is brutal enough
            # Done assigning values, now attempting to perform operation
            if action == 'copy':
                for source in sources:
                    db.Filesystem.copy(source, target, new_owner='user-cp')
            elif action == 'move':
                for source in sources:
                    db.Filesystem.move(source, target)
            elif action == 'delete':
                for source in sources:
                    db.Filesystem.remove(source)
            elif action == 'rename':
                db.Filesystem.rename(sources, target)
            elif action == 'new-folder':
                db.Filesystem.mkdir(sources, target, 'user-nf')
            future.set_result('')
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.write(file_temp)
        self.flush()
        self.finish()
        return self
    pass

################################################################################

class FilesUploadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self, target_path, file_name):
        """"""/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()
        working_user = users.get_user_by_cookie(
            self.get_cookie('user_active_login', default=''))

        def save_file_async(alter_ego, target_path, file_name, working_user):
            upload_data = alter_ego.request.body
            # Crucial, to release data.
            alter_ego.request.body = None
            target_path = decode_hexed_b64_to_str(target_path)
            # Committing changes to database
            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)
            # Final return
            future.set_result('bzs_upload_success')
        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,
            self, target_path, file_name, working_user)

        response_temp = yield future
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(response_temp)))
        self.write(response_temp)
        self.flush()
        self.finish()
        return self
    pass
/n/n/n/bzs/module_home.py/n/n
import re
import tornado

from bzs import files
from bzs import const
from bzs import users
from bzs import preproc

class HomeHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_index_html_async():
                file_data = files.get_static_data('./static/home.html')
                working_user = users.get_user_by_cookie(
                    self.get_cookie('user_active_login', default=''))
                file_data = preproc.preprocess_webpage(file_data, working_user)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)
            file_data = yield future
        except Exception:
            self.set_status(404, ""Not Found"")
            self._headers = tornado.httputil.HTTPHeaders()
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        self.set_status(200, ""OK"")
        self._headers = tornado.httputil.HTTPHeaders()
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/n",1
16,4164d239f0f59b9ef04e3d168e68f958991fe88f,"titlebot.py/n/n#!/usr/bin/env python2
# coding: utf-8

import os
import sys
import socket
import string
import time
import urllib2
import HTMLParser
import zlib

import libirc

HOST=""irc.freenode.net""
PORT=6667
NICK=""titlebot""
IDENT=""titlebot""
REALNAME=""titlebot""
CHANS=[""##Orz""]

def ParseURL(s):
    http_idx=s.find('http:')
    https_idx=s.find('https:')
    if https_idx==-1:
        if http_idx==-1:
            return None
        else:
            return s[http_idx:]
    else:
        if http_idx==-1:
            return s[https_idx:]
        else:
            return s[min(http_idx, https_idx):]

try:
    c=libirc.IRCConnection()
    c.connect((HOST, PORT))
    c.setnick(NICK)
    c.setuser(IDENT, REALNAME)
    for CHAN in CHANS:
        c.join(CHAN)
except:
    time.sleep(10)
    sys.stderr.write(""Restarting...\n"")
    os.execlp(""python2"", ""python2"", __file__)
    raise
CHAN=CHANS[0]
socket.setdefaulttimeout(10)

html_parser=HTMLParser.HTMLParser()

quiting=False
while not quiting:
    if not c.sock:
        quiting=True
        time.sleep(10)
        sys.stderr.write(""Restarting...\n"")
        os.execlp(""python2"", ""python2"", __file__)
        break
    try:
        line=c.recvline(block=True)
        if not line:
            continue
        sys.stderr.write(""%s\n"" % line.encode('utf-8', 'replace'))
        line=c.parse(line=line)
        if line and line[""cmd""]==""PRIVMSG"":
            if line[""dest""]==NICK:
                if line[""msg""]==u""Get out of this channel!"": # A small hack
                    c.quit(u""%s asked to leave."" % line[""nick""])
                    quiting=True
            else:
                CHAN=line[""dest""]
                for w in line[""msg""].split():
                    w=ParseURL(w)
                    if w:
                        w=w.split("">"", 1)[0].split('""', 1)[0]
                        if re.match(""https?:/*git.io(/|$)"", w): # Fix buggy git.io
                            continue
                        opener=urllib2.build_opener()
                        opener.addheaders = [(""Accept-Charset"", ""utf-8, iso-8859-1""), (""Accept-Language"", ""zh-cn, zh-hans, zh-tw, zh-hant, zh, en-us, en-gb, en""), (""Range"", ""bytes=0-16383""), (""User-Agent"", ""Mozilla/5.0 (compatible; Titlebot; like IRCbot; +https://github.com/m13253/titlebot)""), (""X-Forwarded-For"", ""10.2.0.101""), (""X-moz"", ""prefetch""), (""X-Prefetch"", ""yes""), (""X-Requested-With"", ""Titlebot"")]
                        h=opener.open(w.encode(""utf-8"", ""replace""))
                        if h.code==200 or h.code==206:
                            if not ""Content-Type"" in h.info() or h.info()[""Content-Type""].split("";"")[0]==""text/html"":
                                wbuf=h.read(16384)
                                read_times=1
                                while len(wbuf)<16384 and read_times<4:
                                    read_times+=1
                                    wbuf_=h.read(16384)
                                    if wbuf_:
                                        wbuf+=wbuf_
                                    else:
                                        break
                                if ""Content-Encoding"" in h.info() and h.info()[""Content-Encoding""]==""gzip"": # Fix buggy www.bilibili.tv
                                    try:
                                        gunzip_obj=zlib.decompressobj(16+zlib.MAX_WBITS)
                                        wbuf=gunzip_obj.decompress(wbuf)
                                    except:
                                        pass
                                if wbuf.find(""<title>"")!=-1:
                                    titleenc=wbuf.split(""<title>"")[1].split(""</title>"")[0]
                                    title=None
                                    for enc in (""utf-8"", ""gbk"", ""gb18030"", ""iso-8859-1""):
                                        try:
                                            title=titleenc.decode(enc)
                                            break
                                        except UnicodeDecodeError:
                                            pass
                                    if title==None:
                                        title=title.decode(""utf-8"", ""replace"")
                                    title=html_parser.unescape(title).replace(""\r"", """").replace(""\n"", "" "").strip()
                                    c.say(CHAN, u"": %s"" % title)
                                else:
                                    c.say(CHAN, u"""")
                            else:
                                if ""Content-Range"" in h.info():
                                    c.say(CHAN, u"": %s, : %s \r\n"" % (h.info()[""Content-Type""], h.info()[""Content-Range""].split(""/"")[1]))
                                elif ""Content-Length"" in h.info():
                                    c.say(CHAN, u"": %s, : %s \r\n"" % (h.info()[""Content-Type""], h.info()[""Content-Length""]))
                                else:
                                    c.say(CHAN, u"": %s\r\n"" % h.info()[""Content-Type""])
                        else:
                            c.say(CHAN, u""HTTP %d \r\n"" % h.code)
    except Exception as e:
        try:
            c.say(CHAN, u""%s : %s"" % (NICK, e))
        except:
            pass
    except socket.error as e:
        sys.stderr.write(""Error: %s\n"", e)
        c.quit(""Network error."")

# vim: et ft=python sts=4 sw=4 ts=4
/n/n/n",0
17,4164d239f0f59b9ef04e3d168e68f958991fe88f,"/titlebot.py/n/n#!/usr/bin/env python2
# coding: utf-8

import os
import sys
import socket
import string
import time
import urllib2
import HTMLParser
import zlib

import libirc

HOST=""irc.freenode.net""
PORT=6667
NICK=""titlebot""
IDENT=""titlebot""
REALNAME=""titlebot""
CHANS=[""##Orz""]

def ParseURL(s):
    http_idx=s.find('http:')
    https_idx=s.find('https:')
    if https_idx==-1:
        if http_idx==-1:
            return None
        else:
            return s[http_idx:]
    else:
        if http_idx==-1:
            return s[https_idx:]
        else:
            return s[min(http_idx, https_idx):]

try:
    c=libirc.IRCConnection()
    c.connect((HOST, PORT))
    c.setnick(NICK)
    c.setuser(IDENT, REALNAME)
    for CHAN in CHANS:
        c.join(CHAN)
except:
    time.sleep(10)
    sys.stderr.write(""Restarting...\n"")
    os.execlp(""python2"", ""python2"", __file__)
    raise
CHAN=CHANS[0]
socket.setdefaulttimeout(10)

html_parser=HTMLParser.HTMLParser()

quiting=False
while not quiting:
    if not c.sock:
        quiting=True
        time.sleep(10)
        sys.stderr.write(""Restarting...\n"")
        os.execlp(""python2"", ""python2"", __file__)
        break
    try:
        line=c.recvline(block=True)
        if not line:
            continue
        sys.stderr.write(""%s\n"" % line.encode('utf-8', 'replace'))
        line=c.parse(line=line)
        if line and line[""cmd""]==""PRIVMSG"":
            if line[""dest""]==NICK:
                if line[""msg""]==u""Get out of this channel!"": # A small hack
                    c.quit(u""%s asked to leave."" % line[""nick""])
                    quiting=True
            else:
                CHAN=line[""dest""]
                for w in line[""msg""].split():
                    w=ParseURL(w)
                    if w:
                        w=w.split("">"", 1)[0].split('""', 1)[0]
                        if re.match(""https?:/*git.io(/|$)"", w): # Fix buggy git.io
                            continue
                        opener=urllib2.build_opener()
                        opener.addheaders = [(""Accept-Charset"", ""utf-8, iso-8859-1""), (""Accept-Language"", ""zh-cn, zh-hans, zh-tw, zh-hant, zh, en-us, en-gb, en""), (""Range"", ""bytes=0-16383""), (""User-Agent"", ""Mozilla/5.0 (compatible; Titlebot; like IRCbot; +https://github.com/m13253/titlebot)""), (""X-Forwarded-For"", ""10.2.0.101""), (""X-moz"", ""prefetch""), (""X-Prefetch"", ""yes"")]
                        h=opener.open(w.encode(""utf-8"", ""replace""))
                        if h.code==200 or h.code==206:
                            if not ""Content-Type"" in h.info() or h.info()[""Content-Type""].split("";"")[0]==""text/html"":
                                wbuf=h.read(16384)
                                read_times=1
                                while len(wbuf)<16384 and read_times<4:
                                    read_times+=1
                                    wbuf_=h.read(16384)
                                    if wbuf_:
                                        wbuf+=wbuf_
                                    else:
                                        break
                                if ""Content-Encoding"" in h.info() and h.info()[""Content-Encoding""]==""gzip"": # Fix buggy www.bilibili.tv
                                    try:
                                        gunzip_obj=zlib.decompressobj(16+zlib.MAX_WBITS)
                                        wbuf=gunzip_obj.decompress(wbuf)
                                    except:
                                        pass
                                if wbuf.find(""<title>"")!=-1:
                                    titleenc=wbuf.split(""<title>"")[1].split(""</title>"")[0]
                                    title=None
                                    for enc in (""utf-8"", ""gbk"", ""gb18030"", ""iso-8859-1""):
                                        try:
                                            title=titleenc.decode(enc)
                                            break
                                        except UnicodeDecodeError:
                                            pass
                                    if title==None:
                                        title=title.decode(""utf-8"", ""replace"")
                                    title=html_parser.unescape(title).replace(""\r"", """").replace(""\n"", "" "").strip()
                                    c.say(CHAN, u"": %s"" % title)
                                else:
                                    c.say(CHAN, u"""")
                            else:
                                if ""Content-Range"" in h.info():
                                    c.say(CHAN, u"": %s, : %s \r\n"" % (h.info()[""Content-Type""], h.info()[""Content-Range""].split(""/"")[1]))
                                elif ""Content-Length"" in h.info():
                                    c.say(CHAN, u"": %s, : %s \r\n"" % (h.info()[""Content-Type""], h.info()[""Content-Length""]))
                                else:
                                    c.say(CHAN, u"": %s\r\n"" % h.info()[""Content-Type""])
                        else:
                            c.say(CHAN, u""HTTP %d \r\n"" % h.code)
    except Exception as e:
        try:
            c.say(CHAN, u""%s : %s"" % (NICK, e))
        except:
            pass
    except socket.error as e:
        sys.stderr.write(""Error: %s\n"", e)
        c.quit(""Network error."")

# vim: et ft=python sts=4 sw=4 ts=4
/n/n/n",1
18,3d7fb2f1011883da7b627693e001b132bdebf4ea,"aeoid/handlers.py/n/n#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import logging
import os

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template
from openid.consumer.consumer import Consumer
from openid.consumer.discover import DiscoveryFailure
from openid.extensions import sreg
from openid.extensions import ax

from aeoid import store
from aeoid import users


class BaseHandler(webapp.RequestHandler):
  def initialize(self, request, response):
    super(BaseHandler, self).initialize(request, response)
    self.session = self.request.environ.get('aeoid.beaker.session')

  def render_template(self, filename, template_args=None):
    if not template_args:
      template_args = {}
    path = os.path.join(os.path.dirname(__file__), 'templates', filename)
    self.response.out.write(template.render(path, template_args))

  def get_consumer(self):
    return Consumer(self.session, store.AppEngineStore())


class BeginLoginHandler(BaseHandler):
  def get(self):
    openid_url = self.request.get('openid_url')
    if not openid_url:
      self.render_template('login.html', {
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
      return

    try:
      consumer = self.get_consumer()
      request = consumer.begin(openid_url)
			
      # TODO: Support custom specification of extensions
      # TODO: Don't ask for data we already have, perhaps?
      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    
      ax_req = ax.FetchRequest()
      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))
      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))
      request.addExtension(ax_req)
      
      continue_url = self.request.get('continue', '/')
      return_to = ""%s%s?continue=%s"" % (self.request.host_url,
                                        users.OPENID_FINISH_PATH, continue_url)
      self.redirect(request.redirectURL(self.request.host_url, return_to))
      self.session.save()
    except DiscoveryFailure, ex:
      logging.error(""Unexpected error in OpenID authentication: %s"" % ex)
      self.render_template('error.html', {'identity_url': openid_url})


  def post(self):
    self.get()


class FinishLoginHandler(BaseHandler):
  def finish_login(self, response):
    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}
    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    #if ax_fetch:
    #  ax_data = ax_fetch.getExtensionArgs();
    #else:
    #  ax_data = {}
      
    #for k, v in ax_data.items():
    #  logging.info(""key: "" + k + "", value: "" + v)
    
    #user_info = users.UserInfo.update_or_insert(
    #    response.endpoint.claimed_id,
    #    server_url=response.endpoint.server_url,
    #    **dict(sreg_data))

    ax_data = {}
    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    if ax_fetch:
      args = ax_fetch.getExtensionArgs()
      i = 0
      while ""type.ext%i"" % i in args:
        t = args[""type.ext%i"" % i]
        logging.info(""type: %s"" % t)
        if t == ""http://axschema.org/namePerson/first"":
          p = ""nickname""
        elif t == ""http://axschema.org/contact/email"":
          p = ""email""
        else:
          p = ""unknown""
        ax_data[p] = args[""value.ext%i.1"" % i]
        i = i + 1

    res_data = {}
    res_data.update(sreg_data)
    res_data.update(ax_data)
    
    user_info = users.UserInfo.update_or_insert(
        response.endpoint.claimed_id,
        server_url=response.endpoint.server_url,
        **dict(res_data))
    
    self.session['aeoid.user'] = str(user_info.key())
    self.session.save()
    users._current_user = users.User(None, _from_model_key=user_info.key(),
                                     _from_model=user_info)
    self.redirect(self.request.get('continue', '/'))

  def get(self):
    consumer = self.get_consumer()
    response = consumer.complete(self.request.GET, self.request.url)
    if response.status == 'success':
      self.finish_login(response)
    elif response.status in ('failure', 'cancel'):
      self.render_template('failure.html', {
          'response': response,
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
    else:
      logging.error(""Unexpected error in OpenID authentication: %s"", response)
      self.render_template('error.html', {'identity_url': response.identity_url()})


class LogoutHandler(BaseHandler):
  def get(self):
    # before logging user out, check that http referer contains the current hostname
    httphost = str(self.request.environ.get('HTTP_HOST'))
    httprefer = str(self.request.environ.get('HTTP_REFERER'))
    # if it does, log them out as expected
    if httprefer.startswith(('http://'+httphost,'https://'+httphost)):
      if 'aeoid.user' in self.session:
        del self.session['aeoid.user']
      self.session.save()
      self.redirect(self.request.get('continue', '/'))
    # if it doesn't, prompt them via an interstitial page
    else:
      self.render_template('logout.html', {
          'confirmurl': '?continue='+self.request.get('continue', '/'),
          'cancelurl': self.request.get('continue', '/')
      })


# highly modified from example at:
# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/
class StaticHandler(webapp.RequestHandler):
  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }
  
  def get(self, filepath, fileext):
    # build full system path to requested file
    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )
    
    # only allow specified file extensions
    if not self.allowed_exts.has_key(fileext):
      logging.error(""Not an allowed file extension: %s"" % fileext)
      self.error(404)
      return
    
    # file must exist before we can return it
    if not os.path.isfile(resourcepath):
      logging.error(""Not an existing file: '%s'"" % resourcepath)
      self.error(404)
      return
    
    # only allow absolute paths (no symlinks or up-level references, for example)
    testpath = os.path.normcase(resourcepath)
    if testpath != os.path.abspath(testpath):
      logging.error(""Not an absolute path to file: '%s' != '%s'"" % (testpath, os.path.abspath(testpath)) )
      self.error(403)
      return
    
    # set appropriate content-type
    self.response.headers['Content-Type'] = self.allowed_exts[fileext]
    
    # serve file (supporting client-side caching)
    try:
      import datetime
      fileinfo = os.stat(resourcepath)
      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])
      if self.request.headers.has_key('If-Modified-Since'):
        dt = self.request.headers.get('If-Modified-Since').split(';')[0]
        modsince = datetime.datetime.strptime(dt, ""%a, %d %b %Y %H:%M:%S %Z"")
        if modsince >= lastmod:
        # The file is older than the cached copy (or exactly the same)
          self.error(304)
          return
        else:
        # The file is newer
          self.output_file(resourcepath, lastmod)
      else:
        self.output_file(resourcepath, lastmod)
    except Exception, e:
      logging.error(""Failed to serve file: %s"" % e)
      self.error(404)
      return

  def output_file(self, resourcepath, lastmod):
    import datetime
    try:
      self.response.headers['Cache-Control']='public, max-age=31536000'
      self.response.headers['Last-Modified'] = lastmod.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      expires=lastmod+datetime.timedelta(days=365)
      self.response.headers['Expires'] = expires.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      self.response.out.write( file(resourcepath, 'rb').read() )
      return
    except IOError, e:
      logging.error(""Failed to output file: %s"" % e)
      self.error(404)
      return


handler_map = [
    (users.OPENID_LOGIN_PATH, BeginLoginHandler),
    (users.OPENID_FINISH_PATH, FinishLoginHandler),
    (users.OPENID_LOGOUT_PATH, LogoutHandler),
    (users.OPENID_STATIC_PATH, StaticHandler),
]
/n/n/n",0
19,3d7fb2f1011883da7b627693e001b132bdebf4ea,"/aeoid/handlers.py/n/n#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import logging
import os

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template
from openid.consumer.consumer import Consumer
from openid.consumer.discover import DiscoveryFailure
from openid.extensions import sreg
from openid.extensions import ax

from aeoid import store
from aeoid import users


class BaseHandler(webapp.RequestHandler):
  def initialize(self, request, response):
    super(BaseHandler, self).initialize(request, response)
    self.session = self.request.environ.get('aeoid.beaker.session')

  def render_template(self, filename, template_args=None):
    if not template_args:
      template_args = {}
    path = os.path.join(os.path.dirname(__file__), 'templates', filename)
    self.response.out.write(template.render(path, template_args))

  def get_consumer(self):
    return Consumer(self.session, store.AppEngineStore())


class BeginLoginHandler(BaseHandler):
  def get(self):
    openid_url = self.request.get('openid_url')
    if not openid_url:
      self.render_template('login.html', {
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
      return

    try:
      consumer = self.get_consumer()
      request = consumer.begin(openid_url)
			
      # TODO: Support custom specification of extensions
      # TODO: Don't ask for data we already have, perhaps?
      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    
      ax_req = ax.FetchRequest()
      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))
      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))
      request.addExtension(ax_req)
      
      continue_url = self.request.get('continue', '/')
      return_to = ""%s%s?continue=%s"" % (self.request.host_url,
                                        users.OPENID_FINISH_PATH, continue_url)
      self.redirect(request.redirectURL(self.request.host_url, return_to))
      self.session.save()
    except DiscoveryFailure, ex:
      logging.error(""Unexpected error in OpenID authentication: %s"" % ex)
      self.render_template('error.html', {'identity_url': openid_url})


  def post(self):
    self.get()


class FinishLoginHandler(BaseHandler):
  def finish_login(self, response):
    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}
    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    #if ax_fetch:
    #  ax_data = ax_fetch.getExtensionArgs();
    #else:
    #  ax_data = {}
      
    #for k, v in ax_data.items():
    #  logging.info(""key: "" + k + "", value: "" + v)
    
    #user_info = users.UserInfo.update_or_insert(
    #    response.endpoint.claimed_id,
    #    server_url=response.endpoint.server_url,
    #    **dict(sreg_data))

    ax_data = {}
    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    if ax_fetch:
      args = ax_fetch.getExtensionArgs()
      i = 0
      while ""type.ext%i"" % i in args:
        t = args[""type.ext%i"" % i]
        logging.info(""type: %s"" % t)
        if t == ""http://axschema.org/namePerson/first"":
          p = ""nickname""
        elif t == ""http://axschema.org/contact/email"":
          p = ""email""
        else:
          p = ""unknown""
        ax_data[p] = args[""value.ext%i.1"" % i]
        i = i + 1

    res_data = {}
    res_data.update(sreg_data)
    res_data.update(ax_data)
    
    user_info = users.UserInfo.update_or_insert(
        response.endpoint.claimed_id,
        server_url=response.endpoint.server_url,
        **dict(res_data))
    
    self.session['aeoid.user'] = str(user_info.key())
    self.session.save()
    users._current_user = users.User(None, _from_model_key=user_info.key(),
                                     _from_model=user_info)
    self.redirect(self.request.get('continue', '/'))

  def get(self):
    consumer = self.get_consumer()
    response = consumer.complete(self.request.GET, self.request.url)
    if response.status == 'success':
      self.finish_login(response)
    elif response.status in ('failure', 'cancel'):
      self.render_template('failure.html', {
          'response': response,
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
    else:
      logging.error(""Unexpected error in OpenID authentication: %s"", response)
      self.render_template('error.html', {'identity_url': response.identity_url()})


class LogoutHandler(BaseHandler):
  def get(self):
    # TODO: Handle the possibility of XSRF forcing a user to log out
    if 'aeoid.user' in self.session:
      del self.session['aeoid.user']
    self.session.save()
    self.redirect(self.request.get('continue', '/'))


# highly modified from example at:
# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/
class StaticHandler(webapp.RequestHandler):
  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }
  
  def get(self, filepath, fileext):
    # build full system path to requested file
    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )
    
    # only allow specified file extensions
    if not self.allowed_exts.has_key(fileext):
      logging.error(""Not an allowed file extension: %s"" % fileext)
      self.error(404)
      return
    
    # file must exist before we can return it
    if not os.path.isfile(resourcepath):
      logging.error(""Not an existing file: '%s'"" % resourcepath)
      self.error(404)
      return
    
    # only allow absolute paths (no symlinks or up-level references, for example)
    testpath = os.path.normcase(resourcepath)
    if testpath != os.path.abspath(testpath):
      logging.error(""Not an absolute path to file: '%s' != '%s'"" % (testpath, os.path.abspath(testpath)) )
      self.error(403)
      return
    
    # set appropriate content-type
    self.response.headers['Content-Type'] = self.allowed_exts[fileext]
    
    # serve file (supporting client-side caching)
    try:
      import datetime
      fileinfo = os.stat(resourcepath)
      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])
      if self.request.headers.has_key('If-Modified-Since'):
        dt = self.request.headers.get('If-Modified-Since').split(';')[0]
        modsince = datetime.datetime.strptime(dt, ""%a, %d %b %Y %H:%M:%S %Z"")
        if modsince >= lastmod:
        # The file is older than the cached copy (or exactly the same)
          self.error(304)
          return
        else:
        # The file is newer
          self.output_file(resourcepath, lastmod)
      else:
        self.output_file(resourcepath, lastmod)
    except Exception, e:
      logging.error(""Failed to serve file: %s"" % e)
      self.error(404)
      return

  def output_file(self, resourcepath, lastmod):
    import datetime
    try:
      self.response.headers['Cache-Control']='public, max-age=31536000'
      self.response.headers['Last-Modified'] = lastmod.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      expires=lastmod+datetime.timedelta(days=365)
      self.response.headers['Expires'] = expires.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      self.response.out.write( file(resourcepath, 'rb').read() )
      return
    except IOError, e:
      logging.error(""Failed to output file: %s"" % e)
      self.error(404)
      return


handler_map = [
    (users.OPENID_LOGIN_PATH, BeginLoginHandler),
    (users.OPENID_FINISH_PATH, FinishLoginHandler),
    (users.OPENID_LOGOUT_PATH, LogoutHandler),
    (users.OPENID_STATIC_PATH, StaticHandler),
]
/n/n/n",1
20,d81fc3b81a2255ae128c54bf50a83bebc2118439,"app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

def to_authorization_params(param):
    param_list = [
        'contact_name',
        'contact_email',
        'organization_name',
        'domain_write_permission',
        'read_permission',
        'full_read_permission',
        'search_permission',
        'subscribe_permission',
        'mark_notes_reviewed',
        'believed_dead_permission',
        'stats_permission',
        'is_valid',
    ]
    ret = {}
    for param_name in param_list:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags,
                           xsrf_token=xsrf_tool.generate_token(
                               user.user_id(), 'admin_api_keys'))


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/napp/utils.py/n/n#!/usr/bin/python2.7
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'

from django_setup import ugettext as _  # always keep this first

import calendar
import cgi
from datetime import datetime, timedelta
import hmac
import httplib
import logging
import os
import random
import re
import string
import sys
import time
import traceback
import unicodedata
import urllib
import urlparse
import base64

import django.utils.html
from django.template.defaulttags import register
from google.appengine.api import images
from google.appengine.api import taskqueue
from google.appengine.api import users
from google.appengine.ext import webapp
import google.appengine.ext.webapp.template
import google.appengine.ext.webapp.util
from recaptcha.client import captcha
from babel.dates import format_date
from babel.dates import format_datetime
from babel.dates import format_time
import babel

import const
import config
import model
import pfif
import resources

# The domain name from which to send e-mail.
EMAIL_DOMAIN = 'appspotmail.com'  # All apps on appspot.com use this for mail.

# Query parameters which are automatically preserved on page transition
# if you use utils.BaseHandler.get_url() or
# env.hidden_input_tags_for_preserved_query_params.
PRESERVED_QUERY_PARAM_NAMES = ['ui', 'charsets', 'referrer']

@register.filter
def get_value(dictionary, key):
    """"""Django Template filter to get dictionary value based on the given key""""""
    return dictionary.get(key)

# ==== Field value text ========================================================


def get_person_sex_text(person):
    """"""Returns the UI text for a person's sex field.""""""
    return const.PERSON_SEX_TEXT.get(person.sex or '')


def get_note_status_text(note):
    """"""Returns the UI text for a note's status field.""""""
    return const.NOTE_STATUS_TEXT.get(note.status or '')


def get_person_status_text(person):
    """"""Returns the UI text for a person's latest_status.""""""
    return const.PERSON_STATUS_TEXT.get(person.latest_status or '')


# Things that occur as prefixes of global paths (i.e. no repository name).
GLOBAL_PATH_RE = re.compile(r'^/(global|personfinder)(/?|/.*)$')


# ==== String formatting =======================================================


def format_boolean(value):
    return value and 'true' or 'false'


def format_utc_datetime(dt):
    if not dt:
        return ''
    return dt.replace(microsecond=0).isoformat() + 'Z'


def format_utc_timestamp(timestamp):
    if not isinstance(timestamp, (int, float)):
        return ''
    return format_utc_datetime(datetime.utcfromtimestamp(timestamp))


def format_sitemaps_datetime(dt):
    integer_dt = datetime(
        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
    return integer_dt.isoformat() + '+00:00'


def encode(string, encoding='utf-8'):
    """"""If unicode, encode to encoding; if 8-bit string, leave unchanged.""""""
    if isinstance(string, unicode):
        string = string.encode(encoding)
    return string


def urlencode(params, encoding='utf-8'):
    """"""Encode the key-value pairs in 'params' into a query string, applying
    the specified encoding to any Unicode strings and ignoring any keys that
    have value == None.  (urllib.urlencode doesn't support Unicode).""""""
    keys = params.keys()
    keys.sort()  # Sort the keys to get canonical ordering
    return urllib.urlencode([
        (encode(key, encoding), encode(params[key], encoding))
        for key in keys if isinstance(params[key], basestring)])


def set_param(params, param, value):
    """"""Take the params from a urlparse and override one of the values.""""""
    # This will strip out None-valued params and collapse repeated params.
    params = dict(cgi.parse_qsl(params))
    if value is None:
        if param in params:
            del(params[param])
    else:
        params[param] = value
    return urlencode(params)


def set_url_param(url, param, value):
    """"""This modifies a URL setting the given param to the specified value.  This
    may add the param or override an existing value, or, if the value is None,
    it will remove the param.  Note that value must be a basestring and can't be
    an int, for example.""""""
    url_parts = list(urlparse.urlparse(url))
    url_parts[4] = set_param(url_parts[4], param, value)
    return urlparse.urlunparse(url_parts)


def anchor_start(href):
    """"""Returns the HREF escaped and embedded in an anchor tag.""""""
    return '<a href=""%s"">' % django.utils.html.escape(href)


def anchor(href, body):
    """"""Returns a string anchor HTML element with the given href and body.""""""
    return anchor_start(href) + django.utils.html.escape(body) + '</a>'


# ==== Validators ==============================================================

# These validator functions are used to check and parse query parameters.
# Each validator should return a parsed, sanitized value, or return a default
# value, or raise ValueError to display an error message to the user.


def strip(string):
    # Trailing nulls appear in some strange character encodings like Shift-JIS.
    return string.strip().rstrip('\0')


def strip_and_lower(string):
    return strip(string).lower()


def validate_yes(string):
    return (strip(string).lower() == 'yes') and 'yes' or ''


def validate_checkbox(string):
    return (strip(string).lower() == 'on') and 'yes' or ''


def validate_checkbox_as_bool(val):
    if val.lower() in ['on', 'yes', 'true']:
        return True
    return False


def validate_role(string):
    return (strip(string).lower() == 'provide') and 'provide' or 'seek'


def validate_int(string):
    return string and int(strip(string))


def validate_sex(string):
    """"""Validates the 'sex' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.PERSON_SEX_VALUES and string or ''


def validate_expiry(value):
    """"""Validates that the 'expiry_option' parameter is a positive integer.

    Returns:
      the int() value if it's present and parses, or the default_expiry_days
      for the repository, if it's set, otherwise -1 which represents the
      'unspecified' status.
    """"""
    try:
        value = int(value)
    except Exception, e:
        return None
    return value > 0 and value or None


APPROXIMATE_DATE_RE = re.compile(r'^\d{4}(-\d\d)?(-\d\d)?$')


def validate_approximate_date(string):
    if string:
        string = strip(string)
        if APPROXIMATE_DATE_RE.match(string):
            return string
    return ''


AGE_RE = re.compile(r'^\d+(-\d+)?$')
# Hyphen with possibly surrounding whitespaces.
HYPHEN_RE = re.compile(
    ur'\s*[-\u2010-\u2015\u2212\u301c\u30fc\ufe58\ufe63\uff0d]\s*',
    re.UNICODE)


def validate_age(string):
    """"""Validates the 'age' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string)
        string = unicodedata.normalize('NFKC', unicode(string))
        string = HYPHEN_RE.sub('-', string)
        if AGE_RE.match(string):
            return string
    return ''


def validate_status(string):
    """"""Validates an incoming status parameter, returning one of the canonical
    status strings or ''.  Note that '' is always used as the Python value
    to represent the 'unspecified' status.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.NOTE_STATUS_VALUES and string or ''


DATETIME_RE = re.compile(r'^(2\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z$')


def validate_datetime(string):
    if not string:
        return None  # A missing value is okay.
    match = DATETIME_RE.match(string)
    if match:
        return datetime(*map(int, match.groups()))
    raise ValueError('Bad datetime: %r' % string)


def validate_timestamp(string):
    try:
        return string and datetime.utcfromtimestamp(float(strip(string)))
    except:
        raise ValueError('Bad timestamp: %s' % string)


def validate_image(bytestring):
    try:
        image = None
        if bytestring:
            image = images.Image(bytestring)
            image.width
        return image
    except:
        return False


def validate_version(string):
    """"""Version, if present, should be in pfif versions.""""""
    if string and strip(string) not in pfif.PFIF_VERSIONS:
        raise ValueError('Bad pfif version: %s' % string)
    return pfif.PFIF_VERSIONS[strip(string) or pfif.PFIF_DEFAULT_VERSION]


REPO_RE = re.compile('^[a-z0-9-]+$')


def validate_repo(string):
    string = (string or '').strip()
    if not string:
        return None
    if string == 'global':
        raise ValueError('""global"" is an illegal repository name.')
    if REPO_RE.match(string):
        return string
    raise ValueError('Repository names can only contain '
                     'lowercase letters, digits, and hyphens.')


RESOURCE_NAME_RE = re.compile('^[a-z0-9._-]+$')


def validate_resource_name(string):
    """"""A resource name or bundle label.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if RESOURCE_NAME_RE.match(string):
        return string
    raise ValueError('Invalid resource name or bundle name: %r' % string)


LANG_RE = re.compile('^[A-Za-z0-9-]+$')


def validate_lang(string):
    """"""A BCP 47 language tag.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if LANG_RE.match(string):
        return string
    raise ValueError('Invalid language tag: %r' % string)


def validate_cache_seconds(string):
    """"""A number of seconds to cache a Resource in RAM.""""""
    string = (string or '').strip()
    if string:
        return float(string)
    return 1.0


# ==== Other utilities =========================================================


def url_is_safe(url):
    current_scheme, _, _, _, _ = urlparse.urlsplit(url)
    return current_scheme in ['http', 'https']


def get_app_name():
    """"""Canonical name of the app, without HR s~ nonsense.  This only works in
    the context of the appserver (eg remote_api can't use it).""""""
    from google.appengine.api import app_identity
    return app_identity.get_application_id()


def sanitize_urls(record):
    """"""Clean up URLs to protect against XSS.""""""
    # Single-line URLs.
    for field in ['photo_url', 'source_url']:
        url = getattr(record, field, None)
        if url and not url_is_safe(url):
            setattr(record, field, None)
    # Multi-line URLs.
    for field in ['profile_urls']:
        urls = (getattr(record, field, None) or '').splitlines()
        sanitized_urls = [url for url in urls if url and url_is_safe(url)]
        if len(urls) != len(sanitized_urls):
            setattr(record, field, '\n'.join(sanitized_urls))


def get_host(host=None):
    host = host or os.environ['HTTP_HOST']
    """"""Return the host name, without version specific details.""""""
    parts = host.split('.')
    if len(parts) > 3:
        return '.'.join(parts[-3:])
    else:
        return host


# List of sensitive field names in person and note records.
SENSITIVE_FIELDS = [
  'date_of_birth',
  'author_email',
  'author_phone',
  'email_of_found_person',
  'phone_of_found_person',
]


def optionally_filter_sensitive_fields(records, auth=None):
    """"""Removes sensitive fields from a list of dictionaries, unless the client
    has full read authorization.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    if not (auth and auth.full_read_permission):
        filter_sensitive_fields(records)


def filter_sensitive_fields(records):
    """"""Removes sensitive fields from a list of dictionaries.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    for record in records:
        for prefix in ['', 'person_', 'note_']:
            for field in SENSITIVE_FIELDS:
                prefixed_field = prefix + field
                if prefixed_field in record:
                    record[prefixed_field] = ''


def join_person_and_note_record(person_record, note_record):
    """"""Join a person record and a note record into a single dictionary.

    The field names are prefixed with 'person_' or 'note_' to avoid name
    collision. note_record can be None. In that case, person record field
    names are still prefixed.

    Args:
        person_record (dict): A dictionary representation of a person record.
            Cannot be None.
        note_record (dict): A dictionary representation of a note record for
            the person. Can be None.
    """"""
    joined_record = {}
    for name, value in person_record.iteritems():
        new_name = get_field_name_for_joined_record(name, 'person')
        joined_record[new_name] = value
    if note_record:
        assert (note_record['person_record_id'] ==
                person_record['person_record_id'])
        for name, value in note_record.iteritems():
            new_name = get_field_name_for_joined_record(name, 'note')
            joined_record[new_name] = value
    return joined_record


def get_field_name_for_joined_record(original_field_name, record_type):
    """"""Converts a field name in a person/note record into a field name used in
    a joined record of a person and a note.

    See also join_person_and_note_record().

    Args:
        original_field_name (str): A field name in a person/note record.
        record_type (str): 'person' or 'note'.
    """"""
    if original_field_name in ('person_record_id', 'note_record_id'):
        return original_field_name
    else:
        return '%s_%s' % (record_type, original_field_name)


# The current time for testing as a datetime object, or None if using real time.
_utcnow_for_test = None


def set_utcnow_for_test(now):
    """"""Sets the current time for testing purposes.  Pass in a datetime object
    or a timestamp in epoch seconds; or pass None to revert to real time.""""""
    global _utcnow_for_test
    if isinstance(now, (int, float)):
        now = datetime.utcfromtimestamp(float(now))
    _utcnow_for_test = now


def get_utcnow():
    """"""Returns the current UTC datetime (settable with set_utcnow_for_test).""""""
    global _utcnow_for_test
    return (_utcnow_for_test is None) and datetime.utcnow() or _utcnow_for_test


def get_timestamp(dt):
    """"""Converts datetime object to a float value in epoch seconds.""""""
    return calendar.timegm(dt.utctimetuple()) + dt.microsecond * 1e-6


def get_utcnow_timestamp():
    """"""Returns the current time in epoch seconds (settable with
    set_utcnow_for_test).""""""
    return get_timestamp(get_utcnow())


def log_api_action(handler, action, num_person_records=0, num_note_records=0,
                   people_skipped=0, notes_skipped=0):
    """"""Log an API action.""""""
    if handler.config and handler.config.api_action_logging:
        model.ApiActionLog.record_action(
            handler.repo, handler.params.key,
            handler.params.version.version, action,
            num_person_records, num_note_records,
            people_skipped, notes_skipped,
            handler.request.headers.get('User-Agent'),
            handler.request.remote_addr, handler.request.url)


def get_full_name(given_name, family_name, config):
    """"""Return full name string obtained by concatenating given_name and
    family_name in the order specified by config.family_name_first, or just
    given_name if config.use_family_name is False.""""""
    if config.use_family_name:
        separator = (given_name and family_name) and u' ' or u''
        if config.family_name_first:
            return separator.join([family_name, given_name])
        else:
            return separator.join([given_name, family_name])
    else:
        return given_name


def send_confirmation_email_to_record_author(
    handler, person, action, confirm_url, record_id):
    """"""Send the author an email to confirm enabling/disabling notes
    of a record.""""""
    if not person.author_email:
        return handler.error(
            400, _('No author email for record %(id)s.') % {'id' : record_id})

    # i18n: Subject line of an e-mail message confirming the author
    # wants to disable notes for this record
    if action == 'enable':
        subject = _('[Person Finder] Enable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    elif action == 'disable':
        subject = _('[Person Finder] Disable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    else:
        raise ValueError('Unknown action: %s' % action)

    # send e-mail to record author confirming the lock of this record.
    template_name = '%s_notes_email.txt' % action
    handler.send_mail(
        subject=subject,
        to=person.author_email,
        body=handler.render_to_string(
            template_name,
            author_name=person.author_name,
            full_name=person.primary_full_name,
            site_url=handler.get_url('/'),
            confirm_url=confirm_url
        )
    )


def get_repo_url(request, repo, scheme=None):
    """"""Constructs the absolute root URL for a given repository.""""""
    req_scheme, req_netloc, req_path, _, _ = urlparse.urlsplit(request.url)
    prefix = req_path.startswith('/personfinder') and '/personfinder' or ''
    if is_dev_app_server():
        scheme = 'http'  # HTTPS is not available when using dev_appserver
    return (scheme or req_scheme) + '://' + req_netloc + prefix + '/' + repo


def get_url(request, repo, action, charset='utf-8', scheme=None, **params):
    """"""Constructs the absolute URL for a given action and query parameters,
    preserving the current repo and the parameters listed in
    PRESERVED_QUERY_PARAM_NAMES.""""""
    repo_url = get_repo_url(request, repo or 'global', scheme)
    for name in PRESERVED_QUERY_PARAM_NAMES:
        params[name] = params.get(name, request.get(name, None))
    query = urlencode(params, charset)
    return repo_url + '/' + action.lstrip('/') + (query and '?' + query or '')


def add_profile_icon_url(website, handler):
    website['icon_url'] = \
        handler.env.global_url + '/' + website['icon_filename']
    return website


def strip_url_scheme(url):
    if not url:
        return url
    _, netloc, path, query, segment = urlparse.urlsplit(url)
    return urlparse.urlunsplit(('', netloc, path, query, segment))


def is_dev_app_server():
    return os.environ['APPLICATION_ID'].startswith('dev~')

# ==== Struct ==================================================================

class Struct:
    """"""A simple bag of attributes.""""""
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def get(self, name, default=None):
        return self.__dict__.get(name, default)


# ==== Key management ======================================================

def generate_random_key(length):
    """"""Generates a random key with given length.""""""
    source = ('abcdefghijklmnopqrstuvwxyz'
              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
              '1234567890'
              '-_')
    rng = random.SystemRandom()
    return ''.join(rng.choice(source) for i in range(length))


# ==== Decorators  ============================================================

def require_api_key_management_permission(handler_method):
    """"""
    This is a decorator for API Key management feature. The limitation
    is that the decorator can not preserve payloads within a POST/PUT
    request.

    Usage:
    class SomeHandler(utils.BaseHandler):
        @utils.require_api_key_management_permission
        def get(self):
            # ....
            # ....
    """"""
    def inner(*args, **kwargs):
        handler = args[0]
        user = users.get_current_user()
        if (users.is_current_user_admin() or
            (user and handler.config.key_management_operators and
             user.email() in handler.config.key_management_operators)):
            return handler_method(*args, **kwargs)
        else:
            return handler.redirect(
                users.create_login_url(handler.request.url))
    return inner


# ==== Base Handler ============================================================

class BaseHandler(webapp.RequestHandler):
    # Handlers that don't need a repository name can set this to False.
    repo_required = True

    # Handlers that require HTTPS can set this to True.
    https_required = False

    # Set this to True to enable a handler even for deactivated repositories.
    ignore_deactivation = False

    # Handlers that require an admin permission must set this to True.
    admin_required = False

    # List all accepted query parameters here with their associated validators.
    auto_params = {
        'action': strip,
        'add_note': validate_yes,
        'age': validate_age,
        'alternate_family_names': strip,
        'alternate_given_names': strip,
        'author_email': strip,
        'author_made_contact': validate_yes,
        'author_name': strip,
        'author_phone': strip,
        'your_own_email': strip,
        'your_own_phone': strip,
        'believed_dead_permission': validate_checkbox_as_bool,
        'cache_seconds': validate_cache_seconds,
        'clone': validate_yes,
        'confirm': validate_yes,
        'contact_email': strip,
        'contact_name': strip,
        'content_id': strip,
        'context': strip,
        'cursor': strip,
        'date_of_birth': validate_approximate_date,
        'description': strip,
        'domain_write_permission': strip,
        'dupe_notes': validate_yes,
        'email_of_found_person': strip,
        'error': strip,
        'expiry_option': validate_expiry,
        'family_name': strip,
        'full_read_permission': validate_checkbox_as_bool,
        'given_name': strip,
        'home_city': strip,
        'home_country': strip,
        'home_neighborhood': strip,
        'home_postal_code': strip,
        'home_state': strip,
        'home_street': strip,
        'id': strip,
        'id1': strip,
        'id2': strip,
        'id3': strip,
        'is_valid': validate_checkbox_as_bool,
        'key': strip,
        'lang': validate_lang,
        'last_known_location': strip,
        'mark_notes_reviewed': validate_checkbox_as_bool,
        'max_results': validate_int,
        'min_entry_date': validate_datetime,
        'new_repo': validate_repo,
        'note_photo': validate_image,
        'note_photo_url': strip,
        'omit_notes': validate_yes,
        'operation': strip,
        'organization_name': strip,
        'person_record_id': strip,
        'phone_of_found_person': strip,
        'photo': validate_image,
        'photo_url': strip,
        'profile_url1': strip,
        'profile_url2': strip,
        'profile_url3': strip,
        'query': strip,
        'query_name': strip,
        'query_location': strip,
        'query_type': strip,
        'read_permission': validate_checkbox_as_bool,
        'referrer': strip,
        'resource_bundle': validate_resource_name,
        'resource_bundle_default': validate_resource_name,
        'resource_bundle_original': validate_resource_name,
        'resource_lang': validate_lang,
        'resource_name': validate_resource_name,
        'role': validate_role,
        'search_engine_id': validate_int,
        'search_permission': validate_checkbox_as_bool,
        'sex': validate_sex,
        'signature': strip,
        'skip': validate_int,
        'small': validate_yes,
        'source': strip,
        'source_date': strip,
        'source_name': strip,
        'source_url': strip,
        'stats_permission': validate_checkbox_as_bool,
        'status': validate_status,
        'style': strip,
        'subscribe': validate_checkbox,
        'subscribe_own_info': validate_checkbox,
        'subscribe_email': strip,
        'subscribe_permission': validate_checkbox_as_bool,
        'suppress_redirect': validate_yes,
        'target': strip,
        'text': strip,
        'thumb': validate_checkbox_as_bool,
        'timestamp': validate_timestamp,
        'ui': strip_and_lower,
        'utcnow': validate_timestamp,
        'version': validate_version,
        'own_info': validate_yes,
        'xsrf_token': strip,
    }

    def redirect(self, path, repo=None, permanent=False, **params):
        # This will prepend the repo to the path to create a working URL,
        # unless the path has a global prefix or is an absolute URL.
        if re.match('^[a-z]+:', path) or GLOBAL_PATH_RE.match(path):
            if params:
              path += '?' + urlencode(params, self.charset)
        else:
            path = self.get_url(path, repo, **params)
        return webapp.RequestHandler.redirect(self, path, permanent=permanent)

    def render(self, name, language_override=None, cache_seconds=0,
               get_vars=lambda: {}, **vars):
        """"""Renders a template to the output stream, passing in the variables
        specified in **vars as well as any additional variables returned by
        get_vars().  Since this is intended for use by a dynamic page handler,
        caching is off by default; if cache_seconds is positive, then
        get_vars() will be called only when cached content is unavailable.""""""
        self.write(self.render_to_string(
            name, language_override, cache_seconds, get_vars, **vars))

    def render_to_string(self, name, language_override=None, cache_seconds=0,
                         get_vars=lambda: {}, **vars):
        """"""Renders a template to a string, passing in the variables specified
        in **vars as well as any additional variables returned by get_vars().
        Since this is intended for use by a dynamic page handler, caching is
        off by default; if cache_seconds is positive, then get_vars() will be
        called only when cached content is unavailable.""""""
        # TODO(kpy): Make the contents of extra_key overridable by callers?
        lang = language_override or self.env.lang
        extra_key = (self.env.repo, self.env.charset, self.request.query_string)
        def get_all_vars():
            vars.update(get_vars())
            for key in ('env', 'config', 'params'):
                if key in vars:
                    raise Exception(
                        'Cannot use ""%s"" as a key in vars. It is reserved.'
                        % key)
            vars['env'] = self.env  # pass along application-wide context
            vars['config'] = self.config  # pass along the configuration
            vars['params'] = self.params  # pass along the query parameters
            return vars
        return resources.get_rendered(
            name, lang, extra_key, get_all_vars, cache_seconds)

    def error(self, code, message='', message_html=''):
        self.info(code, message, message_html, style='error')

    def info(self, code, message='', message_html='', style='info'):
        """"""Renders a simple page with a message.

        Args:
          code: HTTP status code.
          message: A message in plain text.
          message_html: A message in HTML.
          style: 'info', 'error' or 'plain'. 'info' and 'error' differs in
              appearance. 'plain' just renders the message without extra
              HTML tags. Good for API response.
        """"""
        is_error = 400 <= code < 600
        if is_error:
            webapp.RequestHandler.error(self, code)
        else:
            self.response.set_status(code)
        if not message and not message_html:
            message = '%d: %s' % (code, httplib.responses.get(code))
        if style == 'plain':
            self.__render_plain_message(message, message_html)
        else:
            try:
                self.render('message.html', cls=style,
                            message=message, message_html=message_html)
            except:
                self.__render_plain_message(message, message_html)
        self.terminate_response()

    def __render_plain_message(self, message, message_html):
        self.response.out.write(
            django.utils.html.escape(message) +
            ('<p>' if message and message_html else '') +
            message_html)

    def terminate_response(self):
        """"""Prevents any further output from being written.""""""
        self.response.out.write = lambda *args: None
        self.get = lambda *args: None
        self.post = lambda *args: None

    def write(self, text):
        """"""Sends text to the client using the charset from select_charset().""""""
        self.response.out.write(text.encode(self.env.charset, 'replace'))

    def get_url(self, action, repo=None, scheme=None, **params):
        """"""Constructs the absolute URL for a given action and query parameters,
        preserving the current repo and the parameters listed in
        PRESERVED_QUERY_PARAM_NAMES.""""""
        return get_url(self.request, repo or self.env.repo, action,
                       charset=self.env.charset, scheme=scheme, **params)

    @staticmethod
    def add_task_for_repo(repo, name, action, **kwargs):
        """"""Queues up a task for an individual repository.""""""
        task_name = '%s-%s-%s' % (repo, name, int(time.time()*1000))
        path = '/%s/%s' % (repo, action)
        taskqueue.add(name=task_name, method='GET', url=path, params=kwargs)

    def send_mail(self, to, subject, body):
        """"""Sends e-mail using a sender address that's allowed for this app.""""""
        app_id = get_app_name()
        sender = 'Do not reply <do-not-reply@%s.%s>' % (app_id, EMAIL_DOMAIN)
        logging.info('Add mail task: recipient %r, subject %r' % (to, subject))
        taskqueue.add(queue_name='send-mail', url='/global/admin/send_mail',
                      params={'sender': sender,
                              'to': to,
                              'subject': subject,
                              'body': body})

    def get_captcha_html(self, error_code=None, use_ssl=False):
        """"""Generates the necessary HTML to display a CAPTCHA validation box.""""""

        # We use the 'custom_translations' parameter for UI messages, whereas
        # the 'lang' parameter controls the language of the challenge itself.
        # reCAPTCHA falls back to 'en' if this parameter isn't recognized.
        lang = self.env.lang.split('-')[0]

        return captcha.get_display_html(
            site_key=config.get('captcha_site_key'),
            use_ssl=use_ssl, error=error_code, lang=lang
        )

    def get_captcha_response(self):
        """"""Returns an object containing the CAPTCHA response information for the
        given request's CAPTCHA field information.""""""
        # Allows faking the CAPTCHA response by an HTTP request parameter, but
        # only locally, for testing purpose.
        faked_captcha_response = self.request.get('faked_captcha_response')
        if faked_captcha_response and self.request.remote_addr == '127.0.0.1':
            return captcha.RecaptchaResponse(
                is_valid=faked_captcha_response == 'success')

        captcha_response = self.request.get('g-recaptcha-response')
        return captcha.submit(captcha_response)

    def handle_exception(self, exception, debug_mode):
        logging.error(traceback.format_exc())
        self.error(500, _(
            'There was an error processing your request.  Sorry for the '
            'inconvenience.  Our administrators will investigate the source '
            'of the problem, but please check that the format of your '
            'request is correct.'))

    def __get_env_language_for_babel(self):
        language_code = self.env.lang
        try:
            return babel.Locale.parse(language_code, sep='-')
        except babel.UnknownLocaleError as e:
            # fallback language
            return babel.Locale('en')

    def to_local_time(self, date):
        """"""Converts a datetime object to the local time configured for the
        current repository.  For convenience, returns None if date is None.""""""
        # TODO(kpy): This only works for repositories that have a single fixed
        # time zone offset and never use Daylight Saving Time.
        if date:
            if self.config.time_zone_offset:
                return date + timedelta(0, 3600*self.config.time_zone_offset)
            return date

    def format_datetime_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale.""""""
        return format_datetime(dt, locale=self.__get_env_language_for_babel());

    def format_date_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the date.""""""
        return format_date(dt, locale=self.__get_env_language_for_babel());

    def format_time_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the time.""""""
        return format_time(dt, locale=self.__get_env_language_for_babel());

    def to_formatted_local_datetime(self, dt):
        """"""Converts a datetime object to the local datetime configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_datetime_localized(dt)

    def to_formatted_local_date(self, dt):
        """"""Converts a datetime object to the local date configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_date_localized(dt)

    def to_formatted_local_time(self, dt):
        """"""Converts a datetime object to the local time configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_time_localized(dt)

    def maybe_redirect_for_repo_alias(self, request):
        """"""If the specified repository name is an alias, redirects to the URL
        with the canonical repository name and returns True. Otherwise returns
        False.
        """"""
        # Config repo_alias is a dictionary from a repository name alias to
        # its canonical.
        # e.g., {'yol': '2013-yolanda', 'jam': '2014-jammu-kashmir-floods'}
        #
        # A repository name alias can be used instead of the canonical
        # repository name in URLs. This is especially useful combined with
        # the short URL. e.g., You can access
        # https://www.google.org/personfinder/2014-jammu-kashmir-floods
        # by http://g.co/pf/jam .
        if not self.repo:
            return False
        repo_aliases = config.get('repo_aliases', default={})
        if self.repo in repo_aliases:
            canonical_repo = repo_aliases[self.repo]
            params = {}
            for name in request.arguments():
                params[name] = request.get(name)
            # Redirects to the same URL including the query parameters, except
            # for the repository name.
            self.redirect('/' + self.env.action, repo=canonical_repo, **params)
            self.terminate_response()
            return True
        else:
            return False

    def should_show_inline_photo(self, photo_url):
        """"""Returns True if we should show the photo in our site directly with
        <img> tag. In zero-rating mode, it returns True only if the photo is
        served by our domain, to avoid loading resources in other domains in
        Person Finder.

        See ""Zero-rating"" section of the admin page
        (app/resources/admin.html.template) for details of zero-rating mode.
        """"""
        if not photo_url:
            return False
        elif self.env.config.zero_rating_mode:
            _, our_netloc, _, _, _ = urlparse.urlsplit(self.request.url)
            _, photo_netloc, _, _, _ = urlparse.urlsplit(photo_url)
            return photo_netloc == our_netloc
        else:
            return True

    URL_PARSE_QUERY_INDEX = 4

    def get_thumbnail_url(self, photo_url):
        """"""Get a thumbnail URL for an uploaded photo's URL.

        Args:
            photo_url: a photo URL for an uploaded photo
        """"""
        if not photo_url:
            return None
        parsed_url = list(urlparse.urlparse(photo_url))
        params_dict = dict(urlparse.parse_qsl(
            parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX]))
        params_dict['thumb'] = 'true'
        parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX] = urllib.urlencode(
            params_dict)
        return urlparse.urlunparse(parsed_url)

    def __return_unimplemented_method_error(self):
        return self.error(
            405,
            'HTTP method %s is not allowed for this URL.'
                % self.request.method)

    def __init__(self, request, response, env):
        webapp.RequestHandler.__init__(self, request, response)
        self.params = Struct()
        self.env = env
        self.repo = env.repo
        self.config = env.config
        self.charset = env.charset

        # Set default Content-Type header.
        self.response.headers['Content-Type'] = (
            'text/html; charset=%s' % self.charset)

        # Validate query parameters.
        for name, validator in self.auto_params.items():
            try:
                value = self.request.get(name, '')
                setattr(self.params, name, validator(value))
            except Exception, e:
                setattr(self.params, name, validator(None))
                return self.error(400, 'Invalid parameter %s: %s' % (name, e))

        # Ensure referrer is in whitelist, if it exists
        if self.params.referrer and (not self.params.referrer in
                                     self.config.referrer_whitelist):
            setattr(self.params, 'referrer', '')

        # Log the User-Agent header.
        sample_rate = float(
            self.config and self.config.user_agent_sample_rate or 0)
        if random.random() < sample_rate:
            model.UserAgentLog(
                repo=self.repo, sample_rate=sample_rate,
                user_agent=self.request.headers.get('User-Agent'), lang=lang,
                accept_charset=self.request.headers.get('Accept-Charset', ''),
                ip_address=self.request.remote_addr).put()

        # Check for SSL (unless running local dev app server).
        if self.https_required and not is_dev_app_server():
            if self.env.scheme != 'https':
                return self.error(403, 'HTTPS is required.')

        # Handles repository alias.
        if self.maybe_redirect_for_repo_alias(request):
            return

        # Check for an authorization key.
        self.auth = None
        if self.params.key:
            if self.repo:
                # check for domain specific one.
                self.auth = model.Authorization.get(self.repo, self.params.key)
            if not self.auth:
                # perhaps this is a global key ('*' for consistency with config).
                self.auth = model.Authorization.get('*', self.params.key)
        if self.auth and not self.auth.is_valid:
            self.auth = None

        # Shows a custom error page here when the user is not an admin
        # instead of ""login: admin"" in app.yaml
        # If we use it, user can't sign out
        # because the error page of ""login: admin"" doesn't have sign-out link.
        if self.admin_required:
            user = users.get_current_user()
            if not user:
                login_url = users.create_login_url(self.request.url)
                webapp.RequestHandler.redirect(self, login_url)
                self.terminate_response()
                return
            if not users.is_current_user_admin():
                logout_url = users.create_logout_url(self.request.url)
                self.render('not_admin_error.html', logout_url=logout_url, user=user)
                self.terminate_response()
                return

        # Handlers that don't need a repository configuration can skip it.
        if not self.repo:
            if self.repo_required:
                return self.error(400, 'No repository specified.')
            return
        # Everything after this requires a repo.

        # Reject requests for repositories that don't exist.
        if not model.Repo.get_by_key_name(self.repo):
            html = 'No such repository. '
            if self.env.repo_options:
                html += 'Select:<p>' + self.render_to_string('repo-menu.html')
            return self.error(404, message_html=html)

        # If this repository has been deactivated, terminate with a message.
        # The ignore_deactivation flag is for admin pages that bypass this.
        if self.config.deactivated and not self.ignore_deactivation:
            self.env.language_menu = []
            self.env.robots_ok = True
            self.render('message.html', cls='deactivation',
                        message_html=self.config.deactivation_message_html)
            self.terminate_response()

    def get(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def post(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def put(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def head(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def options(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def delete(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def trace(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()


# ==== XSRF protection =========================================================

class XsrfTool(object):

    # XSRF tokens expire after 4 hours.
    TOKEN_EXPIRATION_TIME = 60 * 60 * 4

    # Characters with which to choose a key if it's not set yet.
    TOKEN_CHARACTER_SET = string.letters + string.digits

    def __init__(self):
        configured_key = config.get('xsrf_token_key')
        if configured_key:
            # config.get returns unicode, but hmac is going to want a str
            self._key = configured_key.encode('utf-8')
        else:
            configured_key = ''.join([
                XsrfTool.TOKEN_CHARACTER_SET for _ in range(20)])
            config.set(xsrf_token_key=configured_key)
            self._key = configured_key

    def generate_token(self, user_id, action_id):
        action_time = get_utcnow_timestamp()
        return '%s/%f' % (
            self._generate_hmac_digest(user_id, action_id, action_time),
            action_time)

    def verify_token(self, token, user_id, action_id):
        [hmac_digest, action_time_str] = token.split('/')
        action_time = float(action_time_str)
        if (action_time + XsrfTool.TOKEN_EXPIRATION_TIME <
            get_utcnow_timestamp()):
          return False
        expected_hmac_digest = self._generate_hmac_digest(
            user_id, action_id, action_time)
        return hmac.compare_digest(
            hmac_digest.encode('utf-8'), expected_hmac_digest)

    def _generate_hmac_digest(self, user_id, action_id, action_time):
        hmac_obj = hmac.new(
            self._key, '%s/%s/%f' % (user_id, action_id, action_time))
        return hmac_obj.hexdigest()
/n/n/ntests/server_test_cases/xsrftool_tests.py/n/nimport datetime

import config
from server_tests_base import ServerTestsBase


class XsrfToolTests(ServerTestsBase):

    def setUp(self):
        ServerTestsBase.setUp(self)
        config.set(xsrf_token_key='abcdef')

    def testRejectGlobalEdit(self):
        self._checkPostIsRejected(
            '/global/admin',
            {'operation': 'save_global',
             'tos_url': 'www.evil.com',
             'sms_number_to_repo': '{}',
             'repo_aliases': '{}',
             'unreviewed_notes_threshold': '{}',})

    def testRejectApiKeyEdit(self):
        self._checkPostIsRejected(
            '/global/admin/api_keys',
            {'contact_name': 'Fred',
             'contact_email': 'fred@example.com',
             'organization_name': 'Fred Inc.',})

    def testRejectCreateRepo(self):
        self._checkPostIsRejected(
            '/global/admin/create_repo',
            {'new_repo': 'buffalo'})

    def testRejectDeleteRecord(self):
        self._checkPostIsRejected(
            '/haiti/admin/delete_record',
            {'operation': 'delete',
             'id': 'localhost.person/123'})

    def testRejectSetDefaultResourceBundle(self):
        self._checkPostIsRejected(
            '/global/admin/resources',
            {'operation': 'set_default',
             'resource_bundle_default': 'newbundle'})

    def _checkPostIsRejected(self, path, data):
        data['xsrf_token'] = 'NotTheRightDigest/123'
        doc = self.go_as_admin(path, data=data)
        self.assertEqual(doc.status, 403)
/n/n/ntests/test_xsrftool.py/n/nimport datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def testGenerateAndVerifyGoodToken(self):
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def testRejectsInvalidToken(self):
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(tool.verify_token(
            'NotTheRightDigest/%f' % timestamp, 12345, 'test_action'))

    def testRejectsExpiredToken(self):
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(
            XsrfToolTests.TEST_NOW + datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def testGoodTokenWithNoPriorTokenKey(self):
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def testBadTokenWithNoPriorTokenKey(self):
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(tool.verify_token(
            'NotTheRightDigest/%f' % timestamp, 12345, 'test_action'))
/n/n/n",0
21,d81fc3b81a2255ae128c54bf50a83bebc2118439,"/app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

def to_authorization_params(param):
    param_list = [
        'contact_name',
        'contact_email',
        'organization_name',
        'domain_write_permission',
        'read_permission',
        'full_read_permission',
        'search_permission',
        'subscribe_permission',
        'mark_notes_reviewed',
        'believed_dead_permission',
        'stats_permission',
        'is_valid',
    ]
    ret = {}
    for param_name in param_list:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags)


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and 
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/n",1
22,047c9683b31aef990531ccd084962ddb25e88be5,"app/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""URL routing module.""""""

from django.conf import urls

import site_settings
import views.admin.statistics

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [('admin-statistics', r'global/admin/statistics/?',
                       views.admin.statistics.AdminStatisticsView.as_view)]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^%s$' % path_exp, view_func(), name=name)
    for (name, path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^%(prefix)s/%(path)s$' % {
                'prefix': site_settings.OPTIONAL_PATH_PREFIX,
                'path': path_exp
            },
            view_func(),
            name='prefixed:%s' % name)
        for (name, path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/napp/views/admin/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Code shared by admin view modules.""""""

import django.shortcuts
from google.appengine.api import users

import model
import utils
import views.base


class AdminBaseView(views.base.BaseView):
    """"""Base view for admin views.""""""

    _POST_PARAMETERS = {
        'xsrf_token': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        super(AdminBaseView, self).setup(request, *args, **kwargs)
        self.read_params(post_params=AdminBaseView._POST_PARAMETERS)
        self.env.show_logo = True
        self.env.enable_javascript = True
        self.env.user = users.get_current_user()
        self.env.logout_url = users.create_logout_url(self.build_absolute_uri())
        self.env.all_repo_options = [
            utils.Struct(
                repo=repo, url=self.build_absolute_path('/%s/admin' % repo))
            for repo in sorted(model.Repo.list())
        ]

    def dispatch(self, request, *args, **kwargs):
        # All the admin pages, and only the admin pages, require the user to be
        # logged in as an admin.
        # If we start requiring login for other pages, we should consider
        # refactoring this into a decorator or something like that.
        if not self.env.user:
            return django.shortcuts.redirect(
                users.create_login_url(self.build_absolute_uri()))
        if not users.is_current_user_admin():
            logout_url = users.create_logout_url(self.build_absolute_uri())
            return self.render(
                'not_admin_error.html',
                status_code=403,
                logout_url=logout_url,
                user=self.env.user)
        return super(AdminBaseView, self).dispatch(request, args, kwargs)
/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    _GET_PARAMETERS = {
        'lang': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = utils.Struct()
        self.read_params(get_params=BaseView._GET_PARAMETERS)

        # Set up env variable with data needed by the whole app.
        self.env = utils.Struct()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def read_params(self, get_params=None, post_params=None, file_params=None):
        """"""Reads CGI parameter values into self.params.

        Args:
            get_params (dict): A dictionary from GET parameter keys to validator
                functions.
            post_params (dict): A dictionary from POST parameter keys to
                validator functions.
            file_params (dict): A dictionary from POST parameter keys for
                uploaded files to validator functions.
        """"""
        if self.request.method == 'GET':
            if get_params:
                for key, validator in get_params.items():
                    if key in self.request.GET:
                        setattr(self.params, key,
                                validator(self.request.GET[key]))
        else:
            if post_params:
                for key, validator in post_params.items():
                    if key in self.request.POST:
                        setattr(self.params, key,
                                validator(self.request.POST[key]))
            if file_params:
                for key, validator in file_params.items():
                    if key in self.request.FILES:
                        setattr(self.params, key,
                                validator(self.request.FILES[key]))

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, status_code=200, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0),
            status=status_code)

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import django.urls

import urls
import views

import django_tests_base


class AccessRestrictionTests(django_tests_base.DjangoTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin-statistics': True,
    }

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = django.urls.reverse(path_name)
            assert self.client.get(path).status_code == 403
            assert self.client.post(path).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = django.urls.reverse(path_name)
            assert self.client.get(path).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = django.urls.reverse(path_name)
            assert self.client.get(path).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed:'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/n",0
23,047c9683b31aef990531ccd084962ddb25e88be5,"/app/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""URL routing module.""""""

from django.conf import urls

import site_settings
import views.admin.statistics

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [(r'global/admin/statistics/?',
                       views.admin.statistics.AdminStatisticsView.as_view)]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^(%s)$' % path_exp, view_func())
    for (path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^(%s)/(%s)$' % (site_settings.OPTIONAL_PATH_PREFIX, path_exp),
            view_func()) for (path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/n/app/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    _GET_PARAMETERS = {
        'lang': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = utils.Struct()
        self.read_params(get_params=BaseView._GET_PARAMETERS)

        # Set up env variable with data needed by the whole app.
        self.env = utils.Struct()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def read_params(self, get_params=None, post_params=None, file_params=None):
        """"""Reads CGI parameter values into self.params.

        Args:
            get_params (dict): A dictionary from GET parameter keys to validator
                functions.
            post_params (dict): A dictionary from POST parameter keys to
                validator functions.
            file_params (dict): A dictionary from POST parameter keys for
                uploaded files to validator functions.
        """"""
        if self.request.method == 'GET':
            if get_params:
                for key, validator in get_params.items():
                    if key in self.request.GET:
                        setattr(self.params, key,
                                validator(self.request.GET[key]))
        else:
            if post_params:
                for key, validator in post_params.items():
                    if key in self.request.POST:
                        setattr(self.params, key,
                                validator(self.request.POST[key]))
            if file_params:
                for key, validator in file_params.items():
                    if key in self.request.FILES:
                        setattr(self.params, key,
                                validator(self.request.FILES[key]))

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0))

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view
/n/n/n",1
24,fa58bf0d37503c857be1a8cf533e8400d5cdbb6f,"app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

AUTHORIZATION_PARAMS_LIST = [
    'contact_name',
    'contact_email',
    'organization_name',
    'domain_write_permission',
    'read_permission',
    'full_read_permission',
    'search_permission',
    'subscribe_permission',
    'mark_notes_reviewed',
    'believed_dead_permission',
    'stats_permission',
    'is_valid',
]

def to_authorization_params(param):
    ret = {}
    for param_name in AUTHORIZATION_PARAMS_LIST:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags,
                           xsrf_token=xsrf_tool.generate_token(
                               user.user_id(), 'admin_api_keys'))


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/napp/model.py/n/n#!/usr/bin/python2.7
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""The Person Finder data model, based on PFIF (http://zesty.ca/pfif).""""""

__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'

from datetime import timedelta

from google.appengine.api import datastore_errors
from google.appengine.api import memcache
from google.appengine.ext import db

import config
import full_text_search
import indexing
import pfif
import prefix
from const import HOME_DOMAIN, NOTE_STATUS_TEXT

# default # of days for a record to expire.
DEFAULT_EXPIRATION_DAYS = 40

# ==== PFIF record IDs =====================================================

def is_original(repo, record_id):
    """"""Returns True if this is a record_id for a record originally created in
    the specified repository.""""""
    try:
        repo_id, local_id = record_id.split('/', 1)
        return repo_id == repo + '.' + HOME_DOMAIN
    except ValueError:
        raise ValueError('%r is not a valid record_id' % record_id)

def is_clone(repo, record_id):
    """"""Returns True if this is a record_id for a clone record (a record created
    in another repository and copied into the specified one).""""""
    return not is_original(repo, record_id)

def filter_by_prefix(query, key_name_prefix):
    """"""Filters a query for key_names that have the given prefix.  If root_kind
    is specified, filters the query for children of any entities that are of
    that kind with the given prefix; otherwise, the results are assumed to be
    top-level entities of the kind being queried.""""""
    root_kind = query._model_class.__name__
    min_key = db.Key.from_path(root_kind, key_name_prefix)
    max_key = db.Key.from_path(root_kind, key_name_prefix + u'\uffff')
    return query.filter('__key__ >=', min_key).filter('__key__ <=', max_key)

def get_properties_as_dict(db_obj):
    """"""Returns a dictionary containing all (dynamic)* properties of db_obj.""""""
    properties = dict((k, v.__get__(db_obj, db_obj.__class__)) for
                      k, v in db_obj.properties().iteritems() if
                      v.__get__(db_obj, db_obj.__class__))
    dynamic_properties = dict((prop, getattr(db_obj, prop)) for
                              prop in db_obj.dynamic_properties())
    properties.update(dynamic_properties)
    return properties

def clone_to_new_type(origin, dest_class, **kwargs):
    """"""Clones the given entity to a new entity of the type ""dest_class"".
    Optionally, pass in values to kwargs to update values during cloning.""""""
    vals = get_properties_as_dict(origin)
    vals.update(**kwargs)
    if hasattr(origin, 'record_id'):
        vals.update(record_id=origin.record_id)
    return dest_class(key_name=origin.key().name(), **vals)

# ==== Model classes =======================================================

# Every Person or Note entity belongs to a specific repository.  To partition
# the datastore, key names consist of the repo name, a colon, and then the
# record ID.  Each repository appears to be a separate instance of the app.

# Note that the repository name doesn't necessarily have to match the original
# repository domain in the record ID!  For example, a person record created at
# foo.person-finder.appspot.com would have a key name such as:
#
#     foo:foo.person-finder.appspot.com/person.234
#
# This record would be searchable only at foo.person-finder.appspot.com --
# each repository is independent.  Copying it to bar.person-finder.appspot.com
# would produce a clone record with the key name:
#
#     bar:foo.person-finder.appspot.com/person.234
#
# That is, the clone has the same record ID but a different repository name.

class Repo(db.Model):
    """"""Identifier for a repository of Person and Note records.  This is a
    top-level entity, with no parent, whose existence just indicates the
    existence of a repository.  Key name: unique repository name.  In the UI,
    each repository behaves like an independent instance of the application.""""""

    class ActivationStatus(object):
        """"""An enum for the launch/activation status of the repo.""""""
        # For use with repositories that have not yet been publicly launched.
        # Staging repos aren't listed on the homepage or in the repository feed,
        # but are otherwise totally usable repos for anyone who knows the URL.
        STAGING = 0
        # For repositories in active use. These repos are listed on the homepage
        # and in the repository feed.
        ACTIVE = 1
        # For repositories that have been turned down. The repository is
        # unavailable, through either the web interface or the API, and users
        # will instead see a deactivation message. These repos aren't listed on
        # the homepage or in the repository feed.
        DEACTIVATED = 2

    # TODO(nworden): actually use this field
    activation_status = db.IntegerProperty(
        required=False, default=ActivationStatus.STAGING)

    # Whether the repository is in test mode; meant for use with evergreen
    # repositories when they're not needed. Records for repos in test mode are
    # automatically deleted after 24 hours.
    test_mode = db.BooleanProperty(default=False)

    # Few properties for now; the repository title and other settings are all in
    # ConfigEntry entities (see config.py).

    @classmethod
    def list(cls):
        """"""Returns a list of all repository names.""""""
        return [repo.key().name() for repo in cls.all()]

    @classmethod
    def list_active(cls):
        """"""Returns a list of the active (non-deactivated) repository names.""""""
        return [name for name in Repo.list()
                if not config.get_for_repo(name, 'deactivated')]

    @classmethod
    def list_launched(cls):
        """"""Returns a list of the launched (listed in menu) repository names.""""""
        return [name for name in Repo.list()
                if config.get_for_repo(name, 'launched') and
                        not config.get_for_repo(name, 'deactivated')]


class Base(db.Model):
    """"""Base class providing methods common to both Person and Note entities,
    whose key names are partitioned using the repo name as a prefix.""""""

    # max records to fetch in one go.
    FETCH_LIMIT = 200

    # Even though the repo is part of the key_name, it is also stored
    # redundantly as a separate property so it can be indexed and queried upon.
    repo = db.StringProperty(required=True)

    # We can't use an inequality filter on expiry_date (together with other
    # inequality filters), so we use a periodic task to set the is_expired flag
    # on expired records, and filter using the flag.  A record's life cycle is:
    #
    # 1. Record is created with some expiry_date.
    # 2. expiry_date passes.
    # 3. tasks.DeleteExpired sets is_expired to True; record vanishes from UI.
    # 4. delete.EXPIRED_TTL_DAYS days pass.
    # 5. tasks.DeleteExpired wipes the record.

    # We set default=False to ensure all entities are indexed by is_expired.
    # NOTE: is_expired should ONLY be modified in Person.put_expiry_flags().
    is_expired = db.BooleanProperty(required=False, default=False)

    @classmethod
    def all(cls, keys_only=False, filter_expired=True):
        """"""Returns a query for all records of this kind; by default this
        filters out the records marked as expired.

        Args:
          keys_only - If true, return only the keys.
          filter_expired - If true, omit records with is_expired == True.
        Returns:
          query - A Query object for the results.
        """"""
        query = super(Base, cls).all(keys_only=keys_only)
        if filter_expired:
            query.filter('is_expired =', False)
        return query

    @classmethod
    def all_in_repo(cls, repo, filter_expired=True):
        """"""Gets a query for all entities in a given repository.""""""
        return cls.all(filter_expired=filter_expired).filter('repo =', repo)

    def get_record_id(self):
        """"""Returns the record ID of this record.""""""
        repo, record_id = self.key().name().split(':', 1)
        return record_id
    record_id = property(get_record_id)

    def get_original_domain(self):
        """"""Returns the domain name of this record's original repository.""""""
        return self.record_id.split('/', 1)[0]
    original_domain = property(get_original_domain)

    def is_original(self):
        """"""Returns True if this record was created in this repository.""""""
        return is_original(self.repo, self.record_id)

    def is_clone(self):
        """"""Returns True if this record was copied from another repository.""""""
        return not self.is_original()

    @classmethod
    def get_key(cls, repo, record_id):
        """"""Get entity key from its record id""""""
        return db.Key.from_path(cls.kind(), repo + ':' + record_id)

    @classmethod
    def get_all(cls, repo, record_ids, limit=200):
        """"""Gets the entities with the given record_ids in a given repository.""""""
        keys = [cls.get_key(repo, id) for id in record_ids]
        return [record for record in db.get(keys) if record is not None]

    @classmethod
    def get(cls, repo, record_id, filter_expired=True):
        """"""Gets the entity with the given record_id in a given repository.""""""
        record = cls.get_by_key_name(repo + ':' + record_id)
        if record:
            if not (filter_expired and record.is_expired):
                return record

    @classmethod
    def create_original(cls, repo, **kwargs):
        """"""Creates a new original entity with the given field values.""""""
        # TODO(ryok): Consider switching to URL-like record id format,
        # which is more consitent with repo id format.
        record_id = '%s.%s/%s.%d' % (
            repo, HOME_DOMAIN, cls.__name__.lower(), UniqueId.create_id())
        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)

    @classmethod
    def create_clone(cls, repo, record_id, **kwargs):
        """"""Creates a new clone entity with the given field values.""""""
        assert is_clone(repo, record_id)
        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)

    # TODO(kpy): Rename this function (maybe to create_with_record_id?).
    @classmethod
    def create_original_with_record_id(cls, repo, record_id, **kwargs):
        """"""Creates an original entity with the given record_id and field
        values, overwriting any existing entity with the same record_id.
        This should be rarely used in practice (e.g. for an administrative
        import into a home repository), hence the long method name.""""""
        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)


# All fields are either required, or have a default value.  For property
# types that have a false value, the default is the false value.  For types
# with no false value, the default is None.

class Person(Base):
    """"""The datastore entity kind for storing a PFIF person record.  Never call
    Person() directly; use Person.create_clone() or Person.create_original().

    Methods that start with ""get_"" return actual values or lists of values;
    other methods return queries or generators for values.
    """"""
    # If you add any new fields, be sure they are handled in wipe_contents().

    # entry_date should update every time a record is created or re-imported.
    entry_date = db.DateTimeProperty(required=True)
    expiry_date = db.DateTimeProperty(required=False)

    author_name = db.StringProperty(default='', multiline=True)
    author_email = db.StringProperty(default='')
    author_phone = db.StringProperty(default='')

    # the original date we saw this record; it should not change.
    original_creation_date = db.DateTimeProperty(auto_now_add=True)

    # source_date is the date that the original repository last changed
    # any of the fields in the pfif record.
    source_date = db.DateTimeProperty()

    source_name = db.StringProperty(default='')
    source_url = db.StringProperty(default='')

    # TODO(ryok): consider marking this required.
    full_name = db.StringProperty(multiline=True)
    given_name = db.StringProperty()
    family_name = db.StringProperty()
    alternate_names = db.StringProperty(default='', multiline=True)
    description = db.TextProperty(default='')
    sex = db.StringProperty(default='', choices=pfif.PERSON_SEX_VALUES)
    date_of_birth = db.StringProperty(default='')  # YYYY, YYYY-MM, YYYY-MM-DD
    age = db.StringProperty(default='')  # NN or NN-MM
    home_street = db.StringProperty(default='')
    home_neighborhood = db.StringProperty(default='')
    home_city = db.StringProperty(default='')
    home_state = db.StringProperty(default='')
    home_postal_code = db.StringProperty(default='')
    home_country = db.StringProperty(default='')
    photo_url = db.TextProperty(default='')
    profile_urls = db.TextProperty(default='')

    # This reference points to a locally stored Photo entity.  ONLY set this
    # property when storing a new Photo object that is owned by this Person
    # record and can be safely deleted when the Person is deleted.
    photo = db.ReferenceProperty(default=None)

    # The following properties are not part of the PFIF data model; they are
    # cached on the Person for efficiency.

    # Value of the 'status' and 'source_date' properties on the Note
    # with the latest source_date with the 'status' field present.
    latest_status = db.StringProperty(default='')
    latest_status_source_date = db.DateTimeProperty()
    # Value of the 'author_made_contact' and 'source_date' properties on the
    # Note with the latest source_date with the 'author_made_contact' field
    # present.
    latest_found = db.BooleanProperty()
    latest_found_source_date = db.DateTimeProperty()

    # Last write time of this Person or any Notes on this Person.
    # This reflects any change to the Person page.
    last_modified = db.DateTimeProperty(auto_now=True)

    # This flag is set to true only when the record author disabled
    # adding new notes to a record.
    notes_disabled = db.BooleanProperty(default=False)

    # attributes used by indexing.py
    names_prefixes = db.StringListProperty()
    # TODO(ryok): index address components.
    _fields_to_index_properties = ['given_name', 'family_name', 'full_name']
    _fields_to_index_by_prefix_properties = ['given_name', 'family_name',
        'full_name']

    @staticmethod
    def past_due_records(repo):
        """"""Returns a query for all Person records with expiry_date in the past,
        or None, regardless of their is_expired flags.""""""
        import utils
        return Person.all(filter_expired=False).filter(
            'expiry_date <=', utils.get_utcnow()).filter(
            'repo =', repo)

    @staticmethod
    def potentially_expired_records(repo,
                                    days_to_expire=DEFAULT_EXPIRATION_DAYS):
        """"""Returns a query for all Person records with source date
        older than days_to_expire (or empty source_date), regardless of
        is_expired flags value.""""""
        import utils
        cutoff_date = utils.get_utcnow() - timedelta(days_to_expire)
        return Person.all(filter_expired=False).filter(
            'source_date <=',cutoff_date).filter(
            'repo =', repo)

    @property
    def person_record_id(self):
        return self.record_id

    @property
    def primary_full_name(self):
        return self.full_name.splitlines()[0] if self.full_name else ''

    @property
    def full_name_list(self):
        return self.full_name.splitlines() if self.full_name else []

    @property
    def alternate_names_list(self):
        return self.alternate_names.splitlines() if self.alternate_names else []

    @property
    def fuzzified_age(self):
        import utils
        return utils.fuzzify_age(self.age) if self.age else None

    @property
    def profile_urls_list(self):
        return self.profile_urls.splitlines() if self.profile_urls else []

    @property
    def photo_url_no_scheme(self):
        import utils
        return utils.strip_url_scheme(self.photo_url)

    def get_notes(self, filter_expired=True):
        """"""Returns a list of all the Notes on this Person, omitting expired
        Notes by default.""""""
        return Note.get_by_person_record_id(
            self.repo, self.record_id, filter_expired=filter_expired)

    def get_subscriptions(self, subscription_limit=200):
        """"""Retrieves a list of all the Subscriptions for this Person.""""""
        return Subscription.get_by_person_record_id(
            self.repo, self.record_id, limit=subscription_limit)

    def get_linked_person_ids(self, note_limit=200):
        """"""Retrieves IDs of Persons marked as duplicates of this Person.""""""
        return [note.linked_person_record_id
                for note in self.get_notes(note_limit)
                if note.linked_person_record_id]

    def get_linked_persons(self, note_limit=200):
        """"""Retrieves Persons marked as duplicates of this Person.""""""
        return Person.get_all(self.repo,
                              self.get_linked_person_ids(note_limit))

    def get_all_linked_persons(self):
        """"""Retrieves all Persons transitively linked to this Person.""""""
        linked_person_ids = set([self.record_id])
        linked_persons = []
        # Maintain a list of ids of duplicate persons that have not
        # yet been processed.
        new_person_ids = set(self.get_linked_person_ids())
        # Iteratively process all new_person_ids by retrieving linked
        # duplicates and storing those not yet processed.
        # Processed ids are stored in the linked_person_ids set, and
        # their corresponding records are in the linked_persons list.
        while new_person_ids:
            linked_person_ids.update(new_person_ids)
            new_persons = Person.get_all(self.repo, list(new_person_ids))
            for person in new_persons:
                new_person_ids.update(person.get_linked_person_ids())
            linked_persons += new_persons
            new_person_ids -= linked_person_ids
        return linked_persons

    def get_associated_emails(self):
        """"""Gets a set of all the e-mail addresses to notify when this record
        is changed.""""""
        email_addresses = set([note.author_email for note in self.get_notes()
                               if note.author_email])
        if self.author_email:
            email_addresses.add(self.author_email)
        return email_addresses

    def get_effective_expiry_date(self):
        """"""Gets the expiry_date, or if no expiry_date is present, returns the
        source_date plus the configurable default_expiration_days interval.

        If there's no source_date, we use original_creation_date.
        Returns:
          A datetime date (not None).
        """"""
        if self.expiry_date:
            return self.expiry_date
        else:
            expiration_days = config.get_for_repo(
                self.repo, 'default_expiration_days') or (
                DEFAULT_EXPIRATION_DAYS)
            # in theory, we should always have original_creation_date, but since
            # it was only added recently, we might have legacy
            # records without it.
            start_date = self.original_creation_date or utils.get_utcnow()
            return start_date + timedelta(expiration_days)

    def put_expiry_flags(self):
        """"""Updates the is_expired flags on this Person and related Notes to
        make them consistent with the effective_expiry_date() on this Person,
        and commits the changes to the datastore.""""""
        import utils
        now = utils.get_utcnow()
        expired = self.get_effective_expiry_date() <= now

        if self.is_expired != expired:
            # NOTE: This should be the ONLY code that modifies is_expired.
            self.is_expired = expired

            # if we neglected to capture the original_creation_date,
            # make a best effort to grab it now, for posterity.
            if not self.original_creation_date:
                self.original_creation_date = self.source_date

            # If the record is expiring (being replaced with a placeholder,
            # see http://zesty.ca/pfif/1.3/#data-expiry) or un-expiring (being
            # restored from deletion), we want the source_date and entry_date
            # updated so downstream clients will see this as the newest state.
            self.source_date = now
            self.entry_date = now

            # All the Notes on the Person also expire or unexpire, to match.
            notes = self.get_notes(filter_expired=False)
            for note in notes:
                note.is_expired = expired

            # Store these changes in the datastore.
            db.put(notes + [self])
            # TODO(lschumacher): photos don't have expiration currently.

    def wipe_contents(self):
        """"""Sets all the content fields to None (leaving timestamps and the
        expiry flag untouched), stores the empty record, and permanently
        deletes any related Notes and Photos.  Call this method ONLY on records
        that have already expired.""""""
        # We rely on put_expiry_flags to have properly set the source_date,
        # entry_date, and is_expired flags on Notes, as necessary.
        assert self.is_expired

        # Permanently delete all related Photos and Notes, but not self.
        self.delete_related_entities()

        was_changed = False
        # TODO(nworden): consider adding a is_tombstone property or something
        # like that, so we could just check that instead of checking each
        # property individually every time.
        for name, property in self.properties().items():
            # Leave the repo, is_expired flag, and timestamps untouched.
            if name not in ['repo', 'is_expired', 'original_creation_date',
                            'source_date', 'entry_date', 'expiry_date']:
                if name == 'photo':
                    # If we attempt to access this directly, Datastore will try
                    # to fetch the actual photo, which won't go well, because we
                    # just deleted the photo.
                    cur_value = Person.photo.get_value_for_datastore(self)
                else:
                    cur_value = getattr(self, name)
                if cur_value != property.default:
                    setattr(self, name, property.default)
                    was_changed = True
        if was_changed:
            self.put()  # Store the empty placeholder record.

    def delete_related_entities(self, delete_self=False):
        """"""Permanently delete all related Photos and Notes, and also self if
        delete_self is True.""""""
        # Delete all related Notes.
        notes = self.get_notes(filter_expired=False)
        # Delete the locally stored Photos.  We use get_value_for_datastore to
        # get just the keys and prevent auto-fetching the Photo data.
        photo = Person.photo.get_value_for_datastore(self)
        note_photos = [Note.photo.get_value_for_datastore(n) for n in notes]

        entities_to_delete = filter(None, notes + [photo] + note_photos)
        if delete_self:
            entities_to_delete.append(self)
            if config.get('enable_fulltext_search'):
                full_text_search.delete_record_from_index(self)
        db.delete(entities_to_delete)

    def update_from_note(self, note):
        """"""Updates any necessary fields on the Person to reflect a new Note.""""""
        # We want to transfer only the *non-empty, newer* values to the Person.
        if note.author_made_contact is not None:  # for boolean, None means
                                                  # unspecified
            # datetime stupidly refuses to compare to None, so check for None.
            if (self.latest_found_source_date is None or
                note.source_date >= self.latest_found_source_date):
                self.latest_found = note.author_made_contact
                self.latest_found_source_date = note.source_date
        if note.status:  # for string, '' means unspecified
            if (self.latest_status_source_date is None or
                note.source_date >= self.latest_status_source_date):
                self.latest_status = note.status
                self.latest_status_source_date = note.source_date

    def update_index(self, which_indexing):
        #setup new indexing
        if 'new' in which_indexing:
            indexing.update_index_properties(self)
            if config.get('enable_fulltext_search'):
                full_text_search.add_record_to_index(self)
        # setup old indexing
        if 'old' in which_indexing:
            prefix.update_prefix_properties(self)

    def update_latest_status(self, modified_note=None):
        """"""Scans all notes on this Person and fixes latest_status if needed.""""""
        status = None
        status_source_date = None
        for note in self.get_notes():
            if modified_note and modified_note.note_record_id == note.record_id:
                note = modified_note
            if note.status and not note.hidden:
                status = note.status
                status_source_date = note.source_date
        if status != self.latest_status:
            self.latest_status = status
            self.latest_status_source_date = status_source_date
            self.put()

    def put_new(self):
        """"""Write the new person record to datastore. Increments person_counter
        because a new record is created. Logs user actions is updated too.
        We should never call this method against an existing record.""""""
        db.put(self)
        UsageCounter.increment_counter(self.repo, ['person'])
        UserActionLog.put_new('add', self, copy_properties=False)

# Old indexing
# TODO(ryok): This is obsolete. Remove it.
prefix.add_prefix_properties(
    Person, 'given_name', 'family_name', 'home_street', 'home_neighborhood',
    'home_city', 'home_state', 'home_postal_code')


class Note(Base):
    """"""The datastore entity kind for storing a PFIF note record.  Never call
    Note() directly; use Note.create_clone() or Note.create_original().""""""

    # The entry_date should update every time a record is re-imported.
    entry_date = db.DateTimeProperty(required=True)

    person_record_id = db.StringProperty(required=True)

    # Use this field to store the person_record_id of a duplicate Person entry.
    linked_person_record_id = db.StringProperty(default='')

    author_name = db.StringProperty(default='', multiline=True)
    author_email = db.StringProperty(default='')
    author_phone = db.StringProperty(default='')

    # the original date we saw this record; it should not change.
    original_creation_date = db.DateTimeProperty(auto_now_add=True)

    # source_date is the date that the original repository last changed
    # any of the fields in the pfif record.
    source_date = db.DateTimeProperty()

    status = db.StringProperty(default='', choices=pfif.NOTE_STATUS_VALUES)
    author_made_contact = db.BooleanProperty()
    email_of_found_person = db.StringProperty(default='')
    phone_of_found_person = db.StringProperty(default='')
    last_known_location = db.StringProperty(default='', multiline=True)
    text = db.TextProperty(default='')
    photo_url = db.TextProperty(default='')

    # This reference points to a locally stored Photo entity.  ONLY set this
    # property when storing a new Photo object that is owned by this Note
    # record and can be safely deleted when the Note is deleted.
    photo = db.ReferenceProperty(default=None)

    # True if the note has been marked as spam. Will cause the note to be
    # initially hidden from display upon loading a record page.
    hidden = db.BooleanProperty(default=False)

    # True if the note has been reviewed for spam content at /admin/review.
    reviewed = db.BooleanProperty(default=False)

    def get_note_record_id(self):
        return self.record_id
    note_record_id = property(get_note_record_id)

    @property
    def photo_url_no_scheme(self):
        import utils
        return utils.strip_url_scheme(self.photo_url)

    @staticmethod
    def get_by_person_record_id(
        repo, person_record_id, filter_expired=True):
        """"""Gets a list of all the Notes on a Person, ordered by source_date.""""""
        return list(Note.generate_by_person_record_id(
            repo, person_record_id, filter_expired))

    @staticmethod
    def generate_by_person_record_id(
        repo, person_record_id, filter_expired=True):
        """"""Generates all the Notes on a Person record ordered by source_date.""""""
        query = Note.all_in_repo(repo, filter_expired=filter_expired
            ).filter('person_record_id =', person_record_id
            ).order('source_date')
        notes = query.fetch(Note.FETCH_LIMIT)
        while notes:
            for note in notes:
                yield note
            query.with_cursor(query.cursor())  # Continue where fetch left off.
            notes = query.fetch(Note.FETCH_LIMIT)

    @staticmethod
    def get_unreviewed_notes_count(repo, filter_expired=True):
        """"""Gets the number of unreviewed notes.""""""
        query = Note.all_in_repo(repo, filter_expired=filter_expired
            ).filter('reviewed =', False).filter('hidden =', False)
        return query.count()

    def put_new(self):
        """"""Write the new note to datastore. Increments note_counter because
        a new note is created. Also, logs user actions is updated. We should
        never call this method against an existing record.""""""
        db.put(self)
        UserActionLog.put_new('add', self, copy_properties=False)
        note_status = self.status if self.status else 'unspecified'
        UsageCounter.increment_counter(self.repo, ['note', note_status])

class NoteWithBadWords(Note):
    # Spam score given by SpamDetector
    spam_score = db.FloatProperty(default=0)
    # True is the note is confirmed by its author through email
    confirmed = db.BooleanProperty(default=False)
    # Once the note is confirmed, this field stores the copy of
    # this note in Note table. It will be useful if we want to
    # delete the notes with bad words, even when they are confirmed.
    confirmed_copy_id = db.StringProperty(default='')

class Photo(db.Model):
    """"""An uploaded image file.  Key name: repo + ':' + photo_id.""""""

    # Even though the repo is part of the key_name, it is also stored
    # redundantly as a separate property so it can be indexed and queried upon.
    repo = db.StringProperty(required=True)
    image_data = db.BlobProperty()  # sanitized, resized image in PNG format
    upload_date = db.DateTimeProperty(auto_now_add=True)
    # thumbnail image in PNG format
    thumbnail_data = db.BlobProperty(default=None)

    @staticmethod
    def create(repo, **kwargs):
        """"""Creates a Photo entity with the given field values.""""""
        id = UniqueId.create_id()
        return Photo(key_name='%s:%s' % (repo, id), repo=repo, **kwargs)

    @staticmethod
    def get(repo, id):
        return Photo.get_by_key_name('%s:%s' % (repo, id))


class Authorization(db.Model):
    """"""Authorization keys.  Key name: repo + ':' + auth_key.""""""

    DEFAULT_SETTINGS = dict(contact_name='', contact_email='',
                            organization_name='', domain_write_permission='',
                            read_permission=False, full_read_permission=False,
                            search_permission=True, subscribe_permission=False,
                            mark_notes_reviewed=False, is_valid=True, key='')

    # Even though the repo is part of the key_name, it is also stored
    # redundantly as a separate property so it can be indexed and queried upon.
    repo = db.StringProperty(required=True)

    def summary_str(self):
        """"""Generates a summary of the key's current state.

        Meant for logging.
        """"""
        permissions_list = []
        for permission_field in ['read_permission',
                                 'full_read_permission',
                                 'search_permission',
                                 'subscribe_permission',
                                 'mark_notes_reviewed',
                                 'believed_dead_permission',
                                 'stats_permission']:
            if getattr(self, permission_field):
                permissions_list.append(permission_field)
        permissions = '; '.join(permissions_list)
        return ('repo: %(repo)s\n'
                'write domain: %(write_domain)s\n'
                'permissions: %(permissions)s\n'
                'valid: %(valid)s\n'
                'contact name: %(contact_name)s\n'
                'contact email: %(contact_email)s\n'
                'organization name: %(org_name)s') % {
                    'repo': self.repo,
                    'write_domain': self.domain_write_permission or 'None',
                    'permissions': permissions,
                    'valid': self.is_valid,
                    'contact_name': self.contact_name,
                    'contact_email': self.contact_email,
                    'org_name': self.organization_name,
                }

    # If this field is non-empty, this authorization token allows the client
    # to write records with this original domain.
    domain_write_permission = db.StringProperty()

    # If this flag is true, this authorization token allows the client to read
    # non-sensitive fields (i.e. filtered by utils.filter_sensitive_fields).
    read_permission = db.BooleanProperty()

    # If this flag is true, this authorization token allows the client to read
    # all fields (i.e. not filtered by utils.filter_sensitive_fields).
    full_read_permission = db.BooleanProperty()

    # If this flag is true, this authorization token allows the client to use
    # the search API and return non-sensitive fields (i.e. filtered
    # by utils.filter_sensitive_fields).
    search_permission = db.BooleanProperty()

    # If this flag is true, this authorization token allows the client to use
    # the API to subscribe any e-mail address to updates on any person.
    subscribe_permission = db.BooleanProperty()

    # If this flag is true, notes written with this authorization token are
    # marked as ""reviewed"" and won't show up in admin's review list.
    mark_notes_reviewed = db.BooleanProperty()

    # If this flag is true, notes written with this authorization token are
    # allowed to have status == 'believed_dead'.
    believed_dead_permission = db.BooleanProperty()

    # If this flag is true, this key can be used to get overall statistics.
    stats_permission = db.BooleanProperty()

    # If this flag is False, the API access with this key won't be
    # allowed.
    is_valid = db.BooleanProperty(default=True)

    # Bookkeeping information for humans, not used programmatically.
    contact_name = db.StringProperty()
    contact_email = db.StringProperty()
    organization_name = db.StringProperty()

    @property
    def api_key(self):
        """"""Gets a key value excluding the repo part. """"""
        if self.has_key():
            return self.key().name().split(':')[1]
        return None

    @classmethod
    def get(cls, repo, key):
        """"""Gets the Authorization entity for a given repository and key.""""""
        return cls.get_by_key_name(repo + ':' + key)

    @classmethod
    def create(cls, repo, key, **kwargs):
        """"""Creates an Authorization entity for a given repository and key.""""""
        return cls(key_name=repo + ':' + key, repo=repo, **kwargs)


class ApiKeyManagementLog(db.Model):
    """"""Log management history for API keys.""""""
    CREATE = 'create'
    UPDATE = 'update'
    DELETE = 'delete'
    ACTIONS = [CREATE, UPDATE, DELETE]

    user = db.UserProperty(auto_current_user_add=True)
    timestamp = db.DateTimeProperty(auto_now_add=True)
    repo = db.StringProperty(required=True)
    api_key = db.StringProperty(required=True)
    action = db.StringProperty(required=True, choices=ACTIONS)
    # The IP address of the admin making the change.
    ip_address = db.StringProperty()
    # A string representation of the state of the key after this action.
    key_state = db.TextProperty()

    @property
    def authorization(self):
        return Authorization.get(self.repo, self.api_key)

def encode_count_name(count_name):
    """"""Encode a name to printable ASCII characters so it can be safely
    used as an attribute name for the datastore.""""""
    encoded = []
    append = encoded.append
    for ch in map(ord, count_name):
        if ch == 92:
            append('\\\\')
        elif 33 <= ch <= 126:
            append(chr(ch))
        else:
            append('\\u%04x' % ch)
    return ''.join(encoded)

class ApiActionLog(db.Model):
    """"""Log of api key usage.""""""
    # actions
    REPO = 'repo'
    DELETE = 'delete'
    READ = 'read'
    SEARCH = 'search'
    WRITE = 'write'
    SUBSCRIBE = 'subscribe'
    UNSUBSCRIBE = 'unsubscribe'
    ACTIONS = [REPO, DELETE, READ, SEARCH, WRITE, SUBSCRIBE, UNSUBSCRIBE]

    repo = db.StringProperty()
    api_key = db.StringProperty()
    action = db.StringProperty(required=True, choices=ACTIONS)
    person_records = db.IntegerProperty()
    note_records = db.IntegerProperty()
    people_skipped = db.IntegerProperty() # write only
    notes_skipped = db.IntegerProperty() # write only
    user_agent = db.StringProperty()
    ip_address = db.StringProperty() # client ip
    request_url = db.StringProperty()
    version = db.StringProperty() # pfif version.
    timestamp = db.DateTimeProperty(auto_now=True)

    @staticmethod
    def record_action(repo, api_key, version, action, person_records,
                      note_records, people_skipped, notes_skipped, user_agent,
                      ip_address, request_url,
                      timestamp=None):
        import utils
        try:
            ApiActionLog(repo=repo,
                         api_key=api_key,
                         action=action,
                         person_records=person_records,
                         note_records=note_records,
                         people_skipped=people_skipped,
                         notes_skipped=notes_skipped,
                         user_agent=user_agent,
                         ip_address=ip_address,
                         request_url=request_url,
                         version=version,
                         timestamp=timestamp or utils.get_utcnow()).put()
        except Exception:
            # swallow anything to prevent the main action from failing.
            pass

class Counter(db.Expando):
    """"""Counters hold partial and completed results for ongoing counting tasks.
    To see how this is used, check out tasks.py.  A single Counter object can
    contain several named accumulators.  Typical usage is to scan for entities
    in order by __key__, update the accumulators for each entity, and save the
    partial counts when the time limit for a request is reached.  The last
    scanned key is saved in last_key so the next request can pick up the scan
    where the last one left off.  A non-empty last_key means a scan is not
    finished; when a scan is done, last_key should be set to ''.""""""
    timestamp = db.DateTimeProperty(auto_now=True)
    scan_name = db.StringProperty()
    repo = db.StringProperty()
    last_key = db.StringProperty(default='')  # if non-empty, count is partial

    # Each Counter also has a dynamic property for each accumulator; all such
    # properties are named ""count_"" followed by a count_name.  The count_name
    # is encoded to ensure all its characters are printable ASCII.
    def get(self, count_name):
        """"""Gets the specified accumulator from this counter object.""""""
        return getattr(self, 'count_' + encode_count_name(count_name), 0)

    def increment(self, count_name):
        """"""Increments the given accumulator on this Counter object.""""""
        prop_name = 'count_' + encode_count_name(count_name)
        setattr(self, prop_name, getattr(self, prop_name, 0) + 1)

    @classmethod
    def get_count(cls, repo, name):
        """"""Gets the latest finished count for the given repository and name.
        'name' should be in the format scan_name + '.' + count_name.""""""
        scan_name, count_name = name.split('.')
        count_name = encode_count_name(count_name)
        return cls.get_all_counts(repo, scan_name).get(count_name, 0)

    @classmethod
    def get_all_counts(cls, repo, scan_name):
        """"""Gets a dictionary of all the counts for the last completed scan
        for the given repository and scan name.""""""
        counter_key = repo + ':' + scan_name

        # Get the counts from memcache, loading from datastore if necessary.
        counter_dict = memcache.get(counter_key)
        if not counter_dict:
            try:
                # Get the latest completed counter with this scan_name.
                counter = cls.all().filter('repo =', repo
                                  ).filter('scan_name =', scan_name
                                  ).filter('last_key =', ''
                                  ).order('-timestamp').get()
            except datastore_errors.NeedIndexError:
                # Absurdly, it can take App Engine up to an hour to build an
                # index for a kind that has zero entities, and during that time
                # all queries fail.  Catch this error so we don't get screwed.
                counter = None

            counter_dict = {}
            if counter:
                # Cache the counter's contents in memcache for one minute.
                counter_dict = dict((name[6:], getattr(counter, name))
                                    for name in counter.dynamic_properties()
                                    if name.startswith('count_'))
                memcache.set(counter_key, counter_dict, 60)

        # Return the dictionary of counts for this scan.
        return counter_dict

    @classmethod
    def all_finished_counters(cls, repo, scan_name):
        """"""Gets a query for all finished counters for the specified scan.""""""
        return cls.all().filter('repo =', repo
                       ).filter('scan_name =', scan_name
                       ).filter('last_key =', '')

    @classmethod
    def get_unfinished_or_create(cls, repo, scan_name):
        """"""Gets the latest unfinished Counter entity for the given repository
        and scan_name.  If there is no unfinished Counter, create a new one.""""""
        counter = cls.all().filter('repo =', repo
                          ).filter('scan_name =', scan_name
                          ).order('-timestamp').get()
        if not counter or not counter.last_key:
            counter = Counter(repo=repo, scan_name=scan_name)
        return counter


class Subscription(db.Model):
    """"""Subscription to notifications when a note is added to a person record""""""
    repo = db.StringProperty(required=True)
    person_record_id = db.StringProperty(required=True)
    email = db.StringProperty(required=True)
    language = db.StringProperty(required=True)
    timestamp = db.DateTimeProperty(auto_now_add=True)

    @staticmethod
    def create(repo, record_id, email, language):
        """"""Creates a new Subscription""""""
        key_name = '%s:%s:%s' % (repo, record_id, email)
        return Subscription(key_name=key_name, repo=repo,
                            person_record_id=record_id,
                            email=email, language=language)

    @staticmethod
    def get(repo, record_id, email):
        """"""Gets the entity with the given record_id in a given repository.""""""
        key_name = '%s:%s:%s' % (repo, record_id, email)
        return Subscription.get_by_key_name(key_name)

    @staticmethod
    def get_by_person_record_id(repo, person_record_id, limit=200):
        """"""Retrieve subscriptions for a person record.""""""
        query = Subscription.all().filter('repo =', repo)
        query = query.filter('person_record_id =', person_record_id)
        return query.fetch(limit)


class UserActionLog(db.Expando):
    """"""Logs user actions.""""""
    time = db.DateTimeProperty(required=True)
    repo = db.StringProperty(required=True)
    action = db.StringProperty(required=True, choices=[
        'add', 'delete', 'extend', 'hide', 'mark_dead', 'mark_alive',
        'restore', 'unhide', 'disable_notes', 'enable_notes'])
    entity_kind = db.StringProperty(required=True)
    entity_key_name = db.StringProperty(required=True)
    detail = db.TextProperty()
    ip_address = db.StringProperty()

    @classmethod
    def put_new(cls, action, entity, detail='', ip_address='',
                copy_properties=True):
        """"""Adds an entry to the UserActionLog.  'action' is the action that
        the user performed, 'entity' is the entity that was operated on, and
        'detail' is a string containing any other details.""""""
        import utils
        kind = entity.kind()
        entry = cls(
            time=utils.get_utcnow(), repo=entity.repo, action=action,
            entity_kind=kind, entity_key_name=entity.key().name(),
            detail=detail, ip_address=ip_address)
        # copy the properties of the entity
        if copy_properties:
            for name in entity.properties():
                value = getattr(entity, name)
                if isinstance(value, db.Model):
                    value = value.key()
                setattr(entry, kind + '_' + name, value)
        entry.put()


class StaticSiteMapInfo(db.Model):
    """"""Holds static sitemaps file info.""""""
    static_sitemaps = db.StringListProperty()
    static_sitemaps_generation_time = db.DateTimeProperty(required=True)
    shard_size_seconds = db.IntegerProperty(default=90)


class SiteMapPingStatus(db.Model):
    """"""Tracks the last shard index that was pinged to the search engine.""""""
    search_engine = db.StringProperty(required=True)
    shard_index = db.IntegerProperty(default=-1)


class UniqueId(db.Model):
    """"""This entity is used just to generate unique numeric IDs.""""""
    @staticmethod
    def create_id():
        """"""Gets an integer ID that is guaranteed to be different from any ID
        previously returned by this static method.""""""
        unique_id = UniqueId()
        unique_id.put()
        return unique_id.key().id()

class UsageCounter(db.Expando):
    """"""Counters which count the historical statistics for each repository.
    To see how this is used, check out admin_statistics.py.
    Unlike the Counter class, UsageCounter object increments when
    a new record or a new note is created, which means, the UsageCounter
    will not decrement when a record/note is expired/deleted.""""""

    # repo stored as a seperate property so it can be indexed and queried.
    repo = db.StringProperty(required=True)

    @classmethod
    def create(cls, repo):
        """"""Create a new counter""""""
        return UsageCounter(key_name=repo, repo=repo)

    @classmethod
    def get(cls, repo):
        """"""Gets the entity with a given repository.""""""
        return UsageCounter.get_by_key_name(repo)

    @classmethod
    @db.transactional
    def increment_counter(cls, repo, counter_list, amount=1):
        """"""Increase the counter for the counter value
        based on the given amount. Each Counter has a dynamic property
        and is named based on a given counter_name.""""""
        counter = cls.get(repo)
        if not counter:
            counter = cls.create(repo)
        for counter_name in counter_list:
            counter_value = getattr(counter, counter_name, 0)
            setattr(counter, counter_name, counter_value + amount)
        counter.put()
/n/n/napp/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""URL routing module.""""""

from django.conf import urls

import site_settings
import tasksmodule.deletion
import tasksmodule.sitemap_ping
import views.admin.api_keys
import views.admin.create_repo
import views.admin.statistics
import views.meta.sitemap

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [
    ('admin_apikeys-list', r'(?P<repo>[^\/]+)/admin/api_keys/list/?',
     views.admin.api_keys.ApiKeyListView.as_view),
    ('admin_apikeys-manage', r'(?P<repo>[^\/]+)/admin/api_keys/?',
     views.admin.api_keys.ApiKeyManagementView.as_view),
    ('admin_create-repo', r'global/admin/create_repo/?',
     views.admin.create_repo.AdminCreateRepoView.as_view),
    ('admin_statistics', r'global/admin/statistics/?',
     views.admin.statistics.AdminStatisticsView.as_view),
    ('meta_sitemap', r'global/sitemap/?',
     views.meta.sitemap.SitemapView.as_view),
    ('tasks_process-expirations',
     r'(?P<repo>[^\/]+)/tasks/process_expirations/?',
     tasksmodule.deletion.ProcessExpirationsTask.as_view),
    ('tasks_cleanup-stray-notes',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_notes/?',
     tasksmodule.deletion.CleanupStrayNotesTask.as_view),
    ('tasks_cleanup-stray-subscriptions',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_subscriptions/?',
     tasksmodule.deletion.CleanupStraySubscriptionsTask.as_view),
    ('tasks_sitemap-ping', r'global/tasks/sitemap_ping/?',
     tasksmodule.sitemap_ping.SitemapPingTaskView.as_view),
]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^%s$' % path_exp, view_func(), name=name)
    for (name, path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^%(prefix)s/%(path)s$' % {
                'prefix': site_settings.OPTIONAL_PATH_PREFIX,
                'path': path_exp
            },
            view_func(),
            name='prefixed__%s' % name)
        for (name, path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/napp/views/admin/api_keys.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""The admin API key pages.

The way navigation is handled for these pages is a little unintuitive so let me
explain:
 - The main entry point to these pages is the list view, which accepts GET
   requests and returns a view with a) a link to create a new API key (which
   makes a GET request to the management page) and b) a list of existing pages,
   each with an ""edit"" button.
 - The list view's ""edit"" buttons make a _POST_ request to send the user to the
   management page for that key, with the key in a CGI parameter. I'm not
   exactly sure why that's a POST instead of a GET request, but I would guess
   it's to keep API keys out of URLs (which would end up in browser histories).
 - When a key is created or edited through the management page, it makes a POST
   request to itself, which returns a redirect to itself (which becomes a GET
   request). Consequently, the POST/GET handlers are the opposite of what you
   might expect: the POST handler handles the initial display of the form, while
   the GET handler handles what you see afterwards. The GET handler takes the
   Datastore key for a log entry (via a CGI param), which it uses to get the API
   key itself by way of the log entry.
""""""

import django.core.exceptions
import django.shortcuts
import django.utils.translation as t
from google.appengine.ext import db

import model
import utils
import views.admin.base


_API_KEY_LENGTH = 16


class ApiKeyListView(views.admin.base.AdminBaseView):
    """"""The admin API key list view.""""""

    ACTION_ID = 'admin/api_keys/list'

    def get(self, request, *args, **kwargs):
        """"""Serves a view with a list of API keys.""""""
        del request, args, kwargs  # unused
        auths = model.Authorization.all().filter(
            'repo = ', self.env.repo or '*')
        return self.render(
            'admin_api_keys_list.html',
            admin_api_keys_url=self.build_absolute_path(
                '/admin/api_keys', self.env.repo or 'global'),
            user=self.env.user,
            user_email=self.env.user.email(),
            authorizations=auths,
            xsrf_token=self.xsrf_tool.generate_token(
               self.env.user.user_id(), 'admin_api_keys'))


class ApiKeyManagementView(views.admin.base.AdminBaseView):
    """"""The API key management view, for creating or editing keys.""""""

    ACTION_ID = 'admin/api_keys'

    def get_params(self):
        return views.base.read_params(
            super(ApiKeyManagementView, self).get_params(),
            self.request,
            get_params={
                'log_key': utils.strip,
            },
            post_params={
                'authorization_key': utils.strip,
                'believed_dead_permission': utils.validate_checkbox_as_bool,
                'contact_name': utils.strip,
                'contact_email': utils.strip,
                'domain_write_permission': utils.strip,
                'edit_form': utils.strip,
                'full_read_permission': utils.validate_checkbox_as_bool,
                'is_valid': utils.validate_checkbox_as_bool,
                'key': utils.strip,
                'mark_notes_reviewed': utils.validate_checkbox_as_bool,
                'organization_name': utils.strip,
                'read_permission': utils.validate_checkbox_as_bool,
                'search_permission': utils.validate_checkbox_as_bool,
                'stats_permission': utils.validate_checkbox_as_bool,
                'subscribe_permission': utils.validate_checkbox_as_bool,
            })

    def get(self, request, *args, **kwargs):
        if self.params.get('log_key'):
            management_log_key = self.params.log_key
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == model.ApiKeyManagementLog.CREATE:
                message = t.ugettext(
                    'A new API key has been created successfully.')
            elif management_log.action == model.ApiKeyManagementLog.UPDATE:
                message = t.ugettext(
                    'The API key has been updated successfully.')
            return self._render_form(management_log.authorization, message)
        else:
            return self._render_form()

    def _make_authorization(self, repo, key_str):
        """"""Creates and stores an Authorization entity with the request's params.

        Args:
            repo (str): The ID of a repository, or '*' for a global key.
            key_str (str): The key itself.

        Returns:
            Authorization: An Authorization entity, already put in Datastore.
        """"""
        authorization = model.Authorization.create(
            repo,
            key_str,
            contact_name=self.params.contact_name,
            contact_email=self.params.contact_email,
            organization_name=self.params.organization_name,
            domain_write_permission=self.params.get('domain_write_permission'),
            read_permission=self.params.get('read_permission'),
            full_read_permission=self.params.get('full_read_permission'),
            search_permission=self.params.get('search_permission'),
            subscribe_permission=self.params.get('subscribe_permission'),
            mark_notes_reviewed=self.params.get('mark_notes_reviewed'),
            believed_dead_permission=self.params.get(
                'believed_dead_permission'),
            stats_permission=self.params.get('stats_permission'),
            is_valid=self.params.get('is_valid'))
        authorization.put()
        return authorization

    def post(self, request, *args, **kwargs):
        self.enforce_xsrf('admin_api_keys')

        # Navigation to an individual key's management page is handled by making
        # a POST request to this view. When it's such a request, the edit_form
        # param will be set.
        if self.params.get('edit_form'):
            authorization = db.get(self.params.get('authorization_key'))
            if not authorization:
                return self.error(404, t.ugettext(
                    'No such Authorization entity.'))
            return self._render_form(authorization)

        if not (self.params.get('contact_name') and
                self.params.get('contact_email') and
                self.params.get('organization_name')):
            return self.error(400, t.ugettext(
                'Please fill in all the required fields.'))

        repo = self.env.repo or '*'
        if self.params.get('key'):
            # Just override the existing one.
            existing_authorization = db.get(self.params.get('key'))
            if not existing_authorization:
                return self.error(404, t.ugettext(
                    'No such Authorization entity.'))
            # This shouldn't happen unless an admin does something funny with
            # URLs, but check just to be safe.
            if existing_authorization.repo != repo:
                return self.error(400, t.ugettext(
                    'Authorization already exists for another repo! '
                    'That\'s not expected.'))
            key_str = existing_authorization.api_key
            action = model.ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(_API_KEY_LENGTH)
            action = model.ApiKeyManagementLog.CREATE

        authorization = self._make_authorization(repo, key_str)

        management_log = model.ApiKeyManagementLog(
            repo=repo,
            api_key=authorization.api_key,
            action=action,
            ip_address=request.META.get('REMOTE_ADDR'),
            key_state=authorization.summary_str())
        management_log.put()

        return django.shortcuts.redirect(
            self.build_absolute_uri(
                '/%s/admin/api_keys?repo=%s&log_key=%s' % (
                    self.env.repo or 'global',
                    self.env.repo or 'global',
                    management_log.key())))

    def _render_form(self, authorization=None, message=None):
        """"""Produces a response with the API key management form.

        Args:
            authorization (Authorization, optional): An Authorization object. If
                present, an edit form will be produced; if None, a create form
                will be produced.
            message (str, optional): A message to display along with the form.

        Returns:
            HttpResponse: An HTTP response with the form.
        """"""
        if authorization:
            operation_type = 'update'
        else:
            authorization = model.Authorization.DEFAULT_SETTINGS
            operation_type = 'create'
        list_url = self.build_absolute_path(
            '/%s/admin/api_keys/list' % (self.env.repo or 'global'))
        return self.render(
            'admin_api_keys.html',
            user=self.env.user,
            target_key=authorization,
            user_email=self.env.user.email(),
            operation_type=operation_type,
            message=message,
            list_url=list_url,
            xsrf_token=self.xsrf_tool.generate_token(
                self.env.user.user_id(), 'admin_api_keys'),
        )
/n/n/napp/views/admin/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Code shared by admin view modules.""""""

import django.shortcuts
from google.appengine.api import users

import model
import utils
import views.base


class AdminBaseView(views.base.BaseView):
    """"""Base view for admin views.""""""

    class Env(views.base.BaseView.Env):
        """"""Class to store environment information used by views and templates.
        """"""
        # pylint: disable=attribute-defined-outside-init

        @property
        def all_repo_options(self):
            """"""Gets a list of Structs with repo IDs and URLs.

            Each Struct is expected to have two values:
            - repo: the repo ID
            - url: the URL to the repo's admin page
            """"""
            return self._all_repo_options

        @all_repo_options.setter
        def all_repo_options(self, value):
            self._all_repo_options = value

        @property
        def logout_url(self):
            """"""Gets a logout URL for the user.""""""
            return self._logout_url

        @logout_url.setter
        def logout_url(self, value):
            self._logout_url = value

        @property
        def user(self):
            """"""Gets a users.User object for the current user, if any.""""""
            return self._user

        @user.setter
        def user(self, value):
            self._user = value

    def setup(self, request, *args, **kwargs):
        """"""See docs on BaseView.setup.""""""
        # pylint: disable=attribute-defined-outside-init
        super(AdminBaseView, self).setup(request, *args, **kwargs)
        self.env.show_logo = True
        self.env.enable_javascript = True
        self.env.user = users.get_current_user()
        self.env.logout_url = users.create_logout_url(self.build_absolute_uri())
        self.env.all_repo_options = [
            utils.Struct(
                repo=repo, url=self.build_absolute_path('/%s/admin' % repo))
            for repo in sorted(model.Repo.list())
        ]
        self.xsrf_tool = utils.XsrfTool()

    def get_params(self):
        return views.base.read_params(
            super(AdminBaseView, self).get_params(),
            self.request,
            post_params={'xsrf_token': utils.strip})

    def enforce_xsrf(self, action_id):
        """"""Verifies the request's XSRF token.

        Checks the request's XSRF token and raises Django's PermissionDenied
        exception if the request didn't have a token or the token is invalid.
        As long as it's not caught, this will cause Django to return a 403.

        Args:
            action_id (str): The action ID used for creating the page's tokens.

        Raises:
            PermissionDenied: If the request's token is missing or invalid.
        """"""
        if not (self.params.get('xsrf_token') and
                self.xsrf_tool.verify_token(
                    self.params.get('xsrf_token'),
                    self.env.user.user_id(),
                    action_id)):
            raise django.core.exceptions.PermissionDenied

    def dispatch(self, request, *args, **kwargs):
        """"""See docs on django.views.View.dispatch.""""""
        # All the admin pages, and only the admin pages, require the user to be
        # logged in as an admin.
        # If we start requiring login for other pages, we should consider
        # refactoring this into a decorator or something like that.
        if not self.env.user:
            return django.shortcuts.redirect(
                users.create_login_url(self.build_absolute_uri()))
        if not users.is_current_user_admin():
            logout_url = users.create_logout_url(self.build_absolute_uri())
            return self.render(
                'not_admin_error.html',
                status_code=403,
                logout_url=logout_url,
                user=self.env.user)
        return super(AdminBaseView, self).dispatch(request, args, kwargs)
/n/n/napp/views/admin/create_repo.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""The admin create-repo page.""""""

import django.shortcuts

import config
import const
import model
import utils
import views.admin.base


class AdminCreateRepoView(views.admin.base.AdminBaseView):
    """"""The admin create-repo view.""""""

    ACTION_ID = 'admin/create_repo'

    def setup(self, request, *args, **kwargs):
        super(AdminCreateRepoView, self).setup(request, *args, **kwargs)

    def get_params(self):
        return views.base.read_params(
            super(AdminCreateRepoView, self).get_params(),
            self.request,
            post_params={'new_repo': utils.strip})

    def get(self, request, *args, **kwargs):
        """"""Serves GET requests.

        Args:
            request: Unused.
            *args: Unused.
            **kwargs: Unused.

        Returns:
            HttpResponse: A HTTP response with the admin create-repo page.
        """"""
        del request, args, kwargs  # unused
        return self.render(
            'admin_create_repo.html',
            xsrf_token=self.xsrf_tool.generate_token(self.env.user.user_id(),
                                                     self.ACTION_ID))

    def post(self, request, *args, **kwargs):
        """"""Serves POST requests, creating a new repo.

        Creates a new repository and sets some default values (assuming the user
        has permission and a valid XSRF token).

        Args:
            request: Unused.
            *args: Unused.
            **kwargs: Unused.

        Returns:
            HttpResponse: A redirect to the new repo's admin page.
        """"""
        del request, args, kwargs  # unused
        self.enforce_xsrf(self.ACTION_ID)
        new_repo = self.params.new_repo
        model.Repo(
            key_name=new_repo,
            activation_status=model.Repo.ActivationStatus.STAGING,
            test_mode=False).put()
        # Provide some defaults.
        config.set_for_repo(
            new_repo,
            language_menu_options=['en', 'fr'],
            repo_titles={
                'en': 'Earthquake',
                'fr': u'S\xe9isme'
            },
            keywords='person finder, people finder, person, people, ' +
            'crisis, survivor, family',
            use_family_name=True,
            use_alternate_names=True,
            use_postal_code=True,
            allow_believed_dead_via_ui=False,
            min_query_word_length=2,
            show_profile_entry=False,
            profile_websites=const.DEFAULT_PROFILE_WEBSITES,
            map_default_zoom=6,
            map_default_center=[0, 0],
            map_size_pixels=[400, 280],
            read_auth_key_required=True,
            search_auth_key_required=True,
            deactivated=False,
            launched=False,
            deactivation_message_html='',
            start_page_custom_htmls={
                'en': '',
                'fr': ''
            },
            results_page_custom_htmls={
                'en': '',
                'fr': ''
            },
            view_page_custom_htmls={
                'en': '',
                'fr': ''
            },
            seek_query_form_custom_htmls={
                'en': '',
                'fr': ''
            },
            footer_custom_htmls={
                'en': '',
                'fr': ''
            },
            bad_words='',
            published_date=utils.get_utcnow_timestamp(),
            updated_date=utils.get_utcnow_timestamp(),
            test_mode=False,
            force_https=True,
            zero_rating_mode=False,
            time_zone_offset=0,
            time_zone_abbreviation='UTC',
        )
        return django.shortcuts.redirect(
            self.build_absolute_path('/%s/admin' % new_repo))
/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    class Env(object):
        """"""Class to store environment information used by views and templates.

        Subclasses of BaseView may define their own Env class (which must be
        subclasses of BaseView.Env); that Env class (as long as it's called
        ""Env"") will be used automatically when the env is set up.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # pylint: disable=too-many-instance-attributes

        @property
        def action(self):
            """"""Gets the action ID, an identifier for the page being served.""""""
            return self._action

        @action.setter
        def action(self, value):
            self._action = value

        @property
        def charset(self):
            """"""Gets the character encoding being used to serve the page.""""""
            return self._charset

        @charset.setter
        def charset(self, value):
            self._charset = value

        @property
        def config(self):
            """"""Gets the config, a config.Config object for the repository.""""""
            return self._config

        @config.setter
        def config(self, value):
            self._config = value

        @property
        def enable_javascript(self):
            ""Gets whether or not to enable JavaScript."" """"
            return self._enable_javascript

        @enable_javascript.setter
        def enable_javascript(self, value):
            self._enable_javascript = value

        @property
        def global_url(self):
            """"""Gets the URL for the global root.""""""
            return self._global_url

        @global_url.setter
        def global_url(self, value):
            self._global_url = value

        @property
        def lang(self):
            """"""Gets the code for the language being used (see const.py).""""""
            return self._lang

        @lang.setter
        def lang(self, value):
            self._lang = value

        @property
        def repo(self):
            """"""Gets the repository ID, or None if it's a global page.""""""
            return self._repo

        @repo.setter
        def repo(self, value):
            self._repo = value

        @property
        def rtl(self):
            """"""Gets whether the language is a right-to-left language.""""""
            return self._rtl

        @rtl.setter
        def rtl(self, value):
            self._rtl = value

        @property
        def show_logo(self):
            """"""Gets whether or not to show the logo in the header.""""""
            return self._show_logo

        @show_logo.setter
        def show_logo(self, value):
            self._show_logo = value

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = self.get_params()

        # Set up env variable with data needed by the whole app.
        self.env = self.Env()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def get_params(self):
        """"""Gets parameter values out of the request.

        Subclasses that need additional values should override this function,
        with an implementation like this:
        return views.base.read_params(
            super(<Subclass>, self).get_params(),
            self.request,
            get_params={'x': validate_x, 'y': validate_y,},
            post_params={'z': validate_z})

        Returns:
            utils.Struct: A container with the values of CGI parameters used by
            this view.
        """"""
        return read_params(
            utils.Struct(), self.request, get_params={'lang': utils.strip})

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None, repo=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.
            repo (str, optional): A repo ID. If specified, the path will be
                considered relative to the repo's route. If this is specified,
                path must also be specified.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            assert not repo
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if repo:
            path = '/%s%s' % (repo, path)
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, status_code=200, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            template_vars['csp_nonce'] = self.request.csp_nonce
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0),
            status=status_code)

    def error(self, status_code, message=''):
        """"""Returns an error response.

        Args:
            status_code (int): The HTTP status code to use.
            message (str, optional): A message to display. Defaults to the empty
                string.

        Returns:
            HttpResponse: An HTTP response with the given status code and
            message.
        """"""
        # pylint: disable=no-self-use
        # Making this a method of BaseView keeps it consistent with render(),
        # and probably other similar functions in the future.
        return django.http.HttpResponse(
            content=message, content_type='text/plain', status=status_code)

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view


def read_params(container,
                request,
                get_params=None,
                post_params=None,
                file_params=None):
    """"""Reads CGI parameter values from the request to the container.

    Args:
        container (utils.Struct): The container to put parameter values in.
        request (HttpRequest): The request to read from.
        get_params (dict): A dictionary from GET parameter keys to validator
            functions.
        post_params (dict): A dictionary from POST parameter keys to validator
            functions.
        file_params (dict): A dictionary from POST parameter keys for uploaded
            files to validator functions.

    Returns:
        utils.Struct: The container, for convenience.
    """"""
    if request.method == 'GET':
        if get_params:
            for key, validator in get_params.items():
                if key in request.GET:
                    setattr(container, key, validator(request.GET[key]))
    elif request.method == 'POST':
        if post_params:
            for key, validator in post_params.items():
                if key in request.POST:
                    setattr(container, key, validator(request.POST[key]))
        if file_params:
            for key, validator in file_params.items():
                if key in request.FILES:
                    setattr(container, key, validator(request.FILES[key]))
    return container
/n/n/ntests/server_test_cases/api_key_management_tests.py/n/n#!/usr/bin/python2.7
# encoding: utf-8
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Test cases for end-to-end testing.  Run with the server_tests script.""""""

import calendar
import datetime
import email
import email.header
import optparse
import os
import pytest
import re
import simplejson
import sys
import tempfile
import time
import unittest
import urlparse

from google.appengine.api import images

import config
from const import ROOT_URL, PERSON_STATUS_TEXT, NOTE_STATUS_TEXT
import download_feed
from model import *
from photo import MAX_IMAGE_DIMENSION
import remote_api
from resources import Resource, ResourceBundle
import reveal
import scrape
import setup_pf as setup
from test_pfif import text_diff
from text_query import TextQuery
import utils
from server_tests_base import ServerTestsBase


# TODO(ryok): fix go_as_operator() and re-enable the tests.
#class ApiKeyManagementTests(ServerTestsBase):
#    """"""Tests for API key management capabilities.""""""
#
#    key_management_operator = ""op@example.com""
#    
#    def go_as_operator(self, path, **kwargs):
#        """"""Navigates to the given path with an operator login.""""""
#        if not self.logged_in_as_operator:
#            scrape.setcookies(self.s.cookiejar, self.hostport,
#                              ['dev_appserver_login=%s:True:1' %
#                                  self.key_management_operator])
#            self.logged_in_as_operator = True
#        return self.go(path, **kwargs)
#
#    def go_as_admin(self, path, **kwargs):
#        """"""Setting logged_in_as_operator to False.""""""
#        ret = ServerTestsBase.go_as_admin(self, path, **kwargs)
#        self.logged_in_as_operator = False
#        return ret
#
#    def setUp(self):
#        ServerTestsBase.setUp(self)
#        self.logged_in_as_operator = False
#        config.set_for_repo(
#            'japan',
#            key_management_operators=[self.key_management_operator])
#
#    def test_toppage(self):
#        """"""Check the main page of API kay management.""""""
#        url = 'http://%s/personfinder/japan/admin/api_keys' % self.hostport
#        doc = self.go(url, redirects=0)
#        # check if 302
#        assert self.s.status == 302
#        doc = self.go_as_operator(url, redirects=0)
#        assert self.s.status == 200
#        assert 'API Key Management' in doc.text
#        doc = self.go_as_admin(url, redirects=0)
#        assert self.s.status == 200
#        assert 'API Key Management' in doc.text
#
#    def test_manage_key(self):
#        """"""Check if a new API key is created/updated correctly.""""""
#        url = 'http://%s/personfinder/japan/admin/api_keys' % self.hostport
#        doc = self.go_as_operator(url)
#        assert self.s.status == 200
#        assert 'API Key Management' in doc.text
#        form = doc.cssselect_one('form#create-or-update-api-key')
#        contact_name = 'Test User'
#        contact_email = 'user@example.com'
#        organization_name = 'Example, Inc.'
#        domain_write_permission = 'example.com'
#        doc = self.s.submit(
#            form,
#            contact_name=contact_name,
#            contact_email=contact_email,
#            organization_name=organization_name,
#            domain_write_permission=domain_write_permission,
#            read_permission='on',
#            full_read_permission='on',
#            search_permission='on',
#            subscribe_permission='on',
#            mark_notes_reviewed='on',
#            is_valid='on',
#        )
#        assert 'A new API key has been created successfully.' in doc.text
#        q = Authorization.all().filter('repo =', 'japan')
#        authorizations = q.fetch(10)
#        assert len(authorizations) == 1
#        authorization = authorizations[0]
#        # Check if the new key is correct.
#        assert authorization.contact_name == contact_name
#        assert authorization.contact_email == contact_email
#        assert authorization.organization_name == organization_name
#        assert authorization.domain_write_permission == domain_write_permission
#        assert authorization.read_permission is True
#        assert authorization.full_read_permission is True
#        assert authorization.search_permission is True
#        assert authorization.subscribe_permission is True
#        assert authorization.mark_notes_reviewed is True
#        assert authorization.is_valid is True
#        # Check if the management self.log is created correctly.
#        q = ApiKeyManagementLog.all().filter('repo =', 'japan')
#        logs = q.fetch(10)
#        assert len(logs) == 1
#        self.log = logs[0]
#        assert self.log.user.email() == self.key_management_operator
#        assert self.log.authorization.key() == authorization.key()
#        assert self.log.action == ApiKeyManagementLog.CREATE
#
#        # List the key and click the edit form on the list
#        url = 'http://%s/personfinder/japan/admin/api_keys/list' % self.hostport
#        doc = self.go_as_admin(url)
#        assert self.s.status == 200
#        assert 'Listing API keys for japan' in doc.text
#        form = doc.cssselect_one('form')
#        doc = self.s.submit(form)
#        assert self.s.status == 200
#        assert 'Detailed information of an API key for japan' in doc.text
#
#        # Update the key
#        contact_name = 'Japanese User'
#        contact_email = 'user@example.jp'
#        organization_name = 'Example, Corp.'
#
#        form = doc.cssselect_one('form')
#        doc = self.s.submit(
#            form,
#            contact_name=contact_name,
#            contact_email=contact_email,
#            organization_name=organization_name,
#            domain_write_permission='',
#            read_permission='',
#            full_read_permission='',
#            search_permission='',
#            subscribe_permission='',
#            mark_notes_reviewed='',
#            is_valid='',
#            key=str(authorization.key()),
#        )
#        assert 'The API key has been updated successfully.' in doc.text
#        q = Authorization.all().filter('repo =', 'japan')
#        authorizations = q.fetch(10)
#        assert len(authorizations) == 1
#        authorization = authorizations[0]
#        # Check if the new key is correct.
#        assert authorization.contact_name == contact_name
#        assert authorization.contact_email == contact_email
#        assert authorization.organization_name == organization_name
#        assert authorization.domain_write_permission == ''
#        assert authorization.read_permission is False
#        assert authorization.full_read_permission is False
#        assert authorization.search_permission is False
#        assert authorization.subscribe_permission is False
#        assert authorization.mark_notes_reviewed is False
#        assert authorization.is_valid is False
#        # Check if the management self.log is created correctly.
#        q = ApiKeyManagementLog.all().filter('repo =', 'japan')
#        logs = q.fetch(10)
#        assert len(logs) == 2
#        for self.log in logs:
#            assert self.log.user.email() == self.key_management_operator
#            assert self.log.authorization.key() == authorization.key()
#            if self.log.action != ApiKeyManagementLog.CREATE:
#                assert self.log.action == ApiKeyManagementLog.UPDATE
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/ntests/views/test_admin_api_keys.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Tests for the admin API keys pages.""""""

import django.http

import model

import view_tests_base


def add_test_authorization():
    authorization = model.Authorization.create(
        'haiti',
        'secret_key',
        contact_name='Bob Vance',
        contact_email='bob@fridge.com',
        organization_name='Vance Refrigeration',
        domain_write_permission='fridge.com',
        read_permission=True,
        full_read_permission=True,
        search_permission=True,
        subscribe_permission=False,
        mark_notes_reviewed=False,
        believed_dead_permission=False,
        stats_permission=False,
        is_valid=True)
    authorization.put()
    return authorization


class ApiKeyListViewTests(view_tests_base.ViewTestsBase):
    """"""Tests the admin API keys list view.""""""

    def setUp(self):
        super(ApiKeyListViewTests, self).setUp()
        model.Repo(key_name='haiti').put()
        add_test_authorization()
        self.login(is_admin=True)

    def test_get(self):
        """"""Tests GET requests.""""""
        doc = self.to_doc(self.client.get(
            '/haiti/admin/api_keys/list/', secure=True))
        self.assertTrue('Bob Vance' in doc.text)
        self.assertTrue('bob@fridge.com' in doc.text)
        self.assertTrue('Vance Refrigeration' in doc.text)
        # The first 10 elements with the ""permissions"" class are the
        # ""Permissions"" header and the individual permissions column headers.
        permissions_row = [el.text for el in doc.cssselect('.permission')[10:]]
        expected_permissions = [
            'fridge.com', 'x', 'x', 'x', None, None, None, None, 'x']
        self.assertEqual(permissions_row, expected_permissions)


class ApiKeyManagementViewTests(view_tests_base.ViewTestsBase):
    """"""Tests the API key management view.""""""

    def init_testbed_stubs(self):
        self.testbed.init_user_stub()
        self.testbed.init_datastore_v3_stub()

    def setUp(self):
        super(ApiKeyManagementViewTests, self).setUp()
        self.login(is_admin=True)

    def test_get_create_form(self):
        """"""Tests GET requests with no log key (i.e., the creation form).""""""
        self.authorization = add_test_authorization()
        res = self.client.get('/haiti/admin/api_keys/', secure=True)
        self.assertEqual(res.context['target_key'],
                         model.Authorization.DEFAULT_SETTINGS)
        self.assertEqual(res.context['operation_type'], 'create')

    def test_get_update_form(self):
        """"""Tests GET requests with a log key specified (i.e., an update form).
        """"""
        self.authorization = add_test_authorization()
        management_log = model.ApiKeyManagementLog(
            repo='haiti',
            api_key=self.authorization.api_key,
            action=model.ApiKeyManagementLog.CREATE,
            ip_address='123.45.67.89',
            key_state=self.authorization.summary_str())
        management_log.put()
        res = self.client.get(
            '/haiti/admin/api_keys/',
            data={'log_key': management_log.key()},
            secure=True)
        self.assertEqual(res.context['target_key'].key(),
                         self.authorization.key())
        self.assertEqual(res.context['operation_type'], 'update')

    def test_post_render_update_form(self):
        """"""Tests POST requests to show the update form.""""""
        self.authorization = add_test_authorization()
        params = {
            'edit_form': '1',
            'authorization_key': self.authorization.key(),
            'xsrf_token': self.xsrf_token('admin_api_keys'),
        }
        res = self.client.post(
            '/haiti/admin/api_keys/', data=params, secure=True)
        self.assertEqual(res.context['target_key'].key(),
                         self.authorization.key())
        self.assertEqual(res.context['operation_type'], 'update')

    def test_create_key(self):
        """"""Tests POST requests to create a new key.""""""
        params = {
            'contact_name': 'Creed Bratton',
            'contact_email': 'creed@aol.com',
            'organization_name': 'Creed Inc.',
            'read_permission': 'true',
            'search_permission': 'true',
            'is_valid': 'true',
            'xsrf_token': self.xsrf_token('admin_api_keys'),
        }
        res = self.client.post(
            '/haiti/admin/api_keys/', data=params, secure=True,
            REMOTE_ADDR='11.22.33.44')
        # Check that the Authorization entity was generated correctly.
        auths = model.Authorization.all().filter('repo =', 'haiti')
        self.assertEqual(auths.count(), 1)
        auth = auths[0]
        self.assertEqual(auth.contact_name, 'Creed Bratton')
        self.assertEqual(auth.contact_email, 'creed@aol.com')
        self.assertEqual(auth.organization_name, 'Creed Inc.')
        self.assertTrue(auth.read_permission)
        self.assertTrue(auth.search_permission)
        self.assertTrue(auth.is_valid)
        self.assertIsNone(auth.domain_write_permission)
        self.assertFalse(auth.full_read_permission)
        self.assertFalse(auth.subscribe_permission)
        self.assertFalse(auth.mark_notes_reviewed)
        self.assertFalse(auth.believed_dead_permission)
        self.assertFalse(auth.stats_permission)
        self.assertIsInstance(res, django.http.HttpResponseRedirect)
        # A management log entry should have been created.
        management_logs = model.ApiKeyManagementLog.all()
        self.assertEqual(1, management_logs.count())
        management_log = management_logs[0]
        self.assertEqual(management_log.repo, 'haiti')
        self.assertEqual(management_log.api_key, auth.api_key)
        self.assertEqual(
            management_log.action, model.ApiKeyManagementLog.CREATE)
        self.assertEqual(management_log.ip_address, '11.22.33.44')
        self.assertTrue('Creed' in management_log.key_state)
        # The user should be redirected to the form with the log key in a GET
        # parameter.
        self.assertEqual(
            res.url,
            'https://testserver/haiti/admin/api_keys?repo=haiti&log_key=%s' %
            management_log.key())

    def test_update_key(self):
        """"""Tests POST request to update an existing key.""""""
        self.authorization = add_test_authorization()
        params = {
            'key': self.authorization.key(),
            'contact_name': 'Phyllis Vance',
            'contact_email': 'phyllis@fridge.com',
            'organization_name': 'Vance Refrigeration',
            'domain_write_permission': 'fridge.com',
            'read_permission': 'true',
            'full_read_permission': 'true',
            'search_permission': 'true',
            'subscribe_permission': 'true',
            'is_valid': 'true',
            'xsrf_token': self.xsrf_token('admin_api_keys'),
        }
        res = self.client.post(
            '/haiti/admin/api_keys/', data=params, secure=True,
            REMOTE_ADDR='11.22.33.44')
        # Check that the Authorization entity was updated correctly.
        auths = model.Authorization.all().filter('repo =', 'haiti')
        self.assertEqual(auths.count(), 1)
        auth = auths[0]
        self.assertEqual(auth.key(), self.authorization.key())
        # Check that changes were made.
        self.assertEqual(auth.contact_name, 'Phyllis Vance')
        self.assertEqual(auth.contact_email, 'phyllis@fridge.com')
        self.assertTrue(auth.subscribe_permission)
        # A management log entry should have been created.
        management_logs = model.ApiKeyManagementLog.all()
        self.assertEqual(1, management_logs.count())
        management_log = management_logs[0]
        self.assertEqual(management_log.repo, 'haiti')
        self.assertEqual(management_log.api_key, auth.api_key)
        self.assertEqual(
            management_log.action, model.ApiKeyManagementLog.UPDATE)
        self.assertEqual(management_log.ip_address, '11.22.33.44')
        self.assertTrue('Phyllis' in management_log.key_state)
        # The user should be redirected to the form with the log key in a GET
        # parameter.
        self.assertEqual(
            res.url,
            'https://testserver/haiti/admin/api_keys?repo=haiti&log_key=%s' %
            management_log.key())
/n/n/ntests/views/view_tests_base.py/n/n""""""Tools to help run tests against the Django app.""""""

import os
import unittest

import django
import django.test
from google.appengine.ext import testbed

import const
import utils

import scrape


class ViewTestsBase(unittest.TestCase):
    """"""A base class for tests for the Django app.""""""

    _USER_ID = 'k'

    def init_testbed_stubs(self):
        self.testbed.init_user_stub()

    def setUp(self):
        self.testbed = testbed.Testbed()
        self.testbed.activate()
        self.init_testbed_stubs()
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
        django.setup()
        django.test.utils.setup_test_environment()
        self.client = django.test.Client()
        self._xsrf_tool = utils.XsrfTool()

    def tearDown(self):
        self.testbed.deactivate()
        django.test.utils.teardown_test_environment()

    def login(self, is_admin=False):
        """"""Logs in the ""user"" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """"""
        self.testbed.setup_env(
            user_email='kay@mib.gov',
            user_id=ViewTestsBase._USER_ID,
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)

    def to_doc(self, response):
        """"""Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """"""
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)
/n/n/n",0
25,fa58bf0d37503c857be1a8cf533e8400d5cdbb6f,"/app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

AUTHORIZATION_PARAMS_LIST = [
    'contact_name',
    'contact_email',
    'organization_name',
    'domain_write_permission',
    'read_permission',
    'full_read_permission',
    'search_permission',
    'subscribe_permission',
    'mark_notes_reviewed',
    'believed_dead_permission',
    'stats_permission',
    'is_valid',
]

def to_authorization_params(param):
    ret = {}
    for param_name in AUTHORIZATION_PARAMS_LIST:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags,
                           xsrf_token=xsrf_tool.generate_token(
                               user.user_id(), 'admin_api_keys'))


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/n",1
26,5bd28a262e274d24cf802ed6051e6880c7033452,"app/admin_delete_record.py/n/n#!/usr/bin/python2.7
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from const import *
from model import *
from utils import *
import reveal


class Handler(BaseHandler):
    """"""An admin page to delete person records.""""""

    # After a repository is deactivated, we still need the admin page to be
    # accessible so we can edit its settings.
    ignore_deactivation = True

    repo_required = False
    admin_required = True

    def get(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        self.render(
            'admin_delete_record.html',
            id=self.env.domain + '/person.',
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_delete_record'))

    def post(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                    self.params.xsrf_token, user.user_id(),
                    'admin_delete_record')):
            self.error(403)
            return False
        # Redirect to the deletion handler with a valid signature.
        action = ('delete', str(self.params.id))
        self.redirect('/delete', id=self.params.id,
                      signature=reveal.sign(action))
/n/n/napp/main.py/n/n#!/usr/bin/python2.7
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""The main request handler. All dynamic requests except for remote_api are
handled by this handler, which dispatches to all other dynamic handlers.""""""

import django_setup  # always keep this first

import mimetypes
import re
import os

import urlparse

from google.appengine.api import memcache
from google.appengine.api import users
from google.appengine.ext import webapp

import config
import const
import django.utils.html
import logging
import model
import pfif
import resources
import utils
import user_agents
import setup_pf


# When no action or repo is specified, redirect to this action.
HOME_ACTION = 'home.html'

# Map of URL actions to Python module and class names.
# TODO(kpy): Remove the need for this configuration information, either by
# regularizing the module and class names or adding a URL attribute to handlers.
HANDLER_CLASSES = dict((x, x.replace('/', '_') + '.Handler') for x in [
  'start',
  'amp_start',
  'query',
  'results',
  'create',
  'view',
  'multiview',
  'reveal',
  'photo',
  'embed',
  'extend',
  'gadget',
  'delete',
  'flag_note',
  'restore',
  'subscribe',
  'unsubscribe',
  'disable_notes',
  'confirm_disable_notes',
  'enable_notes',
  'confirm_enable_notes',
  'post_flagged_note',
  'confirm_post_flagged_note',
  'third_party_search',
  'admin',
  'admin/create_repo',
  'admin/dashboard',
  'admin/resources',
  'admin/review',
  'css',
  'add_note',
  'tos',
])

# Exceptional cases where the module name doesn't match the URL.
HANDLER_CLASSES[''] = 'start.Handler'
HANDLER_CLASSES['admin/api_keys'] = 'admin_api_keys.CreateOrUpdateApiKey'
HANDLER_CLASSES['admin/api_keys/list'] = 'admin_api_keys.ListApiKeys'
HANDLER_CLASSES['api/import'] = 'api.Import'
HANDLER_CLASSES['api/import/notes'] = 'api.Import'
HANDLER_CLASSES['api/import/persons'] = 'api.Import'
HANDLER_CLASSES['api/read'] = 'api.Read'
HANDLER_CLASSES['api/write'] = 'api.Write'
HANDLER_CLASSES['api/search'] = 'api.Search'
HANDLER_CLASSES['api/subscribe'] = 'api.Subscribe'
HANDLER_CLASSES['api/unsubscribe'] = 'api.Unsubscribe'
HANDLER_CLASSES['api/stats'] = 'api.Stats'
HANDLER_CLASSES['api/handle_sms'] = 'api.HandleSMS'
HANDLER_CLASSES['api/photo_upload'] = 'api.PhotoUpload'
HANDLER_CLASSES['feeds/repo'] = 'feeds.Repo'
HANDLER_CLASSES['feeds/note'] = 'feeds.Note'
HANDLER_CLASSES['feeds/person'] = 'feeds.Person'
HANDLER_CLASSES['tasks/count/note'] = 'tasks.CountNote'
HANDLER_CLASSES['tasks/count/person'] = 'tasks.CountPerson'
HANDLER_CLASSES['tasks/count/reindex'] = 'tasks.Reindex'
HANDLER_CLASSES['tasks/count/update_dead_status'] = 'tasks.UpdateDeadStatus'
HANDLER_CLASSES['tasks/count/update_status'] = 'tasks.UpdateStatus'
HANDLER_CLASSES['tasks/delete_expired'] = 'tasks.DeleteExpired'
HANDLER_CLASSES['tasks/delete_old'] = 'tasks.DeleteOld'
HANDLER_CLASSES['tasks/dump_csv'] = 'tasks.DumpCSV'
HANDLER_CLASSES['tasks/clean_up_in_test_mode'] = 'tasks.CleanUpInTestMode'
HANDLER_CLASSES['tasks/notify_many_unreviewed_notes'] = 'tasks.NotifyManyUnreviewedNotes'
HANDLER_CLASSES['tasks/thumbnail_preparer'] = 'tasks.ThumbnailPreparer'
if config.get('enable_react_ui'):
    HANDLER_CLASSES['d/create'] = 'frontend_api.Create'
    HANDLER_CLASSES['d/person'] = 'frontend_api.Person'
    HANDLER_CLASSES['d/repo'] = 'frontend_api.Repo'
    HANDLER_CLASSES['d/results'] = 'frontend_api.Results'

NON_REACT_UI_PATHS = ['api/', 'admin/', 'feeds/', 'sitemap', 'tasks/', 'd/']

def is_development_server():
    """"""Returns True if the app is running in development.""""""
    server = os.environ.get('SERVER_SOFTWARE', '')
    return 'Development' in server

def is_cron_task(request):
    """"""Returns True if the request is from appengine cron.""""""
    return 'X-AppEngine-Cron' in request.headers

def is_task_queue_task(request):
    """"""Returns True if the request is from the appengine task queue.""""""
    return 'X-AppEngine-TaskName' in request.headers

def get_repo_and_action(request):
    """"""Determines the repo and action for a request.  The action is the part
    of the URL path after the repo, with no leading or trailing slashes.""""""
    scheme, netloc, path, _, _ = urlparse.urlsplit(request.url)
    parts = path.lstrip('/').split('/')

    # Depending on whether we're serving from appspot directly or
    # google.org/personfinder we could have /global or /personfinder/global
    # as the 'global' prefix.
    if parts[0] == 'personfinder':
        parts.pop(0)
    repo = parts and parts.pop(0) or None
    action = '/'.join(parts)
    if repo == 'global':
        repo = None
    return repo, action

def select_charset(request):
    """"""Given a request, chooses a charset for encoding the response.

    If the selected charset is UTF-8, it always returns
    'utf-8' (const.CHARSET_UTF8), not 'utf8', 'UTF-8', etc.

    For now, we always use UTF-8, because supporting anything else with WebOB
    1.2.3 and webapp2 is impractical. We might revisit this once we migrate to
    Django, with which it shouldn't be so difficult to support other character
    sets.
    """"""
    return const.CHARSET_UTF8

def select_lang(request, config=None):
    """"""Selects the best language to use for a given request.  The 'lang' query
    parameter has priority, then the django_language cookie, then
    'Accept-Language' HTTP header, then the first language in the language menu,
    then the default setting.""""""
    default_lang = (
        (config and
         config.language_menu_options and
         config.language_menu_options[0]) or
            const.DEFAULT_LANGUAGE_CODE)
    lang = (request.get('lang') or
            request.cookies.get('django_language', None) or
            select_lang_from_header(request, default_lang=default_lang))
    lang = re.sub('[^A-Za-z0-9-]', '', lang)
    lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
    if lang in const.LANGUAGE_ENDONYMS.keys():
        return lang
    else:
        return default_lang

def select_lang_from_header(request, default_lang):
    """"""Selects the best language matching 'Accept-Language' HTTP header.""""""
    # Either of the first item in the first argument or the default_match
    # argument is used as the default depending on the situation. So we need to
    # put the default language to both. See:
    #   https://docs.pylonsproject.org/projects/webob/en/stable/api/webob.html#webob.acceptparse.AcceptLanguageValidHeader.best_match
    #   https://docs.pylonsproject.org/projects/webob/en/stable/api/webob.html#webob.acceptparse.AcceptLanguageNoHeader.best_match
    return request.accept_language.best_match(
        [default_lang] + const.LANGUAGE_ENDONYMS.keys(),
        default_match=default_lang)

def get_repo_options(request, lang):
    """"""Returns a list of the names and titles of the launched repositories.""""""
    options = []
    for repo in model.Repo.list_launched():
        titles = config.get_for_repo(repo, 'repo_titles', {})
        default_title = (titles.values() or ['?'])[0]
        title = titles.get(lang, titles.get('en', default_title))
        url = utils.get_repo_url(request, repo)
        test_mode = config.get_for_repo(repo, 'test_mode')
        options.append(utils.Struct(repo=repo, title=title, url=url,
                                    test_mode=test_mode))
    return options

def get_language_options(request, config, current_lang):
    """"""Returns a list of information needed to generate the language menu.""""""
    primary_langs = (config and config.language_menu_options) or ['en']
    all_langs = sorted(
        const.LANGUAGE_ENDONYMS.keys(),
        key=lambda s: const.LANGUAGE_ENDONYMS[s])
    return {
        'primary':
            [get_language_option(request, lang, lang == current_lang)
             for lang in primary_langs],
        'all':
            # We put both 'primary' and 'all' languages into a single <select>
            # box (See app/resources/language-menu.html.template).
            # If current_lang is in the primary languages, we mark the
            # language as is_selected in 'primary', not in 'all', to make sure
            # a single option is selected in the <select> box.
            [get_language_option(
                request, lang,
                lang == current_lang and lang not in primary_langs)
             for lang in all_langs],
    }

def get_language_option(request, lang, is_selected):
    return {
        'lang': lang,
        'endonym': const.LANGUAGE_ENDONYMS.get(lang, '?'),
        'url': utils.set_url_param(request.url, 'lang', lang),
        'is_selected': is_selected,
    }

def get_localized_message(localized_messages, lang, default):
    """"""Gets the localized message for lang from a dictionary that maps language
    codes to localized messages.  Falls back to English if language 'lang' is
    not available, or to a default message if English is not available.""""""
    if not isinstance(localized_messages, dict):
        return default
    return localized_messages.get(lang, localized_messages.get('en', default))

def get_hidden_input_tags_for_preserved_query_params(request):
    """"""Gets HTML with <input type=""hidden""> tags to preserve query parameters
    listed in utils.PRESERVED_QUERY_PARAM_NAMES e.g. ""ui"".""""""
    tags_str = ''
    for name in utils.PRESERVED_QUERY_PARAM_NAMES:
        value = request.get(name)
        if value:
            tags_str += '<input type=""hidden"" name=""%s"" value=""%s"">\n' % (
                django.utils.html.escape(name),
                django.utils.html.escape(value))
    return tags_str

def setup_env(request):
    """"""Constructs the 'env' object, which contains various template variables
    that are commonly used by most handlers.""""""
    env = utils.Struct()
    env.repo, env.action = get_repo_and_action(request)
    env.config = config.Configuration(env.repo or '*')

    env.analytics_id = env.config.get('analytics_id')
    env.amp_gtm_id = env.config.get('amp_gtm_id')
    env.maps_api_key = env.config.get('maps_api_key')

    # Internationalization-related stuff.
    env.charset = select_charset(request)
    env.lang = select_lang(request, env.config)
    env.rtl = env.lang in const.LANGUAGES_BIDI

    # Determine the resource bundle to use.
    env.default_resource_bundle = env.config.get('default_resource_bundle', '1')
    env.resource_bundle = (request.cookies.get('resource_bundle', '') or
                           env.default_resource_bundle)

    # Information about the request.
    env.url = utils.set_url_param(request.url, 'lang', env.lang)
    env.scheme, env.netloc, env.path, _, _ = urlparse.urlsplit(request.url)
    env.force_https = True
    env.domain = env.netloc.split(':')[0]
    env.global_url = utils.get_repo_url(request, 'global')

    # Commonly used information that's rendered or localized for templates.
    env.language_options = get_language_options(request, env.config, env.lang)
    env.repo_options = get_repo_options(request, env.lang)
    env.expiry_options = [
        utils.Struct(value=value, text=const.PERSON_EXPIRY_TEXT[value])
        for value in sorted(const.PERSON_EXPIRY_TEXT.keys(), key=int)
    ]
    env.status_options = [
        utils.Struct(value=value, text=const.NOTE_STATUS_TEXT[value])
        for value in pfif.NOTE_STATUS_VALUES
        if (value != 'believed_dead' or
            not env.config or env.config.allow_believed_dead_via_ui)
    ]
    env.hidden_input_tags_for_preserved_query_params = (
        get_hidden_input_tags_for_preserved_query_params(request))

    ui_param = request.get('ui', '').strip().lower()

    # Interprets ""small"" and ""style"" parameters for backward compatibility.
    # TODO(ichikawa): Delete these in near future when we decide to drop
    # support of these parameters.
    small_param = request.get('small', '').strip().lower()
    style_param = request.get('style', '').strip().lower()
    if not ui_param and small_param == 'yes':
        ui_param = 'small'
    elif not ui_param and style_param:
        ui_param = style_param

    if ui_param:
        env.ui = ui_param
    elif user_agents.is_jp_tier2_mobile_phone(request):
        env.ui = 'light'
    else:
        env.ui = 'default'

    # UI configurations.
    #
    # Enables features which require JavaScript.
    env.enable_javascript = True
    # Enables operations which requires Captcha.
    env.enable_captcha = True
    # Enables photo upload.
    env.enable_photo_upload = True
    # Enables to flag/unflag notes as spam, and to reveal spam notes.
    env.enable_spam_ops = True
    # Enables duplicate marking mode.
    env.enable_dup_mode = True
    # Shows a logo on top of the page.
    env.show_logo = True
    # Shows language menu.
    env.show_language_menu = True
    # Uses short labels for buttons.
    env.use_short_buttons = False
    # Optional ""target"" attribute for links to non-small pages.
    env.target_attr = ''
    # Shows record IDs in the results page.
    env.show_record_ids_in_results = True
    # Shows non AMP HTML pages by default.
    env.amp = False

    if env.ui == 'small':
        env.show_logo = False
        env.target_attr = ' target=""_blank"" '

    elif env.ui == 'light':
        # Disables features which requires JavaScript. Some feature phones
        # doesn't support JavaScript.
        env.enable_javascript = False
        # Disables operations which requires Captcha because Captcha requires
        # JavaScript.
        env.enable_captcha = False
        # Uploading is often not supported in feature phones.
        env.enable_photo_upload = False
        # Disables spam operations because it requires JavaScript and
        # supporting more pages on ui=light.
        env.enable_spam_ops = False
        # Disables duplicate marking mode because it doesn't support
        # small screens and it requires JavaScript.
        env.enable_dup_mode = False
        # Hides the logo on the top to save the space. Also, the logo links
        # to the global page which doesn't support small screens.
        env.show_logo = False
        # Hides language menu because the menu in the current position is
        # annoying in feature phones.
        # TODO(ichikawa): Consider layout of the language menu.
        env.show_language_menu = False
        # Too long buttons are not fully shown in some feature phones.
        env.use_short_buttons = True
        # To make it simple.
        env.show_record_ids_in_results = False

    env.back_chevron = u'\xab'
    back_chevron_in_charset = True
    try:
        env.back_chevron.encode(env.charset)
    except UnicodeEncodeError:
        # u'\xab' is not in the charset (e.g. Shift_JIS).
        back_chevron_in_charset = False
    if not back_chevron_in_charset or env.ui == 'light':
        # Use ASCII characters on ui=light too because some feature phones
        # support UTF-8 but don't render UTF-8 symbols such as u'\xab'.
        env.back_chevron = u'<<'

    env.enable_maps = (
        env.enable_javascript
        and not env.config.zero_rating_mode
        and env.maps_api_key)
    env.enable_analytics = (
        env.enable_javascript
        and not env.config.zero_rating_mode
        and env.analytics_id)
    env.enable_translate = (
        env.enable_javascript
        and not env.config.zero_rating_mode
        and env.config.translate_api_key)

    # Repo-specific information.
    if env.repo:
        # repo_url is the root URL for the repository.
        env.repo_url = utils.get_repo_url(request, env.repo)
        # start_url is like repo_url but preserves parameters such as 'ui'.
        env.start_url = utils.get_url(request, env.repo, '')
        # URL of the link in the heading. The link on ui=small links to the
        # normal UI.
        env.repo_title_url = (
            env.repo_url if env.ui == 'small' else env.start_url)
        # URL to force default UI. Note that we show ui=light version in some
        # user agents when ui parameter is not specified.
        env.default_ui_url = utils.get_url(request, env.repo, '', ui='default')
        env.repo_path = urlparse.urlsplit(env.repo_url)[2]
        env.repo_title = get_localized_message(
            env.config.repo_titles, env.lang, '?')
        env.start_page_custom_html = get_localized_message(
            env.config.start_page_custom_htmls, env.lang, '')
        env.results_page_custom_html = get_localized_message(
            env.config.results_page_custom_htmls, env.lang, '')
        env.view_page_custom_html = get_localized_message(
            env.config.view_page_custom_htmls, env.lang, '')
        env.seek_query_form_custom_html = get_localized_message(
            env.config.seek_query_form_custom_htmls, env.lang, '')
        env.footer_custom_html = get_localized_message(
            env.config.footer_custom_htmls, env.lang, '')
        # If the repository is deactivated, we should not show test mode
        # notification.
        env.repo_test_mode = (
            env.config.test_mode and not env.config.deactivated)
        env.force_https = env.config.force_https

        env.params_full_name = request.get('full_name', '').strip()
        if not env.params_full_name:
            # Preformat the name from 'given_name' and 'family_name' parameters.
            given_name = request.get('given_name', '').strip()
            family_name = request.get('family_name', '').strip()
            env.params_full_name = utils.get_full_name(
                given_name, family_name, env.config)

    return env

def flush_caches(*keywords):
    """"""Flushes the specified set of caches.  Pass '*' to flush everything.""""""
    if '*' in keywords or 'resource' in keywords:
       resources.clear_caches()
    if '*' in keywords or 'memcache' in keywords:
       memcache.flush_all()
    if '*' in keywords or 'config' in keywords:
       config.cache.flush()
    for keyword in keywords:
        if keyword.startswith('config/'):
            config.cache.delete(keyword[7:])


class Main(webapp.RequestHandler):
    """"""The main request handler.  All dynamic requests except for remote_api are
    handled by this handler, which dispatches to all other dynamic handlers.""""""

    def initialize(self, request, response):
        webapp.RequestHandler.initialize(self, request, response)

        # If requested, set the clock before doing anything clock-related.
        # Only works on localhost for testing.  Specify ?utcnow=1293840000 to
        # set the clock to 2011-01-01, or ?utcnow=real to revert to real time.
        utcnow = request.get('utcnow')
        if request.remote_addr == '127.0.0.1' and utcnow:
            if utcnow == 'real':
                utils.set_utcnow_for_test(None)
            else:
                utils.set_utcnow_for_test(float(utcnow))

        # If requested, flush caches before we touch anything that uses them.
        # This is used for certain tests.
        if utils.is_dev_app_server():
            flush_caches(*request.get('flush', '').split(','))

        # Gather commonly used information into self.env.
        self.env = setup_env(request)

        # Force a redirect if requested, except where https is not supported:
        # - for cron jobs
        # - for task queue jobs
        # - in development
        if (self.env.force_https and self.env.scheme == 'http'
            and not is_cron_task(self.request)
            and not is_task_queue_task(self.request)
            and not is_development_server()):
            self.redirect(self.env.url.replace('http:', 'https:'))

        # Activate the selected language.
        response.headers['Content-Language'] = self.env.lang
        response.headers['Set-Cookie'] = \
            'django_language=%s; path=/' % self.env.lang
        django_setup.activate(self.env.lang)

        # Activate the appropriate resource bundle.
        resources.set_active_bundle_name(self.env.resource_bundle)

    def should_serve_react_ui(self):
        for path_prefix in NON_REACT_UI_PATHS:
            if self.env.action.startswith(path_prefix):
                return False
        return True

    def set_content_security_policy(self):
        """"""Sets the CSP in the headers. Returns the nonce to use for scripts.""""""
        csp_nonce = utils.generate_random_key(20)
        csp_value = (
            'object-src \'none\'; '
            'script-src \'nonce-%s\' \'unsafe-inline\' '
            '\'strict-dynamic\' https: http:; '
            'base-uri \'none\';'
        ) % csp_nonce
        self.response.headers['Content-Security-Policy'] = csp_value
        return csp_nonce

    def serve(self):
        request, response, env = self.request, self.response, self.env

        # If the Person Finder instance has not been initialized yet,
        # prepend to any served page a warning and a link to the admin
        # page where the datastore can be initialized.
        if not env.config.get('initialized'):
            if request.get('operation') == 'setup_datastore':
                setup_pf.setup_datastore()
                self.redirect(env.global_url + '/')
                return
            else:
                get_vars = lambda: {'env': env}
                content = resources.get_rendered('setup_datastore.html', env.lang,
                        (env.repo, env.charset), get_vars)
                response.out.write(content)

        if env.config.get('enable_react_ui'):
            # TODO(nworden): serve static files from /global/static
            if env.repo == 'static':
                self.serve_static_content(self.env.action)
            elif self.should_serve_react_ui():
                csp_nonce = self.set_content_security_policy()
                response.out.write(
                    resources.get_rendered(
                        'react_index.html', env.lang,
                        get_vars=lambda: {'env': env, 'csp_nonce': csp_nonce}))
                return

        if not env.action and not env.repo:
            # A request for the root path ('/'). Renders the home page.
            self.serve_static_content(HOME_ACTION)
        elif env.action in HANDLER_CLASSES:
            # Dispatch to the handler for the specified action.
            module_name, class_name = HANDLER_CLASSES[env.action].split('.')
            handler = getattr(__import__(module_name), class_name)(
                request, response, env)
            getattr(handler, request.method.lower())()  # get() or post()
        elif env.action.endswith('.template'):
            # Don't serve template source code.
            response.set_status(404)
            response.out.write('Not found')
        else:
            self.serve_static_content(self.env.action)

    def serve_static_content(self, resource_name):
        """"""Serve a static page or file in app/resources/static directory.""""""
        response, env = self.response, self.env
        env.robots_ok = True
        get_vars = lambda: {'env': env, 'config': env.config}
        content = resources.get_rendered(
            'static/%s' % resource_name,
            env.lang,
            (env.repo, env.charset),
            get_vars)
        if content is None:
            response.set_status(404)
            response.out.write('Not found')
        else:
            content_type, encoding = mimetypes.guess_type(resource_name)
            response.headers['Content-Type'] = (
                    (content_type or 'text/plain') +
                    ('; charset=%s' % encoding if encoding else ''))
            response.out.write(content)

    def get(self):
        self.serve()

    def post(self):
        self.serve()

    def head(self):
        self.request.method = 'GET'
        self.serve()
        self.response.clear()

if __name__ == '__main__':
    webapp.util.run_wsgi_app(webapp.WSGIApplication([('.*', Main)]))
/n/n/napp/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""URL routing module.""""""

from django.conf import urls

import site_settings
import tasksmodule.deletion
import tasksmodule.sitemap_ping
import views.admin.api_keys
import views.admin.create_repo
import views.admin.delete_record
import views.admin.statistics
import views.meta.sitemap

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [
    ('admin_apikeys-list', r'(?P<repo>[^\/]+)/admin/api_keys/list/?',
     views.admin.api_keys.ApiKeyListView.as_view),
    ('admin_apikeys-manage', r'(?P<repo>[^\/]+)/admin/api_keys/?',
     views.admin.api_keys.ApiKeyManagementView.as_view),
    ('admin_create-repo', r'global/admin/create_repo/?',
     views.admin.create_repo.AdminCreateRepoView.as_view),
    ('admin_delete-record', r'(?P<repo>[^\/]+)/admin/delete_record/?',
     views.admin.delete_record.AdminDeleteRecordView.as_view),
    ('admin_statistics', r'global/admin/statistics/?',
     views.admin.statistics.AdminStatisticsView.as_view),
    ('meta_sitemap', r'global/sitemap/?',
     views.meta.sitemap.SitemapView.as_view),
    ('tasks_process-expirations',
     r'(?P<repo>[^\/]+)/tasks/process_expirations/?',
     tasksmodule.deletion.ProcessExpirationsTask.as_view),
    ('tasks_cleanup-stray-notes',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_notes/?',
     tasksmodule.deletion.CleanupStrayNotesTask.as_view),
    ('tasks_cleanup-stray-subscriptions',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_subscriptions/?',
     tasksmodule.deletion.CleanupStraySubscriptionsTask.as_view),
    ('tasks_sitemap-ping', r'global/tasks/sitemap_ping/?',
     tasksmodule.sitemap_ping.SitemapPingTaskView.as_view),
]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^%s$' % path_exp, view_func(), name=name)
    for (name, path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^%(prefix)s/%(path)s$' % {
                'prefix': site_settings.OPTIONAL_PATH_PREFIX,
                'path': path_exp
            },
            view_func(),
            name='prefixed__%s' % name)
        for (name, path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/napp/views/admin/delete_record.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""The admin delete-record page.

No deleting is done from this page itself; it's just a way to skip the captcha
on the user-facing deletion page.
""""""

import django.shortcuts

import const
import reveal
import utils
import views.admin.base


class AdminDeleteRecordView(views.admin.base.AdminBaseView):
    """"""The admin delete-record view.""""""

    ACTION_ID = 'admin/delete_record'

    def setup(self, request, *args, **kwargs):
        super(AdminDeleteRecordView, self).setup(request, *args, **kwargs)

    def get_params(self):
        return views.base.read_params(
            super(AdminDeleteRecordView, self).get_params(),
            self.request,
            post_params={'id': utils.strip})

    def get(self, request, *args, **kwargs):
        """"""Serves GET requests with the deletion form.""""""
        del request, args, kwargs  # unused
        return self.render(
            'admin_delete_record.html',
            id='%s/person.' % const.HOME_DOMAIN,
            xsrf_token=self.xsrf_tool.generate_token(self.env.user.user_id(),
                                                     self.ACTION_ID))

    def post(self, request, *args, **kwargs):
        """"""Sends the user to the deletion page with a valid signature.""""""
        del request, args, kwargs  # unused
        self.enforce_xsrf(self.ACTION_ID)
        action = ('delete', self.params.id)
        path = '/delete?' + utils.urlencode(
            {'id': self.params.id,
             'signature': reveal.sign(action),})
        return django.shortcuts.redirect(
            self.build_absolute_uri(path, self.env.repo))
/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    class Env(object):
        """"""Class to store environment information used by views and templates.

        Subclasses of BaseView may define their own Env class (which must be
        subclasses of BaseView.Env); that Env class (as long as it's called
        ""Env"") will be used automatically when the env is set up.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # pylint: disable=too-many-instance-attributes

        @property
        def action(self):
            """"""Gets the action ID, an identifier for the page being served.""""""
            return self._action

        @action.setter
        def action(self, value):
            self._action = value

        @property
        def charset(self):
            """"""Gets the character encoding being used to serve the page.""""""
            return self._charset

        @charset.setter
        def charset(self, value):
            self._charset = value

        @property
        def config(self):
            """"""Gets the config, a config.Config object for the repository.""""""
            return self._config

        @config.setter
        def config(self, value):
            self._config = value

        @property
        def enable_javascript(self):
            ""Gets whether or not to enable JavaScript."" """"
            return self._enable_javascript

        @enable_javascript.setter
        def enable_javascript(self, value):
            self._enable_javascript = value

        @property
        def global_url(self):
            """"""Gets the URL for the global root.""""""
            return self._global_url

        @global_url.setter
        def global_url(self, value):
            self._global_url = value

        @property
        def lang(self):
            """"""Gets the code for the language being used (see const.py).""""""
            return self._lang

        @lang.setter
        def lang(self, value):
            self._lang = value

        @property
        def repo(self):
            """"""Gets the repository ID, or None if it's a global page.""""""
            return self._repo

        @repo.setter
        def repo(self, value):
            self._repo = value

        @property
        def rtl(self):
            """"""Gets whether the language is a right-to-left language.""""""
            return self._rtl

        @rtl.setter
        def rtl(self, value):
            self._rtl = value

        @property
        def show_logo(self):
            """"""Gets whether or not to show the logo in the header.""""""
            return self._show_logo

        @show_logo.setter
        def show_logo(self, value):
            self._show_logo = value

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = self.get_params()

        # Set up env variable with data needed by the whole app.
        self.env = self.Env()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def get_params(self):
        """"""Gets parameter values out of the request.

        Subclasses that need additional values should override this function,
        with an implementation like this:
        return views.base.read_params(
            super(<Subclass>, self).get_params(),
            self.request,
            get_params={'x': validate_x, 'y': validate_y,},
            post_params={'z': validate_z})

        Returns:
            utils.Struct: A container with the values of CGI parameters used by
            this view.
        """"""
        return read_params(
            utils.Struct(), self.request, get_params={'lang': utils.strip})

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None, repo=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.
            repo (str, optional): A repo ID. If specified, the path will be
                considered relative to the repo's route. If this is specified,
                path must also be specified.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            assert not repo
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if repo:
            path = '/%s%s' % (repo, path)
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None, repo=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.
            repo (str, optional): A repo ID. If specified, the path will be
                considered relative to the repo's route. If this is specified,
                path must also be specified.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(
            self.build_absolute_path(path, repo))

    def render(self, template_name, status_code=200, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            template_vars['csp_nonce'] = self.request.csp_nonce
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0),
            status=status_code)

    def error(self, status_code, message=''):
        """"""Returns an error response.

        Args:
            status_code (int): The HTTP status code to use.
            message (str, optional): A message to display. Defaults to the empty
                string.

        Returns:
            HttpResponse: An HTTP response with the given status code and
            message.
        """"""
        # pylint: disable=no-self-use
        # Making this a method of BaseView keeps it consistent with render(),
        # and probably other similar functions in the future.
        return django.http.HttpResponse(
            content=message, content_type='text/plain', status=status_code)

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view


def read_params(container,
                request,
                get_params=None,
                post_params=None,
                file_params=None):
    """"""Reads CGI parameter values from the request to the container.

    Args:
        container (utils.Struct): The container to put parameter values in.
        request (HttpRequest): The request to read from.
        get_params (dict): A dictionary from GET parameter keys to validator
            functions.
        post_params (dict): A dictionary from POST parameter keys to validator
            functions.
        file_params (dict): A dictionary from POST parameter keys for uploaded
            files to validator functions.

    Returns:
        utils.Struct: The container, for convenience.
    """"""
    if request.method == 'GET':
        if get_params:
            for key, validator in get_params.items():
                if key in request.GET:
                    setattr(container, key, validator(request.GET[key]))
    elif request.method == 'POST':
        if post_params:
            for key, validator in post_params.items():
                if key in request.POST:
                    setattr(container, key, validator(request.POST[key]))
        if file_params:
            for key, validator in file_params.items():
                if key in request.FILES:
                    setattr(container, key, validator(request.FILES[key]))
    return container
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_delete-record': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/ntests/views/test_admin_delete_record.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Tests for the admin delete-record page.""""""

import datetime

import django
import django.http
import django.test
import six.moves.urllib.parse as urlparse

# pylint: disable=wrong-import-order
# pylint sometimes thinks config is a standard import that belongs before the
# django import. It's mistaken; config is our own module (if you run
# python -c ""import config"", it produces an error saying config doesn't exist).
# Filed issue #626 to move us out of the global namespace someday, which would
# prevent stuff like this.
import config
import const
import model

import view_tests_base


class AdminDeleteRecordViewTests(view_tests_base.ViewTestsBase):
    """"""Tests the admin delete-record view.""""""

    def setUp(self):
        super(AdminDeleteRecordViewTests, self).setUp()
        self.login(is_admin=True)
        self.data_generator.repo()
        self.person = self.data_generator.person()

    def test_get(self):
        """"""Tests GET requests.""""""
        res = self.client.get('/global/admin/delete_record/', secure=True)
        self.assertEqual(res.context['id'], '%s/person.' % const.HOME_DOMAIN)

    def test_post(self):
        """"""Tests POST requests to delete a record.""""""
        get_doc = self.to_doc(self.client.get(
            '/global/admin/delete_record/', secure=True))
        xsrf_token = get_doc.cssselect_one('input[name=""xsrf_token""]').get(
            'value')
        post_resp = self.client.post('/haiti/admin/delete_record/', {
            'xsrf_token': xsrf_token,
            'id': self.person.record_id,
        }, secure=True)
        # Check that the user's redirected to the repo's main admin page.
        self.assertIsInstance(post_resp, django.http.HttpResponseRedirect)
        parse = urlparse.urlparse(post_resp.url)
        self.assertEqual('/haiti/delete', parse.path)
        query_params = dict(urlparse.parse_qsl(parse.query))
        self.assertEqual(query_params['id'], self.person.record_id)
        # Check that the signature param is present and not the empty string.
        self.assertTrue(len(query_params['signature']) > 1)
/n/n/n",0
27,5bd28a262e274d24cf802ed6051e6880c7033452,"/app/admin_delete_record.py/n/n#!/usr/bin/python2.7
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from const import *
from model import *
from utils import *
import reveal


class Handler(BaseHandler):
    """"""An admin page to delete person records.""""""

    # After a repository is deactivated, we still need the admin page to be
    # accessible so we can edit its settings.
    ignore_deactivation = True

    repo_required = False
    admin_required = True

    def get(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        self.render(
            'admin_delete_record.html',
            id=self.env.domain + '/person.',
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_delete_record'))

    def post(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                    self.params.xsrf_token, user.user_id(),
                    'admin_delete_record')):
            self.error(403)
            return False
        # Redirect to the deletion handler with a valid signature.
        action = ('delete', str(self.params.id))
        self.redirect('/delete', id=self.params.id,
                      signature=reveal.sign(action))
/n/n/n",1
28,89bf68c6f62362e29467a2ed22eb2b477268eef8,"app/utils.py/n/n#!/usr/bin/python2.7
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'

import calendar
import copy
from datetime import datetime, timedelta
import hmac
import httplib
import logging
import os
import random
import re
import string
import sys
import time
import traceback
import unicodedata
import urllib
import urlparse
import base64

from django.core.validators import EmailValidator, URLValidator, ValidationError
import django.utils.html
from django.utils.translation import ugettext as _
from django.template.defaulttags import register
from google.appengine.api import images
from google.appengine.api import taskqueue
from google.appengine.api import users
from google.appengine.ext import webapp
import google.appengine.ext.webapp.template
import google.appengine.ext.webapp.util
import recaptcha.client.captcha
from babel.dates import format_date
from babel.dates import format_datetime
from babel.dates import format_time
import babel

import const
import config
import model
import pfif
import resources

# The domain name from which to send e-mail.
EMAIL_DOMAIN = 'appspotmail.com'  # All apps on appspot.com use this for mail.

# Query parameters which are automatically preserved on page transition
# if you use utils.BaseHandler.get_url() or
# env.hidden_input_tags_for_preserved_query_params.
PRESERVED_QUERY_PARAM_NAMES = ['ui', 'charsets', 'referrer']

@register.filter
def get_value(dictionary, key):
    """"""Django Template filter to get dictionary value based on the given key""""""
    return dictionary.get(key)

# ==== Field value text ========================================================


def get_person_sex_text(person):
    """"""Returns the UI text for a person's sex field.""""""
    return const.PERSON_SEX_TEXT.get(person.sex or '')


def get_note_status_text(note):
    """"""Returns the UI text for a note's status field.""""""
    return const.NOTE_STATUS_TEXT.get(note.status or '')


def get_person_status_text(person):
    """"""Returns the UI text for a person's latest_status.""""""
    return const.PERSON_STATUS_TEXT.get(person.latest_status or '')


# Things that occur as prefixes of global paths (i.e. no repository name).
GLOBAL_PATH_RE = re.compile(r'^/(global|personfinder)(/?|/.*)$')


# ==== String formatting =======================================================


def format_boolean(value):
    return value and 'true' or 'false'


def format_utc_datetime(dt):
    if not dt:
        return ''
    return dt.replace(microsecond=0).isoformat() + 'Z'


def format_utc_timestamp(timestamp):
    if not isinstance(timestamp, (int, float)):
        return ''
    return format_utc_datetime(datetime.utcfromtimestamp(timestamp))


def format_sitemaps_datetime(dt):
    integer_dt = datetime(
        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
    return integer_dt.isoformat() + '+00:00'


def encode(string, encoding='utf-8'):
    """"""If unicode, encode to encoding; if 8-bit string, leave unchanged.""""""
    if isinstance(string, unicode):
        string = string.encode(encoding)
    return string


def urlencode(params, encoding='utf-8'):
    """"""Encode the key-value pairs in 'params' into a query string, applying
    the specified encoding to any Unicode strings and ignoring any keys that
    have value == None.  (urllib.urlencode doesn't support Unicode).""""""
    keys = params.keys()
    keys.sort()  # Sort the keys to get canonical ordering
    return urllib.urlencode([
        (encode(key, encoding), encode(params[key], encoding))
        for key in keys if isinstance(params[key], basestring)])


def set_param(params, param, value):
    """"""Take the params from a urlparse and override one of the values.""""""
    # This will strip out None-valued params and collapse repeated params.
    params = dict(urlparse.parse_qsl(params))
    if value is None:
        if param in params:
            del(params[param])
    else:
        params[param] = value
    return urlencode(params)


def set_url_param(url, param, value):
    """"""This modifies a URL setting the given param to the specified value.  This
    may add the param or override an existing value, or, if the value is None,
    it will remove the param.  Note that value must be a basestring and can't be
    an int, for example.""""""
    url_parts = list(urlparse.urlparse(url))
    url_parts[4] = set_param(url_parts[4], param, value)
    return urlparse.urlunparse(url_parts)


def anchor_start(href):
    """"""Returns the HREF escaped and embedded in an anchor tag.""""""
    return '<a href=""%s"">' % django.utils.html.escape(href)


def anchor(href, body):
    """"""Returns a string anchor HTML element with the given href and body.""""""
    return anchor_start(href) + django.utils.html.escape(body) + '</a>'


# ==== Validators ==============================================================

# These validator functions are used to check and parse query parameters.
# Each validator should return a parsed, sanitized value, or return a default
# value, or raise ValueError to display an error message to the user.


def strip(string):
    # Trailing nulls appear in some strange character encodings like Shift-JIS.
    return string.strip().rstrip('\0')


def strip_and_lower(string):
    return strip(string).lower()


def validate_yes(string):
    return (strip(string).lower() == 'yes') and 'yes' or ''


def validate_checkbox(string):
    return (strip(string).lower() == 'on') and 'yes' or ''


def validate_checkbox_as_bool(val):
    if val.lower() in ['on', 'yes', 'true']:
        return True
    return False


def validate_role(string):
    return (strip(string).lower() == 'provide') and 'provide' or 'seek'


def validate_int(string):
    return string and int(strip(string))


def validate_sex(string):
    """"""Validates the 'sex' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.PERSON_SEX_VALUES and string or ''


def validate_expiry(value):
    """"""Validates that the 'expiry_option' parameter is a positive integer.

    Returns:
      the int() value if it's present and parses, or the default_expiry_days
      for the repository, if it's set, otherwise -1 which represents the
      'unspecified' status.
    """"""
    try:
        value = int(value)
    except Exception, e:
        return None
    return value > 0 and value or None


APPROXIMATE_DATE_RE = re.compile(r'^\d{4}(-\d\d)?(-\d\d)?$')


def validate_approximate_date(string):
    if string:
        string = strip(string)
        if APPROXIMATE_DATE_RE.match(string):
            return string
    return ''


AGE_RE = re.compile(r'^(\d+)(-(\d+))?$')
# Hyphen with possibly surrounding whitespaces.
HYPHEN_RE = re.compile(
    ur'\s*[-\u2010-\u2015\u2212\u301c\u30fc\ufe58\ufe63\uff0d]\s*',
    re.UNICODE)


def validate_age(string):
    """"""Validates the 'age' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string)
        string = unicodedata.normalize('NFKC', unicode(string))
        string = HYPHEN_RE.sub('-', string)
        if AGE_RE.match(string):
            return string
    return ''


def validate_status(string):
    """"""Validates an incoming status parameter, returning one of the canonical
    status strings or ''.  Note that '' is always used as the Python value
    to represent the 'unspecified' status.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.NOTE_STATUS_VALUES and string or ''


DATETIME_RE = re.compile(r'^(2\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z$')


def validate_datetime(string):
    if not string:
        return None  # A missing value is okay.
    match = DATETIME_RE.match(string)
    if match:
        return datetime(*map(int, match.groups()))
    raise ValueError('Bad datetime: %r' % string)


def validate_timestamp(string):
    try:
        return string and datetime.utcfromtimestamp(float(strip(string)))
    except:
        raise ValueError('Bad timestamp: %s' % string)


def validate_image(bytestring):
    try:
        image = None
        if bytestring:
            image = images.Image(bytestring)
            image.width
        return image
    except:
        return False


EMAIL_VALIDATOR = EmailValidator()


def validate_email(email):
    """"""Validates an email address, returning True on correct,
    False on incorrect, None on empty string.""""""
    # Note that google.appengine.api.mail.is_email_valid() is unhelpful;
    # it checks only for the empty string
    if not email:
        return None
    try:
        EMAIL_VALIDATOR(email)
        return True
    except ValidationError:
        return False


def validate_version(string):
    """"""Version, if present, should be in pfif versions.""""""
    if string and strip(string) not in pfif.PFIF_VERSIONS:
        raise ValueError('Bad pfif version: %s' % string)
    return pfif.PFIF_VERSIONS[strip(string) or pfif.PFIF_DEFAULT_VERSION]


REPO_RE = re.compile('^[a-z0-9-]+$')


def validate_repo(string):
    string = (string or '').strip()
    if not string:
        return None
    if string == 'global':
        raise ValueError('""global"" is an illegal repository name.')
    if REPO_RE.match(string):
        return string
    raise ValueError('Repository names can only contain '
                     'lowercase letters, digits, and hyphens.')


RESOURCE_NAME_RE = re.compile('^[a-z0-9._-]+$')


def validate_resource_name(string):
    """"""A resource name or bundle label.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if RESOURCE_NAME_RE.match(string):
        return string
    raise ValueError('Invalid resource name or bundle name: %r' % string)


LANG_RE = re.compile('^[A-Za-z0-9-]+$')


def validate_lang(string):
    """"""A BCP 47 language tag.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if LANG_RE.match(string):
        return string
    raise ValueError('Invalid language tag: %r' % string)


def validate_cache_seconds(string):
    """"""A number of seconds to cache a Resource in RAM.""""""
    string = (string or '').strip()
    if string:
        return float(string)
    return 1.0


# ==== Fuzzification functions =================================================

# The range should be no more specific than a five year period.
MIN_AGE_RANGE = 5

def fuzzify_age(value):
    """"""Fuzzifies the age value for privacy.

    Args:
        value: a PFIF-compliant age value (a number or range, e.g., 45-49).

    Returns:
        A range of at least five years that includes the given value, or None if
        the input value is None or invalid.
    """"""
    if not value:
        return None
    parse = AGE_RE.match(value)
    if not parse:
        return None
    range_start = int(parse.group(1))
    range_end = int(parse.group(3)) if parse.group(3) else None
    if not range_end:
        # If no range was given, use a round five years around the given age.
        range_start -= range_start % MIN_AGE_RANGE
        return '%d-%d' % (range_start, range_start + MIN_AGE_RANGE)
    if (range_end - range_start) >= MIN_AGE_RANGE:
        # If the range we were given is already acceptably wide, leave it as-is.
        return value
    # If we were given too specific a range, pad it out to a round five year
    # range.
    range_start -= range_start % MIN_AGE_RANGE
    range_end += MIN_AGE_RANGE - ((range_end) % MIN_AGE_RANGE)
    return '%d-%d' % (range_start, range_end)


# ==== Other utilities =========================================================


def get_app_name():
    """"""Canonical name of the app, without HR s~ nonsense.  This only works in
    the context of the appserver (eg remote_api can't use it).""""""
    from google.appengine.api import app_identity
    return app_identity.get_application_id()


def sanitize_urls(record):
    """"""Clean up URLs to protect against XSS.

    We check URLs submitted through Person Finder, but bad data might come in
    through the API.
    """"""
    url_validator = URLValidator(schemes=['http', 'https'])
    # Single-line URLs.
    for field in ['photo_url', 'source_url']:
        url = getattr(record, field, None)
        if not url:
            continue
        try:
            url_validator(url)
        except ValidationError:
            setattr(record, field, None)
    # Multi-line URLs.
    for field in ['profile_urls']:
        urls = (getattr(record, field, None) or '').splitlines()
        sanitized_urls = []
        for url in urls:
            if url:
                try:
                    url_validator(url)
                    sanitized_urls.append(url)
                except ValidationError:
                    logging.warning(
                        'Unsanitary URL in database on %s' % record.record_id)
        if len(urls) != len(sanitized_urls):
            setattr(record, field, '\n'.join(sanitized_urls))


def get_host(host=None):
    host = host or os.environ['HTTP_HOST']
    """"""Return the host name, without version specific details.""""""
    parts = host.split('.')
    if len(parts) > 3:
        return '.'.join(parts[-3:])
    else:
        return host


# List of sensitive field names in person and note records.
SENSITIVE_FIELDS = [
  'date_of_birth',
  'author_email',
  'author_phone',
  'email_of_found_person',
  'phone_of_found_person',
]


def optionally_filter_sensitive_fields(records, auth=None):
    """"""Removes sensitive fields from a list of dictionaries, unless the client
    has full read authorization.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    if not (auth and auth.full_read_permission):
        filter_sensitive_fields(records)


def filter_sensitive_fields(records):
    """"""Removes sensitive fields from a list of dictionaries.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    for record in records:
        for prefix in ['', 'person_', 'note_']:
            for field in SENSITIVE_FIELDS:
                prefixed_field = prefix + field
                if prefixed_field in record:
                    record[prefixed_field] = ''


def join_person_and_note_record(person_record, note_record):
    """"""Join a person record and a note record into a single dictionary.

    The field names are prefixed with 'person_' or 'note_' to avoid name
    collision. note_record can be None. In that case, person record field
    names are still prefixed.

    Args:
        person_record (dict): A dictionary representation of a person record.
            Cannot be None.
        note_record (dict): A dictionary representation of a note record for
            the person. Can be None.
    """"""
    joined_record = {}
    for name, value in person_record.iteritems():
        new_name = get_field_name_for_joined_record(name, 'person')
        joined_record[new_name] = value
    if note_record:
        assert (note_record['person_record_id'] ==
                person_record['person_record_id'])
        for name, value in note_record.iteritems():
            new_name = get_field_name_for_joined_record(name, 'note')
            joined_record[new_name] = value
    return joined_record


def get_field_name_for_joined_record(original_field_name, record_type):
    """"""Converts a field name in a person/note record into a field name used in
    a joined record of a person and a note.

    See also join_person_and_note_record().

    Args:
        original_field_name (str): A field name in a person/note record.
        record_type (str): 'person' or 'note'.
    """"""
    if original_field_name in ('person_record_id', 'note_record_id'):
        return original_field_name
    else:
        return '%s_%s' % (record_type, original_field_name)


# The current time for testing as a datetime object, or None if using real time.
_utcnow_for_test = None


def set_utcnow_for_test(now):
    """"""Sets the current time for testing purposes.  Pass in a datetime object
    or a timestamp in epoch seconds; or pass None to revert to real time.""""""
    global _utcnow_for_test
    if isinstance(now, (int, float)):
        now = datetime.utcfromtimestamp(float(now))
    _utcnow_for_test = now


def get_utcnow():
    """"""Returns the current UTC datetime (settable with set_utcnow_for_test).""""""
    global _utcnow_for_test
    return (_utcnow_for_test is None) and datetime.utcnow() or _utcnow_for_test


def get_timestamp(dt):
    """"""Converts datetime object to a float value in epoch seconds.""""""
    return calendar.timegm(dt.utctimetuple()) + dt.microsecond * 1e-6


def get_utcnow_timestamp():
    """"""Returns the current time in epoch seconds (settable with
    set_utcnow_for_test).""""""
    return get_timestamp(get_utcnow())


def log_api_action(handler, action, num_person_records=0, num_note_records=0,
                   people_skipped=0, notes_skipped=0):
    """"""Log an API action.""""""
    if handler.config and handler.config.api_action_logging:
        model.ApiActionLog.record_action(
            handler.repo, handler.params.key,
            handler.params.version.version, action,
            num_person_records, num_note_records,
            people_skipped, notes_skipped,
            handler.request.headers.get('User-Agent'),
            handler.request.remote_addr, handler.request.url)


def get_full_name(given_name, family_name, config):
    """"""Return full name string obtained by concatenating given_name and
    family_name in the order specified by config.family_name_first, or just
    given_name if config.use_family_name is False.""""""
    if config.use_family_name:
        separator = (given_name and family_name) and u' ' or u''
        if config.family_name_first:
            return separator.join([family_name, given_name])
        else:
            return separator.join([given_name, family_name])
    else:
        return given_name


def send_confirmation_email_to_record_author(
    handler, person, action, confirm_url, record_id):
    """"""Send the author an email to confirm enabling/disabling notes
    of a record.""""""
    if not person.author_email:
        return handler.error(
            400, _('No author email for record %(id)s.') % {'id' : record_id})

    # i18n: Subject line of an e-mail message confirming the author
    # wants to disable notes for this record
    if action == 'enable':
        subject = _('[Person Finder] Enable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    elif action == 'disable':
        subject = _('[Person Finder] Disable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    else:
        raise ValueError('Unknown action: %s' % action)

    # send e-mail to record author confirming the lock of this record.
    template_name = '%s_notes_email.txt' % action
    handler.send_mail(
        subject=subject,
        to=person.author_email,
        body=handler.render_to_string(
            template_name,
            author_name=person.author_name,
            full_name=person.primary_full_name,
            site_url=handler.get_url('/'),
            confirm_url=confirm_url
        )
    )


def get_repo_url(request, repo, scheme=None):
    """"""Constructs the absolute root URL for a given repository.""""""
    req_scheme, req_netloc, req_path, _, _ = urlparse.urlsplit(request.url)
    prefix = req_path.startswith('/personfinder') and '/personfinder' or ''
    if is_dev_app_server():
        scheme = 'http'  # HTTPS is not available when using dev_appserver
    return (scheme or req_scheme) + '://' + req_netloc + prefix + '/' + repo


def get_url(request, repo, action, charset='utf-8', scheme=None, **params):
    """"""Constructs the absolute URL for a given action and query parameters,
    preserving the current repo and the parameters listed in
    PRESERVED_QUERY_PARAM_NAMES.""""""
    repo_url = get_repo_url(request, repo or 'global', scheme)
    for name in PRESERVED_QUERY_PARAM_NAMES:
        params[name] = params.get(name, request.get(name, None))
    query = urlencode(params, charset)
    return repo_url + '/' + action.lstrip('/') + (query and '?' + query or '')


def add_profile_icon_url(website, handler):
    website = copy.deepcopy(website)  # avoid modifying the original
    website['icon_url'] = \
        handler.env.global_url + '/' + website['icon_filename']
    return website


def strip_url_scheme(url):
    if not url:
        return url
    _, netloc, path, query, segment = urlparse.urlsplit(url)
    return urlparse.urlunsplit(('', netloc, path, query, segment))


def is_dev_app_server():
    return os.environ['APPLICATION_ID'].startswith('dev~')

# ==== Struct ==================================================================

class Struct:
    """"""A simple bag of attributes.""""""
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def get(self, name, default=None):
        return self.__dict__.get(name, default)


# ==== Key management ======================================================

def generate_random_key(length):
    """"""Generates a random key with given length.""""""
    source = ('abcdefghijklmnopqrstuvwxyz'
              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
              '1234567890'
              '-_')
    rng = random.SystemRandom()
    return ''.join(rng.choice(source) for i in range(length))


# ==== Decorators  ============================================================

def require_api_key_management_permission(handler_method):
    """"""
    This is a decorator for API Key management feature. The limitation
    is that the decorator can not preserve payloads within a POST/PUT
    request.

    Usage:
    class SomeHandler(utils.BaseHandler):
        @utils.require_api_key_management_permission
        def get(self):
            # ....
            # ....
    """"""
    def inner(*args, **kwargs):
        handler = args[0]
        user = users.get_current_user()
        if (users.is_current_user_admin() or
            (user and handler.config.key_management_operators and
             user.email() in handler.config.key_management_operators)):
            return handler_method(*args, **kwargs)
        else:
            return handler.redirect(
                users.create_login_url(handler.request.url))
    return inner


# ==== Base Handler ============================================================

class BaseHandler(webapp.RequestHandler):
    # Handlers that don't need a repository name can set this to False.
    repo_required = True

    # Handlers that require HTTPS can set this to True.
    https_required = True

    # Set this to True to enable a handler even for deactivated repositories.
    ignore_deactivation = False

    # Handlers that require an admin permission must set this to True.
    admin_required = False

    # List all accepted query parameters here with their associated validators.
    auto_params = {
        'action': strip,
        'add_note': validate_yes,
        'age': validate_age,
        'alternate_family_names': strip,
        'alternate_given_names': strip,
        'author_email': strip,
        'author_made_contact': validate_yes,
        'author_name': strip,
        'author_phone': strip,
        'your_own_email': strip,
        'your_own_phone': strip,
        'believed_dead_permission': validate_checkbox_as_bool,
        'cache_seconds': validate_cache_seconds,
        'clone': validate_yes,
        'confirm': validate_yes,
        'contact_email': strip,
        'contact_name': strip,
        'content_id': strip,
        'context': strip,
        'cursor': strip,
        'date_of_birth': validate_approximate_date,
        'description': strip,
        'domain_write_permission': strip,
        'dupe_notes': validate_yes,
        'email_of_found_person': strip,
        'error': strip,
        'expiry_option': validate_expiry,
        'family_name': strip,
        'full_read_permission': validate_checkbox_as_bool,
        'given_name': strip,
        'home_city': strip,
        'home_country': strip,
        'home_neighborhood': strip,
        'home_postal_code': strip,
        'home_state': strip,
        'id': strip,
        'id1': strip,
        'id2': strip,
        'id3': strip,
        'is_valid': validate_checkbox_as_bool,
        'key': strip,
        'lang': validate_lang,
        'last_known_location': strip,
        'mark_notes_reviewed': validate_checkbox_as_bool,
        'max_results': validate_int,
        'min_entry_date': validate_datetime,
        'new_repo': validate_repo,
        'note_photo': validate_image,
        'note_photo_url': strip,
        'omit_notes': validate_yes,
        'operation': strip,
        'organization_name': strip,
        'person_record_id': strip,
        'phone_of_found_person': strip,
        'photo': validate_image,
        'photo_url': strip,
        'profile_url1': strip,
        'profile_url2': strip,
        'profile_url3': strip,
        'query': strip,
        'query_name': strip,
        'query_location': strip,
        'query_type': strip,
        'read_permission': validate_checkbox_as_bool,
        'referrer': strip,
        'resource_bundle': validate_resource_name,
        'resource_bundle_default': validate_resource_name,
        'resource_bundle_original': validate_resource_name,
        'resource_lang': validate_lang,
        'resource_name': validate_resource_name,
        'role': validate_role,
        'search_engine_id': validate_int,
        'search_permission': validate_checkbox_as_bool,
        'sex': validate_sex,
        'signature': strip,
        'skip': validate_int,
        'small': validate_yes,
        'source': strip,
        'source_date': strip,
        'source_name': strip,
        'source_url': strip,
        'stats_permission': validate_checkbox_as_bool,
        'status': validate_status,
        'style': strip,
        'subscribe': validate_checkbox,
        'subscribe_own_info': validate_checkbox,
        'subscribe_email': strip,
        'subscribe_permission': validate_checkbox_as_bool,
        'suppress_redirect': validate_yes,
        'target': strip,
        'text': strip,
        'thumb': validate_checkbox_as_bool,
        'timestamp': validate_timestamp,
        'ui': strip_and_lower,
        'utcnow': validate_timestamp,
        'version': validate_version,
        'own_info': validate_yes,
        'xsrf_token': strip,
    }

    def redirect(self, path, repo=None, permanent=False, **params):
        # This will prepend the repo to the path to create a working URL,
        # unless the path has a global prefix or is an absolute URL.
        if re.match('^[a-z]+:', path) or GLOBAL_PATH_RE.match(path):
            if params:
              path += '?' + urlencode(params, self.charset)
        else:
            path = self.get_url(path, repo, **params)
        return webapp.RequestHandler.redirect(self, path, permanent=permanent)

    def render(self, name, language_override=None, cache_seconds=0,
               get_vars=lambda: {}, **vars):
        """"""Renders a template to the output stream, passing in the variables
        specified in **vars as well as any additional variables returned by
        get_vars().  Since this is intended for use by a dynamic page handler,
        caching is off by default; if cache_seconds is positive, then
        get_vars() will be called only when cached content is unavailable.""""""
        self.write(self.render_to_string(
            name, language_override, cache_seconds, get_vars, **vars))

    def render_to_string(self, name, language_override=None, cache_seconds=0,
                         get_vars=lambda: {}, **vars):
        """"""Renders a template to a string, passing in the variables specified
        in **vars as well as any additional variables returned by get_vars().
        Since this is intended for use by a dynamic page handler, caching is
        off by default; if cache_seconds is positive, then get_vars() will be
        called only when cached content is unavailable.""""""
        # TODO(kpy): Make the contents of extra_key overridable by callers?
        lang = language_override or self.env.lang
        extra_key = (self.env.repo, self.env.charset, self.request.query_string)
        def get_all_vars():
            vars.update(get_vars())
            for key in ('env', 'config', 'params'):
                if key in vars:
                    raise Exception(
                        'Cannot use ""%s"" as a key in vars. It is reserved.'
                        % key)
            vars['env'] = self.env  # pass along application-wide context
            vars['config'] = self.config  # pass along the configuration
            vars['params'] = self.params  # pass along the query parameters
            return vars
        return resources.get_rendered(
            name, lang, extra_key, get_all_vars, cache_seconds)

    def error(self, code, message='', message_html=''):
        self.info(code, message, message_html, style='error')

    def info(self, code, message='', message_html='', style='info'):
        """"""Renders a simple page with a message.

        Args:
          code: HTTP status code.
          message: A message in plain text.
          message_html: A message in HTML.
          style: 'info', 'error' or 'plain'. 'info' and 'error' differs in
              appearance. 'plain' just renders the message without extra
              HTML tags. Good for API response.
        """"""
        is_error = 400 <= code < 600
        if is_error:
            webapp.RequestHandler.error(self, code)
        else:
            self.response.set_status(code)
        if not message and not message_html:
            message = '%d: %s' % (code, httplib.responses.get(code))
        if style == 'plain':
            self.__render_plain_message(message, message_html)
        else:
            try:
                self.render('message.html', cls=style,
                            message=message, message_html=message_html)
            except:
                self.__render_plain_message(message, message_html)
        self.terminate_response()

    def __render_plain_message(self, message, message_html):
        self.response.out.write(
            django.utils.html.escape(message) +
            ('<p>' if message and message_html else '') +
            message_html)

    def terminate_response(self):
        """"""Prevents any further output from being written.""""""
        self.response.out.write = lambda *args: None
        self.get = lambda *args: None
        self.post = lambda *args: None

    def write(self, text):
        """"""Sends text to the client using the charset from select_charset().""""""
        self.response.out.write(text.encode(self.env.charset, 'replace'))

    def get_url(self, action, repo=None, scheme=None, **params):
        """"""Constructs the absolute URL for a given action and query parameters,
        preserving the current repo and the parameters listed in
        PRESERVED_QUERY_PARAM_NAMES.""""""
        return get_url(self.request, repo or self.env.repo, action,
                       charset=self.env.charset, scheme=scheme, **params)

    @staticmethod
    def add_task_for_repo(repo, name, action, **kwargs):
        """"""Queues up a task for an individual repository.""""""
        task_name = '%s-%s-%s' % (repo, name, int(time.time()*1000))
        path = '/%s/%s' % (repo, action)
        taskqueue.add(name=task_name, method='GET', url=path, params=kwargs)

    def send_mail(self, to, subject, body):
        """"""Sends e-mail using a sender address that's allowed for this app.""""""
        app_id = get_app_name()
        sender = 'Do not reply <do-not-reply@%s.%s>' % (app_id, EMAIL_DOMAIN)
        logging.info('Add mail task: recipient %r, subject %r' % (to, subject))
        taskqueue.add(queue_name='send-mail', url='/global/admin/send_mail',
                      params={'sender': sender,
                              'to': to,
                              'subject': subject,
                              'body': body})

    def get_captcha_html(self, error_code=None, use_ssl=False):
        """"""Generates the necessary HTML to display a CAPTCHA validation box.""""""

        # We use the 'custom_translations' parameter for UI messages, whereas
        # the 'lang' parameter controls the language of the challenge itself.
        # reCAPTCHA falls back to 'en' if this parameter isn't recognized.
        lang = self.env.lang.split('-')[0]

        return recaptcha.client.captcha.get_display_html(
            site_key=config.get('captcha_site_key'),
            use_ssl=use_ssl, error=error_code, lang=lang
        )

    def get_captcha_response(self):
        """"""Returns an object containing the CAPTCHA response information for the
        given request's CAPTCHA field information.""""""
        # Allows faking the CAPTCHA response by an HTTP request parameter, but
        # only locally, for testing purpose.
        faked_captcha_response = self.request.get('faked_captcha_response')
        if faked_captcha_response and self.request.remote_addr == '127.0.0.1':
            return recaptcha.client.captcha.RecaptchaResponse(
                is_valid=faked_captcha_response == 'success')

        captcha_response = self.request.get('g-recaptcha-response')
        return recaptcha.client.captcha.submit(captcha_response)

    def handle_exception(self, exception, debug_mode):
        logging.error(traceback.format_exc())
        self.error(500, _(
            'There was an error processing your request.  Sorry for the '
            'inconvenience.  Our administrators will investigate the source '
            'of the problem, but please check that the format of your '
            'request is correct.'))

    def __get_env_language_for_babel(self):
        language_code = self.env.lang
        try:
            return babel.Locale.parse(language_code, sep='-')
        except babel.UnknownLocaleError as e:
            # fallback language
            return babel.Locale('en')

    def to_local_time(self, date):
        """"""Converts a datetime object to the local time configured for the
        current repository.  For convenience, returns None if date is None.""""""
        # TODO(kpy): This only works for repositories that have a single fixed
        # time zone offset and never use Daylight Saving Time.
        if date:
            if self.config.time_zone_offset:
                return date + timedelta(0, 3600*self.config.time_zone_offset)
            return date

    def format_datetime_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale.""""""
        return format_datetime(dt, locale=self.__get_env_language_for_babel());

    def format_date_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the date.""""""
        return format_date(dt, locale=self.__get_env_language_for_babel());

    def format_time_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the time.""""""
        return format_time(dt, locale=self.__get_env_language_for_babel());

    def to_formatted_local_datetime(self, dt):
        """"""Converts a datetime object to the local datetime configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_datetime_localized(dt)

    def to_formatted_local_date(self, dt):
        """"""Converts a datetime object to the local date configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_date_localized(dt)

    def to_formatted_local_time(self, dt):
        """"""Converts a datetime object to the local time configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_time_localized(dt)

    def maybe_redirect_for_repo_alias(self, request):
        """"""If the specified repository name is an alias, redirects to the URL
        with the canonical repository name and returns True. Otherwise returns
        False.
        """"""
        # Config repo_alias is a dictionary from a repository name alias to
        # its canonical.
        # e.g., {'yol': '2013-yolanda', 'jam': '2014-jammu-kashmir-floods'}
        #
        # A repository name alias can be used instead of the canonical
        # repository name in URLs. This is especially useful combined with
        # the short URL. e.g., You can access
        # https://www.google.org/personfinder/2014-jammu-kashmir-floods
        # by https://g.co/pf/jam .
        if not self.repo:
            return False
        repo_aliases = config.get('repo_aliases', default={})
        if self.repo in repo_aliases:
            canonical_repo = repo_aliases[self.repo]
            params = {}
            for name in request.arguments():
                params[name] = request.get(name)
            # Redirects to the same URL including the query parameters, except
            # for the repository name.
            self.redirect('/' + self.env.action, repo=canonical_repo, **params)
            self.terminate_response()
            return True
        else:
            return False

    def should_show_inline_photo(self, photo_url):
        """"""Returns True if we should show the photo in our site directly with
        <img> tag. Returns True only if the photo is served by our domain, to
        avoid loading resources in other domains in Person Finder.
        """"""
        if not photo_url:
            return False
        else:
            _, our_netloc, _, _, _ = urlparse.urlsplit(self.request.url)
            _, photo_netloc, _, _, _ = urlparse.urlsplit(photo_url)
            return photo_netloc == our_netloc

    URL_PARSE_QUERY_INDEX = 4

    def get_thumbnail_url(self, photo_url):
        """"""Get a thumbnail URL for an uploaded photo's URL.

        Args:
            photo_url: a photo URL for an uploaded photo
        """"""
        if not photo_url:
            return None
        parsed_url = list(urlparse.urlparse(photo_url))
        params_dict = dict(urlparse.parse_qsl(
            parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX]))
        params_dict['thumb'] = 'true'
        parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX] = urllib.urlencode(
            params_dict)
        return urlparse.urlunparse(parsed_url)

    def set_auth(self):
        self.auth = None
        if self.params.key:
            if self.repo:
                # check for domain specific one.
                self.auth = model.Authorization.get(self.repo, self.params.key)
            if not self.auth:
                # perhaps this is a global key ('*' for consistency with config).
                self.auth = model.Authorization.get('*', self.params.key)
        if self.auth and not self.auth.is_valid:
            self.auth = None

    def __return_unimplemented_method_error(self):
        return self.error(
            405,
            'HTTP method %s is not allowed for this URL.'
                % self.request.method)

    def __init__(self, request, response, env):
        webapp.RequestHandler.__init__(self, request, response)
        self.params = Struct()
        self.env = env
        self.repo = env.repo
        self.config = env.config
        self.charset = env.charset

        # Set default Content-Type header.
        self.response.headers['Content-Type'] = (
            'text/html; charset=%s' % self.charset)
        if self.admin_required:
            self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'

        # Validate query parameters.
        for name, validator in self.auto_params.items():
            try:
                value = self.request.get(name, '')
                setattr(self.params, name, validator(value))
            except Exception, e:
                setattr(self.params, name, validator(None))
                return self.error(400, 'Invalid parameter %s: %s' % (name, e))

        # Ensure referrer is in whitelist, if it exists
        if self.params.referrer and (not self.params.referrer in
                                     self.config.referrer_whitelist):
            setattr(self.params, 'referrer', '')

        # Check for SSL (unless running local dev app server).
        if self.https_required and not is_dev_app_server():
            if self.env.scheme != 'https':
                url_parts = list(urlparse.urlparse(self.request.url))
                url_parts[0] = 'https'  # The 0th part is the scheme.
                webapp.RequestHandler.redirect(
                    self, urlparse.urlunparse(url_parts))
                self.terminate_response()
                return

        # Handles repository alias.
        if self.maybe_redirect_for_repo_alias(request):
            return

        # Shows a custom error page here when the user is not an admin
        # instead of ""login: admin"" in app.yaml
        # If we use it, user can't sign out
        # because the error page of ""login: admin"" doesn't have sign-out link.
        if self.admin_required:
            self.env.user = users.get_current_user()
            if not self.env.user:
                login_url = users.create_login_url(self.request.url)
                webapp.RequestHandler.redirect(self, login_url)
                self.terminate_response()
                return
            if not users.is_current_user_admin():
                logout_url = users.create_logout_url(self.request.url)
                self.render('not_admin_error.html', logout_url=logout_url, user=user)
                self.terminate_response()
                return
            self.env.logout_url = users.create_logout_url(self.request.url)
            # This is different from env.repo_options because this contains all
            # repositories including deactivated ones.
            self.env.all_repo_options = [
                Struct(
                    repo=repo,
                    url=get_repo_url(self.request, repo) + '/admin')
                for repo in sorted(model.Repo.list())]

        # Handlers that don't need a repository configuration can skip it.
        if not self.repo:
            if self.repo_required:
                return self.error(400, 'No repository specified.')
            return
        # Everything after this requires a repo.

        # Reject requests for repositories that don't exist.
        if not model.Repo.get_by_key_name(self.repo):
            html = 'No such repository. '
            if self.env.repo_options:
                html += 'Select:<p>' + self.render_to_string('repo-menu.html')
            return self.error(404, message_html=html)

        # If this repository has been deactivated, terminate with a message.
        # The ignore_deactivation flag is for admin pages that bypass this.
        if self.config.deactivated and not self.ignore_deactivation:
            self.env.language_menu = []
            self.env.robots_ok = True
            self.render('message.html', cls='deactivation',
                        message_html=self.config.deactivation_message_html)
            self.terminate_response()

    def get(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def post(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def put(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def head(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def options(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def delete(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def trace(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()


# ==== XSRF protection =========================================================

class XsrfTool(object):

    # XSRF tokens expire after 4 hours.
    TOKEN_EXPIRATION_TIME = 60 * 60 * 4

    def __init__(self):
        configured_key = config.get('xsrf_token_key')
        if configured_key:
            # config.get returns unicode, but hmac is going to want a str
            self._key = configured_key.encode('utf-8')
        else:
            configured_key = generate_random_key(20)
            config.set(xsrf_token_key=configured_key)
            self._key = configured_key

    def generate_token(self, user_id, action_id):
        action_time = get_utcnow_timestamp()
        return '%s/%f' % (
            self._generate_hmac_digest(user_id, action_id, action_time),
            action_time)

    def verify_token(self, token, user_id, action_id):
        token_spl = token.split('/')
        if len(token_spl) != 2:
            return False
        [hmac_digest, action_time_str] = token_spl
        action_time = float(action_time_str)
        if (action_time + XsrfTool.TOKEN_EXPIRATION_TIME <
            get_utcnow_timestamp()):
            return False
        expected_hmac_digest = self._generate_hmac_digest(
            user_id, action_id, action_time)
        return hmac.compare_digest(
            hmac_digest.encode('utf-8'), expected_hmac_digest)

    def _generate_hmac_digest(self, user_id, action_id, action_time):
        hmac_obj = hmac.new(
            self._key, '%s/%s/%f' % (user_id, action_id, action_time))
        return hmac_obj.hexdigest()
/n/n/ntests/test_xsrftool.py/n/n""""""Tests for the XSRF tool.""""""

import datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):
    """"""Test cases for utils.XsrfTool.""""""

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def test_gen_and_verify_good_token(self):
        """"""Tests generating and verifying a good token.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_rejects_invalid_tokens(self):
        """"""Tests that an invalid token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        self.assertFalse(tool.verify_token(
            'ThisTokenDoesNotEvenHaveASlash', 12345, 'test_action'))
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))

    def test_rejects_expired_token(self):
        """"""Tests that an expired token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +
                                  datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def test_good_with_no_prior_key(self):
        """"""Tests a good token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_bad_with_no_prior_key(self):
        """"""Tests a bad token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_delete-record': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/ntests/views/test_auto_security.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Automatic security tests.

This file isn't meant for tests specific to a particular page; they're designed
as general-purpose tests for common security requirements. All paths must be
included in the AutoSecurityTests.PATH_TEST_INFO list (this is tested to ensure
we can't forget these tests for a new view).
""""""

import collections
import copy
import os

import django.urls

import urls

import view_tests_base


# A tuple containing configuration for automatic security tests for a path.
PathTestInfo = collections.namedtuple(
    'PathTestInfo',
    [
        # Whether the path is expected to accept GET requests.
        'accepts_get',
        # Whether the past is expected to accept POST requests.
        'accepts_post',
        # Whether the page is restricted to admins.
        'restricted_to_admins',
        # Whether POST requests should require an XSRF token.
        'requires_xsrf',
        # A dict with valid POST data, excluding an XSRF token (the tests will
        # add, or omit, the XSRF tokens). Should be None if XSRF isn't used for
        # the page.
        'sample_post_data',
        # The action ID used for XSRF tokens. Should be None if XSRF isn't used
        # for the page.
        'xsrf_action_id',
    ])


class AutoSecurityTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""
    # pylint: disable=no-self-use

    # A map from path names (defined in urls.py) to PathTestInfo tuples.
    PATH_TEST_INFO = {
        'admin_apikeys-list':
        PathTestInfo(
            accepts_get=True,
            accepts_post=False,
            restricted_to_admins=True,
            requires_xsrf=False,
            sample_post_data=None,
            xsrf_action_id=None),
        'admin_apikeys-manage':
        PathTestInfo(
            accepts_get=True,
            accepts_post=True,
            restricted_to_admins=True,
            requires_xsrf=True,
            sample_post_data={
                'contact_name': 'Bob',
                'contact_email': 'bob@fridge.com',
                'organization_name': 'Vance Refrigeration',
            },
            xsrf_action_id='admin_api_keys'),
        'admin_create-repo':
        PathTestInfo(
            accepts_get=True,
            accepts_post=True,
            restricted_to_admins=True,
            requires_xsrf=True,
            sample_post_data={
                'new_repo': 'new-hampshire',
            },
            xsrf_action_id='admin/create_repo'),
        'admin_delete-record':
        PathTestInfo(
            accepts_get=True,
            accepts_post=True,
            restricted_to_admins=True,
            requires_xsrf=True,
            sample_post_data={
                'id': 'abc123',
            },
            xsrf_action_id='admin/delete_record'),
        'admin_statistics':
        PathTestInfo(
            accepts_get=True,
            accepts_post=False,
            restricted_to_admins=True,
            requires_xsrf=False,
            sample_post_data=None,
            xsrf_action_id=None),
        'meta_sitemap':
        PathTestInfo(
            accepts_get=True,
            accepts_post=False,
            restricted_to_admins=False,
            requires_xsrf=False,
            sample_post_data=None,
            xsrf_action_id=None),
    }

    def get_path(self, path_name):
        """"""Gets a path to use for the given path name.

        Args:
            path_name (str): The path name defined in urls.py.

        This will first try to reverse the URL with no arguments, and then fall
        back to reversing it with a ""repo"" argument. If we ever have URLs with
        more interesting things in the path besides repo, we'll have to rethink
        this.
        """"""
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def get_valid_post_data(self, path_info):
        """"""Gets data for a valid POST requests.

        Generates and includes a valid XSRF token when needed.
        """"""
        if path_info.requires_xsrf:
            # Copy the data dict to avoid mutating the original.
            data = copy.deepcopy(path_info.sample_post_data)
            data['xsrf_token'] = self._xsrf_tool.generate_token(
                view_tests_base.ViewTestsBase.TEST_USER_ID,
                path_info.xsrf_action_id)
            return data
        return path_info.sample_post_data

    def get_paths_to_test(self, filter_func):
        """"""Gets paths to test based on a filter function.

        Args:
            filter_func (function): A function that accepts a PathTestInfo tuple
            and returns True or False to indicate if it should be included.

        Returns:
            list: A list of tuples with path names and PathTestInfo tuples.
        """"""
        return [(path_name, path_info)
                for (path_name,
                     path_info) in AutoSecurityTests.PATH_TEST_INFO.items()
                if filter_func(path_info)]

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.restricted_to_admins):
            path = self.get_path(path_name)
            if path_info.accepts_get:
                self.assertEqual(
                    self.client.get(path, secure=True).status_code, 403,
                    'Admin-only page available to non-admin: %s' % path_name)
            if path_info.accepts_post:
                self.assertEqual(
                    self.client.post(
                        path, self.get_valid_post_data(path_info),
                        secure=True).status_code, 403,
                    'Admin-only page available to non-admin: %s' % path_name)

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.restricted_to_admins):
            path = self.get_path(path_name)
            if path_info.accepts_get:
                self.assertEqual(
                    self.client.get(path, secure=True).status_code, 200,
                    'GET unavailable to admins for: %s' % path_name)
            # Some POST requests might return a redirect, so just ensure they
            # don't get a 403 like non-admins do.
            if path_info.accepts_post:
                self.assertNotEqual(
                    self.client.post(
                        path, self.get_valid_post_data(path_info),
                        secure=True).status_code, 403,
                    'POST unavailable to admins for: %s' % path_name)

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: not path_info.restricted_to_admins):
            path = self.get_path(path_name)
            if path_info.accepts_get:
                self.assertEqual(
                    self.client.get(path, secure=True).status_code, 200,
                    'Unrestricted page blocked to non-admin: %s' % path_name)
            if path_info.accepts_post:
                # Redirects are fine, just check that they don't get a 403.
                self.assertNotEqual(
                    self.client.post(
                        path, self.get_valid_post_data(path_info),
                        secure=True).status_code, 403,
                    'Unrestricted page blocked to non-admin: %s' % path_name)

    def test_missing_xsrf_token(self):
        """"""Tests that, if XSRF is required, POSTs without a token are rejected.
        """"""
        self.login(is_admin=True)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.requires_xsrf):
            # Just in case someone accidentally included an XSRF token in the
            # PathTestInfo tuple.
            assert 'xsrf_token' not in path_info.sample_post_data
            path = self.get_path(path_name)
            self.assertEqual(
                self.client.post(path, path_info.sample_post_data,
                                 secure=True).status_code, 403,
                'XSRF page accepts data missing XSRF token: %s' % path_name)
            post_data = copy.deepcopy(path_info.sample_post_data)
            post_data['xsrf_token'] = ''
            self.assertEqual(
                self.client.post(path, post_data, secure=True).status_code, 403,
                'XSRF page accepts data empty XSRF token: %s' % path_name)

    def test_invalid_xsrf_token(self):
        """"""Tests that XSRF tokens are checked for validity.""""""
        self.login(is_admin=True)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.requires_xsrf):
            path = self.get_path(path_name)
            post_data = copy.deepcopy(path_info.sample_post_data)
            post_data['xsrf_token'] = 'NotAValidToken'
            self.assertEqual(
                self.client.post(path, post_data, secure=True).status_code, 403,
                'XSRF page accepts data invalid XSRF token: %s' % path_name)

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip tasks; they'll be tested separately.
                continue
            assert pattern.name in AutoSecurityTests.PATH_TEST_INFO

    def test_gae_task_header_required(self):
        """"""Tests that tasks can only be called by App Engine.

        App Engine sets a special header (and strips it out of external
        requests); we use that to reject external requests to task handlers.
        """"""
        # Set this to a non-dev ID, because we permit non-GAE requests in dev.
        os.environ['APPLICATION_ID'] = 'prod-app'
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if not pattern.name.startswith('tasks_'):
                # Skip views that aren't task handlers; they're tested
                # elsewhere.
                continue
            path = self.get_path(pattern.name)
            assert self.client.get(path, secure=True).status_code == 403
/n/n/ntests/views/view_tests_base.py/n/n""""""Tools to help run tests against the Django app.""""""

import const
import utils

import scrape
import testutils.base


class ViewTestsBase(testutils.base.ServerTestsBase):
    """"""A base class for tests for the Django app.""""""

    TEST_USER_EMAIL = 'kay@mib.gov'
    TEST_USER_ID = 'k'

    def setUp(self):
        super(ViewTestsBase, self).setUp()
        self._xsrf_tool = utils.XsrfTool()

    def login(self, is_admin=False):
        """"""Logs in the ""user"" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """"""
        self.testbed.setup_env(
            user_email=ViewTestsBase.TEST_USER_EMAIL,
            user_id=ViewTestsBase.TEST_USER_ID,
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(
            ViewTestsBase.TEST_USER_ID, action_id)

    def to_doc(self, response):
        """"""Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """"""
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)
/n/n/n",0
29,89bf68c6f62362e29467a2ed22eb2b477268eef8,"/tests/test_xsrftool.py/n/n""""""Tests for the XSRF tool.""""""

import datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):
    """"""Test cases for utils.XsrfTool.""""""

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def test_gen_and_verify_good_token(self):
        """"""Tests generating and verifying a good token.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_rejects_invalid_token(self):
        """"""Tests that an invalid token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))

    def test_rejects_expired_token(self):
        """"""Tests that an expired token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +
                                  datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def test_good_with_no_prior_key(self):
        """"""Tests a good token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_bad_with_no_prior_key(self):
        """"""Tests a bad token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))
/n/n/n/tests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_delete-record': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/n/tests/views/view_tests_base.py/n/n""""""Tools to help run tests against the Django app.""""""

import const
import utils

import scrape
import testutils.base


class ViewTestsBase(testutils.base.ServerTestsBase):
    """"""A base class for tests for the Django app.""""""

    _USER_ID = 'k'

    def setUp(self):
        super(ViewTestsBase, self).setUp()
        self._xsrf_tool = utils.XsrfTool()

    def login(self, is_admin=False):
        """"""Logs in the ""user"" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """"""
        self.testbed.setup_env(
            user_email='kay@mib.gov',
            user_id=ViewTestsBase._USER_ID,
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)

    def to_doc(self, response):
        """"""Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """"""
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)
/n/n/n",1
30,75cf3c0885faa5fa19819b7d83d5bbe120a47fe3,"LikedSavedDownloaderServer.py/n/n#!/usr/bin/env python

import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.httpclient
import tornado.gen

import os
import random
import shutil
import json
import multiprocessing

from utilities import sort_naturally
import settings
import redditUserImageScraper

# Require a username and password in order to use the web interface. See ReadMe.org for details.
enable_authentication = False
#enable_authentication = True

if enable_authentication:
    import PasswordManager

# List of valid user ids (used to compare user cookie)
authenticated_users = []

videoExtensions = ('.mp4', '.webm')
supportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')

savedImagesCache = []
def generateSavedImagesCache(outputDir):
    global savedImagesCache
    # Clear cache in case already created
    savedImagesCache = []

    print('Creating Liked Saved cache...')
    
    for root, dirs, files in os.walk(outputDir):
        for file in files:
            if file.endswith(supportedExtensions):
                savedImagesCache.append(os.path.join(root, file))

    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))

def outputPathToServerPath(path):
    # This is a little weird
    return 'output' + path.split(settings.settings['Output_dir'])[1]

def getRandomImage(filteredImagesCache=None, randomImageFilter=''):
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])

    if filteredImagesCache:
        randomImage = random.choice(filteredImagesCache)
    else:
        randomImage = random.choice(savedImagesCache)

    print('\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))

    serverPath = outputPathToServerPath(randomImage)

    return randomImage, serverPath

#
# Tornado handlers
#

# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py
# https://www.tornadoweb.org/en/stable/guide/security.html

def login_get_current_user(handler):
    if enable_authentication:
        cookie = handler.get_secure_cookie(""user"")
        if cookie in authenticated_users:
            return cookie
        else:
            print(""Bad/expired cookie received"")
            return None
    else:
        return ""authentication_disabled""

class AuthHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
class LoginHandler(AuthHandler):
    def get(self):
        if not enable_authentication:
            self.redirect(""/"")
        else:
            self.write('<html>'
                       '<head>'
	               '<title>Liked Saved Downloader</title>'
	               '<link rel=""stylesheet"" type=""text/css"" href=""webInterfaceNoAuth/index.css"">'
                       '</head>'
                       '<body><h1>Login Required</h1>'
                       '<form action=""/login"" method=""post"">'
                       'Name: <input type=""text"" name=""name""><br />'
                       'Password: <input type=""password"" name=""password"">'
                       '{}'
                       '<br /><input type=""submit"" value=""Sign in"">'
                       '</form></body></html>'.format(self.xsrf_form_html()))

    def post(self):
        global authenticated_users
        # Test password
        if enable_authentication and PasswordManager.verify(self.get_argument(""password"")):
            # Generate new authenticated user session
            randomGenerator = random.SystemRandom()
            cookieSecret = str(randomGenerator.getrandbits(128))
            authenticated_user = self.get_argument(""name"") + ""_"" + cookieSecret
            authenticated_user = authenticated_user.encode()
            authenticated_users.append(authenticated_user)
            
            # Set the cookie on the user's side
            self.set_secure_cookie(""user"", authenticated_user)
            
            print(""Authenticated user {}"".format(self.get_argument(""name"")))
            
            # Let them in
            self.redirect(""/"")
        else:
            print(""Refused user {} (password doesn't match any in database)"".format(self.get_argument(""name"")))
            self.redirect(""/login"")
            
class LogoutHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        global authenticated_users
        
        if enable_authentication:
            print(""User {} logging out"".format(self.current_user))
            if self.current_user in authenticated_users:
                authenticated_users.remove(self.current_user)
            self.redirect(""/login"")
        else:
            self.redirect(""/"")

class AuthedStaticHandler(tornado.web.StaticFileHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
    @tornado.web.authenticated
    def prepare(self):
        pass

class HomeHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        self.render('webInterface/index.html')

def settingsToHtmlForm():
    settingsInputs = []

    for sectionSettingsPair in settings.settingsStructure:
        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))

        for sectionOption in sectionSettingsPair[1]:
            option = None
            optionComment = ''
            if type(sectionOption) == tuple:
                option = sectionOption[0]
                optionComment = '<p class=""optionComment"">{}</p>'.format(sectionOption[1])
            else:
                option = sectionOption
                
            if type(settings.settings[option]) == bool:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""checkbox"" id=""{option}"" name=""{option}"" value=""{optionValue}"" {checkedState} />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment,
                                              checkedState=('checked' if settings.settings[option] else ''),
                                              optionValue=('1' if settings.settings[option] else '0')))
                
            elif type(settings.settings[option]) == int:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""number"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,
                                              optionValue=settings.settings[option]))
                
            elif type(settings.settings[option]) == str:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""{type}"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment, optionValue=settings.settings[option],
                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))

    return ''.join(settingsInputs)

class SettingsHandler(AuthHandler):
    def doSettings(self, afterSubmit):
        htmlSettingsForm = settingsToHtmlForm()
        settingsFilename = settings.getSettingsFilename()
        
        self.write('''<html>
                            <head>
                                  <link rel=""stylesheet"" type=""text/css"" href=""webInterface/settings.css"">
                                  <script type=""text/javascript"" src=""webInterface/settings.js""></script>
                            </head>
                            <body>
                                  <h1>Liked Saved Downloader Settings</h1>
                                  <a href=""/"">Back to Homepage</a><br /><br />
                                  {}
                                  <p>Settings being read from {}</p>
                                  <form action=""/settings"" method=""post"">
                                       <input type=""submit"" value=""Submit"">
                                       {}
                                       <input type=""submit"" value=""Submit"">
                                       {}
                                  </form>
                            </body>
                      </html>'''
                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),
                           settingsFilename, htmlSettingsForm, self.xsrf_form_html()))

    @tornado.web.authenticated
    def get(self):
        self.doSettings(False)

    @tornado.web.authenticated
    def post(self):
        currentOutputDir = settings.settings['Output_dir']
        
        print('Received new settings')
        
        for option in settings.settings:
            newValue = self.get_argument(option, None)
            if not newValue:
                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes
                # This means the user set the value to false
                if type(settings.settings[option]) == bool:
                    settings.settings[option] = False
                else:
                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'
                          '\n\tIgnore this if the field is intentionally empty'.format(option))
            else:
                # All false bools are handed in the above if block, so we know they're true here
                if type(settings.settings[option]) == bool:
                    newValue = True
                elif type(settings.settings[option]) == int:
                    newValue = int(newValue)
                
                settings.settings[option] = newValue
                # print('\tSet {} = {}'.format(option, newValue))

        # Write out the new settings
        settings.writeServerSettings()
        
        # Respond with a settings page saying we've updated the settings
        self.doSettings(True)

        # Refresh the cache in case the output directory changed
        if currentOutputDir != settings.settings['Output_dir']:
            generateSavedImagesCache(settings.settings['Output_dir'])
            

class RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):
    connections = set()

    def cacheFilteredImages(self):
        # Clear the cache
        self.filteredImagesCache = []

        if not self.randomImageFilter:
            return

        randomImageFilterLower = self.randomImageFilter.lower()
    
        for imagePath in savedImagesCache:
            if randomImageFilterLower in imagePath.lower():
                self.filteredImagesCache.append(imagePath)

        print('\tFiltered images with ""{}""; {} images matching filter'
              .format(self.randomImageFilter, len(self.filteredImagesCache)))

    def changeCurrentDirectory(self, newDirectory):
        self.currentDirectoryPath = newDirectory
        dirList = os.listdir(self.currentDirectoryPath)
        
        filteredDirList = []
        for fileOrDir in dirList:
            # The script spits out a lot of .json files the user probably doesn't want to see
            if (not fileOrDir.endswith('.json')
                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):
                filteredDirList.append(fileOrDir)
                
        self.currentDirectoryCache = sorted(filteredDirList)

    def open(self):
        if not login_get_current_user(self):
            return None
        
        self.connections.add(self)
        self.randomHistory = []
        self.randomHistoryIndex = -1
        self.favorites = []
        self.favoritesIndex = 0
        self.currentImage = None
        self.randomImageFilter = ''
        self.filteredImagesCache = []
        
        self.currentDirectoryPath = ''
        self.currentDirectoryCache = []
        self.directoryFilter = ''
        # Set up the directory cache with the top-level output
        self.changeCurrentDirectory(settings.settings['Output_dir'])

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RandomImageBrowserWebSocket: Received message ', message)
        parsedMessage = json.loads(message)
        command = parsedMessage['command']
        print('RandomImageBrowserWebSocket: Command ', command)
        action = ''

        """"""
         Random Image Browser
        """"""

        if command == 'imageAddToFavorites':
            if self.currentImage:
                self.favorites.append(self.currentImage)
                self.favoritesIndex = len(self.favorites) - 1

        if command == 'nextFavorite':
            self.favoritesIndex += 1
            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):
                action = 'setImage'
                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]
            else:
                self.favoritesIndex = len(self.favorites) - 1
                if len(self.favorites):
                    action = 'setImage'
                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'previousFavorite' and len(self.favorites):
            action = 'setImage'

            if self.favoritesIndex > 0:
                self.favoritesIndex -= 1
                
            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'nextImage':
            action = 'setImage'

            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:
                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)
                self.randomHistory.append((fullImagePath, serverImagePath))
                self.randomHistoryIndex = len(self.randomHistory) - 1
            else:
                self.randomHistoryIndex += 1
                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command == 'previousImage':
            action = 'setImage'

            if self.randomHistoryIndex > 0:
                self.randomHistoryIndex -= 1
                
            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):
            fullImagePath, serverImagePath = self.currentImage
                
            folder = fullImagePath[:fullImagePath.rfind('/')]
            imagesInFolder = []
            for root, dirs, files in os.walk(folder):
                for file in files:
                    if file.endswith(supportedExtensions):
                        imagesInFolder.append(os.path.join(root, file))
            sort_naturally(imagesInFolder)
            currentImageIndex = imagesInFolder.index(fullImagePath)
            if currentImageIndex >= 0:
                action = 'setImage'
                
                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)
                if nextImageIndex == len(imagesInFolder):
                    nextImageIndex = 0
                if nextImageIndex < 0:
                    nextImageIndex = len(imagesInFolder) - 1
                    
                fullImagePath = imagesInFolder[nextImageIndex]
                serverImagePath = outputPathToServerPath(fullImagePath)

        if command == 'setFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.randomImageFilter:
                self.randomImageFilter = newFilter
                self.cacheFilteredImages()

        """"""
         Directory browser
        """"""

        if command == 'setDirectoryFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.directoryFilter:
                self.directoryFilter = newFilter
                # Refresh cache with new filter
                self.changeCurrentDirectory(self.currentDirectoryPath)
                action = 'sendDirectory'

        if command == 'listCurrentDirectory':
            action = 'sendDirectory'

        if command == 'changeDirectory':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));
            action = 'sendDirectory'

        if command == 'directoryUp':
            # Don't allow going higher than output dir
            if self.currentDirectoryPath != settings.settings['Output_dir']:
                upDirectory = (settings.settings['Output_dir']  +
                               self.currentDirectoryPath[len(settings.settings['Output_dir'])
                                                         : self.currentDirectoryPath.rfind('/')])
                # Reset the filter (chances are the user only wanted to filter at one level
                self.directoryFilter = ''
                self.changeCurrentDirectory(upDirectory)
                action = 'sendDirectory'
            
        if command == 'directoryRoot':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory(settings.settings['Output_dir'])
            action = 'sendDirectory'

        """"""
         Actions
        """"""

        # Only send a response if needed
        if action == 'setImage':
            # Stupid hack
            if serverImagePath.endswith(videoExtensions):
                action = 'setVideo'
                
            self.currentImage = (fullImagePath, serverImagePath)
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""fullImagePath"":""{}"", ""serverImagePath"":""{}""}}'
                               .format(command, action, fullImagePath, serverImagePath))
            self.write_message(responseMessage)

        if action == 'sendDirectory':
            directoryList = ''
            for path in self.currentDirectoryCache:
                isSupportedFile = path.endswith(supportedExtensions)
                isFile = '.' in path
                if path.endswith(videoExtensions):
                    fileType = 'video'
                elif isSupportedFile:
                    fileType = 'image'
                elif isFile:
                    fileType = 'file'
                else:
                    fileType = 'dir'
                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path
                directoryList += '{{""path"":""{}"", ""type"":""{}"", ""serverPath"":""{}""}},'.format(path, fileType, serverPath)

            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""directoryList"":[{}]}}'
                               .format(command, action, directoryList[:-1]))
            self.write_message(responseMessage)
            

    def on_close(self):
        self.connections.remove(self)

scriptPipeConnection = None
scriptProcess = None

def startScript():
    global scriptPipeConnection, scriptProcess
    
    # Script already running
    if scriptProcess and scriptProcess.is_alive():
        return
    
    scriptPipeConnection, childConnection = multiprocessing.Pipe()
    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,
                                            args=(childConnection,))
    scriptProcess.start()

runScriptWebSocketConnections = set()
class RunScriptWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        if not login_get_current_user(self):
            return None
        
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.add(self)

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RunScriptWebSocket: Received message ', message)

        parsedMessage = json.loads(message)
        command = parsedMessage['command']

        print('RunScriptWebSocket: Command ', command)
        
        if command == 'runScript':
            if scriptProcess and scriptProcess.is_alive():
                print('RunScriptWebSocket: Script already running')
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Script already running\\n', 'printMessage'))
                self.write_message(responseMessage)
                
            else:
                print('RunScriptWebSocket: Starting script')

                startScript()
                
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Running script\\n', 'printMessage'))
                self.write_message(responseMessage)

    def on_close(self):
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.remove(self)

def updateScriptStatus():
    # If no pipe or no data to receive from pipe, we're done
    # Poll() is non-blocking whereas recv is blocking
    if (not runScriptWebSocketConnections
        or not scriptPipeConnection
        or not scriptPipeConnection.poll()):
        return

    pipeOutput = scriptPipeConnection.recv()
    if pipeOutput:
        responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                           .format(pipeOutput.replace('\n', '\\n').replace('\t', ''),
                                   'printMessage'))
        
        for client in runScriptWebSocketConnections:
            client.write_message(responseMessage)

        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:
            # Script finished; refresh image cache
            print('Refreshing cache due to script finishing')
            generateSavedImagesCache(settings.settings['Output_dir'])
            responseMessage = ('{{""action"":""{}""}}'
                               .format('scriptFinished'))
            
            for client in runScriptWebSocketConnections:
                client.write_message(responseMessage)

            scriptPipeConnection.close()

#
# Startup
#

def make_app():
    # Each time the server starts up, invalidate all cookies
    randomGenerator = random.SystemRandom()
    cookieSecret = str(randomGenerator.getrandbits(128))
    
    return tornado.web.Application([
        # Home page
        (r'/', HomeHandler),
        
        # Login
        (r'/login', LoginHandler),
        (r'/logout', LogoutHandler),

        # Configure the script
        (r'/settings', SettingsHandler),

        # Handles messages for run script
        (r'/runScriptWebSocket', RunScriptWebSocket),

        # Handles messages for randomImageBrowser
        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),

        # Static files
        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),
        # Don't change this ""output"" here without changing the other places as well
        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),

        # Files served regardless of whether the user is authenticated. Only login page resources
        # should be in this folder, because anyone can see them
        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),
    ],
                                   xsrf_cookies=True,
                                   cookie_secret=cookieSecret,
                                   login_url=""/login"")

if __name__ == '__main__':
    print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
    
    print('Loading settings...')
    settings.getSettings()

    print('Liked Saved output directory: ' + settings.settings['Output_dir'])
    if not settings.settings['Output_dir']:
        print('WARNING: No output directory specified! This will probably break things')
    
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])
    
    port = 8888
    print('\nStarting LikedSavedDownloader Server on port {}...'.format(port))
    app = make_app()

    # Generating a self-signing certificate:
    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem
    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)
    # I then had to tell Firefox to trust this certificate even though it is self-signing (because
    # I want a free certificate for this non-serious project)
    useSSL = True
    if useSSL:
        app.listen(port, ssl_options={""certfile"":""certificates/server_jupyter_based.crt.pem"",
                                      ""keyfile"":""certificates/server_jupyter_based.crt.key""})
    else:
        # Show the warning only if SSL is not enabled
        print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
        app.listen(port)
        
    ioLoop = tornado.ioloop.IOLoop.current()
    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)
    updateStatusCallback.start()
    ioLoop.start()
/n/n/n",0
31,75cf3c0885faa5fa19819b7d83d5bbe120a47fe3,"/LikedSavedDownloaderServer.py/n/n#!/usr/bin/env python

import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.httpclient
import tornado.gen

import os
import random
import shutil
import json
import multiprocessing

from utilities import sort_naturally
import settings
import redditUserImageScraper

# Require a username and password in order to use the web interface. See ReadMe.org for details.
enable_authentication = False
#enable_authentication = True

if enable_authentication:
    import PasswordManager

# List of valid user ids (used to compare user cookie)
authenticated_users = []

videoExtensions = ('.mp4', '.webm')
supportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')

savedImagesCache = []
def generateSavedImagesCache(outputDir):
    global savedImagesCache
    # Clear cache in case already created
    savedImagesCache = []

    print('Creating Liked Saved cache...')
    
    for root, dirs, files in os.walk(outputDir):
        for file in files:
            if file.endswith(supportedExtensions):
                savedImagesCache.append(os.path.join(root, file))

    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))

def outputPathToServerPath(path):
    # This is a little weird
    return 'output' + path.split(settings.settings['Output_dir'])[1]

def getRandomImage(filteredImagesCache=None, randomImageFilter=''):
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])

    if filteredImagesCache:
        randomImage = random.choice(filteredImagesCache)
    else:
        randomImage = random.choice(savedImagesCache)

    print('\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))

    serverPath = outputPathToServerPath(randomImage)

    return randomImage, serverPath

#
# Tornado handlers
#

# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py
# https://www.tornadoweb.org/en/stable/guide/security.html

def login_get_current_user(handler):
    if enable_authentication:
        cookie = handler.get_secure_cookie(""user"")
        if cookie in authenticated_users:
            return cookie
        else:
            print(""Bad/expired cookie received"")
            return None
    else:
        return ""authentication_disabled""

class AuthHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
class LoginHandler(AuthHandler):
    def get(self):
        if not enable_authentication:
            self.redirect(""/"")
        else:
            self.write('<html>'
                       '<head>'
	               '<title>Liked Saved Downloader</title>'
	               '<link rel=""stylesheet"" type=""text/css"" href=""webInterfaceNoAuth/index.css"">'
                       '</head>'
                       '<body><h1>Login Required</h1>'
                       '<form action=""/login"" method=""post"">'
                       'Name: <input type=""text"" name=""name""><br />'
                       'Password: <input type=""password"" name=""password"">'
                       '{}'
                       '<br /><input type=""submit"" value=""Sign in"">'
                       '</form></body></html>'.format(self.xsrf_form_html()))

    def post(self):
        global authenticated_users
        # Test password
        if enable_authentication and PasswordManager.verify(self.get_argument(""password"")):
            # Generate new authenticated user session
            randomGenerator = random.SystemRandom()
            cookieSecret = str(randomGenerator.getrandbits(128))
            authenticated_user = self.get_argument(""name"") + ""_"" + cookieSecret
            authenticated_user = authenticated_user.encode()
            authenticated_users.append(authenticated_user)
            
            # Set the cookie on the user's side
            self.set_secure_cookie(""user"", authenticated_user)
            
            print(""Authenticated user {}"".format(self.get_argument(""name"")))
            
            # Let them in
            self.redirect(""/"")
        else:
            print(""Refused user {} (password doesn't match any in database)"".format(self.get_argument(""name"")))
            self.redirect(""/login"")
            
class LogoutHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        global authenticated_users
        
        if enable_authentication:
            print(""User {} logging out"".format(self.current_user))
            if self.current_user in authenticated_users:
                authenticated_users.remove(self.current_user)
            self.redirect(""/login"")
        else:
            self.redirect(""/"")

class AuthedStaticHandler(tornado.web.StaticFileHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
    @tornado.web.authenticated
    def prepare(self):
        pass

class HomeHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        self.render('webInterface/index.html')

def settingsToHtmlForm():
    settingsInputs = []

    for sectionSettingsPair in settings.settingsStructure:
        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))

        for sectionOption in sectionSettingsPair[1]:
            option = None
            optionComment = ''
            if type(sectionOption) == tuple:
                option = sectionOption[0]
                optionComment = '<p class=""optionComment"">{}</p>'.format(sectionOption[1])
            else:
                option = sectionOption
                
            if type(settings.settings[option]) == bool:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""checkbox"" id=""{option}"" name=""{option}"" value=""{optionValue}"" {checkedState} />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment,
                                              checkedState=('checked' if settings.settings[option] else ''),
                                              optionValue=('1' if settings.settings[option] else '0')))
                
            elif type(settings.settings[option]) == int:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""number"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,
                                              optionValue=settings.settings[option]))
                
            elif type(settings.settings[option]) == str:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""{type}"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment, optionValue=settings.settings[option],
                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))

    return ''.join(settingsInputs)

class SettingsHandler(AuthHandler):
    def doSettings(self, afterSubmit):
        htmlSettingsForm = settingsToHtmlForm()
        settingsFilename = settings.getSettingsFilename()
        
        self.write('''<html>
                            <head>
                                  <link rel=""stylesheet"" type=""text/css"" href=""webInterface/settings.css"">
                                  <script type=""text/javascript"" src=""webInterface/settings.js""></script>
                            </head>
                            <body>
                                  <h1>Liked Saved Downloader Settings</h1>
                                  <a href=""/"">Back to Homepage</a><br /><br />
                                  {}
                                  <p>Settings being read from {}</p>
                                  <form action=""/settings"" method=""post"">
                                       <input type=""submit"" value=""Submit"">
                                       {}
                                       <input type=""submit"" value=""Submit"">
                                  </form>
                            </body>
                      </html>'''
                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),
                           settingsFilename, htmlSettingsForm))

    @tornado.web.authenticated
    def get(self):
        self.doSettings(False)

    @tornado.web.authenticated
    def post(self):
        currentOutputDir = settings.settings['Output_dir']
        
        print('Received new settings')
        
        for option in settings.settings:
            newValue = self.get_argument(option, None)
            if not newValue:
                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes
                # This means the user set the value to false
                if type(settings.settings[option]) == bool:
                    settings.settings[option] = False
                else:
                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'
                          '\n\tIgnore this if the field is intentionally empty'.format(option))
            else:
                # All false bools are handed in the above if block, so we know they're true here
                if type(settings.settings[option]) == bool:
                    newValue = True
                elif type(settings.settings[option]) == int:
                    newValue = int(newValue)
                
                settings.settings[option] = newValue
                # print('\tSet {} = {}'.format(option, newValue))

        # Write out the new settings
        settings.writeServerSettings()
        
        # Respond with a settings page saying we've updated the settings
        self.doSettings(True)

        # Refresh the cache in case the output directory changed
        if currentOutputDir != settings.settings['Output_dir']:
            generateSavedImagesCache(settings.settings['Output_dir'])
            

class RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):
    connections = set()

    def cacheFilteredImages(self):
        # Clear the cache
        self.filteredImagesCache = []

        if not self.randomImageFilter:
            return

        randomImageFilterLower = self.randomImageFilter.lower()
    
        for imagePath in savedImagesCache:
            if randomImageFilterLower in imagePath.lower():
                self.filteredImagesCache.append(imagePath)

        print('\tFiltered images with ""{}""; {} images matching filter'
              .format(self.randomImageFilter, len(self.filteredImagesCache)))

    def changeCurrentDirectory(self, newDirectory):
        self.currentDirectoryPath = newDirectory
        dirList = os.listdir(self.currentDirectoryPath)
        
        filteredDirList = []
        for fileOrDir in dirList:
            # The script spits out a lot of .json files the user probably doesn't want to see
            if (not fileOrDir.endswith('.json')
                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):
                filteredDirList.append(fileOrDir)
                
        self.currentDirectoryCache = sorted(filteredDirList)

    def open(self):
        if not login_get_current_user(self):
            return None
        
        self.connections.add(self)
        self.randomHistory = []
        self.randomHistoryIndex = -1
        self.favorites = []
        self.favoritesIndex = 0
        self.currentImage = None
        self.randomImageFilter = ''
        self.filteredImagesCache = []
        
        self.currentDirectoryPath = ''
        self.currentDirectoryCache = []
        self.directoryFilter = ''
        # Set up the directory cache with the top-level output
        self.changeCurrentDirectory(settings.settings['Output_dir'])

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RandomImageBrowserWebSocket: Received message ', message)
        parsedMessage = json.loads(message)
        command = parsedMessage['command']
        print('RandomImageBrowserWebSocket: Command ', command)
        action = ''

        """"""
         Random Image Browser
        """"""

        if command == 'imageAddToFavorites':
            if self.currentImage:
                self.favorites.append(self.currentImage)
                self.favoritesIndex = len(self.favorites) - 1

        if command == 'nextFavorite':
            self.favoritesIndex += 1
            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):
                action = 'setImage'
                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]
            else:
                self.favoritesIndex = len(self.favorites) - 1
                if len(self.favorites):
                    action = 'setImage'
                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'previousFavorite' and len(self.favorites):
            action = 'setImage'

            if self.favoritesIndex > 0:
                self.favoritesIndex -= 1
                
            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'nextImage':
            action = 'setImage'

            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:
                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)
                self.randomHistory.append((fullImagePath, serverImagePath))
                self.randomHistoryIndex = len(self.randomHistory) - 1
            else:
                self.randomHistoryIndex += 1
                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command == 'previousImage':
            action = 'setImage'

            if self.randomHistoryIndex > 0:
                self.randomHistoryIndex -= 1
                
            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):
            fullImagePath, serverImagePath = self.currentImage
                
            folder = fullImagePath[:fullImagePath.rfind('/')]
            imagesInFolder = []
            for root, dirs, files in os.walk(folder):
                for file in files:
                    if file.endswith(supportedExtensions):
                        imagesInFolder.append(os.path.join(root, file))
            sort_naturally(imagesInFolder)
            currentImageIndex = imagesInFolder.index(fullImagePath)
            if currentImageIndex >= 0:
                action = 'setImage'
                
                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)
                if nextImageIndex == len(imagesInFolder):
                    nextImageIndex = 0
                if nextImageIndex < 0:
                    nextImageIndex = len(imagesInFolder) - 1
                    
                fullImagePath = imagesInFolder[nextImageIndex]
                serverImagePath = outputPathToServerPath(fullImagePath)

        if command == 'setFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.randomImageFilter:
                self.randomImageFilter = newFilter
                self.cacheFilteredImages()

        """"""
         Directory browser
        """"""

        if command == 'setDirectoryFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.directoryFilter:
                self.directoryFilter = newFilter
                # Refresh cache with new filter
                self.changeCurrentDirectory(self.currentDirectoryPath)
                action = 'sendDirectory'

        if command == 'listCurrentDirectory':
            action = 'sendDirectory'

        if command == 'changeDirectory':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));
            action = 'sendDirectory'

        if command == 'directoryUp':
            # Don't allow going higher than output dir
            if self.currentDirectoryPath != settings.settings['Output_dir']:
                upDirectory = (settings.settings['Output_dir']  +
                               self.currentDirectoryPath[len(settings.settings['Output_dir'])
                                                         : self.currentDirectoryPath.rfind('/')])
                # Reset the filter (chances are the user only wanted to filter at one level
                self.directoryFilter = ''
                self.changeCurrentDirectory(upDirectory)
                action = 'sendDirectory'
            
        if command == 'directoryRoot':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory(settings.settings['Output_dir'])
            action = 'sendDirectory'

        """"""
         Actions
        """"""

        # Only send a response if needed
        if action == 'setImage':
            # Stupid hack
            if serverImagePath.endswith(videoExtensions):
                action = 'setVideo'
                
            self.currentImage = (fullImagePath, serverImagePath)
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""fullImagePath"":""{}"", ""serverImagePath"":""{}""}}'
                               .format(command, action, fullImagePath, serverImagePath))
            self.write_message(responseMessage)

        if action == 'sendDirectory':
            directoryList = ''
            for path in self.currentDirectoryCache:
                isSupportedFile = path.endswith(supportedExtensions)
                isFile = '.' in path
                if path.endswith(videoExtensions):
                    fileType = 'video'
                elif isSupportedFile:
                    fileType = 'image'
                elif isFile:
                    fileType = 'file'
                else:
                    fileType = 'dir'
                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path
                directoryList += '{{""path"":""{}"", ""type"":""{}"", ""serverPath"":""{}""}},'.format(path, fileType, serverPath)

            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""directoryList"":[{}]}}'
                               .format(command, action, directoryList[:-1]))
            self.write_message(responseMessage)
            

    def on_close(self):
        self.connections.remove(self)

scriptPipeConnection = None
scriptProcess = None

def startScript():
    global scriptPipeConnection, scriptProcess
    
    # Script already running
    if scriptProcess and scriptProcess.is_alive():
        return
    
    scriptPipeConnection, childConnection = multiprocessing.Pipe()
    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,
                                            args=(childConnection,))
    scriptProcess.start()

runScriptWebSocketConnections = set()
class RunScriptWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        if not login_get_current_user(self):
            return None
        
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.add(self)

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RunScriptWebSocket: Received message ', message)

        parsedMessage = json.loads(message)
        command = parsedMessage['command']

        print('RunScriptWebSocket: Command ', command)
        
        if command == 'runScript':
            if scriptProcess and scriptProcess.is_alive():
                print('RunScriptWebSocket: Script already running')
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Script already running\\n', 'printMessage'))
                self.write_message(responseMessage)
                
            else:
                print('RunScriptWebSocket: Starting script')

                startScript()
                
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Running script\\n', 'printMessage'))
                self.write_message(responseMessage)

    def on_close(self):
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.remove(self)

def updateScriptStatus():
    # If no pipe or no data to receive from pipe, we're done
    # Poll() is non-blocking whereas recv is blocking
    if (not runScriptWebSocketConnections
        or not scriptPipeConnection
        or not scriptPipeConnection.poll()):
        return

    pipeOutput = scriptPipeConnection.recv()
    if pipeOutput:
        responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                           .format(pipeOutput.replace('\n', '\\n').replace('\t', ''),
                                   'printMessage'))
        
        for client in runScriptWebSocketConnections:
            client.write_message(responseMessage)

        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:
            # Script finished; refresh image cache
            print('Refreshing cache due to script finishing')
            generateSavedImagesCache(settings.settings['Output_dir'])
            responseMessage = ('{{""action"":""{}""}}'
                               .format('scriptFinished'))
            
            for client in runScriptWebSocketConnections:
                client.write_message(responseMessage)

            scriptPipeConnection.close()

#
# Startup
#

def make_app():
    # Each time the server starts up, invalidate all cookies
    randomGenerator = random.SystemRandom()
    cookieSecret = str(randomGenerator.getrandbits(128))
    
    return tornado.web.Application([
        # Home page
        (r'/', HomeHandler),
        
        # Login
        (r'/login', LoginHandler),
        (r'/logout', LogoutHandler),

        # Configure the script
        (r'/settings', SettingsHandler),

        # Handles messages for run script
        (r'/runScriptWebSocket', RunScriptWebSocket),

        # Handles messages for randomImageBrowser
        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),

        # Static files
        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),
        # Don't change this ""output"" here without changing the other places as well
        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),

        # Files served regardless of whether the user is authenticated. Only login page resources
        # should be in this folder, because anyone can see them
        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),
    ],
                                   xsrf_cookies=True,
                                   cookie_secret=cookieSecret,
                                   login_url=""/login"")

if __name__ == '__main__':
    print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
    
    print('Loading settings...')
    settings.getSettings()

    print('Liked Saved output directory: ' + settings.settings['Output_dir'])
    if not settings.settings['Output_dir']:
        print('WARNING: No output directory specified! This will probably break things')
    
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])
    
    port = 8888
    print('\nStarting LikedSavedDownloader Server on port {}...'.format(port))
    app = make_app()

    # Generating a self-signing certificate:
    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem
    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)
    # I then had to tell Firefox to trust this certificate even though it is self-signing (because
    # I want a free certificate for this non-serious project)
    useSSL = True
    if useSSL:
        app.listen(port, ssl_options={""certfile"":""certificates/server_jupyter_based.crt.pem"",
                                      ""keyfile"":""certificates/server_jupyter_based.crt.key""})
    else:
        # Show the warning only if SSL is not enabled
        print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
        app.listen(port)
        
    ioLoop = tornado.ioloop.IOLoop.current()
    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)
    updateStatusCallback.start()
    ioLoop.start()
/n/n/n",1
32,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"jupyter-5.0-default-jupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/njupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/n",0
33,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"/jupyter_notebook_config.py/n/n# Copyright (c) Jupyter Development Team.
from jupyter_core.paths import jupyter_data_dir
import subprocess
import os

PEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')

c = get_config()
c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'
c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)
c.NotebookApp.open_browser = False

# Set a certificate if USE_HTTPS is set to any value
if 'USE_HTTPS' in os.environ:
    if not os.path.isfile(PEM_FILE):
        # Generate a certificate if one doesn't exist on disk
        subprocess.check_call(['openssl', 'req', '-new', 
            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',
            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',
            '-keyout', PEM_FILE, '-out', PEM_FILE])
    c.NotebookApp.certfile = PEM_FILE

# Set a password if PASSWORD is set
if 'PASSWORD' in os.environ:
    from IPython.lib import passwd
    c.NotebookApp.password = passwd(os.environ['PASSWORD'])
    del os.environ['PASSWORD']
/n/n/n",1
34,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"jupyter-5.0-default-jupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/njupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/n",0
35,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"/jupyter_notebook_config.py/n/n# Copyright (c) Jupyter Development Team.
from jupyter_core.paths import jupyter_data_dir
import subprocess
import os

PEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')

c = get_config()
c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'
c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)
c.NotebookApp.open_browser = False

# Set a certificate if USE_HTTPS is set to any value
if 'USE_HTTPS' in os.environ:
    if not os.path.isfile(PEM_FILE):
        # Generate a certificate if one doesn't exist on disk
        subprocess.check_call(['openssl', 'req', '-new', 
            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',
            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',
            '-keyout', PEM_FILE, '-out', PEM_FILE])
    c.NotebookApp.certfile = PEM_FILE

# Set a password if PASSWORD is set
if 'PASSWORD' in os.environ:
    from IPython.lib import passwd
    c.NotebookApp.password = passwd(os.environ['PASSWORD'])
    del os.environ['PASSWORD']
/n/n/n",1
36,9d083ef1bc9cf41ff4e5a065c3196270effe3b5f,"setup.py/n/nfrom setuptools import find_packages, setup

setup(
    name='jupyter-notebook-gist',
    version='0.4.0',
    description='Create a gist from the Jupyter Notebook UI',
    author='Mozilla Firefox Data Platform',
    author_email='fx-data-platform@mozilla.com',
    packages=find_packages(where='src'),
    package_dir={'': 'src'},
    include_package_data=True,
    license='MPL2',
    install_requires=[
        'ipython >= 4',
        'notebook >= 4.3.1',
        'jupyter',
        'requests',
        'six',
        'widgetsnbextension',
    ],
    url='https://github.com/mozilla/jupyter-notebook-gist',
    zip_safe=False,
)
/n/n/n",0
37,9d083ef1bc9cf41ff4e5a065c3196270effe3b5f,"/setup.py/n/nfrom setuptools import find_packages, setup

setup(
    name='jupyter-notebook-gist',
    version='0.4.0',
    description='Create a gist from the Jupyter Notebook UI',
    author='Mozilla Firefox Data Platform',
    author_email='fx-data-platform@mozilla.com',
    packages=find_packages(where='src'),
    package_dir={'': 'src'},
    include_package_data=True,
    license='MPL2',
    install_requires=[
        'ipython >= 4',
        'notebook >= 4.2',
        'jupyter',
        'requests',
        'six',
        'widgetsnbextension',
    ],
    url='https://github.com/mozilla/jupyter-notebook-gist',
    zip_safe=False,
)
/n/n/n",1
38,e64a478b09842d55be64a7cf7badb83ac3eb6493,"kijiji_repost_headless/__main__.py/n/nimport argparse
import os
import sys
from time import sleep

import kijiji_api
import generate_inf_file as generator

if sys.version_info < (3, 0):
    raise Exception(""This program requires Python 3.0 or greater"")


def main():
    parser = argparse.ArgumentParser(description=""Post ads on Kijiji"")
    parser.add_argument('-u', '--username', help='username of your kijiji account')
    parser.add_argument('-p', '--password', help='password of your kijiji account')

    subparsers = parser.add_subparsers(help='sub-command help')

    post_parser = subparsers.add_parser('post', help='post a new ad')
    post_parser.add_argument('inf_file', type=str, help='.inf file containing posting details')
    post_parser.set_defaults(function=post_ad)

    folder_parser = subparsers.add_parser('folder', help='post ad from folder')
    folder_parser.add_argument('folder_name', type=str, help='folder containing ad details')
    folder_parser.set_defaults(function=post_folder)

    repost_folder_parser = subparsers.add_parser('repost_folder', help='post ad from folder')
    repost_folder_parser.add_argument('folder_name', type=str, help='folder containing ad details')
    repost_folder_parser.set_defaults(function=repost_folder)

    show_parser = subparsers.add_parser('show', help='show currently listed ads')
    show_parser.set_defaults(function=show_ads)

    delete_parser = subparsers.add_parser('delete', help='delete a listed ad')
    delete_parser.add_argument('id', type=str, help='id of the ad you wish to delete')
    delete_parser.set_defaults(function=delete_ad)

    nuke_parser = subparsers.add_parser('nuke', help='delete all ads')
    nuke_parser.set_defaults(function=nuke)

    check_parser = subparsers.add_parser('check_ad', help='check if ad is active')
    check_parser.add_argument('folder_name', type=str, help='folder containing ad details')
    check_parser.set_defaults(function=check_ad)

    repost_parser = subparsers.add_parser('repost', help='repost an existing ad')
    repost_parser.add_argument('inf_file', type=str, help='.inf file containing posting details')
    repost_parser.set_defaults(function=repost_ad)

    build_parser = subparsers.add_parser('build_ad', help='Generates the item.inf file for a new ad')
    build_parser.set_defaults(function=generate_inf_file)

    args = parser.parse_args()
    try:
        args.function(args)
    except AttributeError:
        parser.print_help()


def get_folder_data(args):
    """"""
    Set ad data inf file and extract login credentials from inf files
    """"""
    args.inf_file = ""item.inf""
    cred_file = args.folder_name + ""/login.inf""
    creds = [line.strip() for line in open(cred_file, 'r')]
    args.username = creds[0]
    args.password = creds[1]


def get_inf_details(inf_file):
    """"""
    Extract ad data from inf file
    """"""
    with open(inf_file, 'rt') as infFileLines:
        data = {key: val for line in infFileLines for (key, val) in (line.strip().split(""=""),)}
    files = [open(picture, 'rb').read() for picture in data['imageCsv'].split("","")]
    return [data, files]


def post_folder(args):
    """"""
    Post new ad from folder
    """"""
    get_folder_data(args)
    os.chdir(args.folder_name)
    post_ad(args)


def post_ad(args):
    """"""
    Post new ad
    """"""
    [data, image_files] = get_inf_details(args.inf_file)
    attempts = 1
    while not check_ad(args) and attempts < 5:
        if attempts > 1:
            print(""Failed Attempt #{}, trying again."".format(attempts))
        attempts += 1
        api = kijiji_api.KijijiApi()
        api.login(args.username, args.password)
        api.post_ad_using_data(data, image_files)
    if not check_ad(args):
        print(""Failed Attempt #{}, giving up."".format(attempts))


def show_ads(args):
    """"""
    Print list of all ads
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    [print(""{} '{}'"".format(ad_id, ad_name)) for ad_name, ad_id in api.get_all_ads()]


def delete_ad(args):
    """"""
    Delete ad
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    api.delete_ad(args.id)


def delete_ad_using_title(name):
    """"""
    Delete ad based on ad title
    """"""
    api = kijiji_api.KijijiApi()
    api.delete_ad_using_title(name)


def repost_ad(args):
    """"""
    Repost ad

    Try to delete ad with same title if possible before reposting new ad
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    del_ad_name = """"
    for line in open(args.inf_file, 'rt'):
        [key, val] = line.strip().rstrip(""\n"").split(""="")
        if key == ""postAdForm.title"":
            del_ad_name = val
    try:
        api.delete_ad_using_title(del_ad_name)
        print(""Existing ad deleted before reposting"")
    except kijiji_api.DeleteAdException:
        print(""Did not find an existing ad with matching title, skipping ad deletion"")
        pass
    # Must wait a bit before posting the same ad even after deleting it, otherwise Kijiji will automatically remove it
    sleep(180)
    post_ad(args)


def repost_folder(args):
    """"""
    Repost ad from folder
    """"""
    get_folder_data(args)
    os.chdir(args.folder_name)
    repost_ad(args)


def check_ad(args):
    """"""
    Check if ad is live
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    ad_name = """"
    for line in open(args.inf_file, 'rt'):
        [key, val] = line.strip().rstrip(""\n"").split(""="")
        if key == ""postAdForm.title"":
            ad_name = val
    all_ads = api.get_all_ads()
    return [t for t, i in all_ads if t == ad_name]


def nuke(args):
    """"""
    Delete all ads
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    all_ads = api.get_all_ads()
    [api.delete_ad(ad_id) for ad_name, ad_id in all_ads]


def generate_inf_file():
    generator.run_program()


if __name__ == ""__main__"":
    main()
/n/n/nkijiji_repost_headless/kijiji_api.py/n/nimport json
import re
import sys
from time import strftime

import bs4
import requests
import yaml

if sys.version_info < (3, 0):
    raise Exception(""This program requires Python 3.0 or greater"")


class KijijiApiException(Exception):
    """"""
    Custom KijijiApi exception class
    """"""
    def __init__(self, msg=""KijijiApi exception encountered."", dump=None):
        self.msg = msg
        self.dumpfilepath = """"
        if dump:
            self.dumpfilepath = ""kijijiapi_dump_{}.txt"".format(strftime(""%Y%m%dT%H%M%S""))
            with open(self.dumpfilepath, 'a') as f:
                f.write(dump)

    def __str__(self):
        if self.dumpfilepath:
            return ""{}\nSee {} in current directory for latest dumpfile."".format(self.msg, self.dumpfilepath)
        else:
            return self.msg


def get_token(html, attrib_name):
    """"""
    Return value of first match for element with name attribute
    """"""
    soup = bs4.BeautifulSoup(html, 'html.parser')
    res = soup.select(""[name={}]"".format(attrib_name))
    if not res:
        raise KijijiApiException(""Element with name attribute '{}' not found in html text."".format(attrib_name), html)
    return res[0]['value']


def get_kj_data(html):
    """"""
    Return dict of Kijiji page data
    The 'window.__data' JSON object contains many useful key/values
    """"""
    soup = bs4.BeautifulSoup(html, 'html.parser')
    p = re.compile('window.__data=(.*);')
    script_list = soup.find_all(""script"", {""src"": False})
    for script in script_list:
        if script:
            m = p.search(script.string)
            if m:
                return json.loads(m.group(1))
    raise KijijiApiException(""'__data' JSON object not found in html text."", html)


def get_xsrf_token(html):
    """"""
    Return XSRF token
    This function is only necessary for the 'm-my-ads.html' page, as this particular page
    does not contain the usual 'ca.kijiji.xsrf.token' hidden HTML form input element, which is easier to scrape
    """"""
    soup = bs4.BeautifulSoup(html, 'html.parser')
    p = re.compile('Zoop\.init\(.*config: ({.+?}).*\);')
    for script in soup.find_all(""script"", {""src"": False}):
        if script:
            m = p.search(script.string.replace(""\n"", """"))
            if m:
                # Using yaml to load since this is not valid JSON
                return yaml.load(m.group(1))['token']
    raise KijijiApiException(""XSRF token not found in html text."", html)


class KijijiApi:
    """"""
    All functions require to be logged in to Kijiji first in order to function correctly
    """"""
    def __init__(self):
        config = {}
        self.session = requests.Session()

    def login(self, username, password):
        """"""
        Login to Kijiji for the current session
        """"""
        login_url = 'https://www.kijiji.ca/t-login.html'
        resp = self.session.get(login_url)
        payload = {
            'emailOrNickname': username,
            'password': password,
            'rememberMe': 'true',
            '_rememberMe': 'on',
            'ca.kijiji.xsrf.token': get_token(resp.text, 'ca.kijiji.xsrf.token'),
            'targetUrl': get_kj_data(resp.text)['config']['targetUrl'],
        }
        resp = self.session.post(login_url, data=payload)
        if not self.is_logged_in():
            raise KijijiApiException(""Could not log in."", resp.text)

    def is_logged_in(self):
        """"""
        Return true if logged into Kijiji for the current session
        """"""
        return ""Sign Out"" in self.session.get('https://www.kijiji.ca/m-my-ads.html/').text

    def logout(self):
        """"""
        Logout of Kijiji for the current session
        """"""
        self.session.get('https://www.kijiji.ca/m-logout.html')

    def delete_ad(self, ad_id):
        """"""
        Delete ad based on ad ID
        """"""
        my_ads_page = self.session.get('https://www.kijiji.ca/m-my-ads.html')
        params = {
            'Action': 'DELETE_ADS',
            'Mode': 'ACTIVE',
            'needsRedirect': 'false',
            'ads': '[{{""adId"":""{}"",""reason"":""PREFER_NOT_TO_SAY"",""otherReason"":""""}}]'.format(ad_id),
            'ca.kijiji.xsrf.token': get_xsrf_token(my_ads_page.text),
        }
        resp = self.session.post('https://www.kijiji.ca/j-delete-ad.json', data=params)
        if ""OK"" not in resp.text:
            raise KijijiApiException(""Could not delete ad."", resp.text)

    def delete_ad_using_title(self, title):
        """"""
        Delete ad based on ad title
        """"""
        all_ads = self.get_all_ads()
        [self.delete_ad(i) for t, i in all_ads if t.strip() == title.strip()]

    def upload_image(self, token, image_files=[]):
        """"""
        Upload one or more photos to Kijiji

        'image_files' is a list of binary objects corresponding to images
        """"""
        image_urls = []
        image_upload_url = 'https://www.kijiji.ca/p-upload-image.html'
        for img_file in image_files:
            for i in range(0, 3):
                r = self.session.post(image_upload_url, files={'file': img_file}, headers={""X-Ebay-Box-Token"": token})
                r.raise_for_status()
                try:
                    image_tree = json.loads(r.text)
                    img_url = image_tree['thumbnailUrl']
                    print(""Image Upload success on try #{}"".format(i+1))
                    image_urls.append(img_url)
                    break
                except (KeyError, ValueError):
                    print(""Image Upload failed on try #{}"".format(i+1))
        return [image for image in image_urls if image is not None]

    def post_ad_using_data(self, data, image_files=[]):
        """"""
        Post new ad

        'data' is a dictionary of ad data that to be posted
        'image_files' is a list of binary objects corresponding to images to upload
        """"""
        # Load ad posting page (arbitrary category)
        resp = self.session.get('https://www.kijiji.ca/p-admarkt-post-ad.html?categoryId=15')

        # Get token required for upload
        m = re.search(r""initialXsrfToken: '(\S+)'"", resp.text)
        if m:
            image_upload_token = m.group(1)
        else:
            raise KijijiApiException(""'initialXsrfToken' not found in html text."", resp.text)

        # Upload the images
        image_list = self.upload_image(image_upload_token, image_files)
        data['images'] = "","".join(image_list)

        # Retrieve XSRF tokens
        data['ca.kijiji.xsrf.token'] = get_token(resp.text, 'ca.kijiji.xsrf.token')
        data['postAdForm.fraudToken'] = get_token(resp.text, 'postAdForm.fraudToken')

        # Format ad data and check constraints
        data['postAdForm.description'] = data['postAdForm.description'].replace(""\\n"", ""\n"")
        title_len = len(data.get(""postAdForm.title"", """"))
        if not title_len >= 10:
            raise KijijiApiException(""Your ad title is too short! (min 10 chars)"")
        if title_len > 64:
            raise KijijiApiException(""Your ad title is too long! (max 64 chars)"")

        # Upload the ad itself
        new_ad_url = ""https://www.kijiji.ca/p-submit-ad.html""
        resp = self.session.post(new_ad_url, data=data)
        resp.raise_for_status()
        if ""Delete Ad?"" not in resp.text:
            if ""There was an issue posting your ad, please contact Customer Service."" in resp.text:
                raise KijijiApiException(""Could not post ad; this user is banned."", resp.text)
            else:
                raise KijijiApiException(""Could not post ad."", resp.text)

        # Extract ad ID from response set-cookie
        ad_id = re.search('kjrva=(\d+)', resp.headers['Set-Cookie']).group(1)

        return ad_id

    def get_all_ads(self):
        """"""
        Return an iterator of tuples containing the ad title and ad ID for every ad
        """"""
        resp = self.session.get('https://www.kijiji.ca/m-my-ads.html')
        user_id = get_kj_data(resp.text)['config']['userId']
        my_ads_url = 'https://www.kijiji.ca/j-get-my-ads.json?currentOffset=0&show=ACTIVE&user={}'.format(user_id)
        my_ads_page = self.session.get(my_ads_url)
        my_ads_tree = json.loads(my_ads_page.text)
        ad_ids = [entry['id'] for entry in my_ads_tree['myAdEntries']]
        ad_names = [entry['title'] for entry in my_ads_tree['myAdEntries']]
        return zip(ad_names, ad_ids)
/n/n/n",0
39,e64a478b09842d55be64a7cf7badb83ac3eb6493,"/kijiji_repost_headless/__main__.py/n/nimport argparse
import os
import sys
from time import sleep

import kijiji_api
import generate_inf_file as generator

if sys.version_info < (3, 0):
    raise Exception(""This program requires Python 3.0 or greater"")


def main():
    parser = argparse.ArgumentParser(description=""Post ads on Kijiji"")
    parser.add_argument('-u', '--username', help='username of your kijiji account')
    parser.add_argument('-p', '--password', help='password of your kijiji account')

    subparsers = parser.add_subparsers(help='sub-command help')

    postParser = subparsers.add_parser('post', help='post a new ad')
    postParser.add_argument('inf_file', type=str, help='.inf file containing posting details')
    postParser.set_defaults(function=post_ad)

    folderParser = subparsers.add_parser('folder', help='post ad from folder')
    folderParser.add_argument('folderName', type=str, help='folder containing ad details')
    folderParser.set_defaults(function=post_folder)

    repostFolderParser = subparsers.add_parser('repost_folder', help='post ad from folder')
    repostFolderParser.add_argument('folderName', type=str, help='folder containing ad details')
    repostFolderParser.set_defaults(function=repost_folder)

    showParser = subparsers.add_parser('show', help='show currently listed ads')
    showParser.set_defaults(function=show_ads)

    deleteParser = subparsers.add_parser('delete', help='delete a listed ad')
    deleteParser.add_argument('id', type=str, help='id of the ad you wish to delete')
    deleteParser.set_defaults(function=delete_ad)

    nukeParser = subparsers.add_parser('nuke', help='delete all ads')
    nukeParser.set_defaults(function=nuke)

    checkParser = subparsers.add_parser('check_ad', help='check if ad is active')
    checkParser.add_argument('folderName', type=str, help='folder containing ad details')
    checkParser.set_defaults(function=check_ad)

    repostParser = subparsers.add_parser('repost', help='repost an existing ad')
    repostParser.add_argument('inf_file', type=str, help='.inf file containing posting details')
    repostParser.set_defaults(function=repost_ad)

    buildParser = subparsers.add_parser('build_ad', help='Generates the item.inf file for a new ad')
    buildParser.set_defaults(function=generate_inf_file)

    args = parser.parse_args()
    try:
        args.function(args)
    except AttributeError:
        parser.print_help()


def get_folder_data(args):
    """"""
    Set ad data inf file and extract login credentials from inf files
    """"""
    args.inf_file = ""item.inf""
    cred_file = args.folderName + ""/login.inf""
    creds = [line.strip() for line in open(cred_file, 'r')]
    args.username = creds[0]
    args.password = creds[1]


def get_inf_details(inf_file):
    """"""
    Extract ad data from inf file
    """"""
    with open(inf_file, 'rt') as infFileLines:
        data = {key: val for line in infFileLines for (key, val) in (line.strip().split(""=""),)}
    files = [open(picture, 'rb').read() for picture in data['imageCsv'].split("","")]
    return [data, files]


def post_folder(args):
    """"""
    Post new ad from folder
    """"""
    get_folder_data(args)
    os.chdir(args.folderName)
    post_ad(args)


def post_ad(args):
    """"""
    Post new ad
    """"""
    [data, imageFiles] = get_inf_details(args.inf_file)
    attempts = 1
    while not check_ad(args) and attempts < 5:
        if attempts > 1:
            print(""Failed Attempt #"" + str(attempts) + "", trying again."")
        attempts += 1
        api = kijiji_api.KijijiApi()
        api.login(args.username, args.password)
        api.post_ad_using_data(data, imageFiles)
        sleep(180)
    if not check_ad(args):
        print(""Failed Attempt #"" + str(attempts) + "", giving up."")


def show_ads(args):
    """"""
    Print list of all ads
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    [print(""{} '{}'"".format(adId, adName)) for adName, adId in api.get_all_ads()]


def delete_ad(args):
    """"""
    Delete ad
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    api.delete_ad(args.id)


def delete_ad_using_title(name):
    """"""
    Delete ad based on ad title
    """"""
    api = kijiji_api.KijijiApi()
    api.delete_ad_using_title(name)


def repost_ad(args):
    """"""
    Repost ad

    Try to delete ad with same title if possible before reposting new ad
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    delAdName = """"
    for line in open(args.inf_file, 'rt'):
        [key, val] = line.strip().rstrip(""\n"").split(""="")
        if key == ""postAdForm.title"":
            delAdName = val
    try:
        api.delete_ad_using_title(delAdName)
        print(""Existing ad deleted before reposting"")
    except kijiji_api.DeleteAdException:
        print(""Did not find an existing ad with matching title, skipping ad deletion"")
        pass
    # Must wait a bit before posting the same ad even after deleting it, otherwise Kijiji will automatically remove it
    sleep(180)
    post_ad(args)


def repost_folder(args):
    """"""
    Repost ad from folder
    """"""
    get_folder_data(args)
    os.chdir(args.folderName)
    repost_ad(args)


def check_ad(args):
    """"""
    Check if ad is live
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    AdName = """"
    for line in open(args.inf_file, 'rt'):
        [key, val] = line.strip().rstrip(""\n"").split(""="")
        if key == ""postAdForm.title"":
            AdName = val
    allAds = api.get_all_ads()
    return [t for t, i in allAds if t == AdName]


def nuke(args):
    """"""
    Delete all ads
    """"""
    api = kijiji_api.KijijiApi()
    api.login(args.username, args.password)
    allAds = api.get_all_ads()
    [api.delete_ad(adId) for adName, adId in allAds]

def generate_inf_file(args):
    generator.run_program()

if __name__ == ""__main__"":
    main()
/n/n/n/kijiji_repost_headless/kijiji_api.py/n/nimport requests
import json
import bs4
import re
import sys
from multiprocessing import Pool
from time import strftime

if sys.version_info < (3, 0):
    raise Exception(""This program requires Python 3.0 or greater"")


class KijijiApiException(Exception):
    """"""
    Custom KijijiApi exception class
    """"""
    def __init__(self, dump=None):
        self.dumpfilepath = """"
        if dump:
            self.dumpfilepath = ""kijiji_dump_{}.txt"".format(strftime(""%Y%m%dT%H%M%S""))
            with open(self.dumpfilepath, 'a') as f:
                f.write(dump)
    def __str__(self):
        if self.dumpfilepath:
            return ""See {} in current directory for latest dumpfile."".format(self.dumpfilepath)
        else:
            return """"

class SignInException(KijijiApiException):
    def __str__(self):
        return ""Could not sign in.\n""+super().__str__()

class PostAdException(KijijiApiException):
    def __str__(self):
        return ""Could not post ad.\n""+super().__str__()

class BannedException(KijijiApiException):
    def __str__(self):
        return ""Could not post ad, this user is banned.\n""+super().__str__()

class DeleteAdException(KijijiApiException):
    def __str__(self):
        return ""Could not delete ad.\n""+super().__str__()


def get_token(html, token_name):
    """"""
    Retrive CSRF token from webpage
    Tokens are different every time a page is visitied
    """"""
    soup = bs4.BeautifulSoup(html, 'html.parser')
    res = soup.select(""[name={}]"".format(token_name))
    if not res:
        print(""Token '{}' not found in html text."".format(token_name))
        return """"
    return res[0]['value']


class KijijiApi:
    """"""
    All functions require to be logged in to Kijiji first in order to function correctly
    """"""
    def __init__(self):
        config = {}
        self.session = requests.Session()

    def login(self, username, password):
        """"""
        Login to Kijiji for the current session
        """"""
        login_url = 'https://www.kijiji.ca/t-login.html'
        resp = self.session.get(login_url)
        payload = {
            'emailOrNickname': username,
            'password': password,
            'rememberMe': 'true',
            '_rememberMe': 'on',
            'ca.kijiji.xsrf.token': get_token(resp.text, 'ca.kijiji.xsrf.token'),
            'targetUrl': 'L3QtbG9naW4uaHRtbD90YXJnZXRVcmw9TDNRdGJHOW5hVzR1YUhSdGJEOTBZWEpuWlhSVmNtdzlUREpuZEZwWFVuUmlNalV3WWpJMGRGbFlTbXhaVXpoNFRucEJkMDFxUVhsWWJVMTZZbFZLU1dGVmJHdGtiVTVzVlcxa1VWSkZPV0ZVUmtWNlUyMWpPVkJSTFMxZVRITTBVMk5wVW5wbVRHRlFRVUZwTDNKSGNtVk9kejA5XnpvMnFzNmc2NWZlOWF1T1BKMmRybEE9PQ--'
            }
        resp = self.session.post(login_url, data=payload)
        if not self.is_logged_in():
            raise SignInException(resp.text)

    def is_logged_in(self):
        """"""
        Return true if logged into Kijiji for the current session
        """"""
        index_page_text = self.session.get('https://www.kijiji.ca/m-my-ads.html/').text
        return ""Sign Out"" in index_page_text

    def logout(self):
        """"""
        Logout of Kijiji for the current session
        """"""
        self.session.get('https://www.kijiji.ca/m-logout.html')

    def delete_ad(self, ad_id):
        """"""
        Delete ad based on ad ID
        """"""
        my_ads_page = self.session.get('https://www.kijiji.ca/m-my-ads.html')
        params = {
            'Action': 'DELETE_ADS',
            'Mode': 'ACTIVE',
            'needsRedirect': 'false',
            'ads': '[{{""adId"":""{}"",""reason"":""PREFER_NOT_TO_SAY"",""otherReason"":""""}}]'.format(ad_id),
            'ca.kijiji.xsrf.token': get_token(my_ads_page.text, 'ca.kijiji.xsrf.token')
            }
        resp = self.session.post('https://www.kijiji.ca/j-delete-ad.json', data=params)
        if (""OK"" not in resp.text):
            raise DeleteAdException(resp.text)

    def delete_ad_using_title(self, title):
        """"""
        Delete ad based on ad title
        """"""
        allAds = self.get_all_ads()
        [self.delete_ad(i) for t, i in allAds if t.strip() == title.strip()]

    def upload_image(self, token, image_files=[]):
        """"""
        Upload one or more photos to Kijiji concurrently using Pool

        'image_files' is a list of binary objects corresponding to images
        """"""
        image_urls = []
        image_upload_url = 'https://www.kijiji.ca/p-upload-image.html'
        for img_file in image_files:
            for i in range(0, 3):
                files = {'file': img_file}
                r = self.session.post(image_upload_url, files=files, headers={""x-ebay-box-token"": token})
                if (r.status_code != 200):
                    print(r.status_code)
                try:
                    image_tree = json.loads(r.text)
                    img_url = image_tree['thumbnailUrl']
                    print(""Image Upload success on try #{}"".format(i+1))
                    image_urls.append(img_url)
                    break
                except (KeyError, ValueError) as e:
                    print(""Image Upload failed on try #{}"".format(i+1))
        return [image for image in image_urls if image is not None]

    def post_ad_using_data(self, data, image_files=[]):
        """"""
        Post new ad

        'data' is a dictionary of ad data that to be posted
        'image_files' is a list of binary objects corresponding to images to upload
        """"""
        # Load ad posting page
        resp = self.session.get('https://www.kijiji.ca/p-admarkt-post-ad.html?categoryId=773')

        #Get tokens required for upload
        token_regex = r""initialXsrfToken: '\S+'""
        image_upload_token = re.findall(token_regex, resp.text)[0].strip(""initialXsrfToken: '"").strip(""'"")

        # Upload the images
        imageList = self.upload_image(image_upload_token, image_files)
        data['images'] = "","".join(imageList)

        # Retrive tokens for website
        data['ca.kijiji.xsrf.token'] = get_token(resp.text, 'ca.kijiji.xsrf.token')
        data['postAdForm.fraudToken'] = get_token(resp.text, 'postAdForm.fraudToken')
        data['postAdForm.description'] = data['postAdForm.description'].replace(""\\n"", ""\n"")

        # Upload the ad itself
        new_ad_url = ""https://www.kijiji.ca/p-submit-ad.html""
        resp = self.session.post(new_ad_url, data=data)
        if not len(data.get(""postAdForm.title"", """")) >= 10:
            raise AssertionError(""Your title is too short!"")
        if (int(resp.status_code) != 200 or \
                ""Delete Ad?"" not in resp.text):
            if ""There was an issue posting your ad, please contact Customer Service."" in resp.text:
                raise BannedException(resp.text)
            else:
                raise PostAdException(resp.text)

        # Get adId and return it
        new_cookie_with_ad_id = resp.headers['Set-Cookie']
        ad_id = re.search('\d+', new_cookie_with_ad_id).group()
        return ad_id

    def get_all_ads(self):
        """"""
        Return an iterator of tuples containing the ad title and ad ID for every ad
        """"""
        resp = self.session.get('https://www.kijiji.ca/m-my-ads.html')
        user_id=get_token(resp.text, 'userId')
        my_ads_url = 'https://www.kijiji.ca/j-get-my-ads.json?_=1&currentOffset=0&isPromoting=false&show=ACTIVE&user={}'.format(user_id)
        my_ads_page = self.session.get(my_ads_url)
        my_ads_tree = json.loads(my_ads_page.text)
        ad_ids = [entry['id'] for entry in my_ads_tree['myAdEntries']]
        ad_names = [entry['title'] for entry in my_ads_tree['myAdEntries']]
        return zip(ad_names, ad_ids)
/n/n/n",1
40,9573bdca55ddc5488066d3af525e41ed1d872ea6,"service/pixelated/resources/__init__.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import json

from twisted.web.http import UNAUTHORIZED
from twisted.web.resource import Resource

# from pixelated.resources.login_resource import LoginResource
from pixelated.resources.session import IPixelatedSession
from pixelated.support import log_time


class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return super(SetEncoder, self).default(obj)


def respond_json(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    return json_response


@log_time
def respond_json_deferred(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    request.write(json_response)
    request.finish()


class BaseResource(Resource):

    def __init__(self, services_factory):
        Resource.__init__(self)
        self._services_factory = services_factory

    def _get_user_id_from_request(self, request):
        if self._services_factory.mode.is_single_user:
            return None  # it doesn't matter
        session = self.get_session(request)
        if session.is_logged_in():
            return session.user_uuid
        raise ValueError('Not logged in')

    def is_logged_in(self, request):
        session = self.get_session(request)
        return session.is_logged_in() and self._services_factory.is_logged_in(session.user_uuid)

    def get_session(self, request):
        return IPixelatedSession(request.getSession())

    def _services(self, request):
        user_id = self._get_user_id_from_request(request)
        return self._services_factory.services(user_id)

    def _service(self, request, attribute):
        return getattr(self._services(request), attribute)

    def keymanager(self, request):
        return self._service(request, 'keymanager')

    def mail_service(self, request):
        return self._service(request, 'mail_service')

    def search_engine(self, request):
        return self._service(request, 'search_engine')

    def draft_service(self, request):
        return self._service(request, 'draft_service')

    def feedback_service(self, request):
        return self._service(request, 'feedback_service')


class UnAuthorizedResource(Resource):

    def __init__(self):
        Resource.__init__(self)

    def render_GET(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""

    def render_POST(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""
/n/n/nservice/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.python.filepath import FilePath
from twisted.web import util
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/nservice/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self.child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            return self.child_resources.get(path)
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self.child_resources.add('assets', File(self._static_folder))
        self.child_resources.add('keys', KeysResource(self._services_factory))
        self.child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.child_resources.add('contacts', ContactsResource(self._services_factory))
        self.child_resources.add('features', FeaturesResource(portal))
        self.child_resources.add('tags', TagsResource(self._services_factory))
        self.child_resources.add('mails', MailsResource(self._services_factory))
        self.child_resources.add('mail', MailResource(self._services_factory))
        self.child_resources.add('feedback', FeedbackResource(self._services_factory))
        self.child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self.child_resources.add(LoginResource.BASE_URL,
                                 LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/nservice/test/integration/test_retrieve_attachment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import base64
import json
from email import encoders
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from poster.encode import multipart_encode, MultipartParam
from twisted.internet import defer

from test.support.integration.soledad_test_base import SoledadTestBase


class RetrieveAttachmentTest(SoledadTestBase):
    @defer.inlineCallbacks
    def test_attachment_content_is_retrieved(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename, content_type=expected_content_type)

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    @defer.inlineCallbacks
    def test_should_retrieve_attachment_even_if_xsrf_token_not_passed(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename,
                                                    content_type=expected_content_type, ajax=False, csrf='mismatched token')

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    def _create_mail_with_attachment(self):
        input_mail = MIMEMultipart()
        input_mail.attach(MIMEText(u'a utf8 message', _charset='utf-8'))
        attachment = MIMEApplication('pretend to be binary attachment data')
        attachment.add_header('Content-Disposition', 'attachment', filename='file name.txt')
        attachment.add_header('Content-Type', 'text/plain')
        input_mail.attach(attachment)
        attachment_id = 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A'
        return attachment_id, input_mail

    @defer.inlineCallbacks
    def test_attachment_error_returned_if_id_not_found(self):
        attachment, req = yield self.get_attachment('invalid attachment id', 'base64')

        self.assertEqual(404, req.code)
        self.assertIsNone(attachment)

    @defer.inlineCallbacks
    def test_post_new_attachment(self):
        content_type = 'text/plain'
        filename = 'filename.txt'
        data = 'pretend to be binary attachment data'
        file = MultipartParam('attachment', value=data, filename=filename, filetype=content_type)
        datagen, headers = multipart_encode([file])
        post_data = """".join(datagen)

        _, req = yield self.post_attachment(post_data, headers)

        self.assertEqual(201, req.code)
        self.assertEqual('/attachment/B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A', req.headers['Location'])
        response_json = {'ident': 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A',
                         'content-type': content_type,
                         'name': filename,
                         'size': len(data),
                         'encoding': 'base64'}
        self.assertEqual(response_json, json.loads(req.written[0]))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/nservice/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None
        self.cookies = {}

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)

    def addCookie(self, key, value):
        self.cookies[key] = value

    def getCookie(self, key):
        return self.cookies.get(key)


def request_mock(path='', method='GET', body='', headers={}, ajax=True, csrf='token'):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)
    if ajax:
        dummy.headers['x-requested-with'] = 'XMLHttpRequest'
        dummy.headers['x-xsrf-token'] = csrf
        dummy.addCookie('XSRF-TOKEN', csrf)

    return dummy
/n/n/nservice/test/unit/resources/test_root_resource.py/n/nimport unittest
import re

from mock import MagicMock, patch
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource, MODE_STARTUP, MODE_RUNNING


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)
        self.root_resource = root_resource

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])
        request.addCookie = lambda key, value: 'stubbed'

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d

    def _test_should_renew_xsrf_cookie(self):
        request = DummyRequest([''])
        request.addCookie = MagicMock()
        generated_csrf_token = 'csrf_token'
        mock_sha = MagicMock()
        mock_sha.hexdigest = MagicMock(return_value=generated_csrf_token)

        with patch('hashlib.sha256', return_value=mock_sha):
            d = self.web.get(request)

        def assert_csrf_cookie(_):
            request.addCookie.assert_called_once_with('XSRF-TOKEN', generated_csrf_token)

        d.addCallback(assert_csrf_cookie)
        return d

    def test_should_renew_xsrf_cookie_on_startup_mode(self):
        self.root_resource._mode = MODE_STARTUP
        self._test_should_renew_xsrf_cookie()

    def test_should_renew_xsrf_cookie_on_running_mode(self):
        self.root_resource._mode = MODE_RUNNING
        self._test_should_renew_xsrf_cookie()

    def _mock_ajax_csrf(self, request, csrf_token):
        request.headers['x-requested-with'] = 'XMLHttpRequest'
        request.headers['x-xsrf-token'] = csrf_token

    def test_should_unauthorize_child_resource_ajax_requests_when_csrf_mismatch(self):
        request = DummyRequest(['/child'])
        self._mock_ajax_csrf(request, 'stubbed csrf token')

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d

    def test_should_authorize_child_resource_non_ajax_GET_requests(self):
        request = DummyRequest(['features'])

        request.getCookie = MagicMock(return_value='irrelevant -- stubbed')
        self.root_resource.initialize()

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(200, request.code)

        d.addCallback(assert_unauthorized)
        return d

    def test_should_unauthorize_child_resource_non_ajax_POST_requests_when_csrf_input_mismatch(self):
        request = DummyRequest(['mails'])
        request.method = 'POST'
        request.addArg('csrftoken', 'some csrf token')
        mock_content = MagicMock()
        mock_content.read = MagicMock(return_value={})
        request.content = mock_content

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d
/n/n/n",0
41,9573bdca55ddc5488066d3af525e41ed1d872ea6,"/service/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.web import util
from twisted.web.error import FlattenerError
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer
from twisted.python.filepath import FilePath

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/n/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import os
from string import Template

from pixelated.resources import BaseResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.resource import Resource
from twisted.web.static import File


MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):

    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        return Resource.getChild(self, path, request)

    def initialize(self, portal=None, disclaimer_banner=None):
        self.putChild('assets', File(self._static_folder))
        self.putChild('keys', KeysResource(self._services_factory))
        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.putChild('contacts', ContactsResource(self._services_factory))
        self.putChild('features', FeaturesResource(portal))
        self.putChild('tags', TagsResource(self._services_factory))
        self.putChild('mails', MailsResource(self._services_factory))
        self.putChild('mail', MailResource(self._services_factory))
        self.putChild('feedback', FeedbackResource(self._services_factory))
        self.putChild('user-settings', UserSettingsResource(self._services_factory))
        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def render_GET(self, request):
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)
/n/n/n/service/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True):
        request = request_mock(path)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers)
        return self._render(request)

    def put(self, path, body):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']})
        return self._render(request)

    def delete(self, path, body=""""):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"")
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n/service/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)


def request_mock(path='', method='GET', body='', headers={}):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)

    return dummy
/n/n/n/service/test/unit/resources/test_root_resource.py/n/nimport unittest
import re
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d
/n/n/n",1
42,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP(port=8889)
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.client.stop()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def stop(self):
        reactor.stop()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n",0
43,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"/service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP()
    proxy = Proxy(proxy_port='8889', app_port='4567')
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client
    context.call_to_terminate_proxy = proxy.run_on_a_thread()

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.call_to_terminate_proxy()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/n",1
44,85094ff8caac585cbff260fe89a6f21df241fd47,"service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = xsrf_token or request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",0
45,85094ff8caac585cbff260fe89a6f21df241fd47,"/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",1
46,9573bdca55ddc5488066d3af525e41ed1d872ea6,"service/pixelated/resources/__init__.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import json

from twisted.web.http import UNAUTHORIZED
from twisted.web.resource import Resource

# from pixelated.resources.login_resource import LoginResource
from pixelated.resources.session import IPixelatedSession
from pixelated.support import log_time


class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return super(SetEncoder, self).default(obj)


def respond_json(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    return json_response


@log_time
def respond_json_deferred(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    request.write(json_response)
    request.finish()


class BaseResource(Resource):

    def __init__(self, services_factory):
        Resource.__init__(self)
        self._services_factory = services_factory

    def _get_user_id_from_request(self, request):
        if self._services_factory.mode.is_single_user:
            return None  # it doesn't matter
        session = self.get_session(request)
        if session.is_logged_in():
            return session.user_uuid
        raise ValueError('Not logged in')

    def is_logged_in(self, request):
        session = self.get_session(request)
        return session.is_logged_in() and self._services_factory.is_logged_in(session.user_uuid)

    def get_session(self, request):
        return IPixelatedSession(request.getSession())

    def _services(self, request):
        user_id = self._get_user_id_from_request(request)
        return self._services_factory.services(user_id)

    def _service(self, request, attribute):
        return getattr(self._services(request), attribute)

    def keymanager(self, request):
        return self._service(request, 'keymanager')

    def mail_service(self, request):
        return self._service(request, 'mail_service')

    def search_engine(self, request):
        return self._service(request, 'search_engine')

    def draft_service(self, request):
        return self._service(request, 'draft_service')

    def feedback_service(self, request):
        return self._service(request, 'feedback_service')


class UnAuthorizedResource(Resource):

    def __init__(self):
        Resource.__init__(self)

    def render_GET(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""

    def render_POST(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""
/n/n/nservice/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.python.filepath import FilePath
from twisted.web import util
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/nservice/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self.child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            return self.child_resources.get(path)
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self.child_resources.add('assets', File(self._static_folder))
        self.child_resources.add('keys', KeysResource(self._services_factory))
        self.child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.child_resources.add('contacts', ContactsResource(self._services_factory))
        self.child_resources.add('features', FeaturesResource(portal))
        self.child_resources.add('tags', TagsResource(self._services_factory))
        self.child_resources.add('mails', MailsResource(self._services_factory))
        self.child_resources.add('mail', MailResource(self._services_factory))
        self.child_resources.add('feedback', FeedbackResource(self._services_factory))
        self.child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self.child_resources.add(LoginResource.BASE_URL,
                                 LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/nservice/test/integration/test_retrieve_attachment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import base64
import json
from email import encoders
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from poster.encode import multipart_encode, MultipartParam
from twisted.internet import defer

from test.support.integration.soledad_test_base import SoledadTestBase


class RetrieveAttachmentTest(SoledadTestBase):
    @defer.inlineCallbacks
    def test_attachment_content_is_retrieved(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename, content_type=expected_content_type)

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    @defer.inlineCallbacks
    def test_should_retrieve_attachment_even_if_xsrf_token_not_passed(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename,
                                                    content_type=expected_content_type, ajax=False, csrf='mismatched token')

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    def _create_mail_with_attachment(self):
        input_mail = MIMEMultipart()
        input_mail.attach(MIMEText(u'a utf8 message', _charset='utf-8'))
        attachment = MIMEApplication('pretend to be binary attachment data')
        attachment.add_header('Content-Disposition', 'attachment', filename='file name.txt')
        attachment.add_header('Content-Type', 'text/plain')
        input_mail.attach(attachment)
        attachment_id = 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A'
        return attachment_id, input_mail

    @defer.inlineCallbacks
    def test_attachment_error_returned_if_id_not_found(self):
        attachment, req = yield self.get_attachment('invalid attachment id', 'base64')

        self.assertEqual(404, req.code)
        self.assertIsNone(attachment)

    @defer.inlineCallbacks
    def test_post_new_attachment(self):
        content_type = 'text/plain'
        filename = 'filename.txt'
        data = 'pretend to be binary attachment data'
        file = MultipartParam('attachment', value=data, filename=filename, filetype=content_type)
        datagen, headers = multipart_encode([file])
        post_data = """".join(datagen)

        _, req = yield self.post_attachment(post_data, headers)

        self.assertEqual(201, req.code)
        self.assertEqual('/attachment/B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A', req.headers['Location'])
        response_json = {'ident': 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A',
                         'content-type': content_type,
                         'name': filename,
                         'size': len(data),
                         'encoding': 'base64'}
        self.assertEqual(response_json, json.loads(req.written[0]))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/nservice/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None
        self.cookies = {}

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)

    def addCookie(self, key, value):
        self.cookies[key] = value

    def getCookie(self, key):
        return self.cookies.get(key)


def request_mock(path='', method='GET', body='', headers={}, ajax=True, csrf='token'):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)
    if ajax:
        dummy.headers['x-requested-with'] = 'XMLHttpRequest'
        dummy.headers['x-xsrf-token'] = csrf
        dummy.addCookie('XSRF-TOKEN', csrf)

    return dummy
/n/n/nservice/test/unit/resources/test_root_resource.py/n/nimport unittest
import re

from mock import MagicMock, patch
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource, MODE_STARTUP, MODE_RUNNING


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)
        self.root_resource = root_resource

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])
        request.addCookie = lambda key, value: 'stubbed'

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d

    def _test_should_renew_xsrf_cookie(self):
        request = DummyRequest([''])
        request.addCookie = MagicMock()
        generated_csrf_token = 'csrf_token'
        mock_sha = MagicMock()
        mock_sha.hexdigest = MagicMock(return_value=generated_csrf_token)

        with patch('hashlib.sha256', return_value=mock_sha):
            d = self.web.get(request)

        def assert_csrf_cookie(_):
            request.addCookie.assert_called_once_with('XSRF-TOKEN', generated_csrf_token)

        d.addCallback(assert_csrf_cookie)
        return d

    def test_should_renew_xsrf_cookie_on_startup_mode(self):
        self.root_resource._mode = MODE_STARTUP
        self._test_should_renew_xsrf_cookie()

    def test_should_renew_xsrf_cookie_on_running_mode(self):
        self.root_resource._mode = MODE_RUNNING
        self._test_should_renew_xsrf_cookie()

    def _mock_ajax_csrf(self, request, csrf_token):
        request.headers['x-requested-with'] = 'XMLHttpRequest'
        request.headers['x-xsrf-token'] = csrf_token

    def test_should_unauthorize_child_resource_ajax_requests_when_csrf_mismatch(self):
        request = DummyRequest(['/child'])
        self._mock_ajax_csrf(request, 'stubbed csrf token')

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d

    def test_should_authorize_child_resource_non_ajax_GET_requests(self):
        request = DummyRequest(['features'])

        request.getCookie = MagicMock(return_value='irrelevant -- stubbed')
        self.root_resource.initialize()

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(200, request.code)

        d.addCallback(assert_unauthorized)
        return d

    def test_should_unauthorize_child_resource_non_ajax_POST_requests_when_csrf_input_mismatch(self):
        request = DummyRequest(['mails'])
        request.method = 'POST'
        request.addArg('csrftoken', 'some csrf token')
        mock_content = MagicMock()
        mock_content.read = MagicMock(return_value={})
        request.content = mock_content

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d
/n/n/n",0
47,9573bdca55ddc5488066d3af525e41ed1d872ea6,"/service/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.web import util
from twisted.web.error import FlattenerError
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer
from twisted.python.filepath import FilePath

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/n/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import os
from string import Template

from pixelated.resources import BaseResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.resource import Resource
from twisted.web.static import File


MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):

    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        return Resource.getChild(self, path, request)

    def initialize(self, portal=None, disclaimer_banner=None):
        self.putChild('assets', File(self._static_folder))
        self.putChild('keys', KeysResource(self._services_factory))
        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.putChild('contacts', ContactsResource(self._services_factory))
        self.putChild('features', FeaturesResource(portal))
        self.putChild('tags', TagsResource(self._services_factory))
        self.putChild('mails', MailsResource(self._services_factory))
        self.putChild('mail', MailResource(self._services_factory))
        self.putChild('feedback', FeedbackResource(self._services_factory))
        self.putChild('user-settings', UserSettingsResource(self._services_factory))
        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def render_GET(self, request):
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)
/n/n/n/service/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True):
        request = request_mock(path)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers)
        return self._render(request)

    def put(self, path, body):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']})
        return self._render(request)

    def delete(self, path, body=""""):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"")
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n/service/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)


def request_mock(path='', method='GET', body='', headers={}):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)

    return dummy
/n/n/n/service/test/unit/resources/test_root_resource.py/n/nimport unittest
import re
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d
/n/n/n",1
48,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP(port=8889)
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.client.stop()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def stop(self):
        reactor.stop()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n",0
49,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"/service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP()
    proxy = Proxy(proxy_port='8889', app_port='4567')
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client
    context.call_to_terminate_proxy = proxy.run_on_a_thread()

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.call_to_terminate_proxy()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/n",1
50,85094ff8caac585cbff260fe89a6f21df241fd47,"service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = xsrf_token or request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",0
51,85094ff8caac585cbff260fe89a6f21df241fd47,"/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",1
52,a1548fa1586bce586c9cf06bf8dd7bf26cc6c212,"cornice/tests/test_validation.py/n/n# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the ""License""); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an ""AS IS"" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Cornice (Sagrada)
#
# The Initial Developer of the Original Code is the Mozilla Foundation.
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Tarek Ziade (tarek@mozilla.com)
#   Alexis Metaireau (alexis@mozilla.com)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the ""GPL""), or
# the GNU Lesser General Public License Version 2.1 or later (the ""LGPL""),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
import unittest
import simplejson as json

from webtest import TestApp
from pyramid.response import Response

from cornice.tests.validationapp import main, _json
from cornice.tests.support import LoggingCatcher
from cornice.schemas import Errors
from cornice.validators import filter_json_xsrf


class TestServiceDefinition(LoggingCatcher, unittest.TestCase):

    def test_validation(self):
        app = TestApp(main({}))
        app.get('/service', status=400)

        res = app.post('/service', params='buh', status=400)
        self.assertTrue('Not a json body' in res.body)

        res = app.post('/service', params=json.dumps('buh'))

        self.assertEqual(res.body, json.dumps({'body': '""buh""'}))

        app.get('/service?paid=yup')

        # valid = foo is one
        res = app.get('/service?foo=1&paid=yup')
        self.assertEqual(res.json['foo'], 1)

        # invalid value for foo
        res = app.get('/service?foo=buh&paid=yup', status=400)

        # check that json is returned
        errors = Errors.from_json(res.body)
        self.assertEqual(len(errors), 1)

        # the ""apidocs"" registry entry contains all the needed information
        # to build up documentation
        # in this case, this means the function is registered and the argument
        # of the service are defined (e.g ""validator"" is set)
        apidocs = app.app.registry.settings['apidocs']

        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])

    def test_accept(self):
        # tests that the accept headers are handled the proper way
        app = TestApp(main({}))

        # requesting the wrong accept header should return a 406 ...
        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)

        # ... with the list of accepted content-types
        self.assertTrue('application/json' in res.json)
        self.assertTrue('text/json' in res.json)

        app.get('/service2', headers={'Accept': 'application/*'}, status=200)

        # it should also work with multiple Accept headers
        app.get('/service2', headers={'Accept': 'audio/*, application/*'},
                status=200)

        # test that using a callable to define what's accepted works as well
        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)
        self.assertTrue('text/json' in res.json)

        app.get('/service3', headers={'Accept': 'text/*'}, status=200)

        # if we are not asking for a particular content-type, everything
        # should work just fine
        app.get('/service2', status=200)

    def test_filters(self):
        app = TestApp(main({}))

        # filters can be applied to all the methods of a service
        self.assertTrue(""filtered response"" in app.get('/filtered').body)
        self.assertTrue(""unfiltered"" in app.post('/filtered').body)

    def test_json_xsrf(self):
        # a view returning a json list should issue a warning
        resp = Response(json.dumps(('value1', 'value2')))
        resp.status = 200
        resp.content_type = 'application/json'
        filter_json_xsrf(resp)
        self.assertEquals(len(self.get_logs()), 1)
/n/n/ncornice/validators.py/n/nimport logging
import re

log = logging.getLogger('cornice')


def filter_json_xsrf(response):
    """"""drops a warning if a service is returning a json array.

    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info
    on this
    """"""
    if response.content_type in ('application/json', 'text/json'):
        if re.match(r'[\(\[).*[\)\]]', response.body):
            log.warn(""returning a json array is a potential security whole, ""
                     ""please ensure you really want to do this. See ""
                     ""http://wiki.pylonshq.com/display/pylonsfaq/Warnings ""
                     ""for more info"")
    return response


DEFAULT_VALIDATORS = []
DEFAULT_FILTERS = [filter_json_xsrf, ]
/n/n/n",0
53,a1548fa1586bce586c9cf06bf8dd7bf26cc6c212,"/cornice/tests/test_validation.py/n/n# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the ""License""); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an ""AS IS"" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Cornice (Sagrada)
#
# The Initial Developer of the Original Code is the Mozilla Foundation.
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Tarek Ziade (tarek@mozilla.com)
#   Alexis Metaireau (alexis@mozilla.com)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the ""GPL""), or
# the GNU Lesser General Public License Version 2.1 or later (the ""LGPL""),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
import unittest
import simplejson as json

from webtest import TestApp
from cornice.tests.validationapp import main, _json
from cornice.schemas import Errors


class TestServiceDefinition(unittest.TestCase):

    def test_validation(self):
        app = TestApp(main({}))
        app.get('/service', status=400)

        res = app.post('/service', params='buh', status=400)
        self.assertTrue('Not a json body' in res.body)

        res = app.post('/service', params=json.dumps('buh'))

        self.assertEqual(res.body, json.dumps({'body': '""buh""'}))

        app.get('/service?paid=yup')

        # valid = foo is one
        res = app.get('/service?foo=1&paid=yup')
        self.assertEqual(res.json['foo'], 1)

        # invalid value for foo
        res = app.get('/service?foo=buh&paid=yup', status=400)

        # check that json is returned
        errors = Errors.from_json(res.body)
        self.assertEqual(len(errors), 1)

        # the ""apidocs"" registry entry contains all the needed information
        # to build up documentation
        # in this case, this means the function is registered and the argument
        # of the service are defined (e.g ""validator"" is set)
        apidocs = app.app.registry.settings['apidocs']

        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])

    def test_accept(self):
        # tests that the accept headers are handled the proper way
        app = TestApp(main({}))

        # requesting the wrong accept header should return a 406 ...
        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)

        # ... with the list of accepted content-types
        self.assertTrue('application/json' in res.json)
        self.assertTrue('text/json' in res.json)

        app.get('/service2', headers={'Accept': 'application/*'}, status=200)

        # it should also work with multiple Accept headers
        app.get('/service2', headers={'Accept': 'audio/*, application/*'},
                status=200)

        # test that using a callable to define what's accepted works as well
        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)
        self.assertTrue('text/json' in res.json)

        app.get('/service3', headers={'Accept': 'text/*'}, status=200)

        # if we are not asking for a particular content-type, everything
        # should work just fine
        app.get('/service2', status=200)

    def test_filters(self):
        app = TestApp(main({}))

        # filters can be applied to all the methods of a service
        self.assertTrue(""filtered response"" in app.get('/filtered').body)
        self.assertTrue(""unfiltered"" in app.post('/filtered').body)
/n/n/n/cornice/validators.py/n/nimport json
import logging

log = logging.getLogger(__name__)


def filter_json_xsrf(response):
    """"""drops a warning if a service is returning a json array.

    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info
    on this
    """"""
    if response.content_type in ('application/json', 'text/json'):
        try:
            content = json.loads(response.body)
            if isinstance(content, (list, tuple)):
                log.warn(""returning a json array is a potential security whole, ""
                         ""please ensure you really want to do this. See ""
                         ""http://wiki.pylonshq.com/display/pylonsfaq/Warnings ""
                         ""for more info"")
        except:
            pass
    return response


DEFAULT_VALIDATORS = []
DEFAULT_FILTERS = [filter_json_xsrf, ]
/n/n/n",1
54,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
55,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
56,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
57,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
58,1c2a256addf7a5273a40963f92a6351e5d053ae0,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers',
                        'accept, content-type, authorization, x-xsrftoken')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",0
59,1c2a256addf7a5273a40963f92a6351e5d053ae0,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",1
60,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
61,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
62,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
63,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
64,1c2a256addf7a5273a40963f92a6351e5d053ae0,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers',
                        'accept, content-type, authorization, x-xsrftoken')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",0
65,1c2a256addf7a5273a40963f92a6351e5d053ae0,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",1
66,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
67,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
68,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
69,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
70,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
71,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
72,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
73,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
74,1c2a256addf7a5273a40963f92a6351e5d053ae0,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers',
                        'accept, content-type, authorization, x-xsrftoken')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",0
75,1c2a256addf7a5273a40963f92a6351e5d053ae0,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",1
76,95d81b6b99a2718be934743e7ba59a1842b273c3,"acl.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import app_identity
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """"""Secret.""""""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """"""Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """"""
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """"""Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """"""Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """"""Wraps text in minimal HTML tags.""""""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """"""Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """"""
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """"""Returns all the IP addressed comprised in a range.""""""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """"""Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """"""
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  app_id = app_identity.get_application_id()
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(app_id),
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """"""Returns True if the provided token is valid.""""""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """"""Adds ACL to the request handler to ensure only valid users can use
  the handlers.""""""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """"""Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message.""""""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """"""Verifies if the IP is whitelisted.""""""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """"""Verifies if the user is whitelisted.""""""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """"""Ensures the token is valid.""""""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """"""Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """"""Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name=""whitelist"" method=""post"">'
      'Domain: <input type=""text"" name=""domain"" /><br />'
      '<input type=""hidden"" name=""token"" value=""%s"" />'
      '<input type=""submit"" value=""SUBMIT"" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """"""Returns the token.""""""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """"""Adds example.com as a valid domain when testing.""""""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')
/n/n/n",0
77,95d81b6b99a2718be934743e7ba59a1842b273c3,"/acl.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """"""Secret.""""""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """"""Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """"""
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """"""Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """"""Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """"""Wraps text in minimal HTML tags.""""""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """"""Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """"""
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """"""Returns all the IP addressed comprised in a range.""""""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """"""Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """"""
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  version = os.environ['CURRENT_VERSION_ID']
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(version),
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """"""Returns True if the provided token is valid.""""""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """"""Adds ACL to the request handler to ensure only valid users can use
  the handlers.""""""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """"""Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message.""""""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """"""Verifies if the IP is whitelisted.""""""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """"""Verifies if the user is whitelisted.""""""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """"""Ensures the token is valid.""""""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """"""Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """"""Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name=""whitelist"" method=""post"">'
      'Domain: <input type=""text"" name=""domain"" /><br />'
      '<input type=""hidden"" name=""token"" value=""%s"" />'
      '<input type=""submit"" value=""SUBMIT"" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """"""Returns the token.""""""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """"""Adds example.com as a valid domain when testing.""""""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')
/n/n/n",1
78,7b18349622ca2f78a4aeb14ba2eb1e7fc224911d,"services/swarming/swarm_bot/url_helper.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""A helper script for wrapping url calls.""""""

import hashlib
import httplib
import logging
import math
import os
import random
import socket
import time
import urllib
import urllib2
import urlparse

from common import swarm_constants  # pylint: disable=W0403


# The index of the query elements from urlparse.
QUERY_INDEX = 4

# The timeout to apply whenever opening a url.
URL_OPEN_TIMEOUT = 5 * 60


class XsrfRemote(object):
  """"""Transparently adds XSRF token to requests.""""""

  def __init__(self, url):
    self.url = url.rstrip('/')
    self.token = None
    self.max_tries = 40

  def url_read(self, resource, **kwargs):
    url = self.url + resource
    if kwargs.get('method') == 'GET':
      return UrlOpen(url, max_tries=self.max_tries, **kwargs)

    if not self.token:
      self.token = self.refresh_token()
    headers = {'X-XSRF-Token': self.token}
    resp = UrlOpen(url, headers=headers, max_tries=self.max_tries, **kwargs)
    if not resp:
      # This includes 403 because the XSRF token expired. Renew the token.
      # TODO(maruel): It'd be great if it were transparent.
      headers = {'X-XSRF-Token': self.refresh_token()}
      resp = UrlOpen(url, headers=headers, max_tries=self.max_tries, **kwargs)
    return resp

  def refresh_token(self):
    """"""Returns a fresh token. Necessary as the token may expire after an hour.
    """"""
    url = self.url + '/auth/api/v1/accounts/self/xsrf_token'
    self.token = UrlOpen(url, max_tries=self.max_tries, method='GET')
    return self.token


def UrlOpen(url, data=None, files=None, max_tries=5, wait_duration=None,
            method='POST', headers=None):
  """"""Attempts to open the given url multiple times.

  UrlOpen will attempt to open the the given url several times, stopping
  if it succeeds at reaching the url. It also includes an additional data pair
  in the data that is sent to indicate how many times it has attempted to
  connect so far.

  Args:
    url: The url to open.
    data: The unencoded data to send to the url. This must be a mapping object.
    files: Files to upload with the url, in the format (key, filename, value).
        This is only valid when the method is POSTFORM.
    max_tries: The maximum number of times to try sending this data. Must be
        greater than 0.
    wait_duration: The number of seconds to wait between successive attempts.
        This must be greater than or equal to 0. If no value is given then a
        random value between 0.1 and 10 will be chosen each time (with
        exponential back off to give later retries a longer wait).
    method: Indicates if the request should be a GET or POST request.
    headers: List of HTTP headers to add.

  Returns:
    The reponse from the url contacted. If it failed to connect or is given
    invalid arguments, then it returns None.
  """"""
  if max_tries <= 0:
    logging.error('UrlOpen(%s): Invalid number of tries: %d', url, max_tries)
    return None

  if wait_duration and wait_duration < 0:
    logging.error('UrlOpen(%s): Invalid wait duration: %d', url, wait_duration)
    return None

  data = data or {}

  if swarm_constants.COUNT_KEY in data:
    logging.error(
        'UrlOpen(%s): key \'%s\' is duplicate.', url, swarm_constants.COUNT_KEY)
    return None

  url_response = None
  for attempt in range(max_tries):
    data[swarm_constants.COUNT_KEY] = attempt
    try:
      # urlencode requires that all strings be in ASCII form.
      for key, value in data.iteritems():
        if isinstance(value, basestring):
          data[key] = value.encode('utf-8', 'xmlcharrefreplace')

      encoded_data = urllib.urlencode(data)

      if method == 'POSTFORM':
        content_type, body = EncodeMultipartFormData(fields=data.iteritems(),
                                                     files=files)
        # We must ensure body isn't None to ensure the request is a POST.
        body = body or ''
        request = urllib2.Request(url, data=body)
        request.add_header('Content-Type', content_type)
        request.add_header('Content-Length', len(body))
      elif method == 'POST':
        # Simply specifying data to urlopen makes it a POST.
        request = urllib2.Request(url, encoded_data)
      else:
        url_parts = list(urlparse.urlparse(url))
        url_parts[QUERY_INDEX] = encoded_data
        url = urlparse.urlunparse(url_parts)
        request = urllib2.Request(url)

      for header, value in (headers or {}).iteritems():
        request.add_header(header, value)
      url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()
    except urllib2.HTTPError as e:
      if e.code >= 500:
        # The HTTPError was due to a server error, so retry the attempt.
        logging.warning('UrlOpen(%s): attempt %d: %s ', url, attempt, e)
      else:
        # This HTTPError means we reached the server and there was a problem
        # with the request, so don't retry.
        logging.exception('UrlOpen(%s): %s', url, e)
        return None
    except (httplib.HTTPException, socket.error, urllib2.URLError) as e:
      logging.warning('UrlOpen(%s): attempt %d: %s', url, attempt, e)

    if url_response is not None:
      logging.info('UrlOpen(%s) got %d bytes.', url, len(url_response))
      return url_response
    elif attempt != max_tries - 1:
      # Only sleep if we are going to try and connect again.
      if wait_duration is None:
        duration = random.random() * 3 + math.pow(1.5, (attempt + 1))
        duration = min(10, max(0.1, duration))
      else:
        duration = wait_duration

      time.sleep(duration)

  logging.error('UrlOpen(%s): Unable to open after %d attempts', url, max_tries)
  return None


def DownloadFile(local_file, url):
  """"""Downloads the data from the given url and saves it in the local_file.

  Args:
    local_file: Where to save the data downloaded from the url.
    url: Where to fetch the data from.

  Returns:
    True if the file is successfully downloaded.
  """"""
  local_file = os.path.abspath(local_file)

  url_data = UrlOpen(url, method='GET')

  if url_data is None:
    return False

  try:
    with open(local_file, 'wb') as f:
      f.write(url_data)
  except IOError as e:
    logging.error('Failed to write to %s\n%s', local_file, e)
    return False

  return True


def _ConvertToAscii(value):
  """"""Convert the given value to an ascii string.

  Args:
    value: The value to convert.

  Returns:
    The value as an ascii string.
  """"""
  if isinstance(value, str):
    return value
  if isinstance(value, unicode):
    return value.encode('utf-8')

  return str(value)


def EncodeMultipartFormData(fields=None, files=None):
  """"""Encodes a Multipart form data object.

  This recipe is taken from http://code.activestate.com/recipes/146306/,
  although it has been slighly modified.

  Args:
    fields: a sequence (name, value) elements for
      regular form fields.
    files: a sequence of (name, filename, value) elements for data to be
      uploaded as files.

  Returns:
    content_type: for httplib.HTTP instance
    body: for httplib.HTTP instance
  """"""
  fields = fields or []
  files = files or []

  boundary = hashlib.md5(str(time.time())).hexdigest()
  body_list = []
  for (key, value) in fields:
    key = _ConvertToAscii(key)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""' % key)
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  for (key, filename, value) in files:
    key = _ConvertToAscii(key)
    filename = _ConvertToAscii(filename)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""; '
                     'filename=""%s""' % (key, filename))
    # Other contents types are possible, but swarm is currently only using
    # this type.
    body_list.append('Content-Type: application/octet-stream')
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  if len(body_list) > 1:
    body_list[-2] += '--'

  body = '\r\n'.join(body_list)
  content_type = 'multipart/form-data; boundary=%s' % boundary

  return content_type, body
/n/n/nservices/swarming/swarm_bot/url_helper_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Unittest to exercise the code in url_helper.py.""""""


import logging
import os
import stat
import StringIO
import sys
import tempfile
import time
import unittest
import urllib
import urllib2

ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, ROOT_DIR)

import test_env

test_env.setup_test_env()

from depot_tools import auto_stub
from third_party.mox import mox

import url_helper  # pylint: disable=W0403


class UrlHelperTest(auto_stub.TestCase):
  def setUp(self):
    self._mox = mox.Mox()

    self.mock(logging, 'error', lambda *_: None)
    self.mock(logging, 'exception', lambda *_: None)
    self.mock(logging, 'info', lambda *_: None)
    self.mock(logging, 'warning', lambda *_: None)
    self._mox.StubOutWithMock(time, 'sleep')
    self._mox.StubOutWithMock(urllib2, 'urlopen')

  def tearDown(self):
    self._mox.UnsetStubs()

  def testXsrfRemoteGET(self):
    def assert_url(url):
      def has_url(req):
        self.assertEqual(url, req.get_full_url())
        return True
      return mox.Func(has_url)

    url_helper.urllib2.urlopen(
        assert_url('http://localhost/a?UrlOpenAttempt=0'),
        timeout=300).AndReturn(StringIO.StringIO('foo'))
    self._mox.ReplayAll()

    remote = url_helper.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a', method='GET'))
    self._mox.VerifyAll()

  def testXsrfRemoteSimple(self):
    def assert_url(url):
      def has_url(req):
        self.assertEqual(url, req.get_full_url())
        return True
      return mox.Func(has_url)

    xsrf_url = (
      'http://localhost/auth/api/v1/accounts/self/xsrf_token?UrlOpenAttempt=0')
    url_helper.urllib2.urlopen(
        assert_url(xsrf_url), timeout=300).AndReturn(StringIO.StringIO('token'))
    url_helper.urllib2.urlopen(
        assert_url('http://localhost/a'),
        timeout=300).AndReturn(StringIO.StringIO('foo'))
    self._mox.ReplayAll()

    remote = url_helper.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))
    self._mox.VerifyAll()

  def testXsrfRemoteRefresh(self):
    self._mox.StubOutWithMock(url_helper, 'UrlOpen')

    url_helper.UrlOpen(
        'http://localhost/auth/api/v1/accounts/self/xsrf_token',
        max_tries=40, method='GET').AndReturn('token')
    url_helper.UrlOpen(
        'http://localhost/a', data={'foo': 'bar'}, max_tries=40,
        headers={'X-XSRF-Token': 'token'}
        ).AndReturn(None)
    url_helper.UrlOpen(
        'http://localhost/auth/api/v1/accounts/self/xsrf_token',
        max_tries=40, method='GET').AndReturn('token2')
    url_helper.UrlOpen(
        'http://localhost/a', data={'foo': 'bar'}, max_tries=40,
        headers={'X-XSRF-Token': 'token2'}
        ).AndReturn('foo')
    self._mox.ReplayAll()

    remote = url_helper.XsrfRemote('http://localhost/')
    remote.url_read('/a', data={'foo': 'bar'})
    #self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))
    self._mox.VerifyAll()

  def testUrlOpenInvalidTryCount(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenInvalidWaitDuration(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', wait_duration=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenGETSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='GET'), response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POST'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTFORMSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(
        mox.IsA(urllib2.Request), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POSTFORM'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenSuccessAfterFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    time.sleep(mox.IgnoreArg())
    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=2), response)

    self._mox.VerifyAll()

  def testUrlOpenFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    self._mox.ReplayAll()

    self.assertIsNone(url_helper.UrlOpen('url', max_tries=1))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorNoRetry(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 400, 'error message', None, None))
    self._mox.ReplayAll()

    # Even though we set max_tries to 10, we should only try once since
    # we get an HTTPError.
    self.assertIsNone(url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorWithRetry(self):
    response = 'response'

    # Urlopen failure attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 500, 'error message', None, None))
    time.sleep(mox.IgnoreArg())

    # Urlopen success attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    # Since the HTTPError was a server error, we should retry and get the
    # desired response after the error.
    self.assertEqual(response, url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testEnsureCountKeyIncludedInOpen(self):
    def assert_data(url):
      def has_data(req):
        self.assertEqual(url, req.get_data())
        return True
      return mox.Func(has_data)

    attempts = 5
    for i in range(attempts):
      encoded_data = urllib.urlencode({url_helper.swarm_constants.COUNT_KEY: i})
      url_helper.urllib2.urlopen(
          assert_data(encoded_data), timeout=mox.IgnoreArg()).AndRaise(
              urllib2.URLError('url'))
      if i != attempts - 1:
        time.sleep(mox.IgnoreArg())
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=attempts), None)
    self._mox.VerifyAll()

  def testCountKeyInData(self):
    data = {url_helper.swarm_constants.COUNT_KEY: 1}
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', data=data), None)
    self._mox.VerifyAll()

  def testNonAcsiiData(self):
    data = {'r': u'not ascii \xa3 \u04bb'}
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, data=data), response)

    self._mox.VerifyAll()

  def testDownloadFile(self):
    local_file = None
    try:
      local_file = tempfile.NamedTemporaryFile(delete=False)
      local_file.close()

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      file_data = 'data'
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(file_data)
      self._mox.ReplayAll()

      self.assertTrue(url_helper.DownloadFile(local_file.name,
                                              'http://www.fakeurl.com'))
      with open(local_file.name) as f:
        self.assertEqual(file_data, f.read())

      self._mox.VerifyAll()
    finally:
      if local_file:
        os.remove(local_file.name)

  def testDownloadFileDownloadError(self):
    try:
      fake_file = 'fake_local_file.fake'

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(None)
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(fake_file,
                                               'http://www.fakeurl.com'))
      self._mox.VerifyAll()
    finally:
      if os.path.exists(fake_file):
        os.remove(fake_file)

  def testDownloadFileSavingErrors(self):
    file_readonly = None
    try:
      file_readonly = tempfile.NamedTemporaryFile(delete=False)
      file_readonly.close()
      os.chmod(file_readonly.name, stat.S_IREAD)

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')

      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn('data')
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(file_readonly.name,
                                               'http://www.fakeurl.com'))

      self._mox.VerifyAll()
    finally:
      if file_readonly:
        os.remove(file_readonly.name)

  def testEncodeMultipartFormData(self):
    fields = [('x', 'y'), (1, 2)]
    files = [('key', 'filename', 'file data')]

    # Ensure that EncodeMultipartFormData works with any combination of fields
    # and files.
    content_type, body = url_helper.EncodeMultipartFormData()
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertEqual('', body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""key""; filename=""filename""' in body, body)
    self.assertTrue('file data' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields,
                                                            files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)


if __name__ == '__main__':
  # We don't want the application logs to interfere with our own messages.
  # You can comment it out for more information when debugging.
  logging.disable(logging.FATAL)
  unittest.main()
/n/n/n",0
79,7b18349622ca2f78a4aeb14ba2eb1e7fc224911d,"/services/swarming/swarm_bot/url_helper.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""A helper script for wrapping url calls.""""""

import hashlib
import httplib
import logging
import math
import os
import random
import socket
import time
import urllib
import urllib2
import urlparse

from common import swarm_constants  # pylint: disable=W0403


# The index of the query elements from urlparse.
QUERY_INDEX = 4

# The timeout to apply whenever opening a url.
URL_OPEN_TIMEOUT = 5 * 60


def UrlOpen(url, data=None, files=None, max_tries=5, wait_duration=None,
            method='POST'):
  """"""Attempts to open the given url multiple times.

  UrlOpen will attempt to open the the given url several times, stopping
  if it succeeds at reaching the url. It also includes an additional data pair
  in the data that is sent to indicate how many times it has attempted to
  connect so far.

  Args:
    url: The url to open.
    data: The unencoded data to send to the url. This must be a mapping object.
    files: Files to upload with the url, in the format (key, filename, value).
        This is only valid when the method is POSTFORM.
    max_tries: The maximum number of times to try sending this data. Must be
        greater than 0.
    wait_duration: The number of seconds to wait between successive attempts.
        This must be greater than or equal to 0. If no value is given then a
        random value between 0.1 and 10 will be chosen each time (with
        exponential back off to give later retries a longer wait).
    method: Indicates if the request should be a GET or POST request.

  Returns:
    The reponse from the url contacted. If it failed to connect or is given
    invalid arguments, then it returns None.
  """"""
  if max_tries <= 0:
    logging.error('UrlOpen(%s): Invalid number of tries: %d', url, max_tries)
    return None

  if wait_duration and wait_duration < 0:
    logging.error('UrlOpen(%s): Invalid wait duration: %d', url, wait_duration)
    return None

  data = data or {}

  if swarm_constants.COUNT_KEY in data:
    logging.error(
        'UrlOpen(%s): key \'%s\' is duplicate.', url, swarm_constants.COUNT_KEY)
    return None

  url_response = None
  for attempt in range(max_tries):
    data[swarm_constants.COUNT_KEY] = attempt
    try:
      # urlencode requires that all strings be in ASCII form.
      for key, value in data.iteritems():
        if isinstance(value, basestring):
          data[key] = value.encode('utf-8', 'xmlcharrefreplace')

      encoded_data = urllib.urlencode(data)

      if method == 'POSTFORM':
        content_type, body = EncodeMultipartFormData(fields=data.iteritems(),
                                                     files=files)
        # We must ensure body isn't None to ensure the request is a POST.
        body = body or ''
        request = urllib2.Request(url, data=body)
        request.add_header('Content-Type', content_type)
        request.add_header('Content-Length', len(body))

        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()
      elif method == 'POST':
        # Simply specifying data to urlopen makes it a POST.
        url_response = urllib2.urlopen(url, encoded_data,
                                       timeout=URL_OPEN_TIMEOUT).read()
      else:
        url_parts = list(urlparse.urlparse(url))
        url_parts[QUERY_INDEX] = encoded_data
        url = urlparse.urlunparse(url_parts)
        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()
    except urllib2.HTTPError as e:
      if e.code >= 500:
        # The HTTPError was due to a server error, so retry the attempt.
        logging.warning('UrlOpen(%s): attempt %d: %s ', url, attempt, e)
      else:
        # This HTTPError means we reached the server and there was a problem
        # with the request, so don't retry.
        logging.exception('UrlOpen(%s): %s', url, e)
        return None
    except (httplib.HTTPException, socket.error, urllib2.URLError) as e:
      logging.warning('UrlOpen(%s): attempt %d: %s', url, attempt, e)

    if url_response is not None:
      logging.info('UrlOpen(%s) got %d bytes.', url, len(url_response))
      return url_response
    elif attempt != max_tries - 1:
      # Only sleep if we are going to try and connect again.
      if wait_duration is None:
        duration = random.random() * 3 + math.pow(1.5, (attempt + 1))
        duration = min(10, max(0.1, duration))
      else:
        duration = wait_duration

      time.sleep(duration)

  logging.error('UrlOpen(%s): Unable to open after %d attempts', url, max_tries)
  return None


def DownloadFile(local_file, url):
  """"""Downloads the data from the given url and saves it in the local_file.

  Args:
    local_file: Where to save the data downloaded from the url.
    url: Where to fetch the data from.

  Returns:
    True if the file is successfully downloaded.
  """"""
  local_file = os.path.abspath(local_file)

  url_data = UrlOpen(url, method='GET')

  if url_data is None:
    return False

  try:
    with open(local_file, 'wb') as f:
      f.write(url_data)
  except IOError as e:
    logging.error('Failed to write to %s\n%s', local_file, e)
    return False

  return True


def _ConvertToAscii(value):
  """"""Convert the given value to an ascii string.

  Args:
    value: The value to convert.

  Returns:
    The value as an ascii string.
  """"""
  if isinstance(value, str):
    return value
  if isinstance(value, unicode):
    return value.encode('utf-8')

  return str(value)


def EncodeMultipartFormData(fields=None, files=None):
  """"""Encodes a Multipart form data object.

  This recipe is taken from http://code.activestate.com/recipes/146306/,
  although it has been slighly modified.

  Args:
    fields: a sequence (name, value) elements for
      regular form fields.
    files: a sequence of (name, filename, value) elements for data to be
      uploaded as files.

  Returns:
    content_type: for httplib.HTTP instance
    body: for httplib.HTTP instance
  """"""
  fields = fields or []
  files = files or []

  boundary = hashlib.md5(str(time.time())).hexdigest()
  body_list = []
  for (key, value) in fields:
    key = _ConvertToAscii(key)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""' % key)
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  for (key, filename, value) in files:
    key = _ConvertToAscii(key)
    filename = _ConvertToAscii(filename)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""; '
                     'filename=""%s""' % (key, filename))
    # Other contents types are possible, but swarm is currently only using
    # this type.
    body_list.append('Content-Type: application/octet-stream')
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  if len(body_list) > 1:
    body_list[-2] += '--'

  body = '\r\n'.join(body_list)
  content_type = 'multipart/form-data; boundary=%s' % boundary

  return content_type, body
/n/n/n/services/swarming/swarm_bot/url_helper_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Unittest to exercise the code in url_helper.py.""""""


import logging
import os
import stat
import StringIO
import sys
import tempfile
import time
import unittest
import urllib
import urllib2

ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, ROOT_DIR)

import test_env

test_env.setup_test_env()

from depot_tools import auto_stub
from third_party.mox import mox

import url_helper  # pylint: disable=W0403


class UrlHelperTest(auto_stub.TestCase):
  def setUp(self):
    self._mox = mox.Mox()

    self.mock(logging, 'error', lambda *_: None)
    self.mock(logging, 'exception', lambda *_: None)
    self.mock(logging, 'info', lambda *_: None)
    self.mock(logging, 'warning', lambda *_: None)
    self._mox.StubOutWithMock(time, 'sleep')
    self._mox.StubOutWithMock(urllib2, 'urlopen')

  def tearDown(self):
    self._mox.UnsetStubs()

  def testUrlOpenInvalidTryCount(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenInvalidWaitDuration(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', wait_duration=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenGETSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.StrContains(url),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='GET'), response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POST'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTFORMSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(
        mox.IsA(urllib2.Request), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POSTFORM'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenSuccessAfterFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    time.sleep(mox.IgnoreArg())
    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=2), response)

    self._mox.VerifyAll()

  def testUrlOpenFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    self._mox.ReplayAll()

    self.assertIsNone(url_helper.UrlOpen('url', max_tries=1))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorNoRetry(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 400, 'error message', None, None))
    self._mox.ReplayAll()

    # Even though we set max_tries to 10, we should only try once since
    # we get an HTTPError.
    self.assertIsNone(url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorWithRetry(self):
    response = 'response'

    # Urlopen failure attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 500, 'error message', None, None))
    time.sleep(mox.IgnoreArg())

    # Urlopen success attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    # Since the HTTPError was a server error, we should retry and get the
    # desired response after the error.
    self.assertEqual(response, url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testEnsureCountKeyIncludedInOpen(self):
    attempts = 5
    for i in range(attempts):
      encoded_data = urllib.urlencode({url_helper.swarm_constants.COUNT_KEY: i})

      url_helper.urllib2.urlopen(
          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(
              urllib2.URLError('url'))
      if i != attempts - 1:
        time.sleep(mox.IgnoreArg())
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=attempts), None)
    self._mox.VerifyAll()

  def testCountKeyInData(self):
    data = {url_helper.swarm_constants.COUNT_KEY: 1}
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', data=data), None)
    self._mox.VerifyAll()

  def testNonAcsiiData(self):
    data = {'r': u'not ascii \xa3 \u04bb'}
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, data=data), response)

    self._mox.VerifyAll()

  def testDownloadFile(self):
    local_file = None
    try:
      local_file = tempfile.NamedTemporaryFile(delete=False)
      local_file.close()

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      file_data = 'data'
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(file_data)
      self._mox.ReplayAll()

      self.assertTrue(url_helper.DownloadFile(local_file.name,
                                              'http://www.fakeurl.com'))
      with open(local_file.name) as f:
        self.assertEqual(file_data, f.read())

      self._mox.VerifyAll()
    finally:
      if local_file:
        os.remove(local_file.name)

  def testDownloadFileDownloadError(self):
    try:
      fake_file = 'fake_local_file.fake'

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(None)
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(fake_file,
                                               'http://www.fakeurl.com'))
      self._mox.VerifyAll()
    finally:
      if os.path.exists(fake_file):
        os.remove(fake_file)

  def testDownloadFileSavingErrors(self):
    file_readonly = None
    try:
      file_readonly = tempfile.NamedTemporaryFile(delete=False)
      file_readonly.close()
      os.chmod(file_readonly.name, stat.S_IREAD)

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')

      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn('data')
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(file_readonly.name,
                                               'http://www.fakeurl.com'))

      self._mox.VerifyAll()
    finally:
      if file_readonly:
        os.remove(file_readonly.name)

  def testEncodeMultipartFormData(self):
    fields = [('x', 'y'), (1, 2)]
    files = [('key', 'filename', 'file data')]

    # Ensure that EncodeMultipartFormData works with any combination of fields
    # and files.
    content_type, body = url_helper.EncodeMultipartFormData()
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertEqual('', body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""key""; filename=""filename""' in body, body)
    self.assertTrue('file data' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields,
                                                            files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)


if __name__ == '__main__':
  # We don't want the application logs to interfere with our own messages.
  # You can comment it out for more information when debugging.
  logging.disable(logging.FATAL)
  unittest.main()
/n/n/n",1
80,0ba6a589d77baefc5ae20cde5c3a5dc24a6290f9,"appengine/components/components/auth/handler.py/n/n# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Integration with webapp2.""""""

# Disable 'Method could be a function.'
# pylint: disable=R0201

import functools
import json
import logging
import urllib
import webapp2

from google.appengine.api import urlfetch
from google.appengine.api import users

from components import utils

from . import api
from . import config
from . import delegation
from . import host_token
from . import ipaddr
from . import model
from . import openid
from . import tokens

# Part of public API of 'auth' component, exposed by this module.
__all__ = [
  'ApiHandler',
  'AuthenticatingHandler',
  'gae_cookie_authentication',
  'get_authenticated_routes',
  'oauth_authentication',
  'openid_cookie_authentication',
  'require_xsrf_token_request',
  'service_to_service_authentication',
]


def require_xsrf_token_request(f):
  """"""Use for handshaking APIs.""""""
  @functools.wraps(f)
  def hook(self, *args, **kwargs):
    if not self.request.headers.get('X-XSRF-Token-Request'):
      raise api.AuthorizationError('Missing required XSRF request header')
    return f(self, *args, **kwargs)
  return hook


class XSRFToken(tokens.TokenKind):
  """"""XSRF token parameters.""""""
  expiration_sec = 4 * 3600
  secret_key = api.SecretKey('xsrf_token', scope='local')
  version = 1


class AuthenticatingHandlerMetaclass(type):
  """"""Ensures that 'get', 'post', etc. are marked with @require or @public.""""""

  def __new__(mcs, name, bases, attributes):
    for method in webapp2.WSGIApplication.allowed_methods:
      func = attributes.get(method.lower())
      if func and not api.is_decorated(func):
        raise TypeError(
            'Method \'%s\' of \'%s\' is not protected by @require or @public '
            'decorator' % (method.lower(), name))
    return type.__new__(mcs, name, bases, attributes)


class AuthenticatingHandler(webapp2.RequestHandler):
  """"""Base class for webapp2 request handlers that use Auth system.

  Knows how to extract Identity from request data and how to initialize auth
  request context, so that get_current_identity() and is_group_member() work.

  All request handling methods (like 'get', 'post', etc) should be marked by
  either @require or @public decorators.
  """"""

  # Checks that all 'get', 'post', etc. are marked with @require or @public.
  __metaclass__ = AuthenticatingHandlerMetaclass

  # List of HTTP methods that trigger XSRF token validation.
  xsrf_token_enforce_on = ('DELETE', 'POST', 'PUT')
  # If not None, the header to search for XSRF token.
  xsrf_token_header = 'X-XSRF-Token'
  # If not None, the request parameter (GET or POST) to search for XSRF token.
  xsrf_token_request_param = 'xsrf_token'
  # Embedded data extracted from XSRF token of current request.
  xsrf_token_data = None
  # If not None, sets X_Frame-Options on all replies.
  frame_options = 'DENY'
  # A method used to authenticate this request, see get_auth_methods().
  auth_method = None

  def dispatch(self):
    """"""Extracts and verifies Identity, sets up request auth context.""""""
    # Ensure auth component is configured before executing any code.
    conf = config.ensure_configured()
    auth_context = api.reinitialize_request_cache()

    # http://www.html5rocks.com/en/tutorials/security/content-security-policy/
    # https://www.owasp.org/index.php/Content_Security_Policy
    # TODO(maruel): Remove 'unsafe-inline' once all inline style=""foo:bar"" in
    # all HTML tags were removed. Warning if seeing this post 2016, it could
    # take a while.
    # - https://www.google.com is due to Google Viz library.
    # - https://www.google-analytics.com due to Analytics.
    # - 'unsafe-eval' due to polymer.
    self.response.headers['Content-Security-Policy'] = (
        'default-src https: \'self\' \'unsafe-inline\' https://www.google.com '
        'https://www.google-analytics.com \'unsafe-eval\'')
    # Enforce HTTPS by adding the HSTS header; 365*24*60*60s.
    # https://www.owasp.org/index.php/HTTP_Strict_Transport_Security
    self.response.headers['Strict-Transport-Security'] = (
        'max-age=31536000; includeSubDomains; preload')
    # Disable frame support wholesale.
    # https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet
    if self.frame_options:
      self.response.headers['X-Frame-Options'] = self.frame_options

    identity = None
    for method_func in self.get_auth_methods(conf):
      try:
        identity = method_func(self.request)
        if identity:
          break
      except api.AuthenticationError as err:
        self.authentication_error(err)
        return
      except api.AuthorizationError as err:
        self.authorization_error(err)
        return
    else:
      method_func = None
    self.auth_method = method_func

    # If no authentication method is applicable, default to anonymous identity.
    identity = identity or model.Anonymous

    # XSRF token is required only if using Cookie based or IP whitelist auth.
    # A browser doesn't send Authorization: 'Bearer ...' or any other headers
    # by itself. So XSRF check is not required if header based authentication
    # is used.
    using_headers_auth = method_func in (
        oauth_authentication, service_to_service_authentication)

    # Extract caller host name from host token header, if present and valid.
    host_tok = self.request.headers.get(host_token.HTTP_HEADER)
    if host_tok:
      validated_host = host_token.validate_host_token(host_tok)
      if validated_host:
        auth_context.peer_host = validated_host

    # Verify IP is whitelisted and authenticate requests from bots.
    assert self.request.remote_addr
    ip = ipaddr.ip_from_string(self.request.remote_addr)
    auth_context.peer_ip = ip
    try:
      # 'verify_ip_whitelisted' may change identity for bots, store new one.
      auth_context.peer_identity = api.verify_ip_whitelisted(
          identity, ip, self.request.headers)
    except api.AuthorizationError as err:
      self.authorization_error(err)
      return

    # Parse delegation token, if given, to deduce end-user identity.
    delegation_tok = self.request.headers.get(delegation.HTTP_HEADER)
    if delegation_tok:
      try:
        auth_context.current_identity = delegation.check_delegation_token(
            delegation_tok, auth_context.peer_identity)
      except delegation.BadTokenError as exc:
        self.authorization_error(
            api.AuthorizationError('Bad delegation token: %s' % exc))
      except delegation.TransientError as exc:
        msg = 'Transient error while validating delegation token.\n%s' % exc
        logging.error(msg)
        self.abort(500, detail=msg)
    else:
      auth_context.current_identity = auth_context.peer_identity

    try:
      # Fail if XSRF token is required, but not provided.
      need_xsrf_token = (
          not using_headers_auth and
          self.request.method in self.xsrf_token_enforce_on)
      if need_xsrf_token and self.xsrf_token is None:
        raise api.AuthorizationError('XSRF token is missing')

      # If XSRF token is present, verify it is valid and extract its payload.
      # Do it even if XSRF token is not strictly required, since some handlers
      # use it to store session state (it is similar to a signed cookie).
      self.xsrf_token_data = {}
      if self.xsrf_token is not None:
        # This raises AuthorizationError if token is invalid.
        try:
          self.xsrf_token_data = self.verify_xsrf_token()
        except api.AuthorizationError as exc:
          if not need_xsrf_token:
            logging.warning('XSRF token is broken, ignoring - %s', exc)
          else:
            raise

      # All other ACL checks will be performed by corresponding handlers
      # manually or via '@required' decorator. Failed ACL check raises
      # AuthorizationError.
      super(AuthenticatingHandler, self).dispatch()
    except api.AuthorizationError as err:
      self.authorization_error(err)

  @classmethod
  def get_auth_methods(cls, conf):
    """"""Returns an enumerable of functions to use to authenticate request.

    The handler will try to apply auth methods sequentially one by one by until
    it finds one that works.

    Each auth method is a function that accepts webapp2.Request and can finish
    with 3 outcomes:

    * Return None: authentication method is not applicable to that request
      and next method should be tried (for example cookie-based
      authentication is not applicable when there's no cookies).

    * Returns Identity associated with the request. Means authentication method
      is applicable and request authenticity is confirmed.

    * Raises AuthenticationError: authentication method is applicable, but
      request contains bad credentials or invalid token, etc. For example,
      OAuth2 token is given, but it is revoked.

    A chosen auth method function will be stored in request's auth_method field.

    Args:
      conf: components.auth GAE config, see config.py.
    """"""
    if conf.USE_OPENID:
      cookie_auth = openid_cookie_authentication
    else:
      cookie_auth = gae_cookie_authentication
    return oauth_authentication, cookie_auth, service_to_service_authentication

  def generate_xsrf_token(self, xsrf_token_data=None):
    """"""Returns new XSRF token that embeds |xsrf_token_data|.

    The token is bound to current identity and is valid only when used by same
    identity.
    """"""
    return XSRFToken.generate(
        [api.get_current_identity().to_bytes()], xsrf_token_data)

  @property
  def xsrf_token(self):
    """"""Returns XSRF token passed with the request or None if missing.

    Doesn't do any validation. Use verify_xsrf_token() instead.
    """"""
    token = None
    if self.xsrf_token_header:
      token = self.request.headers.get(self.xsrf_token_header)
    if not token and self.xsrf_token_request_param:
      param = self.request.get_all(self.xsrf_token_request_param)
      token = param[0] if param else None
    return token

  def verify_xsrf_token(self):
    """"""Grabs a token from the request, validates it and extracts embedded data.

    Current identity must be the same as one used to generate the token.

    Returns:
      Whatever was passed as |xsrf_token_data| in 'generate_xsrf_token'
      method call used to generate the token.

    Raises:
      AuthorizationError if token is missing, invalid or expired.
    """"""
    token = self.xsrf_token
    if not token:
      raise api.AuthorizationError('XSRF token is missing')
    # Check that it was generated for the same identity.
    try:
      return XSRFToken.validate(token, [api.get_current_identity().to_bytes()])
    except tokens.InvalidTokenError as err:
      raise api.AuthorizationError(str(err))

  def authentication_error(self, error):
    """"""Called when authentication fails to report the error to requester.

    Authentication error means that some credentials are provided but they are
    invalid. If no credentials are provided at all, no authentication is
    attempted and current identity is just set to 'anonymous:anonymous'.

    Default behavior is to abort the request with HTTP 401 error (and human
    readable HTML body).

    Args:
      error: instance of AuthenticationError subclass.
    """"""
    logging.warning('Authentication error.\n%s', error)
    self.abort(401, detail=str(error))

  def authorization_error(self, error):
    """"""Called when authentication succeeds, but access to a resource is denied.

    Called whenever request handler raises AuthorizationError exception.
    In particular this exception is raised by method decorated with @require if
    current identity doesn't have required permission.

    Default behavior is to abort the request with HTTP 403 error (and human
    readable HTML body).

    Args:
      error: instance of AuthorizationError subclass.
    """"""
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort(403, detail=str(error))

  ### Wrappers around Users API or its OpenID equivalent.

  def get_current_user(self):
    """"""When cookie auth is used returns instance of CurrentUser or None.""""""
    return self._get_users_api().get_current_user(self.request)

  def is_current_user_gae_admin(self):
    """"""When cookie auth is used returns True if current caller is GAE admin.""""""
    return self._get_users_api().is_current_user_gae_admin(self.request)

  def create_login_url(self, dest_url):
    """"""When cookie auth is used returns URL to redirect user to login.""""""
    return self._get_users_api().create_login_url(self.request, dest_url)

  def create_logout_url(self, dest_url):
    """"""When cookie auth is used returns URL to redirect user to logout.""""""
    return self._get_users_api().create_logout_url(self.request, dest_url)

  def _get_users_api(self):
    """"""Returns GAEUsersAPI, OpenIDAPI or raises NotImplementedError.

    Chooses based on what auth_method was used of what methods are available.
    """"""
    method = self.auth_method
    if not method:
      # Anonymous request -> pick first method that supports API.
      for method in self.get_auth_methods(config.ensure_configured()):
        if method in _METHOD_TO_USERS_API:
          break
      else:
        raise NotImplementedError('No methods support UsersAPI')
    elif method not in _METHOD_TO_USERS_API:
      raise NotImplementedError(
          '%s doesn\'t support UsersAPI' % method.__name__)
    return _METHOD_TO_USERS_API[method]


class ApiHandler(AuthenticatingHandler):
  """"""Parses JSON request body to a dict, serializes response to JSON.""""""
  CONTENT_TYPE_BASE = 'application/json'
  CONTENT_TYPE_FULL = 'application/json; charset=utf-8'
  _json_body = None
  # Clickjacking not applicable to APIs.
  frame_options = None

  def authentication_error(self, error):
    logging.warning('Authentication error.\n%s', error)
    self.abort_with_error(401, text=str(error))

  def authorization_error(self, error):
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort_with_error(403, text=str(error))

  def send_response(self, response, http_code=200, headers=None):
    """"""Sends successful reply and continues execution.""""""
    self.response.set_status(http_code)
    self.response.headers.update(headers or {})
    self.response.headers['Content-Type'] = self.CONTENT_TYPE_FULL
    self.response.write(json.dumps(response))

  def abort_with_error(self, http_code, **kwargs):
    """"""Sends error reply and stops execution.""""""
    self.abort(
        http_code,
        json=kwargs,
        headers={'Content-Type': self.CONTENT_TYPE_FULL})

  def parse_body(self):
    """"""Parses JSON body and verifies it's a dict.

    webob.Request doesn't cache the decoded json body, this function does.
    """"""
    if self._json_body is None:
      if (self.CONTENT_TYPE_BASE and
          self.request.content_type != self.CONTENT_TYPE_BASE):
        msg = (
            'Expecting JSON body with content type \'%s\'' %
            self.CONTENT_TYPE_BASE)
        self.abort_with_error(400, text=msg)
      try:
        self._json_body = self.request.json
        if not isinstance(self._json_body, dict):
          raise ValueError()
      except (LookupError, ValueError):
        self.abort_with_error(400, text='Not a valid json dict body')
    return self._json_body.copy()


def get_authenticated_routes(app):
  """"""Given WSGIApplication returns list of routes that use authentication.

  Intended to be used only for testing.
  """"""
  # This code is adapted from router's __repr__ method (that enumerate
  # all routes for pretty-printing).
  routes = list(app.router.match_routes)
  routes.extend(
      v for k, v in app.router.build_routes.iteritems()
      if v not in app.router.match_routes)
  return [r for r in routes if issubclass(r.handler, AuthenticatingHandler)]


################################################################################
## All supported implementations of authentication methods for webapp2 handlers.


def gae_cookie_authentication(_request):
  """"""AppEngine cookie based authentication via users.get_current_user().""""""
  user = users.get_current_user()
  try:
    return model.Identity(model.IDENTITY_USER, user.email()) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email())


def openid_cookie_authentication(request):
  """"""Cookie based authentication that uses OpenID flow for login.""""""
  user = openid.get_current_user(request)
  try:
    return model.Identity(model.IDENTITY_USER, user.email) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email)


def oauth_authentication(request):
  """"""OAuth2 based authentication via oauth.get_current_user().""""""
  if not request.headers.get('Authorization'):
    return None
  if not utils.is_local_dev_server():
    return api.extract_oauth_caller_identity()

  # OAuth2 library is mocked on dev server to return some nonsense. Use (slow,
  # but real) OAuth2 API endpoint instead to validate access_token. It is also
  # what Cloud Endpoints do on a local server. For simplicity ignore client_id
  # on dev server.
  header = request.headers['Authorization'].split(' ', 1)
  if len(header) != 2 or header[0] not in ('OAuth', 'Bearer'):
    raise api.AuthenticationError('Invalid authorization header')

  # Adapted from endpoints/users_id_tokens.py, _set_bearer_user_vars_local.
  base_url = 'https://www.googleapis.com/oauth2/v1/tokeninfo'
  result = urlfetch.fetch(
      url='%s?%s' % (base_url, urllib.urlencode({'access_token': header[1]})),
      follow_redirects=False,
      validate_certificate=True)
  if result.status_code != 200:
    try:
      error = json.loads(result.content)['error_description']
    except (KeyError, ValueError):
      error = repr(result.content)
    raise api.AuthenticationError('Failed to validate the token: %s' % error)

  token_info = json.loads(result.content)
  if 'email' not in token_info:
    raise api.AuthenticationError('Token doesn\'t include an email address')
  if not token_info.get('verified_email'):
    raise api.AuthenticationError('Token email isn\'t verified')

  email = token_info['email']
  try:
    return model.Identity(model.IDENTITY_USER, email)
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % email)


def service_to_service_authentication(request):
  """"""Used for AppEngine <-> AppEngine communication.

  Relies on X-Appengine-Inbound-Appid header set by AppEngine itself. It can't
  be set by external users (with exception of admins).
  """"""
  app_id = request.headers.get('X-Appengine-Inbound-Appid')
  try:
    return model.Identity(model.IDENTITY_SERVICE, app_id) if app_id else None
  except ValueError:
    raise api.AuthenticationError('Unsupported application ID: %s' % app_id)


################################################################################
## API wrapper on top of Users API and OpenID API to make them similar.


class CurrentUser(object):
  """"""Mimics subset of GAE users.User object for ease of transition.

  Also adds .picture().
  """"""

  def __init__(self, user_id, email, picture):
    self._user_id = user_id
    self._email = email
    self._picture = picture

  def nickname(self):
    return self._email

  def email(self):
    return self._email

  def user_id(self):
    return self._user_id

  def picture(self):
    return self._picture

  def __unicode__(self):
    return unicode(self.nickname())

  def __str__(self):
    return str(self.nickname())


class GAEUsersAPI(object):
  @staticmethod
  def get_current_user(request):  # pylint: disable=unused-argument
    user = users.get_current_user()
    return CurrentUser(user.user_id(), user.email(), None) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return users.is_current_user_admin()

  @staticmethod
  def create_login_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_login_url(dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_logout_url(dest_url)


class OpenIDAPI(object):
  @staticmethod
  def get_current_user(request):
    user = openid.get_current_user(request)
    return CurrentUser(user.sub, user.email, user.picture) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return False

  @staticmethod
  def create_login_url(request, dest_url):
    return openid.create_login_url(request, dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):
    return openid.create_logout_url(request, dest_url)


# See AuthenticatingHandler._get_users_api().
_METHOD_TO_USERS_API = {
  gae_cookie_authentication: GAEUsersAPI,
  openid_cookie_authentication: OpenIDAPI,
}
/n/n/nappengine/components/components/auth/handler_test.py/n/n#!/usr/bin/env python
# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

# Disable 'Unused variable', 'Unused argument' and 'Method could be a function'.
# pylint: disable=W0612,W0613,R0201

import datetime
import json
import os
import sys
import unittest

from test_support import test_env
test_env.setup_test_env()

from google.appengine.api import oauth
from google.appengine.api import users

import webapp2
import webtest

from components import utils
from components.auth import api
from components.auth import delegation
from components.auth import handler
from components.auth import host_token
from components.auth import ipaddr
from components.auth import model
from components.auth.proto import delegation_pb2
from test_support import test_case


class AuthenticatingHandlerMetaclassTest(test_case.TestCase):
  """"""Tests for AuthenticatingHandlerMetaclass.""""""

  def test_good(self):
    # No request handling methods defined at all.
    class TestHandler1(handler.AuthenticatingHandler):
      def some_other_method(self):
        pass

    # @public is used.
    class TestHandler2(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        pass

    # @require is used.
    class TestHandler3(handler.AuthenticatingHandler):
      @api.require(lambda: True)
      def get(self):
        pass

  def test_bad(self):
    # @public or @require is missing.
    with self.assertRaises(TypeError):
      class TestHandler1(handler.AuthenticatingHandler):
        def get(self):
          pass


class AuthenticatingHandlerTest(test_case.TestCase):
  """"""Tests for AuthenticatingHandler class.""""""

  def setUp(self):
    super(AuthenticatingHandlerTest, self).setUp()
    # Reset global config of auth library before each test.
    api.reset_local_state()
    # Capture error and warning log messages.
    self.logged_errors = []
    self.mock(handler.logging, 'error',
        lambda *args, **kwargs: self.logged_errors.append((args, kwargs)))
    self.logged_warnings = []
    self.mock(handler.logging, 'warning',
        lambda *args, **kwargs: self.logged_warnings.append((args, kwargs)))

  def make_test_app(self, path, request_handler):
    """"""Returns webtest.TestApp with single route.""""""
    return webtest.TestApp(
        webapp2.WSGIApplication([(path, request_handler)], debug=True),
        extra_environ={'REMOTE_ADDR': '127.0.0.1'})

  def test_anonymous(self):
    """"""If all auth methods are not applicable, identity is set to Anonymous.""""""
    test = self

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        non_applicable = lambda _request: None
        return [non_applicable, non_applicable]

      @api.public
      def get(self):
        test.assertEqual(model.Anonymous, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)

  def test_ip_whitelist_bot(self):
    """"""Requests from client in ""bots"" IP whitelist are authenticated as bot.""""""
    model.bootstrap_ip_whitelist('bots', ['192.168.1.100/32'])

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_current_identity().to_bytes())

    app = self.make_test_app('/request', Handler)
    def call(ip):
      api.reset_local_state()
      return app.get('/request', extra_environ={'REMOTE_ADDR': ip}).body

    self.assertEqual('bot:whitelisted-ip', call('192.168.1.100'))
    self.assertEqual('anonymous:anonymous', call('127.0.0.1'))

  def test_ip_whitelist(self):
    """"""Per-account IP whitelist works.""""""
    ident1 = model.Identity(model.IDENTITY_USER, 'a@example.com')
    ident2 = model.Identity(model.IDENTITY_USER, 'b@example.com')

    model.bootstrap_ip_whitelist('whitelist', ['192.168.1.100/32'])
    model.bootstrap_ip_whitelist_assignment(ident1, 'whitelist')

    mocked_ident = [None]

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _req: mocked_ident[0]]

      @api.public
      def get(self):
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    def call(ident, ip):
      api.reset_local_state()
      mocked_ident[0] = ident
      response = app.get(
          '/request', extra_environ={'REMOTE_ADDR': ip}, expect_errors=True)
      return response.status_int

    # IP is whitelisted.
    self.assertEqual(200, call(ident1, '192.168.1.100'))
    # IP is NOT whitelisted.
    self.assertEqual(403, call(ident1, '127.0.0.1'))
    # Whitelist is not used.
    self.assertEqual(200, call(ident2, '127.0.0.1'))

  def test_auth_method_order(self):
    """"""Registered auth methods are tested in order.""""""
    test = self
    calls = []
    ident = model.Identity(model.IDENTITY_USER, 'joe@example.com')

    def not_applicable(request):
      self.assertEqual('/request', request.path)
      calls.append('not_applicable')
      return None

    def applicable(request):
      self.assertEqual('/request', request.path)
      calls.append('applicable')
      return ident

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [not_applicable, applicable]

      @api.public
      def get(self):
        test.assertEqual(ident, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)

    # Both methods should be tried.
    expected_calls = [
      'not_applicable',
      'applicable',
    ]
    self.assertEqual(expected_calls, calls)

  def test_authentication_error(self):
    """"""AuthenticationError in auth method stops request processing.""""""
    test = self
    calls = []

    def failing(request):
      raise api.AuthenticationError('Too bad')

    def skipped(request):
      self.fail('authenticate should not be called')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [failing, skipped]

      @api.public
      def get(self):
        test.fail('Handler code should not be called')

      def authentication_error(self, err):
        test.assertEqual('Too bad', err.message)
        calls.append('authentication_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authentication_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 401.
    self.assertEqual(['authentication_error'], calls)
    self.assertEqual(401, response.status_int)

    # Authentication error is logged.
    self.assertEqual(1, len(self.logged_warnings))

  def test_authorization_error(self):
    """"""AuthorizationError in auth method is handled.""""""
    test = self
    calls = []

    class Handler(handler.AuthenticatingHandler):
      @api.require(lambda: False)
      def get(self):
        test.fail('Handler code should not be called')

      def authorization_error(self, err):
        calls.append('authorization_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authorization_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 403.
    self.assertEqual(['authorization_error'], calls)
    self.assertEqual(403, response.status_int)

  def make_xsrf_handling_app(
      self,
      xsrf_token_enforce_on=None,
      xsrf_token_header=None,
      xsrf_token_request_param=None):
    """"""Returns webtest app with single XSRF-aware handler.

    If generates XSRF tokens on GET and validates them on POST, PUT, DELETE.
    """"""
    calls = []

    def record(request_handler, method):
      is_valid = request_handler.xsrf_token_data == {'some': 'data'}
      calls.append((method, is_valid))

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(self.generate_xsrf_token({'some': 'data'}))
      @api.public
      def post(self):
        record(self, 'POST')
      @api.public
      def put(self):
        record(self, 'PUT')
      @api.public
      def delete(self):
        record(self, 'DELETE')

    if xsrf_token_enforce_on is not None:
      Handler.xsrf_token_enforce_on = xsrf_token_enforce_on
    if xsrf_token_header is not None:
      Handler.xsrf_token_header = xsrf_token_header
    if xsrf_token_request_param is not None:
      Handler.xsrf_token_request_param = xsrf_token_request_param

    app = self.make_test_app('/request', Handler)
    return app, calls

  def mock_get_current_identity(self, ident):
    """"""Mocks api.get_current_identity() to return |ident|.""""""
    self.mock(handler.api, 'get_current_identity', lambda: ident)

  def test_xsrf_token_get_param(self):
    """"""XSRF token works if put in GET parameters.""""""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request?xsrf_token=%s' % token)
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_post_param(self):
    """"""XSRF token works if put in POST parameters.""""""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_header(self):
    """"""XSRF token works if put in the headers.""""""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', headers={'X-XSRF-Token': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_missing(self):
    """"""XSRF token is not given but handler requires it.""""""
    app, calls = self.make_xsrf_handling_app()
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)
    self.assertFalse(calls)

  def test_xsrf_token_uses_enforce_on(self):
    """"""Only methods set in |xsrf_token_enforce_on| require token validation.""""""
    # Validate tokens only on PUT (not on POST).
    app, calls = self.make_xsrf_handling_app(xsrf_token_enforce_on=('PUT',))
    token = app.get('/request').body
    # Both POST and PUT work when token provided, verifying it.
    app.post('/request', {'xsrf_token': token})
    app.put('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True), ('PUT', True)], calls)
    # POST works without a token, put PUT doesn't.
    self.assertEqual(200, app.post('/request').status_int)
    self.assertEqual(403, app.put('/request', expect_errors=True).status_int)
    # Only the one that requires the token fails if wrong token is provided.
    bad_token = {'xsrf_token': 'boo'}
    self.assertEqual(200, app.post('/request', bad_token).status_int)
    self.assertEqual(
        403, app.put('/request', bad_token, expect_errors=True).status_int)

  def test_xsrf_token_uses_xsrf_token_header(self):
    """"""Name of the header used for XSRF can be changed.""""""
    app, calls = self.make_xsrf_handling_app(xsrf_token_header='X-Some')
    token = app.get('/request').body
    app.post('/request', headers={'X-Some': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_uses_xsrf_token_request_param(self):
    """"""Name of the request param used for XSRF can be changed.""""""
    app, calls = self.make_xsrf_handling_app(xsrf_token_request_param='tok')
    token = app.get('/request').body
    app.post('/request', {'tok': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_identity_matters(self):
    app, calls = self.make_xsrf_handling_app()
    # Generate token for identity A.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'a@example.com'))
    token = app.get('/request').body
    # Try to use it by identity B.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'b@example.com'))
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)
    self.assertFalse(calls)

  def test_get_authenticated_routes(self):
    class Authenticated(handler.AuthenticatingHandler):
      pass

    class NotAuthenticated(webapp2.RequestHandler):
      pass

    app = webapp2.WSGIApplication([
      webapp2.Route('/authenticated', Authenticated),
      webapp2.Route('/not-authenticated', NotAuthenticated),
    ])
    routes = handler.get_authenticated_routes(app)
    self.assertEqual(1, len(routes))
    self.assertEqual(Authenticated, routes[0].handler)

  def test_get_peer_ip(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(ipaddr.ip_to_string(api.get_peer_ip()))

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', extra_environ={'REMOTE_ADDR': '192.1.2.3'})
    self.assertEqual('192.1.2.3', response.body)

  def test_get_peer_host(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_peer_host() or '<none>')

    app = self.make_test_app('/request', Handler)
    def call(headers):
      api.reset_local_state()
      return app.get('/request', headers=headers).body

    # Good token.
    token = host_token.create_host_token('HOST.domain.com')
    self.assertEqual('host.domain.com', call({'X-Host-Token-V1': token}))

    # Missing or invalid tokens.
    self.assertEqual('<none>', call({}))
    self.assertEqual('<none>', call({'X-Host-Token-V1': 'broken'}))

    # Expired token.
    origin = datetime.datetime(2014, 1, 1, 1, 1, 1)
    self.mock_now(origin)
    token = host_token.create_host_token('HOST.domain.com', expiration_sec=60)
    self.mock_now(origin, 61)
    self.assertEqual('<none>', call({'X-Host-Token-V1': token}))

  def test_delegation_token(self):
    peer_ident = model.Identity.from_bytes('user:peer@a.com')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _request: peer_ident]

      @api.public
      def get(self):
        self.response.write(json.dumps({
          'peer_id': api.get_peer_identity().to_bytes(),
          'cur_id': api.get_current_identity().to_bytes(),
        }))

    app = self.make_test_app('/request', Handler)
    def call(headers=None):
      return json.loads(app.get('/request', headers=headers).body)

    # No delegation.
    self.assertEqual(
        {u'cur_id': u'user:peer@a.com', u'peer_id': u'user:peer@a.com'}, call())

    # TODO(vadimsh): Mint token via some high-level function call.
    subtokens = delegation_pb2.SubtokenList(subtokens=[
        delegation_pb2.Subtoken(
            issuer_id='user:delegated@a.com',
            creation_time=int(utils.time_time()),
            validity_duration=3600),
    ])
    tok = delegation.serialize_token(delegation.seal_token(subtokens))

    # With valid delegation token.
    self.assertEqual(
        {u'cur_id': u'user:delegated@a.com', u'peer_id': u'user:peer@a.com'},
        call({'X-Delegation-Token-V1': tok}))

    # With invalid delegation token.
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok + 'blah'},
        expect_errors=True)
    self.assertEqual(403, r.status_int)

    # Transient error.
    def mocked_check(*_args):
      raise delegation.TransientError('Blah')
    self.mock(delegation, 'check_delegation_token', mocked_check)
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok},
        expect_errors=True)
    self.assertEqual(500, r.status_int)


class GaeCookieAuthenticationTest(test_case.TestCase):
  """"""Tests for gae_cookie_authentication function.""""""

  def test_non_applicable(self):
    self.assertIsNone(handler.gae_cookie_authentication(webapp2.Request({})))

  def test_applicable(self):
    os.environ.update({
      'USER_EMAIL': 'joe@example.com',
      'USER_ID': '123',
      'USER_IS_ADMIN': '0',
    })
    # Actual request is not used by CookieAuthentication.
    self.assertEqual(
        model.Identity(model.IDENTITY_USER, 'joe@example.com'),
        handler.gae_cookie_authentication(webapp2.Request({})))


class ServiceToServiceAuthenticationTest(test_case.TestCase):
  """"""Tests for service_to_service_authentication.""""""

  def test_non_applicable(self):
    request = webapp2.Request({})
    self.assertIsNone(
        handler.service_to_service_authentication(request))

  def test_applicable(self):
    request = webapp2.Request({
      'HTTP_X_APPENGINE_INBOUND_APPID': 'some-app',
    })
    self.assertEqual(
      model.Identity(model.IDENTITY_SERVICE, 'some-app'),
      handler.service_to_service_authentication(request))


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  unittest.main()
/n/n/nappengine/components/components/auth/model.py/n/n# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""NDB model classes used to model AuthDB relations.

Overview
--------

Models defined here are used by central authentication service (that stores all
groups and secrets) and by services that implement some concrete functionality
protected with ACLs (like isolate and swarming services).

Applications that use auth component may work in 3 modes:
  1. Standalone. Application is self contained and manages its own groups.
     Useful when developing a new service or for simple installations.
  2. Replica. Application uses a central authentication service. An application
     can be dynamically switched from Standalone to Replica mode.
  3. Primary. Application IS a central authentication service. Only 'auth'
     service is running in this mode. 'configure_as_primary' call during startup
     switches application to that mode.

Central authentication service (Primary) holds authoritative copy of all auth
related information (groups, secrets, etc.) and acts as a single source of truth
for it. All other services (Replicas) hold copies of a relevant subset of
this information (that they use to perform authorization checks).

Primary service is responsible for updating replicas' configuration via
service-to-service push based replication protocol.

AuthDB holds a list of groups. Each group has a unique name and is defined
as union of 3 sets:
  1) Explicit enumeration of particular Identities e.g. 'user:alice@example.com'
  2) Set of glob-like identity patterns e.g. 'user:*@example.com'
  3) Set of nested Groups.

Identity defines an actor making an action (it can be a real person, a bot,
an AppEngine application or special 'anonymous' identity).

In addition to that, AuthDB stores small amount of authentication related
configuration data, such as OAuth2 client_id and client_secret and various
secret keys.

Audit trail
-----------

Each change to AuthDB has an associated revision number (that monotonically
increases with each change). All entities modified by a change are copied to
append-only log under an entity key associated with the revision (see
historical_revision_key below). Removals are marked by special auth_db_deleted
flag in entites in the log. This is enough to recover a snapshot of all groups
at some specific moment in time, or to produce a diff between two revisions.

Note that entities in the historical log are not used by online queries. At any
moment in time most recent version of an AuthDB entity exists in two copies:
  1) Main copy used for online queries. It is mutated in-place with each change.
  2) Most recent record in the historical log. Read only.

To reduce a possibility of misuse of historical copies in online transactions,
history log entity classes are suffixied with 'History' suffix. They also have
all indexes stripped.

This mechanism is enabled only on services in Standalone or Primary mode.
Replicas do not keep track of AuthDB revisions and do not keep any historical
log.
""""""

import collections
import fnmatch
import logging
import os
import re

from google.appengine.api import app_identity
from google.appengine.ext import ndb

from components import datastore_utils
from components import utils

from . import ipaddr

# Part of public API of 'auth' component, exposed by this module.
__all__ = [
  'ADMIN_GROUP',
  'Anonymous',
  'bootstrap_group',
  'bootstrap_ip_whitelist',
  'bootstrap_loopback_ips',
  'BOTS_IP_WHITELIST',
  'configure_as_primary',
  'find_group_dependency_cycle',
  'find_referencing_groups',
  'get_auth_db_revision',
  'get_missing_groups',
  'get_service_self_identity',
  'group_key',
  'Identity',
  'IDENTITY_ANONYMOUS',
  'IDENTITY_BOT',
  'IDENTITY_SERVICE',
  'IDENTITY_USER',
  'IdentityGlob',
  'IdentityProperty',
  'ip_whitelist_key',
  'is_empty_group',
  'is_external_group_name',
  'is_primary',
  'is_replica',
  'is_standalone',
  'is_valid_group_name',
  'is_valid_ip_whitelist_name',
  'replicate_auth_db',
]


# Name of a group whose members have access to Group management UI. It's the
# only group needed to bootstrap everything else.
ADMIN_GROUP = 'administrators'

# Name of AuthIPWhitelist with bots IP ranges. See AuthIPWhitelist.
BOTS_IP_WHITELIST = 'bots'

# No identity information is provided. Identity name is always 'anonymous'.
IDENTITY_ANONYMOUS = 'anonymous'
# Using bot credentials. Identity name is bot's id.
IDENTITY_BOT = 'bot'
# Using App Engine service credentials. Identity name is app name.
IDENTITY_SERVICE = 'service'
# Using user credentials. Identity name is user's email.
IDENTITY_USER = 'user'

# All allowed identity kinds + regexps to validate identity name.
ALLOWED_IDENTITY_KINDS = {
  IDENTITY_ANONYMOUS: re.compile(r'^anonymous$'),
  IDENTITY_BOT: re.compile(r'^[0-9a-zA-Z_\-\.@]+$'),
  IDENTITY_SERVICE: re.compile(r'^[0-9a-zA-Z_\-\:\.]+$'),
  IDENTITY_USER: re.compile(r'^[0-9a-zA-Z_\-\.\+]+@[0-9a-z_\-\.]+$'),
}

# Regular expression that matches group names. ASCII only, no leading or
# trailing spaces allowed (spaces inside are fine).
GROUP_NAME_RE = re.compile(
    r'^([a-z\-]+/)?[0-9a-zA-Z_][0-9a-zA-Z_\-\.\ ]{1,80}[0-9a-zA-Z_\-\.]$')
# Special group name that means 'All possible users' (including anonymous!).
GROUP_ALL = '*'

# Regular expression for IP whitelist name.
IP_WHITELIST_NAME_RE = re.compile(r'^[0-9a-zA-Z_\-\+\.\ ]{2,200}$')


# Configuration of Primary service, set by 'configure_as_primary'.
_replication_callback = None


# Root ndb keys of various models. They can't be defined as a module level
# constants because ndb.Key implicitly includes current APPLICATION_ID. And in
# testing environment it is '_' during module loading time. Trying to use such
# key from within a testbed test case results in the following error:
# BadRequestError: app ""testbed-test"" cannot access app ""_""'s data


def root_key():
  """"""Global root key of auth models entity group.""""""
  return ndb.Key('AuthGlobalConfig', 'root')


def replication_state_key():
  """"""Key of AuthReplicationState entity.""""""
  return ndb.Key('AuthReplicationState', 'self', parent=root_key())


def ip_whitelist_assignments_key():
  """"""Key of AuthIPWhitelistAssignments entity.""""""
  return ndb.Key('AuthIPWhitelistAssignments', 'default', parent=root_key())


def historical_revision_key(auth_db_rev):
  """"""Key for entity subgroup that holds changes done in a concrete revision.""""""
  return ndb.Key('Rev', auth_db_rev, parent=root_key())


################################################################################
## Identity & IdentityGlob.


class Identity(
    datastore_utils.BytesSerializable,
    collections.namedtuple('Identity', 'kind, name')):
  """"""Represents a caller that makes requests. Immutable.

  A tuple of (kind, name) where 'kind' is one of IDENTITY_* constants and
  meaning of 'name' depends on a kind (see comments for IDENTITY_*).
  It generalizes accounts of real people, bot accounts and service-to-service
  accounts.

  It's a pure identity information. Any additional information that may be
  related to an identity (e.g. registration date, last access time, etc.) should
  be stored elsewhere using Identity.to_bytes() as a key.
  """"""

  # Inheriting from tuple requires use of __new__ instead of __init__. __init__
  # is called with object already 'frozen', so it's not possible to modify its
  # attributes in __init__.
  # See http://docs.python.org/2/reference/datamodel.html#object.__new__
  def __new__(cls, kind, name):
    if isinstance(name, unicode):
      try:
        name = name.encode('ascii')
      except UnicodeEncodeError:
        raise ValueError('Identity has invalid format: only ASCII is allowed')
    if (kind not in ALLOWED_IDENTITY_KINDS or
        not ALLOWED_IDENTITY_KINDS[kind].match(name)):
      raise ValueError('Identity has invalid format: %s' % name)
    return super(Identity, cls).__new__(cls, str(kind), name)

  def to_bytes(self):
    """"""Serializes this identity to byte buffer.""""""
    return '%s:%s' % (self.kind, self.name)

  @classmethod
  def from_bytes(cls, byte_buf):
    """"""Given a byte buffer returns corresponding Identity object.""""""
    kind, sep, name = byte_buf.partition(':')
    if not sep:
      raise ValueError('Missing \':\' separator in Identity string')
    return cls(kind, name)

  @property
  def is_anonymous(self):
    """"""True if this object represents anonymous identity.""""""
    return self.kind == IDENTITY_ANONYMOUS

  @property
  def is_bot(self):
    """"""True if this object represents bot account.""""""
    return self.kind == IDENTITY_BOT

  @property
  def is_service(self):
    """"""True if this object represents service account.""""""
    return self.kind == IDENTITY_SERVICE

  @property
  def is_user(self):
    """"""True if this object represents user account.""""""
    return self.kind == IDENTITY_USER


# Predefined Anonymous identity.
Anonymous = Identity(IDENTITY_ANONYMOUS, 'anonymous')


class IdentityProperty(datastore_utils.BytesSerializableProperty):
  """"""NDB model property for Identity values.

  Identities are stored as indexed short blobs internally.
  """"""
  _value_type = Identity
  _indexed = True


class IdentityGlob(
    datastore_utils.BytesSerializable,
    collections.namedtuple('IdentityGlob', 'kind, pattern')):
  """"""Glob-like pattern that matches subset of identities. Immutable.

  Tuple (kind, glob) where 'kind' is is one of IDENTITY_* constants and 'glob'
  defines pattern that identity names' should match. For example, IdentityGlob
  that matches all bots is (IDENTITY_BOT, '*') which is also can be written
  as 'bot:*'.
  """"""

  # See comment for Identity.__new__ regarding use of __new__ here.
  def __new__(cls, kind, pattern):
    if isinstance(pattern, unicode):
      try:
        pattern = pattern.encode('ascii')
      except UnicodeEncodeError:
        raise ValueError('Invalid IdentityGlob pattern: only ASCII is allowed')
    if not pattern:
      raise ValueError('No pattern is given')
    if kind not in ALLOWED_IDENTITY_KINDS:
      raise ValueError('Invalid Identity kind: %s' % kind)
    return super(IdentityGlob, cls).__new__(cls, str(kind), pattern)

  def to_bytes(self):
    """"""Serializes this identity glob to byte buffer.""""""
    return '%s:%s' % (self.kind, self.pattern)

  @classmethod
  def from_bytes(cls, byte_buf):
    """"""Given a byte buffer returns corresponding IdentityGlob object.""""""
    kind, sep, pattern = byte_buf.partition(':')
    if not sep:
      raise ValueError('Missing \':\' separator in IdentityGlob string')
    return cls(kind, pattern)

  def match(self, identity):
    """"""Return True if |identity| matches this pattern.""""""
    if identity.kind != self.kind:
      return False
    return fnmatch.fnmatchcase(identity.name, self.pattern)


class IdentityGlobProperty(datastore_utils.BytesSerializableProperty):
  """"""NDB model property for IdentityGlob values.

  IdentityGlobs are stored as short indexed blobs internally.
  """"""
  _value_type = IdentityGlob
  _indexed = True


################################################################################
## Singleton entities and replication related models.


def configure_as_primary(replication_callback):
  """"""Registers a callback to be called when AuthDB changes.

  Should be called during Primary application startup. The callback will be
  called as 'replication_callback(AuthReplicationState)' from inside transaction
  on root_key() entity group whenever replicate_auth_db() is called (i.e. on
  every change to auth db that should be replication to replicas).
  """"""
  global _replication_callback
  _replication_callback = replication_callback


def is_primary():
  """"""Returns True if current application was configured as Primary.""""""
  return bool(_replication_callback)


def is_replica():
  """"""Returns True if application is in Replica mode.""""""
  return not is_primary() and not is_standalone()


def is_standalone():
  """"""Returns True if application is in Standalone mode.""""""
  ent = get_replication_state()
  return not ent or not ent.primary_id


def get_replication_state():
  """"""Returns AuthReplicationState singleton entity if it exists.""""""
  return replication_state_key().get()


def get_auth_db_revision():
  """"""Returns current revision of AuthDB, it increases with each change.""""""
  state = get_replication_state()
  return state.auth_db_rev if state else 0


def get_service_self_identity():
  """"""Returns Identity that correspond to the current GAE app itself.""""""
  return Identity(IDENTITY_SERVICE, app_identity.get_application_id())


class AuthVersionedEntityMixin(object):
  """"""Mixin class for entities that keep track of when they change.

  Entities that have this mixin are supposed to be updated in get()\put() or
  get()\delete() transactions. Caller must call record_revision(...) sometime
  during the transaction (but before put()). Similarly a call to
  record_deletion(...) is expected sometime before delete().

  replicate_auth_db will store a copy of the entity in the revision log when
  committing a transaction.

  A pair of properties auth_db_rev and auth_db_prev_rev are used to implement
  a linked list of versions of this entity (e.g. one can take most recent entity
  version and go back in time by following auth_db_prev_rev links).
  """"""
  # When the entity was modified last time. Do not use 'auto_now' property since
  # such property overrides any explicitly set value with now() during put. It's
  # undesired when storing a copy of entity received from Primary (Replica
  # should have modified_ts to be same as on Primary).
  modified_ts = ndb.DateTimeProperty()
  # Who modified the entity last time.
  modified_by = IdentityProperty()

  # Revision of Auth DB at which this entity was updated last time.
  auth_db_rev = ndb.IntegerProperty()
  # Revision of Auth DB of previous version of this entity or None.
  auth_db_prev_rev = ndb.IntegerProperty()

  def record_revision(self, modified_by, modified_ts=None, comment=None):
    """"""Updates the entity to record Auth DB revision of the current transaction.

    Stages the entity to be copied to historical log.

    Must be called sometime before 'put' (not necessary right before it). Note
    that NDB hooks are not used because they are buggy. See docstring for
    replicate_auth_db for more info.

    Args:
      modified_by: Identity that made the change.
      modified_ts: datetime when the change was made (or None for current time).
      comment: optional comment to put in the revision log.
    """"""
    _get_pending_auth_db_transaction().record_change(
        entity=self,
        deletion=False,
        modified_by=modified_by,
        modified_ts=modified_ts or utils.utcnow(),
        comment=comment)

  def record_deletion(self, modified_by, modified_ts=None, comment=None):
    """"""Marks entity as being deleted in the current transaction.

    Stages the entity to be copied to historical log (with 'auth_db_deleted'
    flag set). The entity must not be mutated between 'get' and AuthDB commit.

    Must be called sometime before 'delete' (not necessary right before it).
    Note that NDB hooks are not used because they are buggy. See docstring for
    replicate_auth_db for more info.

    Args:
      modified_by: Identity that made the change.
      modified_ts: datetime when the change was made (or None for current time).
      comment: optional comment to put in the revision log.
    """"""
    _get_pending_auth_db_transaction().record_change(
        entity=self,
        deletion=True,
        modified_by=modified_by,
        modified_ts=modified_ts or utils.utcnow(),
        comment=comment)

  ## Internal interface. Do not use directly unless you know what you are doing.

  @classmethod
  def get_historical_copy_class(cls):
    """"""Returns entity class for historical copies of original entity.

    Has all the same properties, but unindexed (not needed), unvalidated
    (original entity is already validated) and not cached.

    The name of the new entity class is ""<original name>History"" (to make sure
    it doesn't show up in indexes for original entity class).
    """"""
    existing = getattr(cls, '_auth_db_historical_copy_cls', None)
    if existing:
      return existing
    props = {}
    for name, prop in cls._properties.iteritems():
      # Whitelist supported property classes. Better to fail loudly when
      # encountering something new, rather than silently produce (possibly)
      # incorrect result. Note that all AuthDB classes are instantiated in
      # unit tests, so there should be no unexpected asserts in production.
      assert prop.__class__ in (
        IdentityGlobProperty,
        IdentityProperty,
        ndb.BlobProperty,
        ndb.BooleanProperty,
        ndb.DateTimeProperty,
        ndb.IntegerProperty,
        ndb.LocalStructuredProperty,
        ndb.StringProperty,
        ndb.TextProperty,
      ), prop.__class__
      kwargs = {
        'name': prop._name,
        'indexed': False,
        'required': False,
        'repeated': prop._repeated,
      }
      if prop.__class__ == ndb.LocalStructuredProperty:
        kwargs['modelclass'] = prop._modelclass
      props[name] = prop.__class__(**kwargs)
    new_cls = type(
        '%sHistory' % cls.__name__, (_AuthDBHistoricalEntity,), props)
    cls._auth_db_historical_copy_cls = new_cls
    return new_cls

  def make_historical_copy(self, deleted, comment):
    """"""Returns an entity to put in the historical log.

    It's a copy of the original entity, but stored under another key and with
    indexes removed. It also has a bunch of additional properties (defined
    in _AuthDBHistoricalEntity). See 'get_historical_copy_class'.

    The key is derived from auth_db_rev and class and ID of the original entity.
    For example, AuthGroup ""admins"" modified at rev 123 will be copied to
    the history as ('AuthGlobalConfig', 'root', 'Rev', 123, 'AuthGroupHistory',
    'admins'), where the key prefix (first two pairs) is obtained with
    historical_revision_key(...).
    """"""
    assert self.key.parent() == root_key() or self.key == root_key(), self.key
    cls = self.get_historical_copy_class()
    entity = cls(
        id=self.key.id(),
        parent=historical_revision_key(self.auth_db_rev))
    for prop in self._properties:
      setattr(entity, prop, getattr(self, prop))
    entity.auth_db_deleted = deleted
    entity.auth_db_change_comment = comment
    entity.auth_db_app_version = utils.get_app_version()
    return entity


class AuthGlobalConfig(ndb.Model, AuthVersionedEntityMixin):
  """"""Acts as a root entity for auth models.

  There should be only one instance of this model in Datastore, with a key set
  to root_key(). A change to an entity group rooted at this key is a signal that
  AuthDB has to be refetched (see 'fetch_auth_db' in api.py).

  Entities that change often or associated with particular bot or user
  MUST NOT be in this entity group.

  Content of this particular entity is replicated from Primary service to all
  Replicas.

  Entities that belong to this entity group are:
   * AuthGroup
   * AuthIPWhitelist
   * AuthIPWhitelistAssignments
   * AuthReplicationState
   * AuthSecret
  """"""
  # OAuth2 client_id to use to mint new OAuth2 tokens.
  oauth_client_id = ndb.StringProperty(indexed=False, default='')
  # OAuth2 client secret. Not so secret really, since it's passed to clients.
  oauth_client_secret = ndb.StringProperty(indexed=False, default='')
  # Additional OAuth2 client_ids allowed to access the services.
  oauth_additional_client_ids = ndb.StringProperty(repeated=True, indexed=False)


class AuthReplicationState(ndb.Model, datastore_utils.SerializableModelMixin):
  """"""Contains state used to control Primary -> Replica replication.

  It's a singleton entity with key replication_state_key() (in same entity
  groups as root_key()). This entity should be small since it is updated
  (auth_db_rev is incremented) whenever AuthDB changes.

  Exists in any AuthDB (on Primary and Replicas). Primary updates it whenever
  changes to AuthDB are made, Replica updates it whenever it receives a push
  from Primary.
  """"""
  # How to convert this entity to or from serializable dict.
  serializable_properties = {
    'primary_id': datastore_utils.READABLE,
    'primary_url': datastore_utils.READABLE,
    'auth_db_rev': datastore_utils.READABLE,
    'modified_ts': datastore_utils.READABLE,
  }

  # For services in Standalone mode it is None.
  # For services in Primary mode: own GAE application ID.
  # For services in Replica mode it is a GAE application ID of Primary.
  primary_id = ndb.StringProperty(indexed=False)

  # For services in Replica mode, root URL of Primary, i.e https://<host>.
  primary_url = ndb.StringProperty(indexed=False)

  # Revision of auth DB. Increased by 1 with every change that should be
  # propagate to replicas. Only services in Standalone or Primary mode
  # update this property by themselves. Replicas receive it from Primary.
  auth_db_rev = ndb.IntegerProperty(default=0, indexed=False)

  # Time when auth_db_rev was created (by Primary clock). For informational
  # purposes only. See comment at AuthGroup.modified_ts for explanation why
  # auto_now is not used.
  modified_ts = ndb.DateTimeProperty(auto_now_add=True, indexed=False)


def replicate_auth_db():
  """"""Increments auth_db_rev, updates historical log, triggers replication.

  Must be called once from inside a transaction (right before exiting it).

  Should only be called for services in Standalone or Primary modes. Will raise
  ValueError if called on Replica. When called for service in Standalone mode,
  will update auth_db_rev but won't kick any replication. For services in
  Primary mode will also initiate replication by calling callback set in
  'configure_as_primary'. The callback usually transactionally enqueues a task
  (to gracefully handle transaction rollbacks).

  WARNING: This function relies on a valid transaction context. NDB hooks and
  asynchronous operations are known to be buggy in this regard: NDB hook for
  an async operation in a transaction may be called with a wrong context
  (main event loop context instead of transaction context). One way to work
  around that is to monkey patch NDB (as done here: https://goo.gl/1yASjL).
  Another is to not use hooks at all. There's no way to differentiate between
  sync and async modes of an NDB operation from inside a hook. And without a
  strict assert it's very easy to forget about ""Do not use put_async"" warning.
  For that reason _post_put_hook is NOT used and replicate_auth_db() should be
  called explicitly whenever relevant part of root_key() entity group is
  updated.

  Returns:
    New AuthDB revision number.
  """"""
  assert ndb.in_transaction()
  txn = _get_pending_auth_db_transaction()
  txn.commit()
  if is_primary():
    _replication_callback(txn.replication_state)
  return txn.replication_state.auth_db_rev


################################################################################
## Auth DB transaction details (used for historical log of changes).


_commit_callbacks = []


def commit_callback(cb):
  """"""Adds a callback that's called before AuthDB transaction is committed.

  Can be used as decorator. Adding a callback second time is noop.

  Args:
    cb: function that takes single auth_db_rev argument as input.
  """"""
  if cb not in _commit_callbacks:
    _commit_callbacks.append(cb)
  return cb


def _get_pending_auth_db_transaction():
  """"""Used internally to keep track of changes done in the transaction.

  Returns:
    Instance of _AuthDBTransaction (stored in the transaction context).
  """"""
  # Use transaction context to store the object. Note that each transaction
  # retry gets its own new transaction context which is what we need,
  # see ndb/context.py, 'transaction' tasklet, around line 982 (for SDK 1.9.6).
  assert ndb.in_transaction()
  ctx = ndb.get_context()
  txn = getattr(ctx, '_auth_db_transaction', None)
  if txn:
    return txn

  # Prepare next AuthReplicationState (auth_db_rev +1).
  state = replication_state_key().get()
  if not state:
    primary_id = app_identity.get_application_id() if is_primary() else None
    state = AuthReplicationState(
        key=replication_state_key(),
        primary_id=primary_id,
        auth_db_rev=0)
  # Assert Primary or Standalone. Replicas can't increment auth db revision.
  if not is_primary() and state.primary_id:
    raise ValueError('Can\'t modify Auth DB on Replica')
  state.auth_db_rev += 1
  state.modified_ts = utils.utcnow()

  # Store the state in the transaction context. Used in replicate_auth_db(...)
  # later.
  txn = _AuthDBTransaction(state)
  ctx._auth_db_transaction = txn
  return txn


class _AuthDBTransaction(object):
  """"""Keeps track of entities updated or removed in current transaction.""""""

  _Change = collections.namedtuple('_Change', 'entity deletion comment')

  def __init__(self, replication_state):
    self.replication_state = replication_state
    self.changes = [] # list of _Change tuples
    self.committed = False

  def record_change(self, entity, deletion, modified_by, modified_ts, comment):
    assert not self.committed
    assert isinstance(entity, AuthVersionedEntityMixin)
    assert all(entity.key != c.entity.key for c in self.changes)

    # Mutate the main entity (the one used to serve online requests).
    entity.modified_by = modified_by
    entity.modified_ts = modified_ts
    entity.auth_db_prev_rev = entity.auth_db_rev # can be None for new entities
    entity.auth_db_rev = self.replication_state.auth_db_rev

    # Keep a historical copy. Delay make_historical_copy call until the commit.
    # Here (in 'record_change') entity may not have all the fields updated yet.
    self.changes.append(self._Change(entity, deletion, comment))

  def commit(self):
    assert not self.committed
    puts = [
      c.entity.make_historical_copy(c.deletion, c.comment)
      for c in self.changes
    ]
    ndb.put_multi(puts + [self.replication_state])
    for cb in _commit_callbacks:
      cb(self.replication_state.auth_db_rev)
    self.committed = True


class _AuthDBHistoricalEntity(ndb.Model):
  """"""Base class for *History magic class in AuthVersionedEntityMixin.

  In addition to properties defined here the child classes (*History) also
  always inherit (for some definition of ""inherit"") properties from
  AuthVersionedEntityMixin.

  See get_historical_copy_class().
  """"""
  # Historical entities are not intended to be read often, and updating the
  # cache will make AuthDB transactions only slower.
  _use_cache = False
  _use_memcache = False

  # True if entity was deleted in the given revision.
  auth_db_deleted = ndb.BooleanProperty(indexed=False)
  # Comment string passed to record_revision or record_deletion.
  auth_db_change_comment = ndb.StringProperty(indexed=False)
  # A GAE module version that committed the change.
  auth_db_app_version = ndb.StringProperty(indexed=False)

  def get_previous_historical_copy_key(self):
    """"""Returns ndb.Key of *History entity matching auth_db_prev_rev revision.""""""
    if self.auth_db_prev_rev is None:
      return None
    return ndb.Key(
        self.__class__, self.key.id(),
        parent=historical_revision_key(self.auth_db_prev_rev))


################################################################################
## Groups.


class AuthGroup(
    ndb.Model,
    AuthVersionedEntityMixin,
    datastore_utils.SerializableModelMixin):
  """"""A group of identities, entity id is a group name.

  Parent is AuthGlobalConfig entity keyed at root_key().

  Primary service holds authoritative list of Groups, that gets replicated to
  all Replicas.
  """"""
  # How to convert this entity to or from serializable dict.
  serializable_properties = {
    'members': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'globs': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'nested': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'description': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'owners': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'created_ts': datastore_utils.READABLE,
    'created_by': datastore_utils.READABLE,
    'modified_ts': datastore_utils.READABLE,
    'modified_by': datastore_utils.READABLE,
  }

  # List of members that are explicitly in this group. Indexed.
  members = IdentityProperty(repeated=True)
  # List of identity-glob expressions (like 'user:*@example.com'). Indexed.
  globs = IdentityGlobProperty(repeated=True)
  # List of nested group names. Indexed.
  nested = ndb.StringProperty(repeated=True)

  # Human readable description.
  description = ndb.TextProperty(default='')
  # A name of the group that can modify or delete this group.
  owners = ndb.StringProperty(default=ADMIN_GROUP)

  # When the group was created.
  created_ts = ndb.DateTimeProperty()
  # Who created the group.
  created_by = IdentityProperty()


def group_key(group):
  """"""Returns ndb.Key for AuthGroup entity.""""""
  return ndb.Key(AuthGroup, group, parent=root_key())


def is_empty_group(group):
  """"""Returns True if group is missing or completely empty.""""""
  group = group_key(group).get()
  return not group or not(group.members or group.globs or group.nested)


def is_valid_group_name(name):
  """"""True if string looks like a valid group name.""""""
  return bool(GROUP_NAME_RE.match(name))


def is_external_group_name(name):
  """"""True if group is imported from outside and is not writable.""""""
  return is_valid_group_name(name) and '/' in name


@ndb.transactional
def bootstrap_group(group, identities, description=''):
  """"""Makes a group (if not yet exists) and adds |identities| to it as members.

  Returns True if modified the group, False if identities are already there.
  """"""
  key = group_key(group)
  entity = key.get()
  if entity and all(i in entity.members for i in identities):
    return False
  now = utils.utcnow()
  if not entity:
    entity = AuthGroup(
        key=key,
        description=description,
        created_ts=now,
        created_by=get_service_self_identity())
  for i in identities:
    if i not in entity.members:
      entity.members.append(i)
  entity.record_revision(
      modified_by=get_service_self_identity(),
      modified_ts=now,
      comment='Bootstrap')
  entity.put()
  replicate_auth_db()
  return True


def find_referencing_groups(group):
  """"""Finds groups that reference the specified group as nested group or owner.

  Used to verify that |group| is safe to delete, i.e. no other group is
  depending on it.

  Returns:
    Set of names of referencing groups.
  """"""
  nesting_groups = AuthGroup.query(
      AuthGroup.nested == group,
      ancestor=root_key()).fetch_async(keys_only=True)
  owned_groups = AuthGroup.query(
      AuthGroup.owners == group,
      ancestor=root_key()).fetch_async(keys_only=True)
  refs = set()
  refs.update(key.id() for key in nesting_groups.get_result())
  refs.update(key.id() for key in owned_groups.get_result())
  return refs


def get_missing_groups(groups):
  """"""Given a list of group names, returns a list of groups that do not exist.""""""
  # We need to iterate over |groups| twice. It won't work if |groups|
  # is a generator. So convert to list first.
  groups = list(groups)
  entities = ndb.get_multi(group_key(name) for name in groups)
  return [name for name, ent in zip(groups, entities) if not ent]


def find_group_dependency_cycle(group):
  """"""Searches for dependency cycle between nested groups.

  Traverses the dependency graph starting from |group|, fetching all necessary
  groups from datastore along the way.

  Args:
    group: instance of AuthGroup to start traversing from. It doesn't have to be
        committed to Datastore itself (but all its nested groups should be
        there already).

  Returns:
    List of names of groups that form a cycle or empty list if no cycles.
  """"""
  # It is a depth-first search on a directed graph with back edge detection.
  # See http://www.cs.nyu.edu/courses/summer04/G22.1170-001/6a-Graphs-More.pdf

  # Cache of already fetched groups.
  groups = {group.key.id(): group}

  # List of groups that are completely explored (all subtree is traversed).
  visited = []
  # Stack of groups that are being explored now. In case cycle is detected
  # it would contain that cycle.
  visiting = []

  def visit(group):
    """"""Recursively explores |group| subtree, returns True if finds a cycle.""""""
    assert group not in visiting
    assert group not in visited

    # Load bodies of nested groups not seen so far into |groups|.
    entities = ndb.get_multi(
        group_key(name) for name in group.nested if name not in groups)
    groups.update({entity.key.id(): entity for entity in entities if entity})

    visiting.append(group)
    for nested in group.nested:
      obj = groups.get(nested)
      # Do not crash if non-existent group is referenced somehow.
      if not obj:
        continue
      # Cross edge. Can happen in diamond-like graph, not a cycle.
      if obj in visited:
        continue
      # Back edge: |group| references its own ancestor -> cycle.
      if obj in visiting:
        return True
      # Explore subtree.
      if visit(obj):
        return True
    visiting.pop()

    visited.append(group)
    return False

  visit(group)
  return [group.key.id() for group in visiting]


################################################################################
## Secrets store.


class AuthSecretScope(ndb.Model):
  """"""Entity to act as parent entity for AuthSecret.

  Parent is AuthGlobalConfig entity keyed at root_key().

  Id of this entity defines scope of secret keys that have this entity as
  a parent. Possible scopes are 'local' and 'global'.

  Secrets in 'local' scope never leave Datastore they are stored in and they
  are different for each service (even for Replicas). Only service that
  generated a local secret knows it.

  Secrets in 'global' scope are known to all services (via Primary -> Replica
  DB replication mechanism). Source of truth for global secrets is in Primary's
  Datastore.
  """"""


def secret_scope_key(scope):
  """"""Key of AuthSecretScope entity for a given scope ('global' or 'local').""""""
  return ndb.Key(AuthSecretScope, scope, parent=root_key())


class AuthSecret(ndb.Model):
  """"""Some service-wide named secret blob.

  Entity can be a child of:
    * Key(AuthSecretScope, 'global', parent=root_key()):
        Global secrets replicated across all services.
    * Key(AuthSecretScope, 'local', parent=root_key()):
        Secrets local to the current service.

  There should be only very limited number of AuthSecret entities around. AuthDB
  fetches them all at once. Do not use this entity for per-user secrets.

  Holds most recent value of a secret as well as several previous values. Most
  recent value is used to generate new tokens, previous values may be used to
  validate existing tokens. That way secret can be rotated without invalidating
  any existing outstanding tokens.
  """"""
  # Last several values of a secret, with current value in front.
  values = ndb.BlobProperty(repeated=True, indexed=False)

  # When secret was modified last time.
  modified_ts = ndb.DateTimeProperty(auto_now_add=True)
  # Who modified the secret last time.
  modified_by = IdentityProperty()

  @classmethod
  def bootstrap(cls, name, scope, length=32):
    """"""Creates a secret if it doesn't exist yet.

    Args:
      name: name of the secret.
      scope: 'local' or 'global', see doc string for AuthSecretScope. 'global'
          scope should only be used on Primary service.
      length: length of the secret to generate if secret doesn't exist yet.

    Returns:
      Instance of AuthSecret (creating it if necessary) with random secret set.
    """"""
    # Note that 'get_or_insert' is a bad fit here. With 'get_or_insert' we'd
    # have to call os.urandom every time we want to get a key. It's a waste of
    # time and entropy.
    if scope not in ('local', 'global'):
      raise ValueError('Invalid secret scope: %s' % scope)
    key = ndb.Key(cls, name, parent=secret_scope_key(scope))
    entity = key.get()
    if entity is not None:
      return entity
    @ndb.transactional
    def create():
      entity = key.get()
      if entity is not None:
        return entity
      logging.info('Creating new secret key %s in %s scope', name, scope)
      # Global keys can only be created on Primary or Standalone service.
      if scope == 'global' and is_replica():
        raise ValueError('Can\'t bootstrap global key on Replica')
      entity = cls(
          key=key,
          values=[os.urandom(length)],
          modified_by=get_service_self_identity())
      entity.put()
      # Only global keys are part of replicated state.
      if scope == 'global':
        replicate_auth_db()
      return entity
    return create()


################################################################################
## IP whitelist.


class AuthIPWhitelistAssignments(ndb.Model, AuthVersionedEntityMixin):
  """"""A singleton entity with ""identity -> AuthIPWhitelist to use"" mapping.

  Entity key is ip_whitelist_assignments_key(). Parent entity is root_key().

  See AuthIPWhitelist for more info about IP whitelists.
  """"""
  class Assignment(ndb.Model):
    # Identity name to limit by IP whitelist. Unique key in 'assignments' list.
    identity = IdentityProperty()
    # Name of IP whitelist to use (see AuthIPWhitelist).
    ip_whitelist = ndb.StringProperty()
    # Why the assignment was created.
    comment = ndb.StringProperty()
    # When the assignment was created.
    created_ts = ndb.DateTimeProperty()
    # Who created the assignment.
    created_by = IdentityProperty()

  # Holds all the assignments.
  assignments = ndb.LocalStructuredProperty(Assignment, repeated=True)


class AuthIPWhitelist(
    ndb.Model,
    AuthVersionedEntityMixin,
    datastore_utils.SerializableModelMixin):
  """"""A named set of whitelisted IPv4 and IPv6 subnets.

  Can be assigned to individual user accounts to forcibly limit them only to
  particular IP addresses, e.g. it can be used to enforce that specific service
  account is used only from some known IP range. The mapping between accounts
  and IP whitelists is stored in AuthIPWhitelistAssignments.

  Entity id is a name of the whitelist. Parent entity is root_key().

  There's a special IP whitelist named 'bots' that can be used to list
  IP addresses of machines the service trusts unconditionally. Requests from
  such machines doesn't have to have any additional credentials attached.
  Requests will be authenticated as coming from identity 'bot:<IP address>'.
  """"""
  # How to convert this entity to or from serializable dict.
  serializable_properties = {
    'subnets': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'description': datastore_utils.READABLE | datastore_utils.WRITABLE,
    'created_ts': datastore_utils.READABLE,
    'created_by': datastore_utils.READABLE,
    'modified_ts': datastore_utils.READABLE,
    'modified_by': datastore_utils.READABLE,
  }

  # The list of subnets. The validator is used only as a last measure. JSON API
  # handler should do validation too.
  subnets = ndb.StringProperty(
      repeated=True, validator=lambda _, val: ipaddr.normalize_subnet(val))

  # Human readable description.
  description = ndb.TextProperty(default='')

  # When the list was created.
  created_ts = ndb.DateTimeProperty()
  # Who created the list.
  created_by = IdentityProperty()

  def is_ip_whitelisted(self, ip):
    """"""Returns True if ipaddr.IP is in the whitelist.""""""
    # TODO(vadimsh): If number of subnets to check grows it makes sense to add
    # an internal cache to 'subnet_from_string' (sort of like in re.compile).
    return any(
        ipaddr.is_in_subnet(ip, ipaddr.subnet_from_string(net))
        for net in self.subnets)


def ip_whitelist_key(name):
  """"""Returns ndb.Key for AuthIPWhitelist entity given its name.""""""
  return ndb.Key(AuthIPWhitelist, name, parent=root_key())


def is_valid_ip_whitelist_name(name):
  """"""True if string looks like a valid IP whitelist name.""""""
  return bool(IP_WHITELIST_NAME_RE.match(name))


@ndb.transactional
def bootstrap_ip_whitelist(name, subnets, description=''):
  """"""Adds subnets to an IP whitelist if not there yet.

  Can be used on local dev appserver to add 127.0.0.1 to IP whitelist during
  startup. Should not be used from request handlers.

  Args:
    name: IP whitelist name to add a subnet to.
    subnets: IP subnet to add (as a list of strings).
    description: description of IP whitelist (if new entity is created).

  Returns:
    True if entry was added, False if it is already there or subnet is invalid.
  """"""
  assert isinstance(subnets, (list, tuple))
  try:
    subnets = [ipaddr.normalize_subnet(s) for s in subnets]
  except ValueError:
    return False
  key = ip_whitelist_key(name)
  entity = key.get()
  if entity and all(s in entity.subnets for s in subnets):
    return False
  now = utils.utcnow()
  if not entity:
    entity = AuthIPWhitelist(
        key=key,
        description=description,
        created_ts=now,
        created_by=get_service_self_identity())
  for s in subnets:
    if s not in entity.subnets:
      entity.subnets.append(s)
  entity.record_revision(
      modified_by=get_service_self_identity(),
      modified_ts=now,
      comment='Bootstrap')
  entity.put()
  replicate_auth_db()
  return True


def bootstrap_loopback_ips():
  """"""Adds 127.0.0.1 and ::1 to 'bots' IP whitelist.

  Useful on local dev server and in tests. Must not be used in production.

  Returns list of corresponding bot Identities.
  """"""
  # See api.py, AuthDB.verify_ip_whitelisted for IP -> Identity conversion.
  assert utils.is_local_dev_server()
  bootstrap_ip_whitelist(BOTS_IP_WHITELIST, ['127.0.0.1', '::1'], 'Local bots')
  return [
    Identity(IDENTITY_BOT, 'whitelisted-ip'),
    Identity(IDENTITY_BOT, '127.0.0.1'),
    Identity(IDENTITY_BOT, '0-0-0-0-0-0-0-1'),
  ]


@ndb.transactional
def bootstrap_ip_whitelist_assignment(identity, ip_whitelist, comment=''):
  """"""Sets a mapping ""identity -> IP whitelist to use"" for some account.

  Replaces existing assignment. Can be used on local dev appserver to configure
  IP whitelist assignments during startup or in tests. Should not be used from
  request handlers.

  Args:
    identity: Identity to modify.
    ip_whitelist: name of AuthIPWhitelist to assign.
    comment: comment to set.

  Returns:
    True if IP whitelist assignment was modified, False if it was already set.
  """"""
  entity = (
      ip_whitelist_assignments_key().get() or
      AuthIPWhitelistAssignments(key=ip_whitelist_assignments_key()))

  found = False
  for assignment in entity.assignments:
    if assignment.identity == identity:
      if assignment.ip_whitelist == ip_whitelist:
        return False
      assignment.ip_whitelist = ip_whitelist
      assignment.comment = comment
      found = True
      break

  now = utils.utcnow()
  if not found:
    entity.assignments.append(
        AuthIPWhitelistAssignments.Assignment(
            identity=identity,
            ip_whitelist=ip_whitelist,
            comment=comment,
            created_ts=now,
            created_by=get_service_self_identity()))

  entity.record_revision(
      modified_by=get_service_self_identity(),
      modified_ts=now,
      comment='Bootstrap')
  entity.put()
  replicate_auth_db()
  return True


def fetch_ip_whitelists():
  """"""Fetches AuthIPWhitelistAssignments and relevant AuthIPWhitelist entities.

  Returns:
    (AuthIPWhitelistAssignments, list of AuthIPWhitelist).
  """"""
  assignments = (
      ip_whitelist_assignments_key().get() or
      AuthIPWhitelistAssignments(key=ip_whitelist_assignments_key()))

  names = set(a.ip_whitelist for a in assignments.assignments)
  names.add(BOTS_IP_WHITELIST)

  whitelists = ndb.get_multi(ip_whitelist_key(n) for n in names)
  whitelists = sorted(filter(None, whitelists), key=lambda x: x.key.id())
  return assignments, whitelists
/n/n/nappengine/swarming/handlers_bot.py/n/n# Copyright 2015 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Internal bot API handlers.""""""

import base64
import json
import logging
import textwrap

import webob
import webapp2

from google.appengine.api import app_identity
from google.appengine.api import datastore_errors
from google.appengine.datastore import datastore_query
from google.appengine import runtime
from google.appengine.ext import ndb

from components import auth
from components import ereporter2
from components import utils
from server import acl
from server import bot_code
from server import bot_management
from server import stats
from server import task_pack
from server import task_scheduler
from server import task_to_run


def has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):
  """"""Returns an error if unexpected keys are present or expected keys are
  missing.

  Accepts optional keys.

  This is important to catch typos.
  """"""
  actual_keys = frozenset(actual_keys)
  superfluous = actual_keys - expected_keys
  missing = minimum_keys - actual_keys
  if superfluous or missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    msg_superfluous = (
        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')
    return 'Unexpected %s%s%s; did you make a typo?' % (
        name, msg_missing, msg_superfluous)


def has_unexpected_keys(expected_keys, actual_keys, name):
  """"""Return an error if unexpected keys are present or expected keys are
  missing.
  """"""
  return has_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, name)


def log_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, request, source, name):
  """"""Logs an error if unexpected keys are present or expected keys are missing.

  Accepts optional keys.

  This is important to catch typos.
  """"""
  message = has_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, name)
  if message:
    ereporter2.log_request(request, source=source, message=message)
  return message


def log_unexpected_keys(expected_keys, actual_keys, request, source, name):
  """"""Logs an error if unexpected keys are present or expected keys are missing.
  """"""
  return log_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, request, source, name)


def has_missing_keys(minimum_keys, actual_keys, name):
  """"""Returns an error if expected keys are not present.

  Do not warn about unexpected keys.
  """"""
  actual_keys = frozenset(actual_keys)
  missing = minimum_keys - actual_keys
  if missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)


class BootstrapHandler(auth.AuthenticatingHandler):
  """"""Returns python code to run to bootstrap a swarming bot.""""""

  @auth.require(acl.is_bot)
  def get(self):
    self.response.headers['Content-Type'] = 'text/x-python'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename=""swarming_bot_bootstrap.py""')
    self.response.out.write(
        bot_code.get_bootstrap(self.request.host_url).content)


class BotCodeHandler(auth.AuthenticatingHandler):
  """"""Returns a zip file with all the files required by a bot.

  Optionally specify the hash version to download. If so, the returned data is
  cacheable.
  """"""

  @auth.require(acl.is_bot)
  def get(self, version=None):
    if version:
      expected = bot_code.get_bot_version(self.request.host_url)
      if version != expected:
        # This can happen when the server is rapidly updated.
        logging.error('Requested Swarming bot %s, have %s', version, expected)
        self.abort(404)
      self.response.headers['Cache-Control'] = 'public, max-age=3600'
    else:
      self.response.headers['Cache-Control'] = 'no-cache, no-store'
    self.response.headers['Content-Type'] = 'application/octet-stream'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename=""swarming_bot.zip""')
    self.response.out.write(
        bot_code.get_swarming_bot_zip(self.request.host_url))


class _BotBaseHandler(auth.ApiHandler):
  """"""
  Request body is a JSON dict:
    {
      ""dimensions"": <dict of properties>,
      ""state"": <dict of properties>,
      ""version"": <sha-1 of swarming_bot.zip uncompressed content>,
    }
  """"""

  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}
  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  def _process(self):
    """"""Returns True if the bot has invalid parameter and should be automatically
    quarantined.

    Does one DB synchronous GET.

    Returns:
      tuple(request, bot_id, version, state, dimensions, quarantined_msg)
    """"""
    request = self.parse_body()
    version = request.get('version', None)

    dimensions = request.get('dimensions', {})
    state = request.get('state', {})
    bot_id = None
    if dimensions.get('id'):
      dimension_id = dimensions['id']
      if (isinstance(dimension_id, list) and len(dimension_id) == 1
          and isinstance(dimension_id[0], unicode)):
        bot_id = dimensions['id'][0]

    # The bot may decide to ""self-quarantine"" itself. Accept both via
    # dimensions or via state. See bot_management._BotCommon.quarantined for
    # more details.
    if (bool(dimensions.get('quarantined')) or
        bool(state.get('quarantined'))):
      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'

    quarantined_msg = None
    # Use a dummy 'for' to be able to break early from the block.
    for _ in [0]:

      quarantined_msg = has_unexpected_keys(
          self.EXPECTED_KEYS, request, 'keys')
      if quarantined_msg:
        break

      quarantined_msg = has_missing_keys(
          self.REQUIRED_STATE_KEYS, state, 'state')
      if quarantined_msg:
        break

      if not bot_id:
        quarantined_msg = 'Missing bot id'
        break

      if not all(
          isinstance(key, unicode) and
          isinstance(values, list) and
          all(isinstance(value, unicode) for value in values)
          for key, values in dimensions.iteritems()):
        quarantined_msg = (
            'Invalid dimensions type:\n%s' % json.dumps(dimensions,
              sort_keys=True, indent=2, separators=(',', ': ')))
        break

      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)
      if dimensions_count > task_to_run.MAX_DIMENSIONS:
        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count
        break

    if quarantined_msg:
      line = 'Quarantined Bot\nhttps://%s/restricted/bot/%s\n%s' % (
          app_identity.get_default_version_hostname(), bot_id,
          quarantined_msg)
      ereporter2.log_request(self.request, source='bot', message=line)
      return request, bot_id, version, state, dimensions, quarantined_msg

    # Look for admin enforced quarantine.
    bot_settings = bot_management.get_settings_key(bot_id).get()
    if bool(bot_settings and bot_settings.quarantined):
      return request, bot_id, version, state, dimensions, 'Quarantined by admin'

    return request, bot_id, version, state, dimensions, None


class BotHandshakeHandler(_BotBaseHandler):
  """"""First request to be called to get initial data like XSRF token.

  The bot is server-controled so the server doesn't have to support multiple API
  version. When running a task, the bot sync the the version specific URL. Once
  abot finished its currently running task, it'll be immediately be upgraded
  after on its next poll.

  This endpoint does not return commands to the bot, for example to upgrade
  itself. It'll be told so when it does its first poll.

  Response body is a JSON dict:
    {
      ""bot_version"": <sha-1 of swarming_bot.zip uncompressed content>,
      ""server_version"": ""138-193f1f3"",
      ""xsrf_token"": ""......"",
    }
  """"""

  # This handler is called to get XSRF token, there's nothing to enforce yet.
  xsrf_token_enforce_on = ()

  @auth.require_xsrf_token_request
  @auth.require(acl.is_bot)
  def post(self):
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    bot_management.bot_event(
        event_type='bot_connected', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=dimensions,
        state=state, version=version, quarantined=bool(quarantined_msg),
        task_id='', task_name=None, message=quarantined_msg)

    data = {
      # This access token will be used to validate each subsequent request.
      'bot_version': bot_code.get_bot_version(self.request.host_url),
      'expiration_sec': auth.handler.XSRFToken.expiration_sec,
      'server_version': utils.get_app_version(),
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.send_response(data)


class BotPollHandler(_BotBaseHandler):
  """"""The bot polls for a task; returns either a task, update command or sleep.

  In case of exception on the bot, this is enough to get it just far enough to
  eventually self-update to a working version. This is to ensure that coding
  errors in bot code doesn't kill all the fleet at once, they should still be up
  just enough to be able to self-update again even if they don't get task
  assigned anymore.
  """"""

  @auth.require(acl.is_bot)
  def post(self):
    """"""Handles a polling request.

    Be very permissive on missing values. This can happen because of errors
    on the bot, *we don't want to deny them the capacity to update*, so that the
    bot code is eventually fixed and the bot self-update to this working code.

    It makes recovery of the fleet in case of catastrophic failure much easier.
    """"""
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    sleep_streak = state.get('sleep_streak', 0)
    quarantined = bool(quarantined_msg)

    # Note bot existence at two places, one for stats at 1 minute resolution,
    # the other for the list of known bots.
    action = 'bot_inactive' if quarantined else 'bot_active'
    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)

    def bot_event(event_type, task_id=None, task_name=None):
      bot_management.bot_event(
          event_type=event_type, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=dimensions,
          state=state, version=version, quarantined=quarantined,
          task_id=task_id, task_name=task_name, message=quarantined_msg)

    # Bot version is host-specific because the host URL is embedded in
    # swarming_bot.zip
    expected_version = bot_code.get_bot_version(self.request.host_url)
    if version != expected_version:
      bot_event('request_update')
      self._cmd_update(expected_version)
      return
    if quarantined:
      bot_event('request_sleep')
      self._cmd_sleep(sleep_streak, quarantined)
      return

    #
    # At that point, the bot should be in relatively good shape since it's
    # running the right version. It is still possible that invalid code was
    # pushed to the server, so be diligent about it.
    #

    # Bot may need a reboot if it is running for too long. We do not reboot
    # quarantined bots.
    needs_restart, restart_message = bot_management.should_restart_bot(
        bot_id, state)
    if needs_restart:
      bot_event('request_restart')
      self._cmd_restart(restart_message)
      return

    # The bot is in good shape. Try to grab a task.
    try:
      # This is a fairly complex function call, exceptions are expected.
      request, run_result = task_scheduler.bot_reap_task(
          dimensions, bot_id, version)
      if not request:
        # No task found, tell it to sleep a bit.
        bot_event('request_sleep')
        self._cmd_sleep(sleep_streak, quarantined)
        return

      try:
        # This part is tricky since it intentionally runs a transaction after
        # another one.
        if request.properties.is_terminate:
          bot_event('bot_terminate', task_id=run_result.task_id)
          self._cmd_terminate(run_result.task_id)
        else:
          bot_event(
              'request_task', task_id=run_result.task_id,
              task_name=request.name)
          self._cmd_run(request, run_result.key, bot_id)
      except:
        logging.exception('Dang, exception after reaping')
        raise
    except runtime.DeadlineExceededError:
      # If the timeout happened before a task was assigned there is no problems.
      # If the timeout occurred after a task was assigned, that task will
      # timeout (BOT_DIED) since the bot didn't get the details required to
      # run it) and it will automatically get retried (TODO) when the task times
      # out.
      # TODO(maruel): Note the task if possible and hand it out on next poll.
      # https://code.google.com/p/swarming/issues/detail?id=130
      self.abort(500, 'Deadline')

  def _cmd_run(self, request, run_result_key, bot_id):
    # Only one of 'command' or 'inputs_ref' can be set.
    out = {
      'cmd': 'run',
      'manifest': {
        'bot_id': bot_id,
        'command':
            request.properties.commands[0]
            if request.properties.commands else None,
        'data': request.properties.data,
        'dimensions': request.properties.dimensions,
        'env': request.properties.env,
        'extra_args': request.properties.extra_args,
        'grace_period': request.properties.grace_period_secs,
        'hard_timeout': request.properties.execution_timeout_secs,
        'host': utils.get_versioned_hosturl(),
        'io_timeout': request.properties.io_timeout_secs,
        'inputs_ref': request.properties.inputs_ref,
        'task_id': task_pack.pack_run_result_key(run_result_key),
      },
    }
    self.send_response(utils.to_json_encodable(out))

  def _cmd_sleep(self, sleep_streak, quarantined):
    out = {
      'cmd': 'sleep',
      'duration': task_scheduler.exponential_backoff(sleep_streak),
      'quarantined': quarantined,
    }
    self.send_response(out)

  def _cmd_terminate(self, task_id):
    out = {
      'cmd': 'terminate',
      'task_id': task_id,
    }
    self.send_response(out)

  def _cmd_update(self, expected_version):
    out = {
      'cmd': 'update',
      'version': expected_version,
    }
    self.send_response(out)

  def _cmd_restart(self, message):
    logging.info('Rebooting bot: %s', message)
    out = {
      'cmd': 'restart',
      'message': message,
    }
    self.send_response(out)


class BotEventHandler(_BotBaseHandler):
  """"""On signal that a bot had an event worth logging.""""""

  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}

  @auth.require(acl.is_bot)
  def post(self):
    (request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    event = request.get('event')
    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):
      self.abort_with_error(400, error='Unsupported event type')
    message = request.get('message')
    bot_management.bot_event(
        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,
        dimensions=dimensions, state=state, version=version,
        quarantined=bool(quarantined_msg), task_id=None, task_name=None,
        message=message)

    if event == 'bot_error':
      line = (
          'Bot: https://%s/restricted/bot/%s\n'
          'Bot error:\n'
          '%s') % (
          app_identity.get_default_version_hostname(), bot_id, message)
      ereporter2.log_request(self.request, source='bot', message=line)
    self.send_response({})


class BotTaskUpdateHandler(auth.ApiHandler):
  """"""Receives updates from a Bot for a task.

  The handler verifies packets are processed in order and will refuse
  out-of-order packets.
  """"""
  ACCEPTED_KEYS = {
    u'cost_usd', u'duration', u'exit_code', u'hard_timeout',
    u'id', u'io_timeout', u'output', u'output_chunk_start', u'outputs_ref',
    u'task_id',
  }
  REQUIRED_KEYS = {u'id', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    # Unlike handshake and poll, we do not accept invalid keys here. This code
    # path is much more strict.
    request = self.parse_body()
    msg = log_unexpected_subset_keys(
        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',
        'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    bot_id = request['id']
    cost_usd = request['cost_usd']
    task_id = request['task_id']

    duration = request.get('duration')
    exit_code = request.get('exit_code')
    hard_timeout = request.get('hard_timeout')
    io_timeout = request.get('io_timeout')
    output = request.get('output')
    output_chunk_start = request.get('output_chunk_start')
    outputs_ref = request.get('outputs_ref')

    run_result_key = task_pack.unpack_run_result_key(task_id)
    if output is not None:
      try:
        output = base64.b64decode(output)
      except UnicodeEncodeError as e:
        logging.error('Failed to decode output\n%s\n%r', e, output)
        output = output.encode('ascii', 'replace')
      except TypeError as e:
        # Save the output as-is instead. The error will be logged in ereporter2
        # and returning a HTTP 500 would only force the bot to stay in a retry
        # loop.
        logging.error('Failed to decode output\n%s\n%r', e, output)

    try:
      success, completed = task_scheduler.bot_update_task(
          run_result_key, bot_id, output, output_chunk_start,
          exit_code, duration, hard_timeout, io_timeout, cost_usd, outputs_ref)
      if not success:
        logging.info('Failed to update, please retry')
        self.abort_with_error(500, error='Failed to update, please retry')

      action = 'task_completed' if completed else 'task_update'
      bot_management.bot_event(
          event_type=action, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=None, state=None,
          version=None, quarantined=None, task_id=task_id, task_name=None)
    except ValueError as e:
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % e)
      self.abort_with_error(400, error=str(e))
    except webob.exc.HTTPException:
      raise
    except Exception as e:
      logging.exception('Internal error: %s', e)
      self.abort_with_error(500, error=str(e))

    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot
    # reboots itself to abort the task abruptly. It is useful when a task hangs
    # and the timeout was set too long or the task was superseded by a newer
    # task with more recent executable (e.g. a new Try Server job on a newer
    # patchset on Rietveld).
    self.send_response({'ok': True})


class BotTaskErrorHandler(auth.ApiHandler):
  """"""It is a specialized version of ereporter2's /ereporter2/api/v1/on_error
  that also attaches a task id to it.

  This formally kills the task, marking it as an internal failure. This can be
  used by bot_main.py to kill the task when task_runner misbehaved.
  """"""

  EXPECTED_KEYS = {u'id', u'message', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    request = self.parse_body()
    bot_id = request.get('id')
    task_id = request.get('task_id', '')
    message = request.get('message', 'unknown')

    bot_management.bot_event(
        event_type='task_error', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=None, state=None,
        version=None, quarantined=None, task_id=task_id, task_name=None,
        message=message)
    line = (
        'Bot: https://%s/restricted/bot/%s\n'
        'Task failed: https://%s/user/task/%s\n'
        '%s') % (
        app_identity.get_default_version_hostname(), bot_id,
        app_identity.get_default_version_hostname(), task_id,
        message)
    ereporter2.log_request(self.request, source='bot', message=line)

    msg = log_unexpected_keys(
        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    msg = task_scheduler.bot_kill_task(
        task_pack.unpack_run_result_key(task_id), bot_id)
    if msg:
      logging.error(msg)
      self.abort_with_error(400, error=msg)
    self.send_response({})


class ServerPingHandler(webapp2.RequestHandler):
  """"""Handler to ping when checking if the server is up.

  This handler should be extremely lightweight. It shouldn't do any
  computations, it should just state that the server is up. It's open to
  everyone for simplicity and performance.
  """"""

  def get(self):
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.out.write('Server up')


def get_routes():
  routes = [
      ('/bootstrap', BootstrapHandler),
      ('/bot_code', BotCodeHandler),
      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),
      ('/swarming/api/v1/bot/event', BotEventHandler),
      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),
      ('/swarming/api/v1/bot/poll', BotPollHandler),
      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),
      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',
          BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),
      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',
          BotTaskErrorHandler),
  ]
  return [webapp2.Route(*i) for i in routes]
/n/n/n",0
81,0ba6a589d77baefc5ae20cde5c3a5dc24a6290f9,"/appengine/components/components/auth/handler.py/n/n# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Integration with webapp2.""""""

# Disable 'Method could be a function.'
# pylint: disable=R0201

import functools
import json
import logging
import urllib
import webapp2

from google.appengine.api import urlfetch
from google.appengine.api import users

from components import utils

from . import api
from . import config
from . import delegation
from . import host_token
from . import ipaddr
from . import model
from . import openid
from . import tokens

# Part of public API of 'auth' component, exposed by this module.
__all__ = [
  'ApiHandler',
  'AuthenticatingHandler',
  'gae_cookie_authentication',
  'get_authenticated_routes',
  'oauth_authentication',
  'openid_cookie_authentication',
  'require_xsrf_token_request',
  'service_to_service_authentication',
]


def require_xsrf_token_request(f):
  """"""Use for handshaking APIs.""""""
  @functools.wraps(f)
  def hook(self, *args, **kwargs):
    if not self.request.headers.get('X-XSRF-Token-Request'):
      raise api.AuthorizationError('Missing required XSRF request header')
    return f(self, *args, **kwargs)
  return hook


class XSRFToken(tokens.TokenKind):
  """"""XSRF token parameters.""""""
  expiration_sec = 4 * 3600
  secret_key = api.SecretKey('xsrf_token', scope='local')
  version = 1


class AuthenticatingHandlerMetaclass(type):
  """"""Ensures that 'get', 'post', etc. are marked with @require or @public.""""""

  def __new__(mcs, name, bases, attributes):
    for method in webapp2.WSGIApplication.allowed_methods:
      func = attributes.get(method.lower())
      if func and not api.is_decorated(func):
        raise TypeError(
            'Method \'%s\' of \'%s\' is not protected by @require or @public '
            'decorator' % (method.lower(), name))
    return type.__new__(mcs, name, bases, attributes)


class AuthenticatingHandler(webapp2.RequestHandler):
  """"""Base class for webapp2 request handlers that use Auth system.

  Knows how to extract Identity from request data and how to initialize auth
  request context, so that get_current_identity() and is_group_member() work.

  All request handling methods (like 'get', 'post', etc) should be marked by
  either @require or @public decorators.
  """"""

  # Checks that all 'get', 'post', etc. are marked with @require or @public.
  __metaclass__ = AuthenticatingHandlerMetaclass

  # List of HTTP methods that trigger XSRF token validation.
  xsrf_token_enforce_on = ('DELETE', 'POST', 'PUT')
  # If not None, the header to search for XSRF token.
  xsrf_token_header = 'X-XSRF-Token'
  # If not None, the request parameter (GET or POST) to search for XSRF token.
  xsrf_token_request_param = 'xsrf_token'
  # Embedded data extracted from XSRF token of current request.
  xsrf_token_data = None
  # If not None, sets X_Frame-Options on all replies.
  frame_options = 'DENY'
  # A method used to authenticate this request, see get_auth_methods().
  auth_method = None

  def dispatch(self):
    """"""Extracts and verifies Identity, sets up request auth context.""""""
    # Ensure auth component is configured before executing any code.
    conf = config.ensure_configured()
    auth_context = api.reinitialize_request_cache()

    # http://www.html5rocks.com/en/tutorials/security/content-security-policy/
    # https://www.owasp.org/index.php/Content_Security_Policy
    # TODO(maruel): Remove 'unsafe-inline' once all inline style=""foo:bar"" in
    # all HTML tags were removed. Warning if seeing this post 2016, it could
    # take a while.
    # - https://www.google.com is due to Google Viz library.
    # - https://www.google-analytics.com due to Analytics.
    # - 'unsafe-eval' due to polymer.
    self.response.headers['Content-Security-Policy'] = (
        'default-src https: \'self\' \'unsafe-inline\' https://www.google.com '
        'https://www.google-analytics.com \'unsafe-eval\'')
    # Enforce HTTPS by adding the HSTS header; 365*24*60*60s.
    # https://www.owasp.org/index.php/HTTP_Strict_Transport_Security
    self.response.headers['Strict-Transport-Security'] = (
        'max-age=31536000; includeSubDomains; preload')
    # Disable frame support wholesale.
    # https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet
    if self.frame_options:
      self.response.headers['X-Frame-Options'] = self.frame_options

    identity = None
    for method_func in self.get_auth_methods(conf):
      try:
        identity = method_func(self.request)
        if identity:
          break
      except api.AuthenticationError as err:
        self.authentication_error(err)
        return
      except api.AuthorizationError as err:
        self.authorization_error(err)
        return
    else:
      method_func = None
    self.auth_method = method_func

    # If no authentication method is applicable, default to anonymous identity.
    identity = identity or model.Anonymous

    # XSRF token is required only if using Cookie based or IP whitelist auth.
    # A browser doesn't send Authorization: 'Bearer ...' or any other headers
    # by itself. So XSRF check is not required if header based authentication
    # is used.
    using_headers_auth = method_func in (
        oauth_authentication, service_to_service_authentication)

    # Extract caller host name from host token header, if present and valid.
    host_tok = self.request.headers.get(host_token.HTTP_HEADER)
    if host_tok:
      validated_host = host_token.validate_host_token(host_tok)
      if validated_host:
        auth_context.peer_host = validated_host

    # Verify IP is whitelisted and authenticate requests from bots.
    assert self.request.remote_addr
    ip = ipaddr.ip_from_string(self.request.remote_addr)
    auth_context.peer_ip = ip
    try:
      # 'verify_ip_whitelisted' may change identity for bots, store new one.
      auth_context.peer_identity = api.verify_ip_whitelisted(
          identity, ip, self.request.headers)
    except api.AuthorizationError as err:
      self.authorization_error(err)
      return

    # Parse delegation token, if given, to deduce end-user identity.
    delegation_tok = self.request.headers.get(delegation.HTTP_HEADER)
    if delegation_tok:
      try:
        auth_context.current_identity = delegation.check_delegation_token(
            delegation_tok, auth_context.peer_identity)
      except delegation.BadTokenError as exc:
        self.authorization_error(
            api.AuthorizationError('Bad delegation token: %s' % exc))
      except delegation.TransientError as exc:
        msg = 'Transient error while validating delegation token.\n%s' % exc
        logging.error(msg)
        self.abort(500, detail=msg)
    else:
      auth_context.current_identity = auth_context.peer_identity

    try:
      # Fail if XSRF token is required, but not provided.
      need_xsrf_token = (
          not using_headers_auth and
          self.request.method in self.xsrf_token_enforce_on)
      if need_xsrf_token and self.xsrf_token is None:
        raise api.AuthorizationError('XSRF token is missing')

      # If XSRF token is present, verify it is valid and extract its payload.
      # Do it even if XSRF token is not strictly required, since some handlers
      # use it to store session state (it is similar to a signed cookie).
      self.xsrf_token_data = {}
      if self.xsrf_token is not None:
        # This raises AuthorizationError if token is invalid.
        self.xsrf_token_data = self.verify_xsrf_token()

      # All other ACL checks will be performed by corresponding handlers
      # manually or via '@required' decorator. Failed ACL check raises
      # AuthorizationError.
      super(AuthenticatingHandler, self).dispatch()
    except api.AuthorizationError as err:
      self.authorization_error(err)

  @classmethod
  def get_auth_methods(cls, conf):
    """"""Returns an enumerable of functions to use to authenticate request.

    The handler will try to apply auth methods sequentially one by one by until
    it finds one that works.

    Each auth method is a function that accepts webapp2.Request and can finish
    with 3 outcomes:

    * Return None: authentication method is not applicable to that request
      and next method should be tried (for example cookie-based
      authentication is not applicable when there's no cookies).

    * Returns Identity associated with the request. Means authentication method
      is applicable and request authenticity is confirmed.

    * Raises AuthenticationError: authentication method is applicable, but
      request contains bad credentials or invalid token, etc. For example,
      OAuth2 token is given, but it is revoked.

    A chosen auth method function will be stored in request's auth_method field.

    Args:
      conf: components.auth GAE config, see config.py.
    """"""
    if conf.USE_OPENID:
      cookie_auth = openid_cookie_authentication
    else:
      cookie_auth = gae_cookie_authentication
    return oauth_authentication, cookie_auth, service_to_service_authentication

  def generate_xsrf_token(self, xsrf_token_data=None):
    """"""Returns new XSRF token that embeds |xsrf_token_data|.

    The token is bound to current identity and is valid only when used by same
    identity.
    """"""
    return XSRFToken.generate(
        [api.get_current_identity().to_bytes()], xsrf_token_data)

  @property
  def xsrf_token(self):
    """"""Returns XSRF token passed with the request or None if missing.

    Doesn't do any validation. Use verify_xsrf_token() instead.
    """"""
    token = None
    if self.xsrf_token_header:
      token = self.request.headers.get(self.xsrf_token_header)
    if not token and self.xsrf_token_request_param:
      param = self.request.get_all(self.xsrf_token_request_param)
      token = param[0] if param else None
    return token

  def verify_xsrf_token(self):
    """"""Grabs a token from the request, validates it and extracts embedded data.

    Current identity must be the same as one used to generate the token.

    Returns:
      Whatever was passed as |xsrf_token_data| in 'generate_xsrf_token'
      method call used to generate the token.

    Raises:
      AuthorizationError if token is missing, invalid or expired.
    """"""
    token = self.xsrf_token
    if not token:
      raise api.AuthorizationError('XSRF token is missing')
    # Check that it was generated for the same identity.
    try:
      return XSRFToken.validate(token, [api.get_current_identity().to_bytes()])
    except tokens.InvalidTokenError as err:
      raise api.AuthorizationError(str(err))

  def authentication_error(self, error):
    """"""Called when authentication fails to report the error to requester.

    Authentication error means that some credentials are provided but they are
    invalid. If no credentials are provided at all, no authentication is
    attempted and current identity is just set to 'anonymous:anonymous'.

    Default behavior is to abort the request with HTTP 401 error (and human
    readable HTML body).

    Args:
      error: instance of AuthenticationError subclass.
    """"""
    logging.warning('Authentication error.\n%s', error)
    self.abort(401, detail=str(error))

  def authorization_error(self, error):
    """"""Called when authentication succeeds, but access to a resource is denied.

    Called whenever request handler raises AuthorizationError exception.
    In particular this exception is raised by method decorated with @require if
    current identity doesn't have required permission.

    Default behavior is to abort the request with HTTP 403 error (and human
    readable HTML body).

    Args:
      error: instance of AuthorizationError subclass.
    """"""
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort(403, detail=str(error))

  ### Wrappers around Users API or its OpenID equivalent.

  def get_current_user(self):
    """"""When cookie auth is used returns instance of CurrentUser or None.""""""
    return self._get_users_api().get_current_user(self.request)

  def is_current_user_gae_admin(self):
    """"""When cookie auth is used returns True if current caller is GAE admin.""""""
    return self._get_users_api().is_current_user_gae_admin(self.request)

  def create_login_url(self, dest_url):
    """"""When cookie auth is used returns URL to redirect user to login.""""""
    return self._get_users_api().create_login_url(self.request, dest_url)

  def create_logout_url(self, dest_url):
    """"""When cookie auth is used returns URL to redirect user to logout.""""""
    return self._get_users_api().create_logout_url(self.request, dest_url)

  def _get_users_api(self):
    """"""Returns GAEUsersAPI, OpenIDAPI or raises NotImplementedError.

    Chooses based on what auth_method was used of what methods are available.
    """"""
    method = self.auth_method
    if not method:
      # Anonymous request -> pick first method that supports API.
      for method in self.get_auth_methods(config.ensure_configured()):
        if method in _METHOD_TO_USERS_API:
          break
      else:
        raise NotImplementedError('No methods support UsersAPI')
    elif method not in _METHOD_TO_USERS_API:
      raise NotImplementedError(
          '%s doesn\'t support UsersAPI' % method.__name__)
    return _METHOD_TO_USERS_API[method]


class ApiHandler(AuthenticatingHandler):
  """"""Parses JSON request body to a dict, serializes response to JSON.""""""
  CONTENT_TYPE_BASE = 'application/json'
  CONTENT_TYPE_FULL = 'application/json; charset=utf-8'
  _json_body = None
  # Clickjacking not applicable to APIs.
  frame_options = None

  def authentication_error(self, error):
    logging.warning('Authentication error.\n%s', error)
    self.abort_with_error(401, text=str(error))

  def authorization_error(self, error):
    logging.warning(
        'Authorization error.\n%s\nPeer: %s\nIP: %s',
        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)
    self.abort_with_error(403, text=str(error))

  def send_response(self, response, http_code=200, headers=None):
    """"""Sends successful reply and continues execution.""""""
    self.response.set_status(http_code)
    self.response.headers.update(headers or {})
    self.response.headers['Content-Type'] = self.CONTENT_TYPE_FULL
    self.response.write(json.dumps(response))

  def abort_with_error(self, http_code, **kwargs):
    """"""Sends error reply and stops execution.""""""
    self.abort(
        http_code,
        json=kwargs,
        headers={'Content-Type': self.CONTENT_TYPE_FULL})

  def parse_body(self):
    """"""Parses JSON body and verifies it's a dict.

    webob.Request doesn't cache the decoded json body, this function does.
    """"""
    if self._json_body is None:
      if (self.CONTENT_TYPE_BASE and
          self.request.content_type != self.CONTENT_TYPE_BASE):
        msg = (
            'Expecting JSON body with content type \'%s\'' %
            self.CONTENT_TYPE_BASE)
        self.abort_with_error(400, text=msg)
      try:
        self._json_body = self.request.json
        if not isinstance(self._json_body, dict):
          raise ValueError()
      except (LookupError, ValueError):
        self.abort_with_error(400, text='Not a valid json dict body')
    return self._json_body.copy()


def get_authenticated_routes(app):
  """"""Given WSGIApplication returns list of routes that use authentication.

  Intended to be used only for testing.
  """"""
  # This code is adapted from router's __repr__ method (that enumerate
  # all routes for pretty-printing).
  routes = list(app.router.match_routes)
  routes.extend(
      v for k, v in app.router.build_routes.iteritems()
      if v not in app.router.match_routes)
  return [r for r in routes if issubclass(r.handler, AuthenticatingHandler)]


################################################################################
## All supported implementations of authentication methods for webapp2 handlers.


def gae_cookie_authentication(_request):
  """"""AppEngine cookie based authentication via users.get_current_user().""""""
  user = users.get_current_user()
  try:
    return model.Identity(model.IDENTITY_USER, user.email()) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email())


def openid_cookie_authentication(request):
  """"""Cookie based authentication that uses OpenID flow for login.""""""
  user = openid.get_current_user(request)
  try:
    return model.Identity(model.IDENTITY_USER, user.email) if user else None
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % user.email)


def oauth_authentication(request):
  """"""OAuth2 based authentication via oauth.get_current_user().""""""
  if not request.headers.get('Authorization'):
    return None
  if not utils.is_local_dev_server():
    return api.extract_oauth_caller_identity()

  # OAuth2 library is mocked on dev server to return some nonsense. Use (slow,
  # but real) OAuth2 API endpoint instead to validate access_token. It is also
  # what Cloud Endpoints do on a local server. For simplicity ignore client_id
  # on dev server.
  header = request.headers['Authorization'].split(' ', 1)
  if len(header) != 2 or header[0] not in ('OAuth', 'Bearer'):
    raise api.AuthenticationError('Invalid authorization header')

  # Adapted from endpoints/users_id_tokens.py, _set_bearer_user_vars_local.
  base_url = 'https://www.googleapis.com/oauth2/v1/tokeninfo'
  result = urlfetch.fetch(
      url='%s?%s' % (base_url, urllib.urlencode({'access_token': header[1]})),
      follow_redirects=False,
      validate_certificate=True)
  if result.status_code != 200:
    try:
      error = json.loads(result.content)['error_description']
    except (KeyError, ValueError):
      error = repr(result.content)
    raise api.AuthenticationError('Failed to validate the token: %s' % error)

  token_info = json.loads(result.content)
  if 'email' not in token_info:
    raise api.AuthenticationError('Token doesn\'t include an email address')
  if not token_info.get('verified_email'):
    raise api.AuthenticationError('Token email isn\'t verified')

  email = token_info['email']
  try:
    return model.Identity(model.IDENTITY_USER, email)
  except ValueError:
    raise api.AuthenticationError('Unsupported user email: %s' % email)


def service_to_service_authentication(request):
  """"""Used for AppEngine <-> AppEngine communication.

  Relies on X-Appengine-Inbound-Appid header set by AppEngine itself. It can't
  be set by external users (with exception of admins).
  """"""
  app_id = request.headers.get('X-Appengine-Inbound-Appid')
  try:
    return model.Identity(model.IDENTITY_SERVICE, app_id) if app_id else None
  except ValueError:
    raise api.AuthenticationError('Unsupported application ID: %s' % app_id)


################################################################################
## API wrapper on top of Users API and OpenID API to make them similar.


class CurrentUser(object):
  """"""Mimics subset of GAE users.User object for ease of transition.

  Also adds .picture().
  """"""

  def __init__(self, user_id, email, picture):
    self._user_id = user_id
    self._email = email
    self._picture = picture

  def nickname(self):
    return self._email

  def email(self):
    return self._email

  def user_id(self):
    return self._user_id

  def picture(self):
    return self._picture

  def __unicode__(self):
    return unicode(self.nickname())

  def __str__(self):
    return str(self.nickname())


class GAEUsersAPI(object):
  @staticmethod
  def get_current_user(request):  # pylint: disable=unused-argument
    user = users.get_current_user()
    return CurrentUser(user.user_id(), user.email(), None) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return users.is_current_user_admin()

  @staticmethod
  def create_login_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_login_url(dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):  # pylint: disable=unused-argument
    return users.create_logout_url(dest_url)


class OpenIDAPI(object):
  @staticmethod
  def get_current_user(request):
    user = openid.get_current_user(request)
    return CurrentUser(user.sub, user.email, user.picture) if user else None

  @staticmethod
  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument
    return False

  @staticmethod
  def create_login_url(request, dest_url):
    return openid.create_login_url(request, dest_url)

  @staticmethod
  def create_logout_url(request, dest_url):
    return openid.create_logout_url(request, dest_url)


# See AuthenticatingHandler._get_users_api().
_METHOD_TO_USERS_API = {
  gae_cookie_authentication: GAEUsersAPI,
  openid_cookie_authentication: OpenIDAPI,
}
/n/n/n/appengine/components/components/auth/handler_test.py/n/n#!/usr/bin/env python
# Copyright 2014 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

# Disable 'Unused variable', 'Unused argument' and 'Method could be a function'.
# pylint: disable=W0612,W0613,R0201

import datetime
import json
import os
import sys
import unittest

from test_support import test_env
test_env.setup_test_env()

from google.appengine.api import oauth
from google.appengine.api import users

import webapp2
import webtest

from components import utils
from components.auth import api
from components.auth import delegation
from components.auth import handler
from components.auth import host_token
from components.auth import ipaddr
from components.auth import model
from components.auth.proto import delegation_pb2
from test_support import test_case


class AuthenticatingHandlerMetaclassTest(test_case.TestCase):
  """"""Tests for AuthenticatingHandlerMetaclass.""""""

  def test_good(self):
    # No request handling methods defined at all.
    class TestHandler1(handler.AuthenticatingHandler):
      def some_other_method(self):
        pass

    # @public is used.
    class TestHandler2(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        pass

    # @require is used.
    class TestHandler3(handler.AuthenticatingHandler):
      @api.require(lambda: True)
      def get(self):
        pass

  def test_bad(self):
    # @public or @require is missing.
    with self.assertRaises(TypeError):
      class TestHandler1(handler.AuthenticatingHandler):
        def get(self):
          pass


class AuthenticatingHandlerTest(test_case.TestCase):
  """"""Tests for AuthenticatingHandler class.""""""

  def setUp(self):
    super(AuthenticatingHandlerTest, self).setUp()
    # Reset global config of auth library before each test.
    api.reset_local_state()
    # Capture error and warning log messages.
    self.logged_errors = []
    self.mock(handler.logging, 'error',
        lambda *args, **kwargs: self.logged_errors.append((args, kwargs)))
    self.logged_warnings = []
    self.mock(handler.logging, 'warning',
        lambda *args, **kwargs: self.logged_warnings.append((args, kwargs)))

  def make_test_app(self, path, request_handler):
    """"""Returns webtest.TestApp with single route.""""""
    return webtest.TestApp(
        webapp2.WSGIApplication([(path, request_handler)], debug=True),
        extra_environ={'REMOTE_ADDR': '127.0.0.1'})

  def test_anonymous(self):
    """"""If all auth methods are not applicable, identity is set to Anonymous.""""""
    test = self

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        non_applicable = lambda _request: None
        return [non_applicable, non_applicable]

      @api.public
      def get(self):
        test.assertEqual(model.Anonymous, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)

  def test_ip_whitelist_bot(self):
    """"""Requests from client in ""bots"" IP whitelist are authenticated as bot.""""""
    model.bootstrap_ip_whitelist('bots', ['192.168.1.100/32'])

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_current_identity().to_bytes())

    app = self.make_test_app('/request', Handler)
    def call(ip):
      api.reset_local_state()
      return app.get('/request', extra_environ={'REMOTE_ADDR': ip}).body

    self.assertEqual('bot:whitelisted-ip', call('192.168.1.100'))
    self.assertEqual('anonymous:anonymous', call('127.0.0.1'))

  def test_ip_whitelist(self):
    """"""Per-account IP whitelist works.""""""
    ident1 = model.Identity(model.IDENTITY_USER, 'a@example.com')
    ident2 = model.Identity(model.IDENTITY_USER, 'b@example.com')

    model.bootstrap_ip_whitelist('whitelist', ['192.168.1.100/32'])
    model.bootstrap_ip_whitelist_assignment(ident1, 'whitelist')

    mocked_ident = [None]

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _req: mocked_ident[0]]

      @api.public
      def get(self):
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    def call(ident, ip):
      api.reset_local_state()
      mocked_ident[0] = ident
      response = app.get(
          '/request', extra_environ={'REMOTE_ADDR': ip}, expect_errors=True)
      return response.status_int

    # IP is whitelisted.
    self.assertEqual(200, call(ident1, '192.168.1.100'))
    # IP is NOT whitelisted.
    self.assertEqual(403, call(ident1, '127.0.0.1'))
    # Whitelist is not used.
    self.assertEqual(200, call(ident2, '127.0.0.1'))

  def test_auth_method_order(self):
    """"""Registered auth methods are tested in order.""""""
    test = self
    calls = []
    ident = model.Identity(model.IDENTITY_USER, 'joe@example.com')

    def not_applicable(request):
      self.assertEqual('/request', request.path)
      calls.append('not_applicable')
      return None

    def applicable(request):
      self.assertEqual('/request', request.path)
      calls.append('applicable')
      return ident

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [not_applicable, applicable]

      @api.public
      def get(self):
        test.assertEqual(ident, api.get_current_identity())
        self.response.write('OK')

    app = self.make_test_app('/request', Handler)
    self.assertEqual('OK', app.get('/request').body)

    # Both methods should be tried.
    expected_calls = [
      'not_applicable',
      'applicable',
    ]
    self.assertEqual(expected_calls, calls)

  def test_authentication_error(self):
    """"""AuthenticationError in auth method stops request processing.""""""
    test = self
    calls = []

    def failing(request):
      raise api.AuthenticationError('Too bad')

    def skipped(request):
      self.fail('authenticate should not be called')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [failing, skipped]

      @api.public
      def get(self):
        test.fail('Handler code should not be called')

      def authentication_error(self, err):
        test.assertEqual('Too bad', err.message)
        calls.append('authentication_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authentication_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 401.
    self.assertEqual(['authentication_error'], calls)
    self.assertEqual(401, response.status_int)

    # Authentication error is logged.
    self.assertEqual(1, len(self.logged_warnings))

  def test_authorization_error(self):
    """"""AuthorizationError in auth method is handled.""""""
    test = self
    calls = []

    class Handler(handler.AuthenticatingHandler):
      @api.require(lambda: False)
      def get(self):
        test.fail('Handler code should not be called')

      def authorization_error(self, err):
        calls.append('authorization_error')
        # pylint: disable=bad-super-call
        super(Handler, self).authorization_error(err)

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', expect_errors=True)

    # Custom error handler is called and returned HTTP 403.
    self.assertEqual(['authorization_error'], calls)
    self.assertEqual(403, response.status_int)

  def make_xsrf_handling_app(
      self,
      xsrf_token_enforce_on=None,
      xsrf_token_header=None,
      xsrf_token_request_param=None):
    """"""Returns webtest app with single XSRF-aware handler.

    If generates XSRF tokens on GET and validates them on POST, PUT, DELETE.
    """"""
    calls = []

    def record(request_handler, method):
      is_valid = request_handler.xsrf_token_data == {'some': 'data'}
      calls.append((method, is_valid))

    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(self.generate_xsrf_token({'some': 'data'}))
      @api.public
      def post(self):
        record(self, 'POST')
      @api.public
      def put(self):
        record(self, 'PUT')
      @api.public
      def delete(self):
        record(self, 'DELETE')

    if xsrf_token_enforce_on is not None:
      Handler.xsrf_token_enforce_on = xsrf_token_enforce_on
    if xsrf_token_header is not None:
      Handler.xsrf_token_header = xsrf_token_header
    if xsrf_token_request_param is not None:
      Handler.xsrf_token_request_param = xsrf_token_request_param

    app = self.make_test_app('/request', Handler)
    return app, calls

  def mock_get_current_identity(self, ident):
    """"""Mocks api.get_current_identity() to return |ident|.""""""
    self.mock(handler.api, 'get_current_identity', lambda: ident)

  def test_xsrf_token_get_param(self):
    """"""XSRF token works if put in GET parameters.""""""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request?xsrf_token=%s' % token)
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_post_param(self):
    """"""XSRF token works if put in POST parameters.""""""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_header(self):
    """"""XSRF token works if put in the headers.""""""
    app, calls = self.make_xsrf_handling_app()
    token = app.get('/request').body
    app.post('/request', headers={'X-XSRF-Token': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_missing(self):
    """"""XSRF token is not given but handler requires it.""""""
    app, calls = self.make_xsrf_handling_app()
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)
    self.assertFalse(calls)

  def test_xsrf_token_uses_enforce_on(self):
    """"""Only methods set in |xsrf_token_enforce_on| require token validation.""""""
    # Validate tokens only on PUT (not on POST).
    app, calls = self.make_xsrf_handling_app(xsrf_token_enforce_on=('PUT',))
    token = app.get('/request').body
    # Both POST and PUT work when token provided, verifying it.
    app.post('/request', {'xsrf_token': token})
    app.put('/request', {'xsrf_token': token})
    self.assertEqual([('POST', True), ('PUT', True)], calls)
    # POST works without a token, put PUT doesn't.
    self.assertEqual(200, app.post('/request').status_int)
    self.assertEqual(403, app.put('/request', expect_errors=True).status_int)
    # Both fail if wrong token is provided.
    bad_token = {'xsrf_token': 'boo'}
    self.assertEqual(
        403, app.post('/request', bad_token, expect_errors=True).status_int)
    self.assertEqual(
        403, app.put('/request', bad_token, expect_errors=True).status_int)

  def test_xsrf_token_uses_xsrf_token_header(self):
    """"""Name of the header used for XSRF can be changed.""""""
    app, calls = self.make_xsrf_handling_app(xsrf_token_header='X-Some')
    token = app.get('/request').body
    app.post('/request', headers={'X-Some': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_uses_xsrf_token_request_param(self):
    """"""Name of the request param used for XSRF can be changed.""""""
    app, calls = self.make_xsrf_handling_app(xsrf_token_request_param='tok')
    token = app.get('/request').body
    app.post('/request', {'tok': token})
    self.assertEqual([('POST', True)], calls)

  def test_xsrf_token_identity_matters(self):
    app, calls = self.make_xsrf_handling_app()
    # Generate token for identity A.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'a@example.com'))
    token = app.get('/request').body
    # Try to use it by identity B.
    self.mock_get_current_identity(
        model.Identity(model.IDENTITY_USER, 'b@example.com'))
    response = app.post('/request', expect_errors=True)
    self.assertEqual(403, response.status_int)
    self.assertFalse(calls)

  def test_get_authenticated_routes(self):
    class Authenticated(handler.AuthenticatingHandler):
      pass

    class NotAuthenticated(webapp2.RequestHandler):
      pass

    app = webapp2.WSGIApplication([
      webapp2.Route('/authenticated', Authenticated),
      webapp2.Route('/not-authenticated', NotAuthenticated),
    ])
    routes = handler.get_authenticated_routes(app)
    self.assertEqual(1, len(routes))
    self.assertEqual(Authenticated, routes[0].handler)

  def test_get_peer_ip(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(ipaddr.ip_to_string(api.get_peer_ip()))

    app = self.make_test_app('/request', Handler)
    response = app.get('/request', extra_environ={'REMOTE_ADDR': '192.1.2.3'})
    self.assertEqual('192.1.2.3', response.body)

  def test_get_peer_host(self):
    class Handler(handler.AuthenticatingHandler):
      @api.public
      def get(self):
        self.response.write(api.get_peer_host() or '<none>')

    app = self.make_test_app('/request', Handler)
    def call(headers):
      api.reset_local_state()
      return app.get('/request', headers=headers).body

    # Good token.
    token = host_token.create_host_token('HOST.domain.com')
    self.assertEqual('host.domain.com', call({'X-Host-Token-V1': token}))

    # Missing or invalid tokens.
    self.assertEqual('<none>', call({}))
    self.assertEqual('<none>', call({'X-Host-Token-V1': 'broken'}))

    # Expired token.
    origin = datetime.datetime(2014, 1, 1, 1, 1, 1)
    self.mock_now(origin)
    token = host_token.create_host_token('HOST.domain.com', expiration_sec=60)
    self.mock_now(origin, 61)
    self.assertEqual('<none>', call({'X-Host-Token-V1': token}))

  def test_delegation_token(self):
    peer_ident = model.Identity.from_bytes('user:peer@a.com')

    class Handler(handler.AuthenticatingHandler):
      @classmethod
      def get_auth_methods(cls, conf):
        return [lambda _request: peer_ident]

      @api.public
      def get(self):
        self.response.write(json.dumps({
          'peer_id': api.get_peer_identity().to_bytes(),
          'cur_id': api.get_current_identity().to_bytes(),
        }))

    app = self.make_test_app('/request', Handler)
    def call(headers=None):
      return json.loads(app.get('/request', headers=headers).body)

    # No delegation.
    self.assertEqual(
        {u'cur_id': u'user:peer@a.com', u'peer_id': u'user:peer@a.com'}, call())

    # TODO(vadimsh): Mint token via some high-level function call.
    subtokens = delegation_pb2.SubtokenList(subtokens=[
        delegation_pb2.Subtoken(
            issuer_id='user:delegated@a.com',
            creation_time=int(utils.time_time()),
            validity_duration=3600),
    ])
    tok = delegation.serialize_token(delegation.seal_token(subtokens))

    # With valid delegation token.
    self.assertEqual(
        {u'cur_id': u'user:delegated@a.com', u'peer_id': u'user:peer@a.com'},
        call({'X-Delegation-Token-V1': tok}))

    # With invalid delegation token.
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok + 'blah'},
        expect_errors=True)
    self.assertEqual(403, r.status_int)

    # Transient error.
    def mocked_check(*_args):
      raise delegation.TransientError('Blah')
    self.mock(delegation, 'check_delegation_token', mocked_check)
    r = app.get(
        '/request',
        headers={'X-Delegation-Token-V1': tok},
        expect_errors=True)
    self.assertEqual(500, r.status_int)


class GaeCookieAuthenticationTest(test_case.TestCase):
  """"""Tests for gae_cookie_authentication function.""""""

  def test_non_applicable(self):
    self.assertIsNone(handler.gae_cookie_authentication(webapp2.Request({})))

  def test_applicable(self):
    os.environ.update({
      'USER_EMAIL': 'joe@example.com',
      'USER_ID': '123',
      'USER_IS_ADMIN': '0',
    })
    # Actual request is not used by CookieAuthentication.
    self.assertEqual(
        model.Identity(model.IDENTITY_USER, 'joe@example.com'),
        handler.gae_cookie_authentication(webapp2.Request({})))


class ServiceToServiceAuthenticationTest(test_case.TestCase):
  """"""Tests for service_to_service_authentication.""""""

  def test_non_applicable(self):
    request = webapp2.Request({})
    self.assertIsNone(
        handler.service_to_service_authentication(request))

  def test_applicable(self):
    request = webapp2.Request({
      'HTTP_X_APPENGINE_INBOUND_APPID': 'some-app',
    })
    self.assertEqual(
      model.Identity(model.IDENTITY_SERVICE, 'some-app'),
      handler.service_to_service_authentication(request))


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  unittest.main()
/n/n/n",1
82,c23a5bf6278f55b3f8135e0edab9927599a09236,"appengine/swarming/handlers_bot.py/n/n# Copyright 2015 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Internal bot API handlers.""""""

import base64
import json
import logging
import textwrap

import webob
import webapp2

from google.appengine.api import app_identity
from google.appengine.api import datastore_errors
from google.appengine.datastore import datastore_query
from google.appengine import runtime
from google.appengine.ext import ndb

from components import auth
from components import ereporter2
from components import utils
from server import acl
from server import bot_code
from server import bot_management
from server import stats
from server import task_pack
from server import task_request
from server import task_result
from server import task_scheduler
from server import task_to_run


def has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):
  """"""Returns an error if unexpected keys are present or expected keys are
  missing.

  Accepts optional keys.

  This is important to catch typos.
  """"""
  actual_keys = frozenset(actual_keys)
  superfluous = actual_keys - expected_keys
  missing = minimum_keys - actual_keys
  if superfluous or missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    msg_superfluous = (
        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')
    return 'Unexpected %s%s%s; did you make a typo?' % (
        name, msg_missing, msg_superfluous)


def has_unexpected_keys(expected_keys, actual_keys, name):
  """"""Return an error if unexpected keys are present or expected keys are
  missing.
  """"""
  return has_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, name)


def log_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, request, source, name):
  """"""Logs an error if unexpected keys are present or expected keys are missing.

  Accepts optional keys.

  This is important to catch typos.
  """"""
  message = has_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, name)
  if message:
    ereporter2.log_request(request, source=source, message=message)
  return message


def log_unexpected_keys(expected_keys, actual_keys, request, source, name):
  """"""Logs an error if unexpected keys are present or expected keys are missing.
  """"""
  return log_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, request, source, name)


def has_missing_keys(minimum_keys, actual_keys, name):
  """"""Returns an error if expected keys are not present.

  Do not warn about unexpected keys.
  """"""
  actual_keys = frozenset(actual_keys)
  missing = minimum_keys - actual_keys
  if missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)


class BootstrapHandler(auth.AuthenticatingHandler):
  """"""Returns python code to run to bootstrap a swarming bot.""""""

  @auth.require(acl.is_bot)
  def get(self):
    self.response.headers['Content-Type'] = 'text/x-python'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename=""swarming_bot_bootstrap.py""')
    self.response.out.write(
        bot_code.get_bootstrap(self.request.host_url).content)


class BotCodeHandler(auth.AuthenticatingHandler):
  """"""Returns a zip file with all the files required by a bot.

  Optionally specify the hash version to download. If so, the returned data is
  cacheable.
  """"""

  @auth.require(acl.is_bot)
  def get(self, version=None):
    if version:
      expected = bot_code.get_bot_version(self.request.host_url)
      if version != expected:
        # This can happen when the server is rapidly updated.
        logging.error('Requested Swarming bot %s, have %s', version, expected)
        self.abort(404)
      self.response.headers['Cache-Control'] = 'public, max-age=3600'
    else:
      self.response.headers['Cache-Control'] = 'no-cache, no-store'
    self.response.headers['Content-Type'] = 'application/octet-stream'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename=""swarming_bot.zip""')
    self.response.out.write(
        bot_code.get_swarming_bot_zip(self.request.host_url))


class _BotBaseHandler(auth.ApiHandler):
  """"""
  Request body is a JSON dict:
    {
      ""dimensions"": <dict of properties>,
      ""state"": <dict of properties>,
      ""version"": <sha-1 of swarming_bot.zip uncompressed content>,
    }
  """"""

  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}
  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  def _process(self):
    """"""Returns True if the bot has invalid parameter and should be automatically
    quarantined.

    Does one DB synchronous GET.

    Returns:
      tuple(request, bot_id, version, state, dimensions, quarantined_msg)
    """"""
    request = self.parse_body()
    version = request.get('version', None)

    dimensions = request.get('dimensions', {})
    state = request.get('state', {})
    bot_id = None
    if dimensions.get('id'):
      dimension_id = dimensions['id']
      if (isinstance(dimension_id, list) and len(dimension_id) == 1
          and isinstance(dimension_id[0], unicode)):
        bot_id = dimensions['id'][0]

    # The bot may decide to ""self-quarantine"" itself. Accept both via
    # dimensions or via state. See bot_management._BotCommon.quarantined for
    # more details.
    if (bool(dimensions.get('quarantined')) or
        bool(state.get('quarantined'))):
      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'

    quarantined_msg = None
    # Use a dummy 'for' to be able to break early from the block.
    for _ in [0]:

      quarantined_msg = has_unexpected_keys(
          self.EXPECTED_KEYS, request, 'keys')
      if quarantined_msg:
        break

      quarantined_msg = has_missing_keys(
          self.REQUIRED_STATE_KEYS, state, 'state')
      if quarantined_msg:
        break

      if not bot_id:
        quarantined_msg = 'Missing bot id'
        break

      if not all(
          isinstance(key, unicode) and
          isinstance(values, list) and
          all(isinstance(value, unicode) for value in values)
          for key, values in dimensions.iteritems()):
        quarantined_msg = (
            'Invalid dimensions type:\n%s' % json.dumps(dimensions,
              sort_keys=True, indent=2, separators=(',', ': ')))
        break

      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)
      if dimensions_count > task_to_run.MAX_DIMENSIONS:
        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count
        break

      if not isinstance(
          state.get('lease_expiration_ts'), (None.__class__, int)):
        quarantined_msg = (
            'lease_expiration_ts (%r) must be int or None' % (
                state['lease_expiration_ts']))
        break

    if quarantined_msg:
      line = 'Quarantined Bot\nhttps://%s/restricted/bot/%s\n%s' % (
          app_identity.get_default_version_hostname(), bot_id,
          quarantined_msg)
      ereporter2.log_request(self.request, source='bot', message=line)
      return request, bot_id, version, state, dimensions, quarantined_msg

    # Look for admin enforced quarantine.
    bot_settings = bot_management.get_settings_key(bot_id).get()
    if bool(bot_settings and bot_settings.quarantined):
      return request, bot_id, version, state, dimensions, 'Quarantined by admin'

    return request, bot_id, version, state, dimensions, None


class BotHandshakeHandler(_BotBaseHandler):
  """"""First request to be called to get initial data like XSRF token.

  The bot is server-controled so the server doesn't have to support multiple API
  version. When running a task, the bot sync the the version specific URL. Once
  abot finished its currently running task, it'll be immediately be upgraded
  after on its next poll.

  This endpoint does not return commands to the bot, for example to upgrade
  itself. It'll be told so when it does its first poll.

  Response body is a JSON dict:
    {
      ""bot_version"": <sha-1 of swarming_bot.zip uncompressed content>,
      ""server_version"": ""138-193f1f3"",
    }
  """"""

  @auth.require(acl.is_bot)
  def post(self):
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    bot_management.bot_event(
        event_type='bot_connected', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=dimensions,
        state=state, version=version, quarantined=bool(quarantined_msg),
        task_id='', task_name=None, message=quarantined_msg)

    data = {
      # This access token will be used to validate each subsequent request.
      'bot_version': bot_code.get_bot_version(self.request.host_url),
      # TODO(maruel): Remove this once all the bots have been updated.
      'expiration_sec': auth.handler.XSRFToken.expiration_sec,
      'server_version': utils.get_app_version(),
      # TODO(maruel): Remove this once all the bots have been updated.
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.send_response(data)


class BotPollHandler(_BotBaseHandler):
  """"""The bot polls for a task; returns either a task, update command or sleep.

  In case of exception on the bot, this is enough to get it just far enough to
  eventually self-update to a working version. This is to ensure that coding
  errors in bot code doesn't kill all the fleet at once, they should still be up
  just enough to be able to self-update again even if they don't get task
  assigned anymore.
  """"""

  @auth.require(acl.is_bot)
  def post(self):
    """"""Handles a polling request.

    Be very permissive on missing values. This can happen because of errors
    on the bot, *we don't want to deny them the capacity to update*, so that the
    bot code is eventually fixed and the bot self-update to this working code.

    It makes recovery of the fleet in case of catastrophic failure much easier.
    """"""
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    sleep_streak = state.get('sleep_streak', 0)
    quarantined = bool(quarantined_msg)

    # Note bot existence at two places, one for stats at 1 minute resolution,
    # the other for the list of known bots.
    action = 'bot_inactive' if quarantined else 'bot_active'
    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)

    def bot_event(event_type, task_id=None, task_name=None):
      bot_management.bot_event(
          event_type=event_type, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=dimensions,
          state=state, version=version, quarantined=quarantined,
          task_id=task_id, task_name=task_name, message=quarantined_msg)

    # Bot version is host-specific because the host URL is embedded in
    # swarming_bot.zip
    expected_version = bot_code.get_bot_version(self.request.host_url)
    if version != expected_version:
      bot_event('request_update')
      self._cmd_update(expected_version)
      return
    if quarantined:
      bot_event('request_sleep')
      self._cmd_sleep(sleep_streak, quarantined)
      return

    #
    # At that point, the bot should be in relatively good shape since it's
    # running the right version. It is still possible that invalid code was
    # pushed to the server, so be diligent about it.
    #

    # Bot may need a reboot if it is running for too long. We do not reboot
    # quarantined bots.
    needs_restart, restart_message = bot_management.should_restart_bot(
        bot_id, state)
    if needs_restart:
      bot_event('request_restart')
      self._cmd_restart(restart_message)
      return

    # The bot is in good shape. Try to grab a task.
    try:
      # This is a fairly complex function call, exceptions are expected.
      request, run_result = task_scheduler.bot_reap_task(
          dimensions, bot_id, version, state.get('lease_expiration_ts'))
      if not request:
        # No task found, tell it to sleep a bit.
        bot_event('request_sleep')
        self._cmd_sleep(sleep_streak, quarantined)
        return

      try:
        # This part is tricky since it intentionally runs a transaction after
        # another one.
        if request.properties.is_terminate:
          bot_event('bot_terminate', task_id=run_result.task_id)
          self._cmd_terminate(run_result.task_id)
        else:
          bot_event(
              'request_task', task_id=run_result.task_id,
              task_name=request.name)
          self._cmd_run(request, run_result.key, bot_id)
      except:
        logging.exception('Dang, exception after reaping')
        raise
    except runtime.DeadlineExceededError:
      # If the timeout happened before a task was assigned there is no problems.
      # If the timeout occurred after a task was assigned, that task will
      # timeout (BOT_DIED) since the bot didn't get the details required to
      # run it) and it will automatically get retried (TODO) when the task times
      # out.
      # TODO(maruel): Note the task if possible and hand it out on next poll.
      # https://code.google.com/p/swarming/issues/detail?id=130
      self.abort(500, 'Deadline')

  def _cmd_run(self, request, run_result_key, bot_id):
    cmd = None
    if request.properties.commands:
      cmd = request.properties.commands[0]
    elif request.properties.command:
      cmd = request.properties.command
    out = {
      'cmd': 'run',
      'manifest': {
        'bot_id': bot_id,
        'command': cmd,
        'dimensions': request.properties.dimensions,
        'env': request.properties.env,
        'extra_args': request.properties.extra_args,
        'grace_period': request.properties.grace_period_secs,
        'hard_timeout': request.properties.execution_timeout_secs,
        'host': utils.get_versioned_hosturl(),
        'io_timeout': request.properties.io_timeout_secs,
        'inputs_ref': request.properties.inputs_ref,
        'task_id': task_pack.pack_run_result_key(run_result_key),
      },
    }
    self.send_response(utils.to_json_encodable(out))

  def _cmd_sleep(self, sleep_streak, quarantined):
    out = {
      'cmd': 'sleep',
      'duration': task_scheduler.exponential_backoff(sleep_streak),
      'quarantined': quarantined,
    }
    self.send_response(out)

  def _cmd_terminate(self, task_id):
    out = {
      'cmd': 'terminate',
      'task_id': task_id,
    }
    self.send_response(out)

  def _cmd_update(self, expected_version):
    out = {
      'cmd': 'update',
      'version': expected_version,
    }
    self.send_response(out)

  def _cmd_restart(self, message):
    logging.info('Rebooting bot: %s', message)
    out = {
      'cmd': 'restart',
      'message': message,
    }
    self.send_response(out)


class BotEventHandler(_BotBaseHandler):
  """"""On signal that a bot had an event worth logging.""""""

  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}

  @auth.require(acl.is_bot)
  def post(self):
    (request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    event = request.get('event')
    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):
      self.abort_with_error(400, error='Unsupported event type')
    message = request.get('message')
    bot_management.bot_event(
        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,
        dimensions=dimensions, state=state, version=version,
        quarantined=bool(quarantined_msg), task_id=None, task_name=None,
        message=message)

    if event == 'bot_error':
      line = (
          'Bot: https://%s/restricted/bot/%s\n'
          'Bot error:\n'
          '%s') % (
          app_identity.get_default_version_hostname(), bot_id, message)
      ereporter2.log_request(self.request, source='bot', message=line)
    self.send_response({})


class BotTaskUpdateHandler(auth.ApiHandler):
  """"""Receives updates from a Bot for a task.

  The handler verifies packets are processed in order and will refuse
  out-of-order packets.
  """"""
  ACCEPTED_KEYS = {
    u'bot_overhead', u'cost_usd', u'duration', u'exit_code',
    u'hard_timeout', u'id', u'io_timeout', u'isolated_stats', u'output',
    u'output_chunk_start', u'outputs_ref', u'task_id',
  }
  REQUIRED_KEYS = {u'id', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    # Unlike handshake and poll, we do not accept invalid keys here. This code
    # path is much more strict.
    request = self.parse_body()
    msg = log_unexpected_subset_keys(
        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',
        'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    bot_id = request['id']
    cost_usd = request['cost_usd']
    task_id = request['task_id']

    bot_overhead = request.get('bot_overhead')
    duration = request.get('duration')
    exit_code = request.get('exit_code')
    hard_timeout = request.get('hard_timeout')
    io_timeout = request.get('io_timeout')
    isolated_stats = request.get('isolated_stats')
    output = request.get('output')
    output_chunk_start = request.get('output_chunk_start')
    outputs_ref = request.get('outputs_ref')

    if bool(isolated_stats) != (bot_overhead is not None):
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % task_id)
      self.abort_with_error(
          400,
          error='Both bot_overhead and isolated_stats must be set '
                'simultaneously\nbot_overhead: %s\nisolated_stats: %s' %
                (bot_overhead, isolated_stats))

    run_result_key = task_pack.unpack_run_result_key(task_id)
    performance_stats = None
    if isolated_stats:
      download = isolated_stats['download']
      upload = isolated_stats['upload']
      performance_stats = task_result.PerformanceStats(
          bot_overhead=bot_overhead,
          isolated_download=task_result.IsolatedOperation(
              duration=download['duration'],
              initial_number_items=download['initial_number_items'],
              initial_size=download['initial_size'],
              items_cold=base64.b64decode(download['items_cold']),
              items_hot=base64.b64decode(download['items_hot'])),
          isolated_upload=task_result.IsolatedOperation(
              duration=upload['duration'],
              items_cold=base64.b64decode(upload['items_cold']),
              items_hot=base64.b64decode(upload['items_hot'])))

    if output is not None:
      try:
        output = base64.b64decode(output)
      except UnicodeEncodeError as e:
        logging.error('Failed to decode output\n%s\n%r', e, output)
        output = output.encode('ascii', 'replace')
      except TypeError as e:
        # Save the output as-is instead. The error will be logged in ereporter2
        # and returning a HTTP 500 would only force the bot to stay in a retry
        # loop.
        logging.error('Failed to decode output\n%s\n%r', e, output)
    if outputs_ref:
      outputs_ref = task_request.FilesRef(**outputs_ref)

    try:
      state = task_scheduler.bot_update_task(
          run_result_key=run_result_key,
          bot_id=bot_id,
          output=output,
          output_chunk_start=output_chunk_start,
          exit_code=exit_code,
          duration=duration,
          hard_timeout=hard_timeout,
          io_timeout=io_timeout,
          cost_usd=cost_usd,
          outputs_ref=outputs_ref,
          performance_stats=performance_stats)
      if not state:
        logging.info('Failed to update, please retry')
        self.abort_with_error(500, error='Failed to update, please retry')

      if state in (task_result.State.COMPLETED, task_result.State.TIMED_OUT):
        action = 'task_completed'
      else:
        assert state == task_result.State.RUNNING, state
        action = 'task_update'
      bot_management.bot_event(
          event_type=action, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=None, state=None,
          version=None, quarantined=None, task_id=task_id, task_name=None)
    except ValueError as e:
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % e)
      self.abort_with_error(400, error=str(e))
    except webob.exc.HTTPException:
      raise
    except Exception as e:
      logging.exception('Internal error: %s', e)
      self.abort_with_error(500, error=str(e))

    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot
    # reboots itself to abort the task abruptly. It is useful when a task hangs
    # and the timeout was set too long or the task was superseded by a newer
    # task with more recent executable (e.g. a new Try Server job on a newer
    # patchset on Rietveld).
    self.send_response({'ok': True})


class BotTaskErrorHandler(auth.ApiHandler):
  """"""It is a specialized version of ereporter2's /ereporter2/api/v1/on_error
  that also attaches a task id to it.

  This formally kills the task, marking it as an internal failure. This can be
  used by bot_main.py to kill the task when task_runner misbehaved.
  """"""

  EXPECTED_KEYS = {u'id', u'message', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    request = self.parse_body()
    bot_id = request.get('id')
    task_id = request.get('task_id', '')
    message = request.get('message', 'unknown')

    bot_management.bot_event(
        event_type='task_error', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=None, state=None,
        version=None, quarantined=None, task_id=task_id, task_name=None,
        message=message)
    line = (
        'Bot: https://%s/restricted/bot/%s\n'
        'Task failed: https://%s/user/task/%s\n'
        '%s') % (
        app_identity.get_default_version_hostname(), bot_id,
        app_identity.get_default_version_hostname(), task_id,
        message)
    ereporter2.log_request(self.request, source='bot', message=line)

    msg = log_unexpected_keys(
        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    msg = task_scheduler.bot_kill_task(
        task_pack.unpack_run_result_key(task_id), bot_id)
    if msg:
      logging.error(msg)
      self.abort_with_error(400, error=msg)
    self.send_response({})


class ServerPingHandler(webapp2.RequestHandler):
  """"""Handler to ping when checking if the server is up.

  This handler should be extremely lightweight. It shouldn't do any
  computations, it should just state that the server is up. It's open to
  everyone for simplicity and performance.
  """"""

  def get(self):
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.out.write('Server up')


def get_routes():
  routes = [
      ('/bootstrap', BootstrapHandler),
      ('/bot_code', BotCodeHandler),
      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),
      ('/swarming/api/v1/bot/event', BotEventHandler),
      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),
      ('/swarming/api/v1/bot/poll', BotPollHandler),
      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),
      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',
          BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),
      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',
          BotTaskErrorHandler),
  ]
  return [webapp2.Route(*i) for i in routes]
/n/n/nappengine/swarming/server/bot_archive.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Generates the swarming_bot.zip archive for the bot.

Unlike the other source files, this file can be run from ../tools/bot_archive.py
stand-alone to generate a swarming_bot.zip for local testing so it doesn't
import anything from the AppEngine SDK.

The hash of the content of the files in the archive is used to define the
current version of the swarming bot code.
""""""

import hashlib
import json
import logging
import os
import StringIO
import zipfile


# List of files needed by the swarming bot.
# TODO(maruel): Make the list automatically generated?
FILES = (
    '__main__.py',
    'api/__init__.py',
    'api/bot.py',
    'api/parallel.py',
    'api/os_utilities.py',
    'api/platforms/__init__.py',
    'api/platforms/android.py',
    'api/platforms/common.py',
    'api/platforms/gce.py',
    'api/platforms/linux.py',
    'api/platforms/osx.py',
    'api/platforms/posix.py',
    'api/platforms/win.py',
    'bot_code/__init__.py',
    'bot_code/bot_main.py',
    'bot_code/common.py',
    'bot_code/singleton.py',
    'bot_code/task_runner.py',
    'client/auth.py',
    'client/isolated_format.py',
    'client/isolateserver.py',
    'client/run_isolated.py',
    'config/__init__.py',
    'third_party/__init__.py',
    'third_party/colorama/__init__.py',
    'third_party/colorama/ansi.py',
    'third_party/colorama/ansitowin32.py',
    'third_party/colorama/initialise.py',
    'third_party/colorama/win32.py',
    'third_party/colorama/winterm.py',
    'third_party/depot_tools/__init__.py',
    'third_party/depot_tools/fix_encoding.py',
    'third_party/depot_tools/subcommand.py',
    'third_party/httplib2/__init__.py',
    'third_party/httplib2/cacerts.txt',
    'third_party/httplib2/iri2uri.py',
    'third_party/httplib2/socks.py',
    'third_party/oauth2client/__init__.py',
    'third_party/oauth2client/_helpers.py',
    'third_party/oauth2client/_openssl_crypt.py',
    'third_party/oauth2client/_pycrypto_crypt.py',
    'third_party/oauth2client/client.py',
    'third_party/oauth2client/clientsecrets.py',
    'third_party/oauth2client/crypt.py',
    'third_party/oauth2client/file.py',
    'third_party/oauth2client/gce.py',
    'third_party/oauth2client/keyring_storage.py',
    'third_party/oauth2client/locked_file.py',
    'third_party/oauth2client/multistore_file.py',
    'third_party/oauth2client/service_account.py',
    'third_party/oauth2client/tools.py',
    'third_party/oauth2client/util.py',
    'third_party/oauth2client/xsrfutil.py',
    'third_party/pyasn1/pyasn1/__init__.py',
    'third_party/pyasn1/pyasn1/codec/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/decoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/encoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/eoo.py',
    'third_party/pyasn1/pyasn1/codec/cer/__init__.py',
    'third_party/pyasn1/pyasn1/codec/cer/decoder.py',
    'third_party/pyasn1/pyasn1/codec/cer/encoder.py',
    'third_party/pyasn1/pyasn1/codec/der/__init__.py',
    'third_party/pyasn1/pyasn1/codec/der/decoder.py',
    'third_party/pyasn1/pyasn1/codec/der/encoder.py',
    'third_party/pyasn1/pyasn1/compat/__init__.py',
    'third_party/pyasn1/pyasn1/compat/binary.py',
    'third_party/pyasn1/pyasn1/compat/octets.py',
    'third_party/pyasn1/pyasn1/debug.py',
    'third_party/pyasn1/pyasn1/error.py',
    'third_party/pyasn1/pyasn1/type/__init__.py',
    'third_party/pyasn1/pyasn1/type/base.py',
    'third_party/pyasn1/pyasn1/type/char.py',
    'third_party/pyasn1/pyasn1/type/constraint.py',
    'third_party/pyasn1/pyasn1/type/error.py',
    'third_party/pyasn1/pyasn1/type/namedtype.py',
    'third_party/pyasn1/pyasn1/type/namedval.py',
    'third_party/pyasn1/pyasn1/type/tag.py',
    'third_party/pyasn1/pyasn1/type/tagmap.py',
    'third_party/pyasn1/pyasn1/type/univ.py',
    'third_party/pyasn1/pyasn1/type/useful.py',
    'third_party/requests/__init__.py',
    'third_party/requests/adapters.py',
    'third_party/requests/api.py',
    'third_party/requests/auth.py',
    'third_party/requests/certs.py',
    'third_party/requests/compat.py',
    'third_party/requests/cookies.py',
    'third_party/requests/exceptions.py',
    'third_party/requests/hooks.py',
    'third_party/requests/models.py',
    'third_party/requests/packages/__init__.py',
    'third_party/requests/packages/urllib3/__init__.py',
    'third_party/requests/packages/urllib3/_collections.py',
    'third_party/requests/packages/urllib3/connection.py',
    'third_party/requests/packages/urllib3/connectionpool.py',
    'third_party/requests/packages/urllib3/contrib/__init__.py',
    'third_party/requests/packages/urllib3/contrib/ntlmpool.py',
    'third_party/requests/packages/urllib3/contrib/pyopenssl.py',
    'third_party/requests/packages/urllib3/exceptions.py',
    'third_party/requests/packages/urllib3/fields.py',
    'third_party/requests/packages/urllib3/filepost.py',
    'third_party/requests/packages/urllib3/packages/__init__.py',
    'third_party/requests/packages/urllib3/packages/ordered_dict.py',
    'third_party/requests/packages/urllib3/packages/six.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '__init__.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '_implementation.py',
    'third_party/requests/packages/urllib3/poolmanager.py',
    'third_party/requests/packages/urllib3/request.py',
    'third_party/requests/packages/urllib3/response.py',
    'third_party/requests/packages/urllib3/util/__init__.py',
    'third_party/requests/packages/urllib3/util/connection.py',
    'third_party/requests/packages/urllib3/util/request.py',
    'third_party/requests/packages/urllib3/util/response.py',
    'third_party/requests/packages/urllib3/util/retry.py',
    'third_party/requests/packages/urllib3/util/ssl_.py',
    'third_party/requests/packages/urllib3/util/timeout.py',
    'third_party/requests/packages/urllib3/util/url.py',
    'third_party/requests/sessions.py',
    'third_party/requests/status_codes.py',
    'third_party/requests/structures.py',
    'third_party/requests/utils.py',
    'third_party/rsa/rsa/__init__.py',
    'third_party/rsa/rsa/_compat.py',
    'third_party/rsa/rsa/_version133.py',
    'third_party/rsa/rsa/_version200.py',
    'third_party/rsa/rsa/asn1.py',
    'third_party/rsa/rsa/bigfile.py',
    'third_party/rsa/rsa/cli.py',
    'third_party/rsa/rsa/common.py',
    'third_party/rsa/rsa/core.py',
    'third_party/rsa/rsa/key.py',
    'third_party/rsa/rsa/parallel.py',
    'third_party/rsa/rsa/pem.py',
    'third_party/rsa/rsa/pkcs1.py',
    'third_party/rsa/rsa/prime.py',
    'third_party/rsa/rsa/randnum.py',
    'third_party/rsa/rsa/transform.py',
    'third_party/rsa/rsa/util.py',
    'third_party/rsa/rsa/varblock.py',
    'third_party/six/__init__.py',
    'utils/__init__.py',
    'utils/cacert.pem',
    'utils/file_path.py',
    'utils/fs.py',
    'utils/large.py',
    'utils/logging_utils.py',
    'utils/lru.py',
    'utils/net.py',
    'utils/oauth.py',
    'utils/on_error.py',
    'utils/subprocess42.py',
    'utils/threading_utils.py',
    'utils/tools.py',
    'utils/zip_package.py',
    'adb/__init__.py',
    'adb/adb_commands.py',
    'adb/adb_protocol.py',
    'adb/common.py',
    'adb/contrib/__init__.py',
    'adb/contrib/adb_commands_safe.py',
    'adb/contrib/high.py',
    'adb/contrib/parallel.py',
    'adb/fastboot.py',
    'adb/filesync_protocol.py',
    'adb/sign_pythonrsa.py',
    'adb/usb_exceptions.py',
    'python_libusb1/__init__.py',
    'python_libusb1/libusb1.py',
    'python_libusb1/usb1.py',
)


def is_windows():
  """"""Returns True if this code is running under Windows.""""""
  return os.__file__[0] != '/'


def resolve_symlink(path):
  """"""Processes path containing symlink on Windows.

  This is needed to make ../swarming_bot/main_test.py pass on Windows because
  git on Windows renders symlinks as normal files.
  """"""
  if not is_windows():
    # Only does this dance on Windows.
    return path
  parts = os.path.normpath(path).split(os.path.sep)
  for i in xrange(2, len(parts)):
    partial = os.path.sep.join(parts[:i])
    if os.path.isfile(partial):
      with open(partial) as f:
        link = f.read()
      assert '\n' not in link and link, link
      parts[i-1] = link
  return os.path.normpath(os.path.sep.join(parts))


def yield_swarming_bot_files(root_dir, host, host_version, additionals):
  """"""Yields all the files to map as tuple(filename, content).

  config.json is injected with json data about the server.

  This function guarantees that the output is sorted by filename.
  """"""
  items = {i: None for i in FILES}
  items.update(additionals)
  config = {
    'server': host.rstrip('/'),
    'server_version': host_version,
  }
  items['config/config.json'] = json.dumps(config)
  for item, content in sorted(items.iteritems()):
    if content is not None:
      yield item, content
    else:
      with open(resolve_symlink(os.path.join(root_dir, item)), 'rb') as f:
        yield item, f.read()


def get_swarming_bot_zip(root_dir, host, host_version, additionals):
  """"""Returns a zipped file of all the files a bot needs to run.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: dict(filepath: content) of additional items to put into the zip
        file, in addition to FILES and MAPPED. In practice, it's going to be a
        custom bot_config.py.
  Returns:
    Tuple(str being the zipped file's content, bot version (SHA-1) it
    represents).
  """"""
  zip_memory_file = StringIO.StringIO()
  h = hashlib.sha1()
  with zipfile.ZipFile(zip_memory_file, 'w', zipfile.ZIP_DEFLATED) as zip_file:
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      zip_file.writestr(name, content)
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)

  data = zip_memory_file.getvalue()
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_zip(%s) is %d bytes; %s',
      additionals.keys(), len(data), bot_version)
  return data, bot_version


def get_swarming_bot_version(root_dir, host, host_version, additionals):
  """"""Returns the SHA1 hash of the bot code, representing the version.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: See get_swarming_bot_zip's doc.

  Returns:
    The SHA1 hash of the bot code.
  """"""
  h = hashlib.sha1()
  try:
    # TODO(maruel): Deduplicate from zip_package.genereate_version().
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)
  except IOError:
    logging.warning('Missing expected file. Hash will be invalid.')
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_version(%s) = %s', sorted(additionals), bot_version)
  return bot_version
/n/n/nappengine/swarming/swarming_bot/__main__.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Runs either task_runner.py, bot_main.py or bot_config.py.

The imports are done late so if an ImportError occurs, it is localized to this
command only.
""""""

import code
import json
import logging
import os
import optparse
import shutil
import sys
import zipfile

# That's from ../../../client/
from third_party.depot_tools import fix_encoding
from utils import logging_utils
from utils import zip_package

# This file can only be run as a zip.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# libusb1 expects to be directly in sys.path.
sys.path.insert(0, os.path.join(THIS_FILE, 'python_libusb1'))

# Copied from //client/utils/oauth.py.
sys.path.insert(0, os.path.join(THIS_FILE, 'third_party'))
sys.path.insert(0, os.path.join(THIS_FILE, 'third_party', 'pyasn1'))
sys.path.insert(0, os.path.join(THIS_FILE, 'third_party', 'rsa'))

from bot_code import common


# TODO(maruel): Use depot_tools/subcommand.py. The goal here is to have all the
# sub commands packed into the single .zip file as a swiss army knife (think
# busybox but worse).


def CMDattributes(_args):
  """"""Prints out the bot's attributes.""""""
  from bot_code import bot_main
  json.dump(
      bot_main.get_attributes(bot_main.get_bot()), sys.stdout, indent=2,
      sort_keys=True, separators=(',', ': '))
  print('')
  return 0


def CMDconfig(_args):
  """"""Prints the config.json embedded in this zip.""""""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  json.dump(bot_main.get_config(), sys.stdout, indent=2, sort_keys=True)
  print('')
  return 0


def CMDis_fine(_args):
  """"""Just reports that the code doesn't throw.

  That ensures that the bot has minimal viability before transfering control to
  it. For now, it just imports bot_main but later it'll check the config, etc.
  """"""
  # pylint: disable=unused-variable
  from bot_code import bot_main
  from config import bot_config
  # We're #goodenough.
  return 0


def CMDrestart(_args):
  """"""Utility subcommand that hides the difference between each OS to reboot
  the host.""""""
  logging_utils.prepare_logging(None)
  import os_utilities
  # This function doesn't return.
  os_utilities.restart()
  # Should never reach here.
  return 1


def CMDrun_isolated(args):
  """"""Internal command to run an isolated command.""""""
  sys.path.insert(0, os.path.join(THIS_FILE, 'client'))
  # run_isolated setups logging by itself.
  import run_isolated
  return run_isolated.main(args)


def CMDsetup(_args):
  """"""Setup the bot to auto-start but doesn't start the bot.""""""
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))
  from bot_code import bot_main
  bot_main.setup_bot(True)
  return 0


def CMDserver(_args):
  """"""Prints the server url. It's like 'config' but easier to parse.""""""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  print bot_main.get_config()['server']
  return 0


def CMDshell(args):
  """"""Starts a shell with api.* in..""""""
  logging_utils.prepare_logging(None)
  logging_utils.set_console_level(logging.DEBUG)

  from bot_code import bot_main
  from api import os_utilities
  from api import platforms
  local_vars = {
    'bot_main': bot_main,
    'json': json,
    'os_utilities': os_utilities,
    'platforms': platforms,
  }
  # Can't use: from api.platforms import *
  local_vars.update(
      (k, v) for k, v in platforms.__dict__.iteritems()
      if not k.startswith('_'))

  if args:
    for arg in args:
      exec code.compile_command(arg) in local_vars
  else:
    code.interact(
        'Locals:\n  ' + '\n  '.join( sorted(local_vars)), None, local_vars)
  return 0


def CMDstart_bot(args):
  """"""Starts the swarming bot.""""""
  logging_utils.prepare_logging(os.path.join('logs', 'swarming_bot.log'))
  logging.info(
      'importing bot_main: %s, %s', THIS_FILE, zip_package.generate_version())
  from bot_code import bot_main
  result = bot_main.main(args)
  logging.info('bot_main exit code: %d', result)
  return result


def CMDstart_slave(args):
  """"""Ill named command that actually sets up the bot then start it.""""""
  # TODO(maruel): Rename function.
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))

  parser = optparse.OptionParser()
  parser.add_option(
      '--survive', action='store_true',
      help='Do not reboot the host even if bot_config.setup_bot() asked to')
  options, args = parser.parse_args(args)

  try:
    from bot_code import bot_main
    bot_main.setup_bot(options.survive)
  except Exception:
    logging.exception('bot_main.py failed.')

  logging.info('Starting the bot: %s', THIS_FILE)
  return common.exec_python([THIS_FILE, 'start_bot'])


def CMDtask_runner(args):
  """"""Internal command to run a swarming task.""""""
  logging_utils.prepare_logging(os.path.join('logs', 'task_runner.log'))
  from bot_code import task_runner
  return task_runner.main(args)


def CMDversion(_args):
  """"""Prints the version of this file and the hash of the code.""""""
  logging_utils.prepare_logging(None)
  print zip_package.generate_version()
  return 0


def main():
  if os.getenv('CHROME_REMOTE_DESKTOP_SESSION') == '1':
    # Disable itself when run under Google Chrome Remote Desktop, as it's
    # normally started at the console and starting up via Remote Desktop would
    # cause multiple bots to run concurrently on the host.
    print >> sys.stderr, (
        'Inhibiting Swarming bot under Google Chrome Remote Desktop.')
    return 0

  # Always make the current working directory the directory containing this
  # file. It simplifies assumptions.
  os.chdir(os.path.dirname(THIS_FILE))
  # Always create the logs dir first thing, before printing anything out.
  if not os.path.isdir('logs'):
    os.mkdir('logs')

  # This is necessary so os.path.join() works with unicode path. No kidding.
  # This must be done here as each of the command take wildly different code
  # path and this must be run in every case, as it causes really unexpected
  # issues otherwise, especially in module os.path.
  fix_encoding.fix_encoding()

  if os.path.basename(THIS_FILE) == 'swarming_bot.zip':
    # Self-replicate itself right away as swarming_bot.1.zip and restart as it.
    print >> sys.stderr, 'Self replicating pid:%d.' % os.getpid()
    if os.path.isfile('swarming_bot.1.zip'):
      os.remove('swarming_bot.1.zip')
    shutil.copyfile('swarming_bot.zip', 'swarming_bot.1.zip')
    cmd = ['swarming_bot.1.zip'] + sys.argv[1:]
    print >> sys.stderr, 'cmd: %s' % cmd
    return common.exec_python(cmd)

  # sys.argv[0] is the zip file itself.
  cmd = 'start_slave'
  args = []
  if len(sys.argv) > 1:
    cmd = sys.argv[1]
    args = sys.argv[2:]

  fn = getattr(sys.modules[__name__], 'CMD%s' % cmd, None)
  if fn:
    try:
      return fn(args)
    except ImportError:
      logging.exception('Failed to run %s', cmd)
      with zipfile.ZipFile(THIS_FILE, 'r') as f:
        logging.error('Files in %s:\n%s', THIS_FILE, f.namelist())
      return 1

  print >> sys.stderr, 'Unknown command %s' % cmd
  return 1


if __name__ == '__main__':
  sys.exit(main())
/n/n/nappengine/swarming/swarming_bot/api/bot.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Bot interface used in bot_config.py.""""""

import logging
import os
import threading
import time

import os_utilities
from utils import net
from utils import zip_package

THIS_FILE = os.path.abspath(zip_package.get_main_script_path())

# Method could be a function - pylint: disable=R0201


class Bot(object):
  def __init__(
      self, attributes, server, server_version, base_dir, shutdown_hook):
    # Do not expose attributes  for now, as attributes may be refactored.
    assert server is None or not server.endswith('/'), server
    self._attributes = attributes
    self._base_dir = base_dir
    self._server = server
    self._server_version = server_version
    self._shutdown_hook = shutdown_hook
    self._timers = []
    self._timers_dying = False
    self._timers_lock = threading.Lock()

  @property
  def base_dir(self):
    """"""Returns the working directory.

    It is normally the current workind directory, e.g. os.getcwd() but it is
    preferable to not assume that.
    """"""
    return self._base_dir

  @property
  def dimensions(self):
    """"""The bot's current dimensions.

    Dimensions are relatively static and not expected to change much. They
    should change only when it effectively affects the bot's capacity to execute
    tasks.
    """"""
    return self._attributes.get('dimensions', {}).copy()

  @property
  def id(self):
    """"""Returns the bot's ID.""""""
    return self.dimensions.get('id', ['unknown'])[0]

  @property
  def server(self):
    """"""URL of the swarming server this bot is connected to.

    It includes the https:// prefix but without trailing /, so it looks like
    ""https://foo-bar.appspot.com"".
    """"""
    return self._server

  @property
  def server_version(self):
    """"""Version of the server's implementation.

    The form is nnn-hhhhhhh for pristine version and nnn-hhhhhhh-tainted-uuuu
    for non-upstreamed code base:
      nnn: revision pseudo number
      hhhhhhh: git commit hash
      uuuu: username
    """"""
    return self._server_version

  @property
  def state(self):
    return self._attributes['state']

  @property
  def swarming_bot_zip(self):
    """"""Absolute path to the swarming_bot.zip file.

    The bot itself is run as swarming_bot.1.zip or swarming_bot.2.zip. Always
    return swarming_bot.zip since this is the script that must be used when
    starting up.
    """"""
    return os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')

  def post_event(self, event_type, message):
    """"""Posts an event to the server.""""""
    data = self._attributes.copy()
    data['event'] = event_type
    data['message'] = message
    net.url_read_json(self.server + '/swarming/api/v1/bot/event', data=data)

  def post_error(self, message):
    """"""Posts given string as a failure.

    This is used in case of internal code error. It traps exception.
    """"""
    logging.error('Error: %s\n%s', self._attributes, message)
    try:
      self.post_event('bot_error', message)
    except Exception:
      logging.exception('post_error(%s) failed.', message)

  def restart(self, message):
    """"""Reboots the machine.

    If the reboot is successful, never returns: the process should just be
    killed by OS.

    If reboot fails, logs the error to the server and moves the bot to
    quarantined mode.
    """"""
    self.post_event('bot_rebooting', message)
    self.cancel_all_timers()
    if self._shutdown_hook:
      try:
        self._shutdown_hook(self)
      except Exception as e:
        logging.exception('shutdown hook failed: %s', e)
    # os_utilities.restart should never return, unless restart is not happening.
    # If restart is taking longer than N minutes, it probably not going to
    # finish at all. Report this to the server.
    try:
      os_utilities.restart(message, timeout=15*60)
    except LookupError:
      # This is a special case where OSX is deeply hosed. In that case the disk
      # is likely in read-only mode and there isn't much that can be done. This
      # exception is deep inside pickle.py. So notify the server then hang in
      # there.
      self.post_error('This host partition is bad; please fix the host')
      while True:
        time.sleep(1)
    self.post_error('Bot is stuck restarting for: %s' % message)

  def call_later(self, delay_sec, callback):
    """"""Schedules a function to be called later (if bot is still running).

    All calls are executed in a separate internal thread, be careful with what
    you call from there (Bot object is generally not thread safe).

    Multiple callbacks can be executed concurrently. It is safe to call
    'call_later' from the callback.
    """"""
    timer = None

    def call_wrapper():
      with self._timers_lock:
        # Canceled already?
        if timer not in self._timers:
          return
        self._timers.remove(timer)
      try:
        callback()
      except Exception:
        logging.exception('Timer callback failed')

    with self._timers_lock:
      if not self._timers_dying:
        timer = threading.Timer(delay_sec, call_wrapper)
        self._timers.append(timer)
        timer.daemon = True
        timer.start()

  def cancel_all_timers(self):
    """"""Cancels all pending 'call_later' calls and forbids adding new ones.""""""
    timers = None
    with self._timers_lock:
      self._timers_dying = True
      for t in self._timers:
        t.cancel()
      timers, self._timers = self._timers, []
    for t in timers:
      t.join(timeout=5)
      if t.isAlive():
        logging.error('Timer thread did not terminate fast enough: %s', t)

  def update_dimensions(self, new_dimensions):
    """"""Called internally to update Bot.dimensions.""""""
    self._attributes['dimensions'] = new_dimensions

  def update_state(self, new_state):
    """"""Called internally to update Bot.state.""""""
    self._attributes['state'] = new_state
/n/n/nappengine/swarming/swarming_bot/api/bot_test.py/n/n#!/usr/bin/env python
# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import os
import sys
import unittest
import threading

THIS_FILE = os.path.abspath(__file__)

import test_env_api
test_env_api.setup_test_env()

import bot


class TestBot(unittest.TestCase):
  def test_bot(self):
    obj = bot.Bot(
        {'dimensions': {'foo': 'bar'}},
        'https://localhost:1',
        '1234-1a2b3c4-tainted-joe',
        'base_dir',
        None)
    self.assertEqual({'foo': 'bar'}, obj.dimensions)
    self.assertEqual(
        os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip'),
        obj.swarming_bot_zip)
    self.assertEqual('1234-1a2b3c4-tainted-joe', obj.server_version)
    self.assertEqual('base_dir', obj.base_dir)

  def test_bot_call_later(self):
    obj = bot.Bot({}, 'https://localhost:1', '1234-1a2b3c4-tainted-joe',
                  'base_dir', None)
    ev = threading.Event()
    obj.call_later(0.001, ev.set)
    self.assertTrue(ev.wait(1))

  def test_bot_call_later_cancel(self):
    obj = bot.Bot({}, 'https://localhost:1', '1234-1a2b3c4-tainted-joe',
                  'base_dir', None)
    ev = threading.Event()
    obj.call_later(0.1, ev.set)
    obj.cancel_all_timers()
    self.assertFalse(ev.wait(0.3))


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  unittest.main()
/n/n/nappengine/swarming/swarming_bot/bot_code/bot_main.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Swarming bot main process.

This is the program that communicates with the Swarming server, ensures the code
is always up to date and executes a child process to run tasks and upload
results back.

It manages self-update and rebooting the host in case of problems.

Set the environment variable SWARMING_LOAD_TEST=1 to disable the use of
server-provided bot_config.py. This permits safe load testing.
""""""

import contextlib
import json
import logging
import optparse
import os
import shutil
import signal
import sys
import tempfile
import threading
import time
import traceback
import zipfile

import common
import singleton
from api import bot
from api import os_utilities
from utils import file_path
from utils import net
from utils import on_error
from utils import subprocess42
from utils import zip_package


# Used to opportunistically set the error handler to notify the server when the
# process exits due to an exception.
_ERROR_HANDLER_WAS_REGISTERED = False


# Set to the zip's name containing this file. This is set to the absolute path
# to swarming_bot.zip when run as part of swarming_bot.zip. This value is
# overriden in unit tests.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# The singleton, initially unset.
SINGLETON = singleton.Singleton(os.path.dirname(THIS_FILE))


### bot_config handler part.


def _in_load_test_mode():
  """"""Returns True if the default values should be used instead of the server
  provided bot_config.py.

  This also disables server telling the bot to restart.
  """"""
  return os.environ.get('SWARMING_LOAD_TEST') == '1'


def get_dimensions(botobj):
  """"""Returns bot_config.py's get_attributes() dict.""""""
  # Importing this administrator provided script could have side-effects on
  # startup. That is why it is imported late.
  try:
    if _in_load_test_mode():
      # Returns a minimal set of dimensions so it doesn't run tasks by error.
      dimensions = os_utilities.get_dimensions()
      return {
        'id': dimensions['id'],
        'load_test': ['1'],
      }

    from config import bot_config
    out = bot_config.get_dimensions(botobj)
    if not isinstance(out, dict):
      raise ValueError('Unexpected type %s' % out.__class__)
    return out
  except Exception as e:
    logging.exception('get_dimensions() failed')
    try:
      out = os_utilities.get_dimensions()
      out['error'] = [str(e)]
      out['quarantined'] = ['1']
      return out
    except Exception as e:
      try:
        botid = os_utilities.get_hostname_short()
      except Exception as e2:
        botid = 'error_%s' % str(e2)
      return {
          'id': [botid],
          'error': ['%s\n%s' % (e, traceback.format_exc()[-2048:])],
          'quarantined': ['1'],
        }


def get_state(botobj, sleep_streak):
  """"""Returns dict with a state of the bot reported to the server with each poll.
  """"""
  try:
    if _in_load_test_mode():
      state = os_utilities.get_state()
      state['dimensions'] = os_utilities.get_dimensions()
    else:
      from config import bot_config
      state = bot_config.get_state(botobj)
      if not isinstance(state, dict):
        state = {'error': state}
  except Exception as e:
    logging.exception('get_state() failed')
    state = {
      'error': '%s\n%s' % (e, traceback.format_exc()[-2048:]),
      'quarantined': True,
    }

  state['sleep_streak'] = sleep_streak
  return state


def call_hook(botobj, name, *args):
  """"""Calls a hook function in bot_config.py.""""""
  try:
    if _in_load_test_mode():
      return

    logging.info('call_hook(%s)', name)
    from config import bot_config
    hook = getattr(bot_config, name, None)
    if hook:
      return hook(botobj, *args)
  except Exception as e:
    msg = '%s\n%s' % (e, traceback.format_exc()[-2048:])
    botobj.post_error('Failed to call hook %s(): %s' % (name, msg))


def setup_bot(skip_reboot):
  """"""Calls bot_config.setup_bot() to have the bot self-configure itself.

  Reboot the host if bot_config.setup_bot() returns False, unless skip_reboot is
  also true.
  """"""
  if _in_load_test_mode():
    return

  botobj = get_bot()
  try:
    from config import bot_config
  except Exception as e:
    msg = '%s\n%s' % (e, traceback.format_exc()[-2048:])
    botobj.post_error('bot_config.py is bad: %s' % msg)
    return

  try:
    should_continue = bot_config.setup_bot(botobj)
  except Exception as e:
    msg = '%s\n%s' % (e, traceback.format_exc()[-2048:])
    botobj.post_error('bot_config.setup_bot() threw: %s' % msg)
    return

  if not should_continue and not skip_reboot:
    botobj.restart('Starting new swarming bot: %s' % THIS_FILE)


### end of bot_config handler part.


def get_min_free_space():
  """"""Returns free disk space needed.

  Add a ""250 MiB slack space"" for logs, temporary files and whatever other leak.
  """"""
  return int((os_utilities.get_min_free_space(THIS_FILE) + 250.) * 1024 * 1024)


def generate_version():
  """"""Returns the bot's code version.""""""
  try:
    return zip_package.generate_version()
  except Exception as e:
    return 'Error: %s' % e


def get_attributes(botobj):
  """"""Returns the attributes sent to the server.

  Each called function catches all exceptions so the bot doesn't die on startup,
  which is annoying to recover. In that case, we set a special property to catch
  these and help the admin fix the swarming_bot code more quickly.

  Arguments:
  - botobj: bot.Bot instance or None
  """"""
  return {
    'dimensions': get_dimensions(botobj),
    'state': get_state(botobj, 0),
    'version': generate_version(),
  }


def post_error_task(botobj, error, task_id):
  """"""Posts given error as failure cause for the task.

  This is used in case of internal code error, and this causes the task to
  become BOT_DIED.

  Arguments:
    botobj: A bot.Bot instance.
    error: String representing the problem.
    task_id: Task that had an internal error. When the Swarming server sends
        commands to a bot, even though they could be completely wrong, the
        server assumes the job as running. Thus this function acts as the
        exception handler for incoming commands from the Swarming server. If for
        any reason the local test runner script can not be run successfully,
        this function is invoked.
  """"""
  logging.error('Error: %s', error)
  data = {
    'id': botobj.id,
    'message': error,
    'task_id': task_id,
  }
  return net.url_read_json(
      botobj.server + '/swarming/api/v1/bot/task_error/%s' % task_id, data=data)


def on_shutdown_hook(b):
  """"""Called when the bot is restarting.""""""
  call_hook(b, 'on_bot_shutdown')
  # Aggressively set itself up so we ensure the auto-reboot configuration is
  # fine before restarting the host. This is important as some tasks delete the
  # autorestart script (!)
  setup_bot(True)


def get_bot():
  """"""Returns a valid Bot instance.

  Should only be called once in the process lifetime.
  """"""
  # This variable is used to bootstrap the initial bot.Bot object, which then is
  # used to get the dimensions and state.
  attributes = {
    'dimensions': {u'id': ['none']},
    'state': {},
    'version': generate_version(),
  }
  config = get_config()
  assert not config['server'].endswith('/'), config

  # Create a temporary object to call the hooks.
  botobj = bot.Bot(
      attributes,
      config['server'],
      config['server_version'],
      os.path.dirname(THIS_FILE),
      on_shutdown_hook)
  return bot.Bot(
      get_attributes(botobj),
      config['server'],
      config['server_version'],
      os.path.dirname(THIS_FILE),
      on_shutdown_hook)


def clean_isolated_cache(botobj):
  """"""Asks run_isolated to clean its cache.

  This may take a while but it ensures that in the case of a run_isolated run
  failed and it temporarily used more space than min_free_disk, it can cleans up
  the mess properly.

  It will remove unexpected files, remove corrupted files, trim the cache size
  based on the policies and update state.json.
  """"""
  bot_dir = botobj.base_dir
  cmd = [
    sys.executable, THIS_FILE, 'run_isolated',
    '--clean',
    '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),
    '--cache', os.path.join(bot_dir, 'cache'),
    '--min-free-space', str(get_min_free_space()),
  ]
  logging.info('Running: %s', cmd)
  try:
    # Intentionally do not use a timeout, it can take a while to hash 50gb but
    # better be safe than sorry.
    proc = subprocess42.Popen(
        cmd,
        stdin=subprocess42.PIPE,
        stdout=subprocess42.PIPE, stderr=subprocess42.STDOUT,
        cwd=bot_dir,
        detached=True,
        close_fds=sys.platform != 'win32')
    output, _ = proc.communicate(None)
    logging.info('Result:\n%s', output)
    if proc.returncode:
      botobj.post_error(
          'swarming_bot.zip failure during run_isolated --clean:\n%s' % output)
  except OSError:
    botobj.post_error(
        'swarming_bot.zip internal failure during run_isolated --clean')


def run_bot(arg_error):
  """"""Runs the bot until it reboots or self-update or a signal is received.

  When a signal is received, simply exit.
  """"""
  quit_bit = threading.Event()
  def handler(sig, _):
    logging.info('Got signal %s', sig)
    quit_bit.set()

  # TODO(maruel): Set quit_bit when stdin is closed on Windows.

  with subprocess42.set_signal_handler(subprocess42.STOP_SIGNALS, handler):
    config = get_config()
    try:
      # First thing is to get an arbitrary url. This also ensures the network is
      # up and running, which is necessary before trying to get the FQDN below.
      resp = net.url_read(config['server'] + '/swarming/api/v1/bot/server_ping')
      if resp is None:
        logging.error('No response from server_ping')
    except Exception as e:
      # url_read() already traps pretty much every exceptions. This except
      # clause is kept there ""just in case"".
      logging.exception('server_ping threw')

    if quit_bit.is_set():
      logging.info('Early quit 1')
      return 0

    # If this fails, there's hardly anything that can be done, the bot can't
    # even get to the point to be able to self-update.
    botobj = get_bot()
    resp = net.url_read_json(
        botobj.server + '/swarming/api/v1/bot/handshake',
        data=botobj._attributes)
    if not resp:
      logging.error('Failed to contact for handshake')
    else:
      logging.info('Connected to %s', resp.get('server_version'))
      if resp.get('bot_version') != botobj._attributes['version']:
        logging.warning(
            'Found out we\'ll need to update: server said %s; we\'re %s',
            resp.get('bot_version'), botobj._attributes['version'])

    if arg_error:
      botobj.post_error('Bootstrapping error: %s' % arg_error)

    if quit_bit.is_set():
      logging.info('Early quit 2')
      return 0

    clean_isolated_cache(botobj)

    call_hook(botobj, 'on_bot_startup')

    if quit_bit.is_set():
      logging.info('Early quit 3')
      return 0

    # This environment variable is accessible to the tasks executed by this bot.
    os.environ['SWARMING_BOT_ID'] = botobj.id.encode('utf-8')

    # Remove the 'work' directory if present, as not removing it may cause the
    # bot to stay quarantined and not be able to get out of this state.
    work_dir = os.path.join(botobj.base_dir, 'work')
    try:
      if os.path.isdir(work_dir):
        file_path.rmtree(work_dir)
    except Exception as e:
      botobj.post_error('Failed to remove work: %s' % e)

    consecutive_sleeps = 0
    while not quit_bit.is_set():
      try:
        botobj.update_dimensions(get_dimensions(botobj))
        botobj.update_state(get_state(botobj, consecutive_sleeps))
        did_something = poll_server(botobj, quit_bit)
        if did_something:
          consecutive_sleeps = 0
        else:
          consecutive_sleeps += 1
      except Exception as e:
        logging.exception('poll_server failed')
        msg = '%s\n%s' % (e, traceback.format_exc()[-2048:])
        botobj.post_error(msg)
        consecutive_sleeps = 0
    logging.info('Quitting')

  # Tell the server we are going away.
  botobj.post_event('bot_shutdown', 'Signal was received')
  botobj.cancel_all_timers()
  return 0


def poll_server(botobj, quit_bit):
  """"""Polls the server to run one loop.

  Returns True if executed some action, False if server asked the bot to sleep.
  """"""
  # Access to a protected member _XXX of a client class - pylint: disable=W0212
  start = time.time()
  resp = net.url_read_json(
     botobj.server + '/swarming/api/v1/bot/poll', data=botobj._attributes)
  if not resp:
    return False
  logging.debug('Server response:\n%s', resp)

  cmd = resp['cmd']
  if cmd == 'sleep':
    quit_bit.wait(resp['duration'])
    return False

  if cmd == 'terminate':
    quit_bit.set()
    # This is similar to post_update() in task_runner.py.
    params = {
      'cost_usd': 0,
      'duration': 0,
      'exit_code': 0,
      'hard_timeout': False,
      'id': botobj.id,
      'io_timeout': False,
      'output': '',
      'output_chunk_start': 0,
      'task_id': resp['task_id'],
    }
    net.url_read_json(
        botobj.server + '/swarming/api/v1/bot/task_update/%s' % resp['task_id'],
        data=params)
    return False

  if cmd == 'run':
    if run_manifest(botobj, resp['manifest'], start):
      # Completed a task successfully so update swarming_bot.zip if necessary.
      update_lkgbc(botobj)
    # TODO(maruel): Handle the case where quit_bit.is_set() happens here. This
    # is concerning as this means a signal (often SIGTERM) was received while
    # running the task. Make sure the host is properly restarting.
  elif cmd == 'update':
    update_bot(botobj, resp['version'])
  elif cmd == 'restart':
    if _in_load_test_mode():
      logging.warning('Would have restarted: %s' % resp['message'])
    else:
      botobj.restart(resp['message'])
  else:
    raise ValueError('Unexpected command: %s\n%s' % (cmd, resp))

  return True


def run_manifest(botobj, manifest, start):
  """"""Defers to task_runner.py.

  Return True if the task succeeded.
  """"""
  # Ensure the manifest is valid. This can throw a json decoding error. Also
  # raise if it is empty.
  if not manifest:
    raise ValueError('Empty manifest')

  # Necessary to signal an internal_failure. This occurs when task_runner fails
  # to execute the command. It is important to note that this data is extracted
  # before any I/O is done, like writting the manifest to disk.
  task_id = manifest['task_id']
  hard_timeout = manifest['hard_timeout'] or None
  # Default the grace period to 30s here, this doesn't affect the grace period
  # for the actual task.
  grace_period = manifest['grace_period'] or 30
  if manifest['hard_timeout']:
    # One for the child process, one for run_isolated, one for task_runner.
    hard_timeout += 3 * manifest['grace_period']
    # For isolated task, download time is not counted for hard timeout so add
    # more time.
    if not manifest['command']:
      hard_timeout += manifest['io_timeout'] or 600

  url = manifest.get('host', botobj.server)
  task_dimensions = manifest['dimensions']
  task_result = {}

  failure = False
  internal_failure = False
  msg = None
  work_dir = os.path.join(botobj.base_dir, 'work')
  try:
    try:
      if os.path.isdir(work_dir):
        file_path.rmtree(work_dir)
    except OSError:
      # If a previous task created an undeleteable file/directory inside 'work',
      # make sure that following tasks are not affected. This is done by working
      # around the undeleteable directory by creating a temporary directory
      # instead. This is not normal behavior. The bot will report a failure on
      # start.
      work_dir = tempfile.mkdtemp(dir=botobj.base_dir, prefix='work')
    else:
      os.makedirs(work_dir)

    env = os.environ.copy()
    # Windows in particular does not tolerate unicode strings in environment
    # variables.
    env['SWARMING_TASK_ID'] = task_id.encode('ascii')

    task_in_file = os.path.join(work_dir, 'task_runner_in.json')
    with open(task_in_file, 'wb') as f:
      f.write(json.dumps(manifest))
    call_hook(botobj, 'on_before_task')
    task_result_file = os.path.join(work_dir, 'task_runner_out.json')
    if os.path.exists(task_result_file):
      os.remove(task_result_file)
    command = [
      sys.executable, THIS_FILE, 'task_runner',
      '--swarming-server', url,
      '--in-file', task_in_file,
      '--out-file', task_result_file,
      '--cost-usd-hour', str(botobj.state.get('cost_usd_hour') or 0.),
      # Include the time taken to poll the task in the cost.
      '--start', str(start),
      '--min-free-space', str(get_min_free_space()),
    ]
    logging.debug('Running command: %s', command)
    # Put the output file into the current working directory, which should be
    # the one containing swarming_bot.zip.
    log_path = os.path.join(botobj.base_dir, 'logs', 'task_runner_stdout.log')
    os_utilities.roll_log(log_path)
    os_utilities.trim_rolled_log(log_path)
    with open(log_path, 'a+b') as f:
      proc = subprocess42.Popen(
          command,
          detached=True,
          cwd=botobj.base_dir,
          env=env,
          stdin=subprocess42.PIPE,
          stdout=f,
          stderr=subprocess42.STDOUT,
          close_fds=sys.platform != 'win32')
      try:
        proc.wait(hard_timeout)
      except subprocess42.TimeoutExpired:
        # That's the last ditch effort; as task_runner should have completed a
        # while ago and had enforced the timeout itself (or run_isolated for
        # hard_timeout for isolated task).
        logging.error('Sending SIGTERM to task_runner')
        proc.terminate()
        internal_failure = True
        msg = 'task_runner hung'
        try:
          proc.wait(grace_period)
        except subprocess42.TimeoutExpired:
          logging.error('Sending SIGKILL to task_runner')
          proc.kill()
        proc.wait()
        return False

    logging.info('task_runner exit: %d', proc.returncode)
    if os.path.exists(task_result_file):
      with open(task_result_file, 'rb') as fd:
        task_result = json.load(fd)

    if proc.returncode:
      msg = 'Execution failed: internal error (%d).' % proc.returncode
      internal_failure = True
    elif not task_result:
      logging.warning('task_runner failed to write metadata')
      msg = 'Execution failed: internal error (no metadata).'
      internal_failure = True
    elif task_result[u'must_signal_internal_failure']:
      msg = (
        'Execution failed: %s' % task_result[u'must_signal_internal_failure'])
      internal_failure = True

    failure = bool(task_result.get('exit_code')) if task_result else False
    return not internal_failure and not failure
  except Exception as e:
    # Failures include IOError when writing if the disk is full, OSError if
    # swarming_bot.zip doesn't exist anymore, etc.
    logging.exception('run_manifest failed')
    msg = 'Internal exception occured: %s\n%s' % (
        e, traceback.format_exc()[-2048:])
    internal_failure = True
  finally:
    if internal_failure:
      post_error_task(botobj, msg, task_id)
    call_hook(
        botobj, 'on_after_task', failure, internal_failure, task_dimensions,
        task_result)
    if os.path.isdir(work_dir):
      try:
        file_path.rmtree(work_dir)
      except Exception as e:
        botobj.post_error(
            'Failed to delete work directory %s: %s' % (work_dir, e))


def update_bot(botobj, version):
  """"""Downloads the new version of the bot code and then runs it.

  Use alternating files; first load swarming_bot.1.zip, then swarming_bot.2.zip,
  never touching swarming_bot.zip which was the originally bootstrapped file.

  LKGBC is handled by update_lkgbc().

  Does not return.
  """"""
  # Alternate between .1.zip and .2.zip.
  new_zip = 'swarming_bot.1.zip'
  if os.path.basename(THIS_FILE) == new_zip:
    new_zip = 'swarming_bot.2.zip'
  new_zip = os.path.join(os.path.dirname(THIS_FILE), new_zip)

  # Download as a new file.
  url = botobj.server + '/swarming/api/v1/bot/bot_code/%s' % version
  if not net.url_retrieve(new_zip, url):
    # It can happen when a server is rapidly updated multiple times in a row.
    botobj.post_error(
        'Unable to download %s from %s; first tried version %s' %
        (new_zip, url, version))
    # Poll again, this may work next time. To prevent busy-loop, sleep a little.
    time.sleep(2)
    return

  s = os.stat(new_zip)
  logging.info('Restarting to %s; %d bytes.', new_zip, s.st_size)
  sys.stdout.flush()
  sys.stderr.flush()

  proc = subprocess42.Popen(
     [sys.executable, new_zip, 'is_fine'],
     stdout=subprocess42.PIPE, stderr=subprocess42.STDOUT)
  output, _ = proc.communicate()
  if proc.returncode:
    botobj.post_error(
        'New bot code is bad: proc exit = %s. stdout:\n%s' %
        (proc.returncode, output))
    # Poll again, the server may have better code next time. To prevent
    # busy-loop, sleep a little.
    time.sleep(2)
    return

  # Don't forget to release the singleton before restarting itself.
  SINGLETON.release()

  # Do not call on_bot_shutdown.
  # On OSX, launchd will be unhappy if we quit so the old code bot process has
  # to outlive the new code child process. Launchd really wants the main process
  # to survive, and it'll restart it if it disappears. os.exec*() replaces the
  # process so this is fine.
  ret = common.exec_python([new_zip, 'start_slave', '--survive'])
  if ret in (1073807364, -1073741510):
    # 1073807364 is returned when the process is killed due to shutdown. No need
    # to alert anyone in that case.
    # -1073741510 is returned when rebooting too. This can happen when the
    # parent code was running the old version and gets confused and decided to
    # poll again.
    # In any case, zap out the error code.
    ret = 0
  elif ret:
    botobj.post_error('Bot failed to respawn after update: %s' % ret)
  sys.exit(ret)


def update_lkgbc(botobj):
  """"""Updates the Last Known Good Bot Code if necessary.""""""
  try:
    if not os.path.isfile(THIS_FILE):
      botobj.post_error('Missing file %s for LKGBC' % THIS_FILE)
      return

    golden = os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')
    if os.path.isfile(golden):
      org = os.stat(golden)
      cur = os.stat(THIS_FILE)
      if org.st_size == org.st_size and org.st_mtime >= cur.st_mtime:
        return

    # Copy the file back.
    shutil.copy(THIS_FILE, golden)
  except Exception as e:
    botobj.post_error('Failed to update LKGBC: %s' % e)


def get_config():
  """"""Returns the data from config.json.""""""
  global _ERROR_HANDLER_WAS_REGISTERED

  with contextlib.closing(zipfile.ZipFile(THIS_FILE, 'r')) as f:
    config = json.load(f.open('config/config.json', 'r'))

  server = config.get('server', '')
  if not _ERROR_HANDLER_WAS_REGISTERED and server:
    on_error.report_on_exception_exit(server)
    _ERROR_HANDLER_WAS_REGISTERED = True
  return config


def main(args):
  # Add SWARMING_HEADLESS into environ so subcommands know that they are running
  # in a headless (non-interactive) mode.
  os.environ['SWARMING_HEADLESS'] = '1'

  # The only reason this is kept is to enable the unit test to use --help to
  # quit the process.
  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)
  _, args = parser.parse_args(args)

  # Enforces that only one process with a bot in this directory can be run on
  # this host at once.
  if not SINGLETON.acquire():
    if sys.platform == 'darwin':
      msg = (
          'Found a previous bot, %d rebooting as a workaround for '
          'https://crbug.com/569610.') % os.getpid()
      print >> sys.stderr, msg
      os_utilities.restart(msg)
    else:
      print >> sys.stderr, 'Found a previous bot, %d exiting.' % os.getpid()
    return 1

  for t in ('out', 'err'):
    log_path = os.path.join(
        os.path.dirname(THIS_FILE), 'logs', 'bot_std%s.log' % t)
    os_utilities.roll_log(log_path)
    os_utilities.trim_rolled_log(log_path)

  error = None
  if len(args) != 0:
    error = 'Unexpected arguments: %s' % args
  try:
    return run_bot(error)
  finally:
    call_hook(bot.Bot(None, None, None, os.path.dirname(THIS_FILE), None),
              'on_bot_shutdown')
    logging.info('main() returning')
/n/n/nappengine/swarming/swarming_bot/bot_code/bot_main_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import json
import logging
import os
import shutil
import sys
import tempfile
import threading
import time
import unittest
import zipfile

import test_env_bot_code
test_env_bot_code.setup_test_env()

# Creates a server mock for functions in net.py.
import net_utils

import bot_main
from api import bot
from api import os_utilities
from depot_tools import fix_encoding
from utils import file_path
from utils import logging_utils
from utils import net
from utils import subprocess42
from utils import zip_package


# Access to a protected member XX of a client class - pylint: disable=W0212


class TestBotMain(net_utils.TestCase):
  maxDiff = 2000

  def setUp(self):
    super(TestBotMain, self).setUp()
    os.environ.pop('SWARMING_LOAD_TEST', None)
    self.root_dir = tempfile.mkdtemp(prefix='bot_main')
    self.old_cwd = os.getcwd()
    os.chdir(self.root_dir)
    # __main__ does it for us.
    os.mkdir('logs')
    self.url = 'https://localhost:1'
    self.attributes = {
      'dimensions': {
        'foo': ['bar'],
        'id': ['localhost'],
        'pool': ['default'],
      },
      'state': {
        'cost_usd_hour': 3600.,
        'sleep_streak': 0,
      },
      'version': '123',
    }
    self.mock(zip_package, 'generate_version', lambda: '123')
    self.bot = bot.Bot(
        self.attributes, 'https://localhost:1', 'version1', self.root_dir,
        self.fail)
    self.mock(self.bot, 'post_error', self.fail)
    self.mock(self.bot, 'restart', self.fail)
    self.mock(subprocess42, 'call', self.fail)
    self.mock(time, 'time', lambda: 100.)
    config_path = os.path.join(
        test_env_bot_code.BOT_DIR, 'config', 'config.json')
    with open(config_path, 'rb') as f:
      config = json.load(f)
    self.mock(bot_main, 'get_config', lambda: config)
    self.mock(
        bot_main, 'THIS_FILE',
        os.path.join(test_env_bot_code.BOT_DIR, 'swarming_bot.zip'))

  def tearDown(self):
    os.environ.pop('SWARMING_BOT_ID', None)
    os.chdir(self.old_cwd)
    file_path.rmtree(self.root_dir)
    super(TestBotMain, self).tearDown()

  def test_get_dimensions(self):
    dimensions = set(bot_main.get_dimensions(None))
    dimensions.discard('hidpi')
    dimensions.discard('zone')  # Only set on GCE bots.
    expected = {'cores', 'cpu', 'gpu', 'id', 'machine_type', 'os', 'pool'}
    self.assertEqual(expected, dimensions)

  def test_get_dimensions_load_test(self):
    os.environ['SWARMING_LOAD_TEST'] = '1'
    self.assertEqual(['id', 'load_test'], sorted(bot_main.get_dimensions(None)))

  def test_generate_version(self):
    self.assertEqual('123', bot_main.generate_version())

  def test_get_state(self):
    self.mock(time, 'time', lambda: 126.0)
    expected = os_utilities.get_state()
    expected['sleep_streak'] = 12
    # During the execution of this test case, the free disk space could have
    # changed.
    for disk in expected['disks'].itervalues():
      self.assertGreater(disk.pop('free_mb'), 1.)
    actual = bot_main.get_state(None, 12)
    for disk in actual['disks'].itervalues():
      self.assertGreater(disk.pop('free_mb'), 1.)
    self.assertGreater(actual.pop('nb_files_in_temp'), 0)
    self.assertGreater(expected.pop('nb_files_in_temp'), 0)
    self.assertGreater(actual.pop('uptime'), 0)
    self.assertGreater(expected.pop('uptime'), 0)
    self.assertEqual(sorted(expected.pop('temp', {})),
                     sorted(actual.pop('temp', {})))
    self.assertEqual(expected, actual)

  def test_setup_bot(self):
    setup_bots = []
    def setup_bot(_bot):
      setup_bots.append(1)
      return False
    from config import bot_config
    self.mock(bot_config, 'setup_bot', setup_bot)
    restarts = []
    post_event = []
    self.mock(
        os_utilities, 'restart', lambda *a, **kw: restarts.append((a, kw)))
    self.mock(
        bot.Bot, 'post_event', lambda *a, **kw: post_event.append((a, kw)))
    self.expected_requests([])
    bot_main.setup_bot(False)
    expected = [
      (('Starting new swarming bot: %s' % bot_main.THIS_FILE,),
        {'timeout': 900}),
    ]
    self.assertEqual(expected, restarts)
    # It is called twice, one as part of setup_bot(False), another as part of
    # on_shutdown_hook().
    self.assertEqual([1, 1], setup_bots)
    expected = [
      'Starting new swarming bot: %s' % bot_main.THIS_FILE,
      'Bot is stuck restarting for: Starting new swarming bot: %s' %
        bot_main.THIS_FILE,
    ]
    self.assertEqual(expected, [i[0][2] for i in post_event])

  def test_post_error_task(self):
    self.mock(time, 'time', lambda: 126.0)
    self.mock(logging, 'error', lambda *_, **_kw: None)
    self.mock(
        bot_main, 'get_config',
        lambda: {'server': self.url, 'server_version': '1'})
    expected_attribs = bot_main.get_attributes(None)
    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/task_error/23',
            {
              'data': {
                'id': expected_attribs['dimensions']['id'][0],
                'message': 'error',
                'task_id': 23,
              },
            },
            {'resp': 1},
          ),
        ])
    botobj = bot_main.get_bot()
    self.assertEqual({'resp': 1}, bot_main.post_error_task(botobj, 'error', 23))

  def test_run_bot(self):
    # Test the run_bot() loop. Does not use self.bot.
    self.mock(time, 'time', lambda: 126.0)
    class Foo(Exception):
      pass

    def poll_server(botobj, _):
      sleep_streak = botobj.state['sleep_streak']
      self.assertEqual(self.url, botobj.server)
      if sleep_streak == 5:
        raise Exception('Jumping out of the loop')
      return False
    self.mock(bot_main, 'poll_server', poll_server)

    def post_error(botobj, e):
      self.assertEqual(self.url, botobj.server)
      lines = e.splitlines()
      self.assertEqual('Jumping out of the loop', lines[0])
      self.assertEqual('Traceback (most recent call last):', lines[1])
      raise Foo('Necessary to get out of the loop')
    self.mock(bot.Bot, 'post_error', post_error)

    self.mock(
        bot_main, 'get_config',
        lambda: {'server': self.url, 'server_version': '1'})
    self.mock(
        bot_main, 'get_dimensions', lambda _: self.attributes['dimensions'])
    self.mock(os_utilities, 'get_state', lambda *_: self.attributes['state'])

    # Method should have ""self"" as first argument - pylint: disable=E0213
    # pylint: disable=unused-argument
    class Popen(object):
      def __init__(
          self2, cmd, detached, cwd, stdout, stderr, stdin, close_fds):
        self2.returncode = None
        expected = [sys.executable, bot_main.THIS_FILE, 'run_isolated']
        self.assertEqual(expected, cmd[:len(expected)])
        self.assertEqual(True, detached)
        self.assertEqual(subprocess42.PIPE, stdout)
        self.assertEqual(subprocess42.STDOUT, stderr)
        self.assertEqual(subprocess42.PIPE, stdin)
        self.assertEqual(sys.platform != 'win32', close_fds)

      def communicate(self2, i):
        self.assertEqual(None, i)
        self2.returncode = 0
        return '', None
    self.mock(subprocess42, 'Popen', Popen)

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/server_ping',
            {}, 'foo', None,
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/handshake',
            {'data': self.attributes},
            {'bot_version': '123', 'server': self.url, 'server_version': 1},
          ),
        ])

    with self.assertRaises(Foo):
      bot_main.run_bot(None)
    self.assertEqual(
        self.attributes['dimensions']['id'][0], os.environ['SWARMING_BOT_ID'])

  def test_poll_server_sleep(self):
    slept = []
    bit = threading.Event()
    self.mock(bit, 'wait', slept.append)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', self.fail)

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {'data': self.attributes},
            {
              'cmd': 'sleep',
              'duration': 1.24,
            },
          ),
        ])
    self.assertFalse(bot_main.poll_server(self.bot, bit))
    self.assertEqual([1.24], slept)

  def test_poll_server_run(self):
    manifest = []
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', lambda *args: manifest.append(args))
    self.mock(bot_main, 'update_bot', self.fail)

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {'data': self.bot._attributes},
            {
              'cmd': 'run',
              'manifest': {'foo': 'bar'},
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))
    expected = [(self.bot, {'foo': 'bar'}, time.time())]
    self.assertEqual(expected, manifest)

  def test_poll_server_update(self):
    update = []
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', lambda *args: update.append(args))

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {'data': self.attributes},
            {
              'cmd': 'update',
              'version': '123',
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))
    self.assertEqual([(self.bot, '123')], update)

  def test_poll_server_restart(self):
    restart = []
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', self.fail)
    self.mock(self.bot, 'restart', lambda *args: restart.append(args))

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {'data': self.attributes},
            {
              'cmd': 'restart',
              'message': 'Please die now',
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))
    self.assertEqual([('Please die now',)], restart)

  def test_poll_server_restart_load_test(self):
    os.environ['SWARMING_LOAD_TEST'] = '1'
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', self.fail)
    self.mock(self.bot, 'restart', self.fail)

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {
              'data': self.attributes,
            },
            {
              'cmd': 'restart',
              'message': 'Please die now',
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))

  def _mock_popen(self, returncode=0, exit_code=0, url='https://localhost:1'):
    result = {
      'exit_code': exit_code,
      'must_signal_internal_failure': None,
      'version': 3,
    }
    # Method should have ""self"" as first argument - pylint: disable=E0213
    class Popen(object):
      def __init__(
          self2, cmd, detached, cwd, env, stdout, stderr, stdin, close_fds):
        self2.returncode = None
        self2._out_file = os.path.join(
            self.root_dir, 'work', 'task_runner_out.json')
        expected = [
          sys.executable, bot_main.THIS_FILE, 'task_runner',
          '--swarming-server', url,
          '--in-file',
          os.path.join(self.root_dir, 'work', 'task_runner_in.json'),
          '--out-file', self2._out_file,
          '--cost-usd-hour', '3600.0', '--start', '100.0',
          '--min-free-space',
          str(int(
            (os_utilities.get_min_free_space(bot_main.THIS_FILE) + 250.) *
            1024 * 1024)),
        ]
        self.assertEqual(expected, cmd)
        self.assertEqual(True, detached)
        self.assertEqual(self.bot.base_dir, cwd)
        self.assertEqual('24', env['SWARMING_TASK_ID'])
        self.assertTrue(stdout)
        self.assertEqual(subprocess42.STDOUT, stderr)
        self.assertEqual(subprocess42.PIPE, stdin)
        self.assertEqual(sys.platform != 'win32', close_fds)

      def wait(self2, timeout=None): # pylint: disable=unused-argument
        self2.returncode = returncode
        with open(self2._out_file, 'wb') as f:
          json.dump(result, f)
        return 0

    self.mock(subprocess42, 'Popen', Popen)
    return result

  def test_run_manifest(self):
    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))
    def call_hook(botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(self.attributes['dimensions'], botobj.dimensions)
        self.assertEqual(False, failure)
        self.assertEqual(False, internal_failure)
        self.assertEqual({'os': 'Amiga', 'pool': 'default'}, dimensions)
        self.assertEqual(result, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    result = self._mock_popen(url='https://localhost:3')

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'os': 'Amiga', 'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'host': 'https://localhost:3',
      'task_id': '24',
    }
    self.assertEqual(self.root_dir, self.bot.base_dir)
    bot_main.run_manifest(self.bot, manifest, time.time())

  def test_run_manifest_task_failure(self):
    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))
    def call_hook(_botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(True, failure)
        self.assertEqual(False, internal_failure)
        self.assertEqual({'pool': 'default'}, dimensions)
        self.assertEqual(result, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    result = self._mock_popen(exit_code=1)

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'io_timeout': 60,
      'task_id': '24',
    }
    bot_main.run_manifest(self.bot, manifest, time.time())

  def test_run_manifest_internal_failure(self):
    posted = []
    self.mock(bot_main, 'post_error_task', lambda *args: posted.append(args))
    def call_hook(_botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(False, failure)
        self.assertEqual(True, internal_failure)
        self.assertEqual({'pool': 'default'}, dimensions)
        self.assertEqual(result, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    result = self._mock_popen(returncode=1)

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'io_timeout': 60,
      'task_id': '24',
    }
    bot_main.run_manifest(self.bot, manifest, time.time())
    expected = [(self.bot, 'Execution failed: internal error (1).', '24')]
    self.assertEqual(expected, posted)

  def test_run_manifest_exception(self):
    posted = []
    def post_error_task(botobj, msg, task_id):
      posted.append((botobj, msg.splitlines()[0], task_id))
    self.mock(bot_main, 'post_error_task', post_error_task)
    def call_hook(_botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(False, failure)
        self.assertEqual(True, internal_failure)
        self.assertEqual({'pool': 'default'}, dimensions)
        self.assertEqual({}, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    def raiseOSError(*_a, **_k):
      raise OSError('Dang')
    self.mock(subprocess42, 'Popen', raiseOSError)

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'task_id': '24',
    }
    bot_main.run_manifest(self.bot, manifest, time.time())
    expected = [(self.bot, 'Internal exception occured: Dang', '24')]
    self.assertEqual(expected, posted)

  def test_update_bot(self):
    # In a real case 'update_bot' never exits and doesn't call 'post_error'.
    # Under the test however forever-blocking calls finish, and post_error is
    # called.
    self.mock(self.bot, 'post_error', lambda *_: None)
    # Mock the file to download in the temporary directory.
    self.mock(
        bot_main, 'THIS_FILE',
        os.path.join(self.root_dir, 'swarming_bot.1.zip'))
    new_zip = os.path.join(self.root_dir, 'swarming_bot.2.zip')
    # This is necessary otherwise zipfile will crash.
    self.mock(time, 'time', lambda: 1400000000)
    def url_retrieve(f, url):
      self.assertEqual(
          'https://localhost:1/swarming/api/v1/bot/bot_code/123', url)
      self.assertEqual(new_zip, f)
      # Create a valid zip that runs properly.
      with zipfile.ZipFile(f, 'w') as z:
        z.writestr('__main__.py', 'print(""hi"")')
      return True
    self.mock(net, 'url_retrieve', url_retrieve)

    calls = []
    def exec_python(args):
      calls.append(args)
      return 23
    self.mock(bot_main.common, 'exec_python', exec_python)

    with self.assertRaises(SystemExit) as e:
      bot_main.update_bot(self.bot, '123')
    self.assertEqual(23, e.exception.code)

    self.assertEqual([[new_zip, 'start_slave', '--survive']], calls)

  def test_main(self):
    def check(x):
      self.assertEqual(logging.WARNING, x)
    self.mock(logging_utils, 'set_console_level', check)

    def run_bot(error):
      self.assertEqual(None, error)
      return 0
    self.mock(bot_main, 'run_bot', run_bot)

    class Singleton(object):
      # pylint: disable=no-self-argument
      def acquire(self2):
        return True
      def release(self2):
        self.fail()
    self.mock(bot_main, 'SINGLETON', Singleton())

    self.assertEqual(0, bot_main.main([]))


if __name__ == '__main__':
  fix_encoding.fix_encoding()
  if '-v' in sys.argv:
    TestBotMain.maxDiff = None
  logging.basicConfig(
      level=logging.DEBUG if '-v' in sys.argv else logging.CRITICAL)
  unittest.main()
/n/n/nappengine/swarming/swarming_bot/bot_code/task_runner.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Runs a Swarming task.

Downloads all the necessary files to run the task, executes the command and
streams results back to the Swarming server.

The process exit code is 0 when the task was executed, even if the task itself
failed. If there's any failure in the setup or teardown, like invalid packet
response, failure to contact the server, etc, a non zero exit code is used. It's
up to the calling process (bot_main.py) to signal that there was an internal
failure and to cancel this task run and ask the server to retry it.
""""""

import base64
import json
import logging
import optparse
import os
import signal
import sys
import time

from utils import net
from utils import on_error
from utils import subprocess42
from utils import zip_package


# Path to this file or the zip containing this file.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# Sends a maximum of 100kb of stdout per task_update packet.
MAX_CHUNK_SIZE = 102400


# Maximum wait between task_update packet when there's no output.
MAX_PACKET_INTERVAL = 30


# Minimum wait between task_update packet when there's output.
MIN_PACKET_INTERNAL = 10


# Current task_runner_out version.
OUT_VERSION = 3


# On Windows, SIGTERM is actually sent as SIGBREAK since there's no real
# SIGTERM.  SIGBREAK is not defined on posix since it's a pure Windows concept.
SIG_BREAK_OR_TERM = (
    signal.SIGBREAK if sys.platform == 'win32' else signal.SIGTERM)


# Used to implement monotonic_time for a clock that never goes backward.
_last_now = 0


def monotonic_time():
  """"""Returns monotonically increasing time.""""""
  global _last_now
  now = time.time()
  if now > _last_now:
    # TODO(maruel): If delta is large, probably worth alerting via ereporter2.
    _last_now = now
  return _last_now


def get_run_isolated():
  """"""Returns the path to itself to run run_isolated.

  Mocked in test to point to the real run_isolated.py script.
  """"""
  return [sys.executable, THIS_FILE, 'run_isolated']


def get_isolated_cmd(
    work_dir, task_details, isolated_result, min_free_space):
  """"""Returns the command to call run_isolated. Mocked in tests.""""""
  bot_dir = os.path.dirname(work_dir)
  if os.path.isfile(isolated_result):
    os.remove(isolated_result)
  cmd = get_run_isolated()
  cmd.extend(
      [
        '--isolated', task_details.inputs_ref['isolated'].encode('utf-8'),
        '--namespace', task_details.inputs_ref['namespace'].encode('utf-8'),
        '-I', task_details.inputs_ref['isolatedserver'].encode('utf-8'),
        '--json', isolated_result,
        '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),
        '--cache', os.path.join(bot_dir, 'cache'),
        '--root-dir', os.path.join(work_dir, 'isolated'),
      ])
  if min_free_space:
    cmd.extend(('--min-free-space', str(min_free_space)))

  if task_details.hard_timeout:
    cmd.extend(('--hard-timeout', str(task_details.hard_timeout)))
  if task_details.grace_period:
    cmd.extend(('--grace-period', str(task_details.grace_period)))
  if task_details.extra_args:
    cmd.append('--')
    cmd.extend(task_details.extra_args)
  return cmd


class TaskDetails(object):
  def __init__(self, data):
    """"""Loads the raw data.

    It is expected to have at least:
     - bot_id
     - command as a list of str
     - data as a list of urls
     - env as a dict
     - hard_timeout
     - io_timeout
     - task_id
    """"""
    logging.info('TaskDetails(%s)', data)
    if not isinstance(data, dict):
      raise ValueError('Expected dict, got %r' % data)

    # Get all the data first so it fails early if the task details is invalid.
    self.bot_id = data['bot_id']

    # Raw command. Only self.command or self.inputs_ref can be set.
    self.command = data['command'] or []

    # Isolated command. Is a serialized version of task_request.FilesRef.
    self.inputs_ref = data['inputs_ref']
    self.extra_args = data['extra_args']

    self.env = {
      k.encode('utf-8'): v.encode('utf-8') for k, v in data['env'].iteritems()
    }
    self.grace_period = data['grace_period']
    self.hard_timeout = data['hard_timeout']
    self.io_timeout = data['io_timeout']
    self.task_id = data['task_id']


class MustExit(Exception):
  """"""Raised on signal that the process must exit immediately.""""""
  def __init__(self, sig):
    super(MustExit, self).__init__()
    self.signal = sig


def load_and_run(
    in_file, swarming_server, cost_usd_hour, start, out_file, min_free_space):
  """"""Loads the task's metadata and execute it.

  This may throw all sorts of exceptions in case of failure. It's up to the
  caller to trap them. These shall be considered 'internal_failure' instead of
  'failure' from a TaskRunResult standpoint.
  """"""
  # The work directory is guaranteed to exist since it was created by
  # bot_main.py and contains the manifest. Temporary files will be downloaded
  # there. It's bot_main.py that will delete the directory afterward. Tests are
  # not run from there.
  task_result = None
  def handler(sig, _):
    logging.info('Got signal %s', sig)
    raise MustExit(sig)
  work_dir = os.path.dirname(out_file)
  try:
    with subprocess42.set_signal_handler([SIG_BREAK_OR_TERM], handler):
      if not os.path.isdir(work_dir):
        raise ValueError('%s expected to exist' % work_dir)

      with open(in_file, 'rb') as f:
        task_details = TaskDetails(json.load(f))

      task_result = run_command(
          swarming_server, task_details, work_dir, cost_usd_hour, start,
          min_free_space)
  except MustExit as e:
    # This normally means run_command() didn't get the chance to run, as it
    # itself trap MustExit and will report accordingly. In this case, we want
    # the parent process to send the message instead.
    if not task_result:
      task_result = {
        u'exit_code': None,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure':
            u'task_runner received signal %s' % e.signal,
        u'version': OUT_VERSION,
      }
  finally:
    # We've found tests to delete 'work' when quitting, causing an exception
    # here. Try to recreate the directory if necessary.
    if not os.path.isdir(work_dir):
      os.mkdir(work_dir)
    with open(out_file, 'wb') as f:
      json.dump(task_result, f)


def post_update(swarming_server, params, exit_code, stdout, output_chunk_start):
  """"""Posts task update to task_update.

  Arguments:
    swarming_server: Base URL to Swarming server.
    params: Default JSON parameters for the POST.
    exit_code: Process exit code, only when a command completed.
    stdout: Incremental output since last call, if any.
    output_chunk_start: Total number of stdout previously sent, for coherency
        with the server.
  """"""
  params = params.copy()
  if exit_code is not None:
    params['exit_code'] = exit_code
  if stdout:
    # The output_chunk_start is used by the server to make sure that the stdout
    # chunks are processed and saved in the DB in order.
    params['output'] = base64.b64encode(stdout)
    params['output_chunk_start'] = output_chunk_start
  # TODO(maruel): Support early cancellation.
  # https://code.google.com/p/swarming/issues/detail?id=62
  resp = net.url_read_json(
      swarming_server+'/swarming/api/v1/bot/task_update/%s' % params['task_id'],
      data=params)
  logging.debug('post_update() = %s', resp)
  if resp.get('error'):
    # Abandon it. This will force a process exit.
    raise ValueError(resp.get('error'))


def should_post_update(stdout, now, last_packet):
  """"""Returns True if it's time to send a task_update packet via post_update().

  Sends a packet when one of this condition is met:
  - more than MAX_CHUNK_SIZE of stdout is buffered.
  - last packet was sent more than MIN_PACKET_INTERNAL seconds ago and there was
    stdout.
  - last packet was sent more than MAX_PACKET_INTERVAL seconds ago.
  """"""
  packet_interval = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  return len(stdout) >= MAX_CHUNK_SIZE or (now - last_packet) > packet_interval


def calc_yield_wait(task_details, start, last_io, timed_out, stdout):
  """"""Calculates the maximum number of seconds to wait in yield_any().""""""
  now = monotonic_time()
  if timed_out:
    # Give a |grace_period| seconds delay.
    if task_details.grace_period:
      return max(now - timed_out - task_details.grace_period, 0.)
    return 0.

  out = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  if task_details.hard_timeout:
    out = min(out, start + task_details.hard_timeout - now)
  if task_details.io_timeout:
    out = min(out, last_io + task_details.io_timeout - now)
  out = max(out, 0)
  logging.debug('calc_yield_wait() = %d', out)
  return out


def kill_and_wait(proc, grace_period, reason):
  logging.warning('SIGTERM finally due to %s', reason)
  proc.terminate()
  try:
    proc.wait(grace_period)
  except subprocess42.TimeoutError:
    logging.warning('SIGKILL finally due to %s', reason)
    proc.kill()
  exit_code = proc.wait()
  logging.info('Waiting for proces exit in finally - done')
  return exit_code


def run_command(
    swarming_server, task_details, work_dir, cost_usd_hour, task_start,
    min_free_space):
  """"""Runs a command and sends packets to the server to stream results back.

  Implements both I/O and hard timeouts. Sends the packets numbered, so the
  server can ensure they are processed in order.

  Returns:
    Metadata about the command.
  """"""
  # TODO(maruel): This function is incomprehensible, split and refactor.
  # Signal the command is about to be started.
  last_packet = start = now = monotonic_time()
  params = {
    'cost_usd': cost_usd_hour * (now - task_start) / 60. / 60.,
    'id': task_details.bot_id,
    'task_id': task_details.task_id,
  }
  post_update(swarming_server, params, None, '', 0)

  if task_details.command:
    # Raw command.
    cmd = task_details.command
    isolated_result = None
  else:
    # Isolated task.
    isolated_result = os.path.join(work_dir, 'isolated_result.json')
    cmd = get_isolated_cmd(
        work_dir, task_details, isolated_result, min_free_space)
    # Hard timeout enforcement is deferred to run_isolated. Grace is doubled to
    # give one 'grace_period' slot to the child process and one slot to upload
    # the results back.
    task_details.hard_timeout = 0
    if task_details.grace_period:
      task_details.grace_period *= 2

  try:
    # TODO(maruel): Support both channels independently and display stderr in
    # red.
    env = None
    if task_details.env:
      env = os.environ.copy()
      for key, value in task_details.env.iteritems():
        if not value:
          env.pop(key, None)
        else:
          env[key] = value
    logging.info('cmd=%s', cmd)
    logging.info('env=%s', env)
    try:
      proc = subprocess42.Popen(
          cmd,
          env=env,
          cwd=work_dir,
          detached=True,
          stdout=subprocess42.PIPE,
          stderr=subprocess42.STDOUT,
          stdin=subprocess42.PIPE)
    except OSError as e:
      stdout = 'Command ""%s"" failed to start.\nError: %s' % (' '.join(cmd), e)
      now = monotonic_time()
      params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
      params['duration'] = now - start
      params['io_timeout'] = False
      params['hard_timeout'] = False
      post_update(swarming_server, params, 1, stdout, 0)
      return {
        u'exit_code': -1,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': OUT_VERSION,
      }

    output_chunk_start = 0
    stdout = ''
    exit_code = None
    had_hard_timeout = False
    had_io_timeout = False
    must_signal_internal_failure = None
    kill_sent = False
    timed_out = None
    try:
      calc = lambda: calc_yield_wait(
          task_details, start, last_io, timed_out, stdout)
      maxsize = lambda: MAX_CHUNK_SIZE - len(stdout)
      last_io = monotonic_time()
      for _, new_data in proc.yield_any(maxsize=maxsize, timeout=calc):
        now = monotonic_time()
        if new_data:
          stdout += new_data
          last_io = now

        # Post update if necessary.
        if should_post_update(stdout, now, last_packet):
          last_packet = monotonic_time()
          params['cost_usd'] = (
              cost_usd_hour * (last_packet - task_start) / 60. / 60.)
          post_update(swarming_server, params, None, stdout, output_chunk_start)
          output_chunk_start += len(stdout)
          stdout = ''

        # Send signal on timeout if necessary. Both are failures, not
        # internal_failures.
        # Eventually kill but return 0 so bot_main.py doesn't cancel the task.
        if not timed_out:
          if (task_details.io_timeout and
              now - last_io > task_details.io_timeout):
            had_io_timeout = True
            logging.warning('I/O timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
          elif (task_details.hard_timeout and
              now - start > task_details.hard_timeout):
            had_hard_timeout = True
            logging.warning('Hard timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
        else:
          # During grace period.
          if not kill_sent and now >= timed_out + task_details.grace_period:
            # Now kill for real. The user can distinguish between the following
            # states:
            # - signal but process exited within grace period,
            #   (hard_|io_)_timed_out will be set but the process exit code will
            #   be script provided.
            # - processed exited late, exit code will be -9 on posix.
            logging.warning('Grace exhausted; sending SIGKILL')
            proc.kill()
            kill_sent = True
      logging.info('Waiting for proces exit')
      exit_code = proc.wait()
    except MustExit as e:
      # TODO(maruel): Do the send SIGTERM to child process and give it
      # task_details.grace_period to terminate.
      must_signal_internal_failure = (
          u'task_runner received signal %s' % e.signal)
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'signal %d' % e.signal)
    except (IOError, OSError):
      # Something wrong happened, try to kill the child process.
      had_hard_timeout = True
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'exception %s' % e)

    # This is the very last packet for this command. It if was an isolated task,
    # include the output reference to the archived .isolated file.
    now = monotonic_time()
    params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
    params['duration'] = now - start
    params['io_timeout'] = had_io_timeout
    params['hard_timeout'] = had_hard_timeout
    if isolated_result:
      try:
        if ((had_io_timeout or had_hard_timeout) and
            not os.path.isfile(isolated_result)):
          # It's possible that run_isolated failed to quit quickly enough; it
          # could be because there was too much data to upload back or something
          # else. Do not create an internal error, just send back the (partial)
          # view as task_runner saw it, for example the real exit_code is
          # unknown.
          logging.warning('TIMED_OUT and there\'s no result file')
          exit_code = -1
        else:
          # See run_isolated.py for the format.
          with open(isolated_result, 'rb') as f:
            run_isolated_result = json.load(f)
          logging.debug('run_isolated:\n%s', run_isolated_result)
          # TODO(maruel): Grab statistics (cache hit rate, data downloaded,
          # mapping time, etc) from run_isolated and push them to the server.
          if run_isolated_result['outputs_ref']:
            params['outputs_ref'] = run_isolated_result['outputs_ref']
          had_hard_timeout = (
              had_hard_timeout or run_isolated_result['had_hard_timeout'])
          params['hard_timeout'] = had_hard_timeout
          if not had_io_timeout and not had_hard_timeout:
            if run_isolated_result['internal_failure']:
              must_signal_internal_failure = (
                  run_isolated_result['internal_failure'])
              logging.error('%s', must_signal_internal_failure)
            elif exit_code:
              # TODO(maruel): Grab stdout from run_isolated.
              must_signal_internal_failure = (
                  'run_isolated internal failure %d' % exit_code)
              logging.error('%s', must_signal_internal_failure)
          exit_code = run_isolated_result['exit_code']
          if run_isolated_result.get('duration') is not None:
            # Calculate the real task duration as measured by run_isolated and
            # calculate the remaining overhead.
            params['bot_overhead'] = params['duration']
            params['duration'] = run_isolated_result['duration']
            params['bot_overhead'] -= params['duration']
            params['bot_overhead'] -= run_isolated_result.get(
                'download', {}).get('duration', 0)
            params['bot_overhead'] -= run_isolated_result.get(
                'upload', {}).get('duration', 0)
            if params['bot_overhead'] < 0:
              params['bot_overhead'] = 0
          stats = run_isolated_result.get('stats')
          if stats:
            params['isolated_stats'] = stats
      except (IOError, OSError, ValueError) as e:
        logging.error('Swallowing error: %s', e)
        if not must_signal_internal_failure:
          must_signal_internal_failure = str(e)
    # TODO(maruel): Send the internal failure here instead of sending it through
    # bot_main, this causes a race condition.
    if exit_code is None:
      exit_code = -1
    post_update(swarming_server, params, exit_code, stdout, output_chunk_start)
    return {
      u'exit_code': exit_code,
      u'hard_timeout': had_hard_timeout,
      u'io_timeout': had_io_timeout,
      u'must_signal_internal_failure': must_signal_internal_failure,
      u'version': OUT_VERSION,
    }
  finally:
    if isolated_result:
      try:
        os.remove(isolated_result)
      except OSError:
        pass


def main(args):
  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)
  parser.add_option('--in-file', help='Name of the request file')
  parser.add_option(
      '--out-file', help='Name of the JSON file to write a task summary to')
  parser.add_option(
      '--swarming-server', help='Swarming server to send data back')
  parser.add_option(
      '--cost-usd-hour', type='float', help='Cost of this VM in $/h')
  parser.add_option('--start', type='float', help='Time this task was started')
  parser.add_option(
      '--min-free-space', type='int',
      help='Value to send down to run_isolated')

  options, args = parser.parse_args(args)
  if not options.in_file or not options.out_file or args:
    parser.error('task_runner is meant to be used by swarming_bot.')

  on_error.report_on_exception_exit(options.swarming_server)

  logging.info('starting')
  now = monotonic_time()
  if options.start > now:
    options.start = now

  try:
    load_and_run(
        options.in_file, options.swarming_server, options.cost_usd_hour,
        options.start, options.out_file, options.min_free_space)
    return 0
  finally:
    logging.info('quitting')
/n/n/nappengine/swarming/swarming_bot/bot_code/task_runner_test.py/n/n#!/usr/bin/env python
# coding=utf-8
# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import json
import logging
import os
import signal
import shutil
import sys
import tempfile
import time
import unittest

import test_env_bot_code
test_env_bot_code.setup_test_env()

# Creates a server mock for functions in net.py.
import net_utils

from api import os_utilities
from depot_tools import fix_encoding
from utils import file_path
from utils import large
from utils import logging_utils
from utils import subprocess42
from utils import tools
import fake_swarming
import task_runner

CLIENT_DIR = os.path.normpath(
    os.path.join(test_env_bot_code.BOT_DIR, '..', '..', '..', 'client'))

sys.path.insert(0, os.path.join(CLIENT_DIR, 'tests'))
import isolateserver_mock


def get_manifest(script=None, inputs_ref=None, **kwargs):
  out = {
    'bot_id': 'localhost',
    'command':
        [sys.executable, '-u', '-c', script] if not inputs_ref else None,
    'env': {},
    'extra_args': [],
    'grace_period': 30.,
    'hard_timeout': 10.,
    'inputs_ref': inputs_ref,
    'io_timeout': 10.,
    'task_id': 23,
  }
  out.update(kwargs)
  return out


class TestTaskRunnerBase(net_utils.TestCase):
  def setUp(self):
    super(TestTaskRunnerBase, self).setUp()
    self.root_dir = tempfile.mkdtemp(prefix='task_runner')
    logging.info('Temp: %s', self.root_dir)
    self.work_dir = os.path.join(self.root_dir, 'work')
    os.chdir(self.root_dir)
    os.mkdir(self.work_dir)
    # Create the logs directory so run_isolated.py can put its log there.
    os.mkdir(os.path.join(self.root_dir, 'logs'))

    self.mock(
        task_runner, 'get_run_isolated',
        lambda: [sys.executable, os.path.join(CLIENT_DIR, 'run_isolated.py')])

  def tearDown(self):
    os.chdir(test_env_bot_code.BOT_DIR)
    try:
      file_path.rmtree(self.root_dir)
    except OSError:
      print >> sys.stderr, 'Failed to delete %s' % self.root_dir
    finally:
      super(TestTaskRunnerBase, self).tearDown()

  @classmethod
  def get_task_details(cls, *args, **kwargs):
    return task_runner.TaskDetails(get_manifest(*args, **kwargs))

  def gen_requests(self, cost_usd=0., **kwargs):
    return [
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        self.get_check_first(cost_usd),
        {},
      ),
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        self.get_check_final(**kwargs),
        {},
      ),
    ]

  def requests(self, **kwargs):
    """"""Generates the expected HTTP requests for a task run.""""""
    self.expected_requests(self.gen_requests(**kwargs))

  def get_check_first(self, cost_usd):
    def check_first(kwargs):
      self.assertLessEqual(cost_usd, kwargs['data'].pop('cost_usd'))
      self.assertEqual(
        {
          'data': {
            'id': 'localhost',
            'task_id': 23,
          },
        },
        kwargs)
    return check_first


class TestTaskRunner(TestTaskRunnerBase):
  def setUp(self):
    super(TestTaskRunner, self).setUp()
    self.mock(time, 'time', lambda: 1000000000.)

  def get_check_final(self, exit_code=0, output='hi\n', outputs_ref=None):
    def check_final(kwargs):
      # It makes the diffing easier.
      if 'output' in kwargs['data']:
        kwargs['data']['output'] = base64.b64decode(kwargs['data']['output'])
      expected = {
        'data': {
          'cost_usd': 10.,
          'duration': 0.,
          'exit_code': exit_code,
          'hard_timeout': False,
          'id': 'localhost',
          'io_timeout': False,
          'output': output,
          'output_chunk_start': 0,
          'task_id': 23,
        },
      }
      if outputs_ref:
        expected['data']['outputs_ref'] = outputs_ref
      self.assertEqual(expected, kwargs)
    return check_final

  def _run_command(self, task_details):
    start = time.time()
    self.mock(time, 'time', lambda: start + 10)
    server = 'https://localhost:1'
    return task_runner.run_command(
        server, task_details, self.work_dir, 3600., start, 1)

  def test_load_and_run_raw(self):
    server = 'https://localhost:1'

    def run_command(
        swarming_server, task_details, work_dir, cost_usd_hour, start,
        min_free_space):
      self.assertEqual(server, swarming_server)
      # Necessary for OSX.
      self.assertEqual(
          os.path.realpath(self.work_dir), os.path.realpath(work_dir))
      self.assertTrue(isinstance(task_details, task_runner.TaskDetails))
      self.assertEqual(3600., cost_usd_hour)
      self.assertEqual(time.time(), start)
      self.assertEqual(1, min_free_space)
      return {
        u'exit_code': 1,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': task_runner.OUT_VERSION,
      }
    self.mock(task_runner, 'run_command', run_command)

    manifest = os.path.join(self.root_dir, 'manifest')
    with open(manifest, 'wb') as f:
      data = {
        'bot_id': 'localhost',
        'command': ['a'],
        'env': {'d': 'e'},
        'extra_args': [],
        'grace_period': 30.,
        'hard_timeout': 10,
        'inputs_ref': None,
        'io_timeout': 11,
        'task_id': 23,
      }
      json.dump(data, f)

    out_file = os.path.join(self.root_dir, 'work', 'task_runner_out.json')
    task_runner.load_and_run(manifest, server, 3600., time.time(), out_file, 1)
    expected = {
      u'exit_code': 1,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    with open(out_file, 'rb') as f:
      self.assertEqual(expected, json.load(f))

  def test_load_and_run_isolated(self):
    self.expected_requests([])
    server = 'https://localhost:1'

    def run_command(
        swarming_server, task_details, work_dir, cost_usd_hour, start,
        min_free_space):
      self.assertEqual(server, swarming_server)
      # Necessary for OSX.
      self.assertEqual(
          os.path.realpath(self.work_dir), os.path.realpath(work_dir))
      self.assertTrue(isinstance(task_details, task_runner.TaskDetails))
      self.assertEqual(3600., cost_usd_hour)
      self.assertEqual(time.time(), start)
      self.assertEqual(1, min_free_space)
      return {
        u'exit_code': 0,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': task_runner.OUT_VERSION,
      }
    self.mock(task_runner, 'run_command', run_command)

    manifest = os.path.join(self.root_dir, 'manifest')
    with open(manifest, 'wb') as f:
      data = {
        'bot_id': 'localhost',
        'command': None,
        'env': {'d': 'e'},
        'extra_args': ['foo', 'bar'],
        'grace_period': 30.,
        'hard_timeout': 10,
        'io_timeout': 11,
        'inputs_ref': {
          'isolated': '123',
          'isolatedserver': 'http://localhost:1',
          'namespace': 'default-gzip',
        },
        'task_id': 23,
      }
      json.dump(data, f)

    out_file = os.path.join(self.root_dir, 'work', 'task_runner_out.json')
    task_runner.load_and_run(manifest, server, 3600., time.time(), out_file, 1)
    expected = {
      u'exit_code': 0,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    with open(out_file, 'rb') as f:
      self.assertEqual(expected, json.load(f))

  def test_run_command_raw(self):
    # This runs the command for real.
    self.requests(cost_usd=1, exit_code=0)
    task_details = self.get_task_details('print(\'hi\')')
    expected = {
      u'exit_code': 0,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_run_command_isolated(self):
    # This runs the command for real.
    self.requests(
        cost_usd=1, exit_code=0,
        outputs_ref={
          u'isolated': u'123',
          u'isolatedserver': u'http://localhost:1',
          u'namespace': u'default-gzip',
        })
    task_details = self.get_task_details(inputs_ref={
      'isolated': '123',
      'isolatedserver': 'localhost:1',
      'namespace': 'default-gzip',
    }, extra_args=['foo', 'bar'])
    # Mock running run_isolated with a script.
    SCRIPT_ISOLATED = (
      'import json, sys;\n'
      'if len(sys.argv) != 2:\n'
      '  raise Exception(sys.argv);\n'
      'with open(sys.argv[1], \'wb\') as f:\n'
      '  json.dump({\n'
      '    \'exit_code\': 0,\n'
      '    \'had_hard_timeout\': False,\n'
      '    \'internal_failure\': None,\n'
      '    \'outputs_ref\': {\n'
      '      \'isolated\': \'123\',\n'
      '      \'isolatedserver\': \'http://localhost:1\',\n'
      '       \'namespace\': \'default-gzip\',\n'
      '    },\n'
      '  }, f)\n'
      'sys.stdout.write(\'hi\\n\')')
    self.mock(
        task_runner, 'get_isolated_cmd',
        lambda _work_dir, _details, isolated_result, min_free_space:
          [sys.executable, '-u', '-c', SCRIPT_ISOLATED, isolated_result])
    expected = {
      u'exit_code': 0,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_run_command_fail(self):
    # This runs the command for real.
    self.requests(cost_usd=10., exit_code=1)
    task_details = self.get_task_details(
        'import sys; print(\'hi\'); sys.exit(1)')
    expected = {
      u'exit_code': 1,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_run_command_os_error(self):
    # This runs the command for real.
    # OS specific error, fix expectation for other OSes.
    output = (
      'Command ""executable_that_shouldnt_be_on_your_system '
      'thus_raising_OSError"" failed to start.\n'
      'Error: [Error 2] The system cannot find the file specified'
      ) if sys.platform == 'win32' else (
      'Command ""executable_that_shouldnt_be_on_your_system '
      'thus_raising_OSError"" failed to start.\n'
      'Error: [Errno 2] No such file or directory')
    self.requests(cost_usd=10., exit_code=1, output=output)
    task_details = task_runner.TaskDetails(
        {
          'bot_id': 'localhost',
          'command': [
            'executable_that_shouldnt_be_on_your_system',
            'thus_raising_OSError',
          ],
          'env': {},
          'extra_args': [],
          'grace_period': 30.,
          'hard_timeout': 6,
          'inputs_ref': None,
          'io_timeout': 6,
          'task_id': 23,
        })
    expected = {
      u'exit_code': -1,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_run_command_large(self):
    # Method should have ""self"" as first argument - pylint: disable=E0213
    class Popen(object):
      """"""Mocks the process so we can control how data is returned.""""""
      def __init__(self2, cmd, cwd, env, stdout, stderr, stdin, detached):
        self.assertEqual(task_details.command, cmd)
        self.assertEqual(self.work_dir, cwd)
        expected_env = os.environ.copy()
        expected_env['foo'] = 'bar'
        self.assertEqual(expected_env, env)
        self.assertEqual(subprocess42.PIPE, stdout)
        self.assertEqual(subprocess42.STDOUT, stderr)
        self.assertEqual(subprocess42.PIPE, stdin)
        self.assertEqual(True, detached)
        self2._out = [
          'hi!\n',
          'hi!\n',
          'hi!\n' * 100000,
          'hi!\n',
        ]

      def yield_any(self2, maxsize, timeout):
        self.assertLess(0, maxsize)
        self.assertLess(0, timeout)
        for i in self2._out:
          yield 'stdout', i

      @staticmethod
      def wait():
        return 0

      @staticmethod
      def kill():
        self.fail()

    self.mock(subprocess42, 'Popen', Popen)

    def check_final(kwargs):
      self.assertEqual(
          {
            'data': {
              # That's because the cost includes the duration starting at start,
              # not when the process was started.
              'cost_usd': 10.,
              'duration': 0.,
              'exit_code': 0,
              'hard_timeout': False,
              'id': 'localhost',
              'io_timeout': False,
              'output': base64.b64encode('hi!\n'),
              'output_chunk_start': 100002*4,
              'task_id': 23,
            },
          },
          kwargs)

    requests = [
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        {
          'data': {
            'cost_usd': 10.,
            'id': 'localhost',
            'task_id': 23,
          },
        },
        {},
      ),
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        {
          'data': {
            'cost_usd': 10.,
            'id': 'localhost',
            'output': base64.b64encode('hi!\n' * 100002),
            'output_chunk_start': 0,
            'task_id': 23,
          },
        },
        {},
      ),
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        check_final,
        {},
      ),
    ]
    self.expected_requests(requests)
    task_details = task_runner.TaskDetails(
        {
          'bot_id': 'localhost',
          'command': ['large', 'executable'],
          'env': {'foo': 'bar'},
          'extra_args': [],
          'grace_period': 30.,
          'hard_timeout': 60,
          'inputs_ref': None,
          'io_timeout': 60,
          'task_id': 23,
        })
    expected = {
      u'exit_code': 0,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_main(self):
    def load_and_run(
        manifest, swarming_server, cost_usd_hour, start, json_file,
        min_free_space):
      self.assertEqual('foo', manifest)
      self.assertEqual('http://localhost', swarming_server)
      self.assertEqual(3600., cost_usd_hour)
      self.assertEqual(time.time(), start)
      self.assertEqual('task_summary.json', json_file)
      self.assertEqual(1, min_free_space)

    self.mock(task_runner, 'load_and_run', load_and_run)
    cmd = [
      '--swarming-server', 'http://localhost',
      '--in-file', 'foo',
      '--out-file', 'task_summary.json',
      '--cost-usd-hour', '3600',
      '--start', str(time.time()),
      '--min-free-space', '1',
    ]
    self.assertEqual(0, task_runner.main(cmd))

  def test_main_reboot(self):
    def load_and_run(
        manifest, swarming_server, cost_usd_hour, start, json_file,
        min_free_space):
      self.assertEqual('foo', manifest)
      self.assertEqual('http://localhost', swarming_server)
      self.assertEqual(3600., cost_usd_hour)
      self.assertEqual(time.time(), start)
      self.assertEqual('task_summary.json', json_file)
      self.assertEqual(1, min_free_space)

    self.mock(task_runner, 'load_and_run', load_and_run)
    cmd = [
      '--swarming-server', 'http://localhost',
      '--in-file', 'foo',
      '--out-file', 'task_summary.json',
      '--cost-usd-hour', '3600',
      '--start', str(time.time()),
      '--min-free-space', '1',
    ]
    self.assertEqual(0, task_runner.main(cmd))


class TestTaskRunnerNoTimeMock(TestTaskRunnerBase):
  # Do not mock time.time() for these tests otherwise it becomes a tricky
  # implementation detail check.
  # These test cases run the command for real.

  # TODO(maruel): Calculate this value automatically through iteration?
  SHORT_TIME_OUT = 0.3

  # Here's a simple script that handles signals properly. Sadly SIGBREAK is not
  # defined on posix.
  SCRIPT_SIGNAL = (
    'import signal, sys, time;\n'
    'l = [];\n'
    'def handler(signum, _):\n'
    '  l.append(signum);\n'
    '  print(\'got signal %%d\' %% signum);\n'
    '  sys.stdout.flush();\n'
    'signal.signal(%s, handler);\n'
    'print(\'hi\');\n'
    'sys.stdout.flush();\n'
    'while not l:\n'
    '  try:\n'
    '    time.sleep(0.01);\n'
    '  except IOError:\n'
    '    pass;\n'
    'print(\'bye\')') % (
        'signal.SIGBREAK' if sys.platform == 'win32' else 'signal.SIGTERM')

  SCRIPT_SIGNAL_HANG = (
    'import signal, sys, time;\n'
    'l = [];\n'
    'def handler(signum, _):\n'
    '  l.append(signum);\n'
    '  print(\'got signal %%d\' %% signum);\n'
    '  sys.stdout.flush();\n'
    'signal.signal(%s, handler);\n'
    'print(\'hi\');\n'
    'sys.stdout.flush();\n'
    'while not l:\n'
    '  try:\n'
    '    time.sleep(0.01);\n'
    '  except IOError:\n'
    '    pass;\n'
    'print(\'bye\');\n'
    'time.sleep(100)') % (
        'signal.SIGBREAK' if sys.platform == 'win32' else 'signal.SIGTERM')

  SCRIPT_HANG = 'import time; print(\'hi\'); time.sleep(100)'

  def get_check_final(
      self, hard_timeout=False, io_timeout=False, exit_code=None,
      output='hi\n'):
    def check_final(kwargs):
      if hard_timeout or io_timeout:
        self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('cost_usd'))
        self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('duration'))
      else:
        self.assertLess(0., kwargs['data'].pop('cost_usd'))
        self.assertLess(0., kwargs['data'].pop('duration'))
      # It makes the diffing easier.
      kwargs['data']['output'] = base64.b64decode(kwargs['data']['output'])
      self.assertEqual(
          {
            'data': {
              'exit_code': exit_code,
              'hard_timeout': hard_timeout,
              'id': 'localhost',
              'io_timeout': io_timeout,
              'output': output,
              'output_chunk_start': 0,
              'task_id': 23,
            },
          },
          kwargs)
    return check_final

  def _load_and_run(self, manifest):
    # Dot not mock time since this test class is testing timeouts.
    server = 'https://localhost:1'
    in_file = os.path.join(self.work_dir, 'task_runner_in.json')
    with open(in_file, 'wb') as f:
      json.dump(manifest, f)
    out_file = os.path.join(self.work_dir, 'task_runner_out.json')
    task_runner.load_and_run(in_file, server, 3600., time.time(), out_file, 1)
    with open(out_file, 'rb') as f:
      return json.load(f)

  def _run_command(self, task_details):
    # Dot not mock time since this test class is testing timeouts.
    server = 'https://localhost:1'
    return task_runner.run_command(
        server, task_details, self.work_dir, 3600., time.time(), 1)

  def test_hard(self):
    # Actually 0xc000013a
    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM
    self.requests(hard_timeout=True, exit_code=sig)
    task_details = self.get_task_details(
        self.SCRIPT_HANG, hard_timeout=self.SHORT_TIME_OUT)
    expected = {
      u'exit_code': sig,
      u'hard_timeout': True,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_io(self):
    # Actually 0xc000013a
    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM
    self.requests(io_timeout=True, exit_code=sig)
    task_details = self.get_task_details(
        self.SCRIPT_HANG, io_timeout=self.SHORT_TIME_OUT)
    expected = {
      u'exit_code': sig,
      u'hard_timeout': False,
      u'io_timeout': True,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_hard_signal(self):
    self.requests(
        hard_timeout=True,
        exit_code=0,
        output='hi\ngot signal %d\nbye\n' % task_runner.SIG_BREAK_OR_TERM)
    task_details = self.get_task_details(
        self.SCRIPT_SIGNAL, hard_timeout=self.SHORT_TIME_OUT)
    # Returns 0 because the process cleaned up itself.
    expected = {
      u'exit_code': 0,
      u'hard_timeout': True,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_io_signal(self):
    self.requests(
        io_timeout=True, exit_code=0,
        output='hi\ngot signal %d\nbye\n' % task_runner.SIG_BREAK_OR_TERM)
    task_details = self.get_task_details(
        self.SCRIPT_SIGNAL, io_timeout=self.SHORT_TIME_OUT)
    # Returns 0 because the process cleaned up itself.
    expected = {
      u'exit_code': 0,
      u'hard_timeout': False,
      u'io_timeout': True,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_hard_no_grace(self):
    # Actually 0xc000013a
    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM
    self.requests(hard_timeout=True, exit_code=sig)
    task_details = self.get_task_details(
        self.SCRIPT_HANG, hard_timeout=self.SHORT_TIME_OUT,
        grace_period=self.SHORT_TIME_OUT)
    expected = {
      u'exit_code': sig,
      u'hard_timeout': True,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_io_no_grace(self):
    # Actually 0xc000013a
    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM
    self.requests(io_timeout=True, exit_code=sig)
    task_details = self.get_task_details(
        self.SCRIPT_HANG, io_timeout=self.SHORT_TIME_OUT,
        grace_period=self.SHORT_TIME_OUT)
    expected = {
      u'exit_code': sig,
      u'hard_timeout': False,
      u'io_timeout': True,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_hard_signal_no_grace(self):
    exit_code = 1 if sys.platform == 'win32' else -signal.SIGKILL
    self.requests(
        hard_timeout=True, exit_code=exit_code,
        output='hi\ngot signal %d\nbye\n' % task_runner.SIG_BREAK_OR_TERM)
    task_details = self.get_task_details(
        self.SCRIPT_SIGNAL_HANG, hard_timeout=self.SHORT_TIME_OUT,
        grace_period=self.SHORT_TIME_OUT)
    # Returns 0 because the process cleaned up itself.
    expected = {
      u'exit_code': exit_code,
      u'hard_timeout': True,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_io_signal_no_grace(self):
    exit_code = 1 if sys.platform == 'win32' else -signal.SIGKILL
    self.requests(
        io_timeout=True, exit_code=exit_code,
        output='hi\ngot signal %d\nbye\n' % task_runner.SIG_BREAK_OR_TERM)
    task_details = self.get_task_details(
        self.SCRIPT_SIGNAL_HANG, io_timeout=self.SHORT_TIME_OUT,
        grace_period=self.SHORT_TIME_OUT)
    # Returns 0 because the process cleaned up itself.
    expected = {
      u'exit_code': exit_code,
      u'hard_timeout': False,
      u'io_timeout': True,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual(expected, self._run_command(task_details))

  def test_isolated_grand_children(self):
    """"""Runs a normal test involving 3 level deep subprocesses.""""""
    # Uses load_and_run()
    files = {
      'parent.py': (
        'import subprocess, sys\n'
        'sys.exit(subprocess.call([sys.executable,\'-u\',\'children.py\']))\n'),
      'children.py': (
        'import subprocess, sys\n'
        'sys.exit(subprocess.call('
            '[sys.executable, \'-u\', \'grand_children.py\']))\n'),
      'grand_children.py': 'print \'hi\'',
    }

    def check_final(kwargs):
      # Warning: this modifies input arguments.
      self.assertLess(0, kwargs['data'].pop('cost_usd'))
      self.assertLess(0, kwargs['data'].pop('bot_overhead'))
      self.assertLess(0, kwargs['data'].pop('duration'))
      self.assertLess(
          0., kwargs['data']['isolated_stats']['download'].pop('duration'))
      # duration==0 can happen on Windows when the clock is in the default
      # resolution, 15.6ms.
      self.assertLessEqual(
          0., kwargs['data']['isolated_stats']['upload'].pop('duration'))
      # Makes the diffing easier.
      kwargs['data']['output'] = base64.b64decode(kwargs['data']['output'])
      for k in ('download', 'upload'):
        for j in ('items_cold', 'items_hot'):
          kwargs['data']['isolated_stats'][k][j] = large.unpack(
              base64.b64decode(kwargs['data']['isolated_stats'][k][j]))
      self.assertEqual(
          {
            'data': {
              'exit_code': 0,
              'hard_timeout': False,
              'id': u'localhost',
              'io_timeout': False,
              'isolated_stats': {
                u'download': {
                  u'initial_number_items': 0,
                  u'initial_size': 0,
                  u'items_cold': [10, 86, 94, 276],
                  u'items_hot': [],
                },
                u'upload': {
                  u'items_cold': [],
                  u'items_hot': [],
                },
              },
              'output': 'hi\n',
              'output_chunk_start': 0,
              'task_id': 23,
            },
          },
          kwargs)
    requests = [
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        self.get_check_first(0.),
        {},
      ),
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        check_final,
        {},
      ),
    ]
    self.expected_requests(requests)

    server = isolateserver_mock.MockIsolateServer()
    try:
      isolated = json.dumps({
        'command': ['python', 'parent.py'],
        'files': {
          name: {
            'h': server.add_content_compressed('default-gzip', content),
            's': len(content),
          } for name, content in files.iteritems()
        },
      })
      isolated_digest = server.add_content_compressed('default-gzip', isolated)
      manifest = get_manifest(
          inputs_ref={
            'isolated': isolated_digest,
            'namespace': 'default-gzip',
            'isolatedserver': server.url,
          })
      expected = {
        u'exit_code': 0,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': task_runner.OUT_VERSION,
      }
      self.assertEqual(expected, self._load_and_run(manifest))
    finally:
      server.close()

  def test_isolated_io_signal_no_grace_grand_children(self):
    """"""Handles grand-children process hanging and signal management.

    In this case, the I/O timeout is implemented by task_runner. An hard timeout
    would be implemented by run_isolated (depending on overhead).
    """"""
    # Uses load_and_run()
    # https://msdn.microsoft.com/library/cc704588.aspx
    # STATUS_CONTROL_C_EXIT=0xC000013A. Python sees it as -1073741510.
    exit_code = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM

    files = {
      'parent.py': (
        'import subprocess, sys\n'
        'print(\'parent\')\n'
        'p = subprocess.Popen([sys.executable, \'-u\', \'children.py\'])\n'
        'print(p.pid)\n'
        'p.wait()\n'
        'sys.exit(p.returncode)\n'),
      'children.py': (
        'import subprocess, sys\n'
        'print(\'children\')\n'
        'p = subprocess.Popen([sys.executable,\'-u\',\'grand_children.py\'])\n'
        'print(p.pid)\n'
        'p.wait()\n'
        'sys.exit(p.returncode)\n'),
      'grand_children.py': self.SCRIPT_SIGNAL_HANG,
    }
    # We need to catch the pid of the grand children to be able to kill it, so
    # create our own check_final() instead of using self._gen_requests().
    to_kill = []
    def check_final(kwargs):
      self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('cost_usd'))
      self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('duration'))
      self.assertLess(0., kwargs['data'].pop('bot_overhead'))
      self.assertLess(
          0., kwargs['data']['isolated_stats']['download'].pop('duration'))
      self.assertLess(
          0., kwargs['data']['isolated_stats']['upload'].pop('duration'))
      # Makes the diffing easier.
      for k in ('download', 'upload'):
        for j in ('items_cold', 'items_hot'):
          kwargs['data']['isolated_stats'][k][j] = large.unpack(
              base64.b64decode(kwargs['data']['isolated_stats'][k][j]))
      # The command print the pid of this child and grand-child processes, each
      # on its line.
      output = base64.b64decode(kwargs['data'].pop('output', ''))
      for line in output.splitlines():
        try:
          to_kill.append(int(line))
        except ValueError:
          pass
      self.assertEqual(
          {
            'data': {
              'exit_code': exit_code,
              'hard_timeout': False,
              'id': u'localhost',
              'io_timeout': True,
              'isolated_stats': {
                u'download': {
                  u'initial_number_items': 0,
                  u'initial_size': 0,
                  u'items_cold': [144, 150, 285, 307],
                  u'items_hot': [],
                },
                u'upload': {
                  u'items_cold': [],
                  u'items_hot': [],
                },
              },
              'output_chunk_start': 0,
              'task_id': 23,
            },
          },
          kwargs)
    requests = [
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        self.get_check_first(0.),
        {},
      ),
      (
        'https://localhost:1/swarming/api/v1/bot/task_update/23',
        check_final,
        {},
      ),
    ]
    self.expected_requests(requests)

    server = isolateserver_mock.MockIsolateServer()
    try:
      # TODO(maruel): -u is needed if you don't want python buffering to
      # interfere.
      isolated = json.dumps({
        'command': ['python', '-u', 'parent.py'],
        'files': {
          name: {
            'h': server.add_content_compressed('default-gzip', content),
            's': len(content),
          } for name, content in files.iteritems()
        },
      })
      isolated_digest = server.add_content_compressed('default-gzip', isolated)
      try:
        manifest = get_manifest(
            inputs_ref={
              'isolated': isolated_digest,
              'namespace': 'default-gzip',
              'isolatedserver': server.url,
            },
            # TODO(maruel): A bit cheezy, we'd want the I/O timeout to be just
            # enough to have the time for the PID to be printed but not more.
            io_timeout=1,
            grace_period=self.SHORT_TIME_OUT)
        expected = {
          u'exit_code': exit_code,
          u'hard_timeout': False,
          u'io_timeout': True,
          u'must_signal_internal_failure': None,
          u'version': task_runner.OUT_VERSION,
        }
        self.assertEqual(expected, self._load_and_run(manifest))
        self.assertEqual(2, len(to_kill))
      finally:
        for k in to_kill:
          try:
            if sys.platform == 'win32':
              os.kill(k, signal.SIGTERM)
            else:
              os.kill(k, signal.SIGKILL)
          except OSError:
            pass
    finally:
      server.close()


class TaskRunnerSmoke(unittest.TestCase):
  # Runs a real process and a real Swarming fake server.
  def setUp(self):
    super(TaskRunnerSmoke, self).setUp()
    self.root_dir = tempfile.mkdtemp(prefix='task_runner')
    logging.info('Temp: %s', self.root_dir)
    self._server = fake_swarming.Server(self)

  def tearDown(self):
    try:
      self._server.shutdown()
    finally:
      try:
        file_path.rmtree(self.root_dir)
      except OSError:
        print >> sys.stderr, 'Failed to delete %s' % self.root_dir
      finally:
        super(TaskRunnerSmoke, self).tearDown()

  def test_signal(self):
    # Tests when task_runner gets a SIGTERM.

    # https://msdn.microsoft.com/library/cc704588.aspx
    # STATUS_ENTRYPOINT_NOT_FOUND=0xc0000139. Python sees it as -1073741510.
    exit_code = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM

    os.mkdir(os.path.join(self.root_dir, 'work'))
    signal_file = os.path.join(self.root_dir, 'work', 'signal')
    open(signal_file, 'wb').close()
    manifest = get_manifest(
        script='import os,time;os.remove(%r);time.sleep(60)' % signal_file,
        hard_timeout=60., io_timeout=60.)
    task_in_file = os.path.join(self.root_dir, 'task_runner_in.json')
    task_result_file = os.path.join(self.root_dir, 'task_runner_out.json')
    with open(task_in_file, 'wb') as f:
      json.dump(manifest, f)
    bot = os.path.join(self.root_dir, 'swarming_bot.1.zip')
    code, _ = fake_swarming.gen_zip(self._server.url)
    with open(bot, 'wb') as f:
      f.write(code)
    cmd = [
      sys.executable, bot, 'task_runner',
      '--swarming-server', self._server.url,
      '--in-file', task_in_file,
      '--out-file', task_result_file,
      '--cost-usd-hour', '1',
      # Include the time taken to poll the task in the cost.
      '--start', str(time.time()),
    ]
    logging.info('%s', cmd)
    proc = subprocess42.Popen(cmd, cwd=self.root_dir, detached=True)
    # Wait for the child process to be alive.
    while os.path.isfile(signal_file):
      time.sleep(0.01)
    # Send SIGTERM to task_runner itself. Ensure the right thing happen.
    # Note that on Windows, this is actually sending a SIGBREAK since there's no
    # such thing as SIGTERM.
    proc.send_signal(signal.SIGTERM)
    proc.wait()
    task_runner_log = os.path.join(self.root_dir, 'logs', 'task_runner.log')
    with open(task_runner_log, 'rb') as f:
      logging.info('task_runner.log:\n---\n%s---', f.read())
    expected = {
      u'exit_code': 0,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure': None,
      u'version': task_runner.OUT_VERSION,
    }
    self.assertEqual([], self._server.get_events())
    tasks = self._server.get_tasks()
    for task in tasks.itervalues():
      for event in task:
        event.pop('cost_usd')
        event.pop('duration', None)
        event.pop('bot_overhead', None)
    expected = {
      '23': [
        {
          u'id': u'localhost',
          u'task_id': 23,
        },
        {
          u'exit_code': exit_code,
          u'hard_timeout': False,
          u'id': u'localhost',
          u'io_timeout': False,
          u'task_id': 23,
        },
      ],
    }
    self.assertEqual(expected, tasks)
    expected = {
      'swarming_bot.1.zip',
      '4e019f31778ba7191f965469dc673280386bbd60-cacert.pem',
      'work',
      'logs',
      # TODO(maruel): Move inside work.
      'task_runner_in.json',
      'task_runner_out.json',
    }
    self.assertEqual(expected, set(os.listdir(self.root_dir)))
    expected = {
      u'exit_code': exit_code,
      u'hard_timeout': False,
      u'io_timeout': False,
      u'must_signal_internal_failure':
          u'task_runner received signal %d' % task_runner.SIG_BREAK_OR_TERM,
      u'version': 3,
    }
    with open(task_result_file, 'rb') as f:
      self.assertEqual(expected, json.load(f))
    self.assertEqual(0, proc.returncode)


if __name__ == '__main__':
  fix_encoding.fix_encoding()
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  logging_utils.prepare_logging(None)
  logging_utils.set_console_level(
      logging.DEBUG if '-v' in sys.argv else logging.CRITICAL+1)
  # Fix litteral text expectation.
  os.environ['LANG'] = 'en_US.UTF-8'
  os.environ['LANGUAGE'] = 'en_US.UTF-8'
  unittest.main()
/n/n/nappengine/swarming/swarming_bot/bot_code/xsrf_client.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Wraps URL requests with an XSRF token using components/auth based service.""""""

import datetime
import logging
import os
import sys

THIS_DIR = os.path.dirname(os.path.abspath(__file__))

sys.path.insert(0, os.path.join(THIS_DIR, 'third_party'))

from utils import net


class Error(Exception):
  pass


def _utcnow():
  """"""So it can be mocked.""""""
  return datetime.datetime.utcnow()


class XsrfRemote(object):
  """"""Transparently adds XSRF token to requests.""""""
  TOKEN_RESOURCE = '/auth/api/v1/accounts/self/xsrf_token'

  def __init__(self, url, token_resource=None):
    self.url = url.rstrip('/')
    self.token = None
    self.token_resource = token_resource or self.TOKEN_RESOURCE
    self.expiration = None
    self.xsrf_request_params = {}

  def url_read(self, resource, **kwargs):
    url = self.url + resource
    if kwargs.get('data') == None:
      # No XSRF token for GET.
      return net.url_read(url, **kwargs)

    if self.need_refresh():
      self.refresh_token()
    resp = self._url_read_post(url, **kwargs)
    if resp is None:
      raise Error('Failed to connect to %s; %s' % (url, self.expiration))
    return resp

  def url_read_json(self, resource, **kwargs):
    url = self.url + resource
    if kwargs.get('data') == None:
      # No XSRF token required for GET.
      return net.url_read_json(url, **kwargs)

    if self.need_refresh():
      self.refresh_token()
    resp = self._url_read_json_post(url, **kwargs)
    if resp is None:
      raise Error('Failed to connect to %s; %s' % (url, self.expiration))
    return resp

  def refresh_token(self):
    """"""Returns a fresh token. Necessary as the token may expire after an hour.
    """"""
    url = self.url + self.token_resource
    resp = net.url_read_json(
        url,
        headers={'X-XSRF-Token-Request': '1'},
        data=self.xsrf_request_params)
    if resp is None:
      raise Error('Failed to connect to %s' % url)
    self.token = resp['xsrf_token']
    if resp.get('expiration_sec'):
      exp = resp['expiration_sec']
      exp -= min(round(exp * 0.1), 600)
      self.expiration = _utcnow() + datetime.timedelta(seconds=exp)
    return self.token

  def need_refresh(self):
    """"""Returns True if the XSRF token needs to be refreshed.""""""
    return (
        not self.token or (self.expiration and self.expiration <= _utcnow()))

  def _url_read_post(self, url, **kwargs):
    headers = (kwargs.pop('headers', None) or {}).copy()
    headers['X-XSRF-Token'] = self.token
    return net.url_read(url, headers=headers, **kwargs)

  def _url_read_json_post(self, url, **kwargs):
    headers = (kwargs.pop('headers', None) or {}).copy()
    headers['X-XSRF-Token'] = self.token
    return net.url_read_json(url, headers=headers, **kwargs)
/n/n/nappengine/swarming/swarming_bot/bot_code/xsrf_client_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import datetime
import logging
import os
import sys
import time
import unittest

import test_env_bot_code
test_env_bot_code.setup_test_env()

# Creates a server mock for functions in net.py.
import net_utils

import xsrf_client


class UrlHelperTest(net_utils.TestCase):
  def setUp(self):
    super(UrlHelperTest, self).setUp()
    self.mock(logging, 'error', lambda *_: None)
    self.mock(logging, 'exception', lambda *_: None)
    self.mock(logging, 'info', lambda *_: None)
    self.mock(logging, 'warning', lambda *_: None)
    self.mock(time, 'sleep', lambda _: None)

  def testXsrfRemoteGET(self):
    self.expected_requests([('http://localhost/a', {}, 'foo', None)])

    remote = xsrf_client.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a'))

  def testXsrfRemoteSimple(self):
    self.expected_requests(
        [
          (
            'http://localhost/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {
              'expiration_sec': 100,
              'xsrf_token': 'token',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},
            'foo',
            None,
          ),
        ])

    remote = xsrf_client.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))

  def testXsrfRemoteRefresh(self):
    self.expected_requests(
        [
          (
            'http://localhost/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {
              'expiration_sec': 100,
              'xsrf_token': 'token',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},
            'bar',
            None,
          ),
          (
            'http://localhost/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {
              'expiration_sec': 100,
              'xsrf_token': 'token2',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token2'}},
            'foo',
            None,
          ),
        ])

    now = xsrf_client._utcnow()
    remote = xsrf_client.XsrfRemote('http://localhost/')
    remote.url_read('/a', data={'foo': 'bar'})
    self.mock(
        xsrf_client, '_utcnow', lambda: now + datetime.timedelta(seconds=91))
    remote.url_read('/a', data={'foo': 'bar'})

  def testXsrfRemoteCustom(self):
    # Use the new swarming bot API as an example of custom XSRF request handler.
    self.expected_requests(
        [
          (
            'http://localhost/swarming/api/v1/bot/handshake',
            {
              'data': {'attributes': 'b'},
              'headers': {'X-XSRF-Token-Request': '1'},
            },
            {
              'expiration_sec': 100,
              'ignored': True,
              'xsrf_token': 'token',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},
            'foo',
            None,
          ),
        ])

    remote = xsrf_client.XsrfRemote(
        'http://localhost/',
        '/swarming/api/v1/bot/handshake')
    remote.xsrf_request_params = {'attributes': 'b'}
    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))


if __name__ == '__main__':
  logging.basicConfig(level=logging.ERROR)
  unittest.main()
/n/n/nclient/tests/net_utils.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """"""Returns HttpResponse with predefined content, useful in tests.""""""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """"""Mocks out url_open() calls.""""""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """"""Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """"""
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s %s' % (url, kwargs))
/n/n/n",0
83,c23a5bf6278f55b3f8135e0edab9927599a09236,"/appengine/swarming/handlers_bot.py/n/n# Copyright 2015 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Internal bot API handlers.""""""

import base64
import json
import logging
import textwrap

import webob
import webapp2

from google.appengine.api import app_identity
from google.appengine.api import datastore_errors
from google.appengine.datastore import datastore_query
from google.appengine import runtime
from google.appengine.ext import ndb

from components import auth
from components import ereporter2
from components import utils
from server import acl
from server import bot_code
from server import bot_management
from server import stats
from server import task_pack
from server import task_request
from server import task_result
from server import task_scheduler
from server import task_to_run


def has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):
  """"""Returns an error if unexpected keys are present or expected keys are
  missing.

  Accepts optional keys.

  This is important to catch typos.
  """"""
  actual_keys = frozenset(actual_keys)
  superfluous = actual_keys - expected_keys
  missing = minimum_keys - actual_keys
  if superfluous or missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    msg_superfluous = (
        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')
    return 'Unexpected %s%s%s; did you make a typo?' % (
        name, msg_missing, msg_superfluous)


def has_unexpected_keys(expected_keys, actual_keys, name):
  """"""Return an error if unexpected keys are present or expected keys are
  missing.
  """"""
  return has_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, name)


def log_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, request, source, name):
  """"""Logs an error if unexpected keys are present or expected keys are missing.

  Accepts optional keys.

  This is important to catch typos.
  """"""
  message = has_unexpected_subset_keys(
    expected_keys, minimum_keys, actual_keys, name)
  if message:
    ereporter2.log_request(request, source=source, message=message)
  return message


def log_unexpected_keys(expected_keys, actual_keys, request, source, name):
  """"""Logs an error if unexpected keys are present or expected keys are missing.
  """"""
  return log_unexpected_subset_keys(
      expected_keys, expected_keys, actual_keys, request, source, name)


def has_missing_keys(minimum_keys, actual_keys, name):
  """"""Returns an error if expected keys are not present.

  Do not warn about unexpected keys.
  """"""
  actual_keys = frozenset(actual_keys)
  missing = minimum_keys - actual_keys
  if missing:
    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''
    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)


class BootstrapHandler(auth.AuthenticatingHandler):
  """"""Returns python code to run to bootstrap a swarming bot.""""""

  @auth.require(acl.is_bot)
  def get(self):
    self.response.headers['Content-Type'] = 'text/x-python'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename=""swarming_bot_bootstrap.py""')
    self.response.out.write(
        bot_code.get_bootstrap(self.request.host_url).content)


class BotCodeHandler(auth.AuthenticatingHandler):
  """"""Returns a zip file with all the files required by a bot.

  Optionally specify the hash version to download. If so, the returned data is
  cacheable.
  """"""

  @auth.require(acl.is_bot)
  def get(self, version=None):
    if version:
      expected = bot_code.get_bot_version(self.request.host_url)
      if version != expected:
        # This can happen when the server is rapidly updated.
        logging.error('Requested Swarming bot %s, have %s', version, expected)
        self.abort(404)
      self.response.headers['Cache-Control'] = 'public, max-age=3600'
    else:
      self.response.headers['Cache-Control'] = 'no-cache, no-store'
    self.response.headers['Content-Type'] = 'application/octet-stream'
    self.response.headers['Content-Disposition'] = (
        'attachment; filename=""swarming_bot.zip""')
    self.response.out.write(
        bot_code.get_swarming_bot_zip(self.request.host_url))


class _BotBaseHandler(auth.ApiHandler):
  """"""
  Request body is a JSON dict:
    {
      ""dimensions"": <dict of properties>,
      ""state"": <dict of properties>,
      ""version"": <sha-1 of swarming_bot.zip uncompressed content>,
    }
  """"""

  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}
  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  def _process(self):
    """"""Returns True if the bot has invalid parameter and should be automatically
    quarantined.

    Does one DB synchronous GET.

    Returns:
      tuple(request, bot_id, version, state, dimensions, quarantined_msg)
    """"""
    request = self.parse_body()
    version = request.get('version', None)

    dimensions = request.get('dimensions', {})
    state = request.get('state', {})
    bot_id = None
    if dimensions.get('id'):
      dimension_id = dimensions['id']
      if (isinstance(dimension_id, list) and len(dimension_id) == 1
          and isinstance(dimension_id[0], unicode)):
        bot_id = dimensions['id'][0]

    # The bot may decide to ""self-quarantine"" itself. Accept both via
    # dimensions or via state. See bot_management._BotCommon.quarantined for
    # more details.
    if (bool(dimensions.get('quarantined')) or
        bool(state.get('quarantined'))):
      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'

    quarantined_msg = None
    # Use a dummy 'for' to be able to break early from the block.
    for _ in [0]:

      quarantined_msg = has_unexpected_keys(
          self.EXPECTED_KEYS, request, 'keys')
      if quarantined_msg:
        break

      quarantined_msg = has_missing_keys(
          self.REQUIRED_STATE_KEYS, state, 'state')
      if quarantined_msg:
        break

      if not bot_id:
        quarantined_msg = 'Missing bot id'
        break

      if not all(
          isinstance(key, unicode) and
          isinstance(values, list) and
          all(isinstance(value, unicode) for value in values)
          for key, values in dimensions.iteritems()):
        quarantined_msg = (
            'Invalid dimensions type:\n%s' % json.dumps(dimensions,
              sort_keys=True, indent=2, separators=(',', ': ')))
        break

      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)
      if dimensions_count > task_to_run.MAX_DIMENSIONS:
        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count
        break

      if not isinstance(
          state.get('lease_expiration_ts'), (None.__class__, int)):
        quarantined_msg = (
            'lease_expiration_ts (%r) must be int or None' % (
                state['lease_expiration_ts']))
        break

    if quarantined_msg:
      line = 'Quarantined Bot\nhttps://%s/restricted/bot/%s\n%s' % (
          app_identity.get_default_version_hostname(), bot_id,
          quarantined_msg)
      ereporter2.log_request(self.request, source='bot', message=line)
      return request, bot_id, version, state, dimensions, quarantined_msg

    # Look for admin enforced quarantine.
    bot_settings = bot_management.get_settings_key(bot_id).get()
    if bool(bot_settings and bot_settings.quarantined):
      return request, bot_id, version, state, dimensions, 'Quarantined by admin'

    return request, bot_id, version, state, dimensions, None


class BotHandshakeHandler(_BotBaseHandler):
  """"""First request to be called to get initial data like XSRF token.

  The bot is server-controled so the server doesn't have to support multiple API
  version. When running a task, the bot sync the the version specific URL. Once
  abot finished its currently running task, it'll be immediately be upgraded
  after on its next poll.

  This endpoint does not return commands to the bot, for example to upgrade
  itself. It'll be told so when it does its first poll.

  Response body is a JSON dict:
    {
      ""bot_version"": <sha-1 of swarming_bot.zip uncompressed content>,
      ""server_version"": ""138-193f1f3"",
      ""xsrf_token"": ""......"",
    }
  """"""

  # This handler is called to get XSRF token, there's nothing to enforce yet.
  xsrf_token_enforce_on = ()

  @auth.require_xsrf_token_request
  @auth.require(acl.is_bot)
  def post(self):
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    bot_management.bot_event(
        event_type='bot_connected', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=dimensions,
        state=state, version=version, quarantined=bool(quarantined_msg),
        task_id='', task_name=None, message=quarantined_msg)

    data = {
      # This access token will be used to validate each subsequent request.
      'bot_version': bot_code.get_bot_version(self.request.host_url),
      'expiration_sec': auth.handler.XSRFToken.expiration_sec,
      'server_version': utils.get_app_version(),
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.send_response(data)


class BotPollHandler(_BotBaseHandler):
  """"""The bot polls for a task; returns either a task, update command or sleep.

  In case of exception on the bot, this is enough to get it just far enough to
  eventually self-update to a working version. This is to ensure that coding
  errors in bot code doesn't kill all the fleet at once, they should still be up
  just enough to be able to self-update again even if they don't get task
  assigned anymore.
  """"""

  @auth.require(acl.is_bot)
  def post(self):
    """"""Handles a polling request.

    Be very permissive on missing values. This can happen because of errors
    on the bot, *we don't want to deny them the capacity to update*, so that the
    bot code is eventually fixed and the bot self-update to this working code.

    It makes recovery of the fleet in case of catastrophic failure much easier.
    """"""
    (_request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    sleep_streak = state.get('sleep_streak', 0)
    quarantined = bool(quarantined_msg)

    # Note bot existence at two places, one for stats at 1 minute resolution,
    # the other for the list of known bots.
    action = 'bot_inactive' if quarantined else 'bot_active'
    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)

    def bot_event(event_type, task_id=None, task_name=None):
      bot_management.bot_event(
          event_type=event_type, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=dimensions,
          state=state, version=version, quarantined=quarantined,
          task_id=task_id, task_name=task_name, message=quarantined_msg)

    # Bot version is host-specific because the host URL is embedded in
    # swarming_bot.zip
    expected_version = bot_code.get_bot_version(self.request.host_url)
    if version != expected_version:
      bot_event('request_update')
      self._cmd_update(expected_version)
      return
    if quarantined:
      bot_event('request_sleep')
      self._cmd_sleep(sleep_streak, quarantined)
      return

    #
    # At that point, the bot should be in relatively good shape since it's
    # running the right version. It is still possible that invalid code was
    # pushed to the server, so be diligent about it.
    #

    # Bot may need a reboot if it is running for too long. We do not reboot
    # quarantined bots.
    needs_restart, restart_message = bot_management.should_restart_bot(
        bot_id, state)
    if needs_restart:
      bot_event('request_restart')
      self._cmd_restart(restart_message)
      return

    # The bot is in good shape. Try to grab a task.
    try:
      # This is a fairly complex function call, exceptions are expected.
      request, run_result = task_scheduler.bot_reap_task(
          dimensions, bot_id, version, state.get('lease_expiration_ts'))
      if not request:
        # No task found, tell it to sleep a bit.
        bot_event('request_sleep')
        self._cmd_sleep(sleep_streak, quarantined)
        return

      try:
        # This part is tricky since it intentionally runs a transaction after
        # another one.
        if request.properties.is_terminate:
          bot_event('bot_terminate', task_id=run_result.task_id)
          self._cmd_terminate(run_result.task_id)
        else:
          bot_event(
              'request_task', task_id=run_result.task_id,
              task_name=request.name)
          self._cmd_run(request, run_result.key, bot_id)
      except:
        logging.exception('Dang, exception after reaping')
        raise
    except runtime.DeadlineExceededError:
      # If the timeout happened before a task was assigned there is no problems.
      # If the timeout occurred after a task was assigned, that task will
      # timeout (BOT_DIED) since the bot didn't get the details required to
      # run it) and it will automatically get retried (TODO) when the task times
      # out.
      # TODO(maruel): Note the task if possible and hand it out on next poll.
      # https://code.google.com/p/swarming/issues/detail?id=130
      self.abort(500, 'Deadline')

  def _cmd_run(self, request, run_result_key, bot_id):
    cmd = None
    if request.properties.commands:
      cmd = request.properties.commands[0]
    elif request.properties.command:
      cmd = request.properties.command
    out = {
      'cmd': 'run',
      'manifest': {
        'bot_id': bot_id,
        'command': cmd,
        'dimensions': request.properties.dimensions,
        'env': request.properties.env,
        'extra_args': request.properties.extra_args,
        'grace_period': request.properties.grace_period_secs,
        'hard_timeout': request.properties.execution_timeout_secs,
        'host': utils.get_versioned_hosturl(),
        'io_timeout': request.properties.io_timeout_secs,
        'inputs_ref': request.properties.inputs_ref,
        'task_id': task_pack.pack_run_result_key(run_result_key),
      },
    }
    self.send_response(utils.to_json_encodable(out))

  def _cmd_sleep(self, sleep_streak, quarantined):
    out = {
      'cmd': 'sleep',
      'duration': task_scheduler.exponential_backoff(sleep_streak),
      'quarantined': quarantined,
    }
    self.send_response(out)

  def _cmd_terminate(self, task_id):
    out = {
      'cmd': 'terminate',
      'task_id': task_id,
    }
    self.send_response(out)

  def _cmd_update(self, expected_version):
    out = {
      'cmd': 'update',
      'version': expected_version,
    }
    self.send_response(out)

  def _cmd_restart(self, message):
    logging.info('Rebooting bot: %s', message)
    out = {
      'cmd': 'restart',
      'message': message,
    }
    self.send_response(out)


class BotEventHandler(_BotBaseHandler):
  """"""On signal that a bot had an event worth logging.""""""

  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}

  @auth.require(acl.is_bot)
  def post(self):
    (request, bot_id, version, state,
        dimensions, quarantined_msg) = self._process()
    event = request.get('event')
    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):
      self.abort_with_error(400, error='Unsupported event type')
    message = request.get('message')
    bot_management.bot_event(
        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,
        dimensions=dimensions, state=state, version=version,
        quarantined=bool(quarantined_msg), task_id=None, task_name=None,
        message=message)

    if event == 'bot_error':
      line = (
          'Bot: https://%s/restricted/bot/%s\n'
          'Bot error:\n'
          '%s') % (
          app_identity.get_default_version_hostname(), bot_id, message)
      ereporter2.log_request(self.request, source='bot', message=line)
    self.send_response({})


class BotTaskUpdateHandler(auth.ApiHandler):
  """"""Receives updates from a Bot for a task.

  The handler verifies packets are processed in order and will refuse
  out-of-order packets.
  """"""
  ACCEPTED_KEYS = {
    u'bot_overhead', u'cost_usd', u'duration', u'exit_code',
    u'hard_timeout', u'id', u'io_timeout', u'isolated_stats', u'output',
    u'output_chunk_start', u'outputs_ref', u'task_id',
  }
  REQUIRED_KEYS = {u'id', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    # Unlike handshake and poll, we do not accept invalid keys here. This code
    # path is much more strict.
    request = self.parse_body()
    msg = log_unexpected_subset_keys(
        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',
        'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    bot_id = request['id']
    cost_usd = request['cost_usd']
    task_id = request['task_id']

    bot_overhead = request.get('bot_overhead')
    duration = request.get('duration')
    exit_code = request.get('exit_code')
    hard_timeout = request.get('hard_timeout')
    io_timeout = request.get('io_timeout')
    isolated_stats = request.get('isolated_stats')
    output = request.get('output')
    output_chunk_start = request.get('output_chunk_start')
    outputs_ref = request.get('outputs_ref')

    if bool(isolated_stats) != (bot_overhead is not None):
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % task_id)
      self.abort_with_error(
          400,
          error='Both bot_overhead and isolated_stats must be set '
                'simultaneously\nbot_overhead: %s\nisolated_stats: %s' %
                (bot_overhead, isolated_stats))

    run_result_key = task_pack.unpack_run_result_key(task_id)
    performance_stats = None
    if isolated_stats:
      download = isolated_stats['download']
      upload = isolated_stats['upload']
      performance_stats = task_result.PerformanceStats(
          bot_overhead=bot_overhead,
          isolated_download=task_result.IsolatedOperation(
              duration=download['duration'],
              initial_number_items=download['initial_number_items'],
              initial_size=download['initial_size'],
              items_cold=base64.b64decode(download['items_cold']),
              items_hot=base64.b64decode(download['items_hot'])),
          isolated_upload=task_result.IsolatedOperation(
              duration=upload['duration'],
              items_cold=base64.b64decode(upload['items_cold']),
              items_hot=base64.b64decode(upload['items_hot'])))

    if output is not None:
      try:
        output = base64.b64decode(output)
      except UnicodeEncodeError as e:
        logging.error('Failed to decode output\n%s\n%r', e, output)
        output = output.encode('ascii', 'replace')
      except TypeError as e:
        # Save the output as-is instead. The error will be logged in ereporter2
        # and returning a HTTP 500 would only force the bot to stay in a retry
        # loop.
        logging.error('Failed to decode output\n%s\n%r', e, output)
    if outputs_ref:
      outputs_ref = task_request.FilesRef(**outputs_ref)

    try:
      state = task_scheduler.bot_update_task(
          run_result_key=run_result_key,
          bot_id=bot_id,
          output=output,
          output_chunk_start=output_chunk_start,
          exit_code=exit_code,
          duration=duration,
          hard_timeout=hard_timeout,
          io_timeout=io_timeout,
          cost_usd=cost_usd,
          outputs_ref=outputs_ref,
          performance_stats=performance_stats)
      if not state:
        logging.info('Failed to update, please retry')
        self.abort_with_error(500, error='Failed to update, please retry')

      if state in (task_result.State.COMPLETED, task_result.State.TIMED_OUT):
        action = 'task_completed'
      else:
        assert state == task_result.State.RUNNING, state
        action = 'task_update'
      bot_management.bot_event(
          event_type=action, bot_id=bot_id,
          external_ip=self.request.remote_addr, dimensions=None, state=None,
          version=None, quarantined=None, task_id=task_id, task_name=None)
    except ValueError as e:
      ereporter2.log_request(
          request=self.request,
          source='server',
          category='task_failure',
          message='Failed to update task: %s' % e)
      self.abort_with_error(400, error=str(e))
    except webob.exc.HTTPException:
      raise
    except Exception as e:
      logging.exception('Internal error: %s', e)
      self.abort_with_error(500, error=str(e))

    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot
    # reboots itself to abort the task abruptly. It is useful when a task hangs
    # and the timeout was set too long or the task was superseded by a newer
    # task with more recent executable (e.g. a new Try Server job on a newer
    # patchset on Rietveld).
    self.send_response({'ok': True})


class BotTaskErrorHandler(auth.ApiHandler):
  """"""It is a specialized version of ereporter2's /ereporter2/api/v1/on_error
  that also attaches a task id to it.

  This formally kills the task, marking it as an internal failure. This can be
  used by bot_main.py to kill the task when task_runner misbehaved.
  """"""

  EXPECTED_KEYS = {u'id', u'message', u'task_id'}

  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.
  xsrf_token_enforce_on = ()

  @auth.require(acl.is_bot)
  def post(self, task_id=None):
    request = self.parse_body()
    bot_id = request.get('id')
    task_id = request.get('task_id', '')
    message = request.get('message', 'unknown')

    bot_management.bot_event(
        event_type='task_error', bot_id=bot_id,
        external_ip=self.request.remote_addr, dimensions=None, state=None,
        version=None, quarantined=None, task_id=task_id, task_name=None,
        message=message)
    line = (
        'Bot: https://%s/restricted/bot/%s\n'
        'Task failed: https://%s/user/task/%s\n'
        '%s') % (
        app_identity.get_default_version_hostname(), bot_id,
        app_identity.get_default_version_hostname(), task_id,
        message)
    ereporter2.log_request(self.request, source='bot', message=line)

    msg = log_unexpected_keys(
        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')
    if msg:
      self.abort_with_error(400, error=msg)

    msg = task_scheduler.bot_kill_task(
        task_pack.unpack_run_result_key(task_id), bot_id)
    if msg:
      logging.error(msg)
      self.abort_with_error(400, error=msg)
    self.send_response({})


class ServerPingHandler(webapp2.RequestHandler):
  """"""Handler to ping when checking if the server is up.

  This handler should be extremely lightweight. It shouldn't do any
  computations, it should just state that the server is up. It's open to
  everyone for simplicity and performance.
  """"""

  def get(self):
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.out.write('Server up')


def get_routes():
  routes = [
      ('/bootstrap', BootstrapHandler),
      ('/bot_code', BotCodeHandler),
      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),
      ('/swarming/api/v1/bot/event', BotEventHandler),
      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),
      ('/swarming/api/v1/bot/poll', BotPollHandler),
      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),
      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',
          BotTaskUpdateHandler),
      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),
      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',
          BotTaskErrorHandler),
  ]
  return [webapp2.Route(*i) for i in routes]
/n/n/n/appengine/swarming/server/bot_archive.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Generates the swarming_bot.zip archive for the bot.

Unlike the other source files, this file can be run from ../tools/bot_archive.py
stand-alone to generate a swarming_bot.zip for local testing so it doesn't
import anything from the AppEngine SDK.

The hash of the content of the files in the archive is used to define the
current version of the swarming bot code.
""""""

import hashlib
import json
import logging
import os
import StringIO
import zipfile


# List of files needed by the swarming bot.
# TODO(maruel): Make the list automatically generated?
FILES = (
    '__main__.py',
    'api/__init__.py',
    'api/bot.py',
    'api/parallel.py',
    'api/os_utilities.py',
    'api/platforms/__init__.py',
    'api/platforms/android.py',
    'api/platforms/common.py',
    'api/platforms/gce.py',
    'api/platforms/linux.py',
    'api/platforms/osx.py',
    'api/platforms/posix.py',
    'api/platforms/win.py',
    'bot_code/__init__.py',
    'bot_code/bot_main.py',
    'bot_code/common.py',
    'bot_code/singleton.py',
    'bot_code/task_runner.py',
    'bot_code/xsrf_client.py',
    'client/auth.py',
    'client/isolated_format.py',
    'client/isolateserver.py',
    'client/run_isolated.py',
    'config/__init__.py',
    'third_party/__init__.py',
    'third_party/colorama/__init__.py',
    'third_party/colorama/ansi.py',
    'third_party/colorama/ansitowin32.py',
    'third_party/colorama/initialise.py',
    'third_party/colorama/win32.py',
    'third_party/colorama/winterm.py',
    'third_party/depot_tools/__init__.py',
    'third_party/depot_tools/fix_encoding.py',
    'third_party/depot_tools/subcommand.py',
    'third_party/httplib2/__init__.py',
    'third_party/httplib2/cacerts.txt',
    'third_party/httplib2/iri2uri.py',
    'third_party/httplib2/socks.py',
    'third_party/oauth2client/__init__.py',
    'third_party/oauth2client/_helpers.py',
    'third_party/oauth2client/_openssl_crypt.py',
    'third_party/oauth2client/_pycrypto_crypt.py',
    'third_party/oauth2client/client.py',
    'third_party/oauth2client/clientsecrets.py',
    'third_party/oauth2client/crypt.py',
    'third_party/oauth2client/file.py',
    'third_party/oauth2client/gce.py',
    'third_party/oauth2client/keyring_storage.py',
    'third_party/oauth2client/locked_file.py',
    'third_party/oauth2client/multistore_file.py',
    'third_party/oauth2client/service_account.py',
    'third_party/oauth2client/tools.py',
    'third_party/oauth2client/util.py',
    'third_party/oauth2client/xsrfutil.py',
    'third_party/pyasn1/pyasn1/__init__.py',
    'third_party/pyasn1/pyasn1/codec/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/__init__.py',
    'third_party/pyasn1/pyasn1/codec/ber/decoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/encoder.py',
    'third_party/pyasn1/pyasn1/codec/ber/eoo.py',
    'third_party/pyasn1/pyasn1/codec/cer/__init__.py',
    'third_party/pyasn1/pyasn1/codec/cer/decoder.py',
    'third_party/pyasn1/pyasn1/codec/cer/encoder.py',
    'third_party/pyasn1/pyasn1/codec/der/__init__.py',
    'third_party/pyasn1/pyasn1/codec/der/decoder.py',
    'third_party/pyasn1/pyasn1/codec/der/encoder.py',
    'third_party/pyasn1/pyasn1/compat/__init__.py',
    'third_party/pyasn1/pyasn1/compat/binary.py',
    'third_party/pyasn1/pyasn1/compat/octets.py',
    'third_party/pyasn1/pyasn1/debug.py',
    'third_party/pyasn1/pyasn1/error.py',
    'third_party/pyasn1/pyasn1/type/__init__.py',
    'third_party/pyasn1/pyasn1/type/base.py',
    'third_party/pyasn1/pyasn1/type/char.py',
    'third_party/pyasn1/pyasn1/type/constraint.py',
    'third_party/pyasn1/pyasn1/type/error.py',
    'third_party/pyasn1/pyasn1/type/namedtype.py',
    'third_party/pyasn1/pyasn1/type/namedval.py',
    'third_party/pyasn1/pyasn1/type/tag.py',
    'third_party/pyasn1/pyasn1/type/tagmap.py',
    'third_party/pyasn1/pyasn1/type/univ.py',
    'third_party/pyasn1/pyasn1/type/useful.py',
    'third_party/requests/__init__.py',
    'third_party/requests/adapters.py',
    'third_party/requests/api.py',
    'third_party/requests/auth.py',
    'third_party/requests/certs.py',
    'third_party/requests/compat.py',
    'third_party/requests/cookies.py',
    'third_party/requests/exceptions.py',
    'third_party/requests/hooks.py',
    'third_party/requests/models.py',
    'third_party/requests/packages/__init__.py',
    'third_party/requests/packages/urllib3/__init__.py',
    'third_party/requests/packages/urllib3/_collections.py',
    'third_party/requests/packages/urllib3/connection.py',
    'third_party/requests/packages/urllib3/connectionpool.py',
    'third_party/requests/packages/urllib3/contrib/__init__.py',
    'third_party/requests/packages/urllib3/contrib/ntlmpool.py',
    'third_party/requests/packages/urllib3/contrib/pyopenssl.py',
    'third_party/requests/packages/urllib3/exceptions.py',
    'third_party/requests/packages/urllib3/fields.py',
    'third_party/requests/packages/urllib3/filepost.py',
    'third_party/requests/packages/urllib3/packages/__init__.py',
    'third_party/requests/packages/urllib3/packages/ordered_dict.py',
    'third_party/requests/packages/urllib3/packages/six.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '__init__.py',
    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'
        '_implementation.py',
    'third_party/requests/packages/urllib3/poolmanager.py',
    'third_party/requests/packages/urllib3/request.py',
    'third_party/requests/packages/urllib3/response.py',
    'third_party/requests/packages/urllib3/util/__init__.py',
    'third_party/requests/packages/urllib3/util/connection.py',
    'third_party/requests/packages/urllib3/util/request.py',
    'third_party/requests/packages/urllib3/util/response.py',
    'third_party/requests/packages/urllib3/util/retry.py',
    'third_party/requests/packages/urllib3/util/ssl_.py',
    'third_party/requests/packages/urllib3/util/timeout.py',
    'third_party/requests/packages/urllib3/util/url.py',
    'third_party/requests/sessions.py',
    'third_party/requests/status_codes.py',
    'third_party/requests/structures.py',
    'third_party/requests/utils.py',
    'third_party/rsa/rsa/__init__.py',
    'third_party/rsa/rsa/_compat.py',
    'third_party/rsa/rsa/_version133.py',
    'third_party/rsa/rsa/_version200.py',
    'third_party/rsa/rsa/asn1.py',
    'third_party/rsa/rsa/bigfile.py',
    'third_party/rsa/rsa/cli.py',
    'third_party/rsa/rsa/common.py',
    'third_party/rsa/rsa/core.py',
    'third_party/rsa/rsa/key.py',
    'third_party/rsa/rsa/parallel.py',
    'third_party/rsa/rsa/pem.py',
    'third_party/rsa/rsa/pkcs1.py',
    'third_party/rsa/rsa/prime.py',
    'third_party/rsa/rsa/randnum.py',
    'third_party/rsa/rsa/transform.py',
    'third_party/rsa/rsa/util.py',
    'third_party/rsa/rsa/varblock.py',
    'third_party/six/__init__.py',
    'utils/__init__.py',
    'utils/cacert.pem',
    'utils/file_path.py',
    'utils/fs.py',
    'utils/large.py',
    'utils/logging_utils.py',
    'utils/lru.py',
    'utils/net.py',
    'utils/oauth.py',
    'utils/on_error.py',
    'utils/subprocess42.py',
    'utils/threading_utils.py',
    'utils/tools.py',
    'utils/zip_package.py',
    'adb/__init__.py',
    'adb/adb_commands.py',
    'adb/adb_protocol.py',
    'adb/common.py',
    'adb/contrib/__init__.py',
    'adb/contrib/adb_commands_safe.py',
    'adb/contrib/high.py',
    'adb/contrib/parallel.py',
    'adb/fastboot.py',
    'adb/filesync_protocol.py',
    'adb/sign_pythonrsa.py',
    'adb/usb_exceptions.py',
    'python_libusb1/__init__.py',
    'python_libusb1/libusb1.py',
    'python_libusb1/usb1.py',
)


def is_windows():
  """"""Returns True if this code is running under Windows.""""""
  return os.__file__[0] != '/'


def resolve_symlink(path):
  """"""Processes path containing symlink on Windows.

  This is needed to make ../swarming_bot/main_test.py pass on Windows because
  git on Windows renders symlinks as normal files.
  """"""
  if not is_windows():
    # Only does this dance on Windows.
    return path
  parts = os.path.normpath(path).split(os.path.sep)
  for i in xrange(2, len(parts)):
    partial = os.path.sep.join(parts[:i])
    if os.path.isfile(partial):
      with open(partial) as f:
        link = f.read()
      assert '\n' not in link and link, link
      parts[i-1] = link
  return os.path.normpath(os.path.sep.join(parts))


def yield_swarming_bot_files(root_dir, host, host_version, additionals):
  """"""Yields all the files to map as tuple(filename, content).

  config.json is injected with json data about the server.

  This function guarantees that the output is sorted by filename.
  """"""
  items = {i: None for i in FILES}
  items.update(additionals)
  config = {
    'server': host.rstrip('/'),
    'server_version': host_version,
  }
  items['config/config.json'] = json.dumps(config)
  for item, content in sorted(items.iteritems()):
    if content is not None:
      yield item, content
    else:
      with open(resolve_symlink(os.path.join(root_dir, item)), 'rb') as f:
        yield item, f.read()


def get_swarming_bot_zip(root_dir, host, host_version, additionals):
  """"""Returns a zipped file of all the files a bot needs to run.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: dict(filepath: content) of additional items to put into the zip
        file, in addition to FILES and MAPPED. In practice, it's going to be a
        custom bot_config.py.
  Returns:
    Tuple(str being the zipped file's content, bot version (SHA-1) it
    represents).
  """"""
  zip_memory_file = StringIO.StringIO()
  h = hashlib.sha1()
  with zipfile.ZipFile(zip_memory_file, 'w', zipfile.ZIP_DEFLATED) as zip_file:
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      zip_file.writestr(name, content)
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)

  data = zip_memory_file.getvalue()
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_zip(%s) is %d bytes; %s',
      additionals.keys(), len(data), bot_version)
  return data, bot_version


def get_swarming_bot_version(root_dir, host, host_version, additionals):
  """"""Returns the SHA1 hash of the bot code, representing the version.

  Arguments:
    root_dir: directory swarming_bot.
    additionals: See get_swarming_bot_zip's doc.

  Returns:
    The SHA1 hash of the bot code.
  """"""
  h = hashlib.sha1()
  try:
    # TODO(maruel): Deduplicate from zip_package.genereate_version().
    for name, content in yield_swarming_bot_files(
        root_dir, host, host_version, additionals):
      h.update(str(len(name)))
      h.update(name)
      h.update(str(len(content)))
      h.update(content)
  except IOError:
    logging.warning('Missing expected file. Hash will be invalid.')
  bot_version = h.hexdigest()
  logging.info(
      'get_swarming_bot_version(%s) = %s', sorted(additionals), bot_version)
  return bot_version
/n/n/n/appengine/swarming/swarming_bot/__main__.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Runs either task_runner.py, bot_main.py or bot_config.py.

The imports are done late so if an ImportError occurs, it is localized to this
command only.
""""""

import code
import json
import logging
import os
import optparse
import shutil
import sys
import zipfile

from bot_code import common

# That's from ../../../client/
from third_party.depot_tools import fix_encoding
from utils import logging_utils
from utils import zip_package

# This file can only be run as a zip.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# libusb1 expects to be directly in sys.path.
sys.path.insert(0, os.path.join(THIS_FILE, 'python_libusb1'))


# TODO(maruel): Use depot_tools/subcommand.py. The goal here is to have all the
# sub commands packed into the single .zip file as a swiss army knife (think
# busybox but worse).


def CMDattributes(_args):
  """"""Prints out the bot's attributes.""""""
  from bot_code import bot_main
  json.dump(
      bot_main.get_attributes(bot_main.get_bot()), sys.stdout, indent=2,
      sort_keys=True, separators=(',', ': '))
  print('')
  return 0


def CMDconfig(_args):
  """"""Prints the config.json embedded in this zip.""""""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  json.dump(bot_main.get_config(), sys.stdout, indent=2, sort_keys=True)
  print('')
  return 0


def CMDis_fine(_args):
  """"""Just reports that the code doesn't throw.

  That ensures that the bot has minimal viability before transfering control to
  it. For now, it just imports bot_main but later it'll check the config, etc.
  """"""
  # pylint: disable=unused-variable
  from bot_code import bot_main
  from config import bot_config
  # We're #goodenough.
  return 0


def CMDrestart(_args):
  """"""Utility subcommand that hides the difference between each OS to reboot
  the host.""""""
  logging_utils.prepare_logging(None)
  import os_utilities
  # This function doesn't return.
  os_utilities.restart()
  # Should never reach here.
  return 1


def CMDrun_isolated(args):
  """"""Internal command to run an isolated command.""""""
  sys.path.insert(0, os.path.join(THIS_FILE, 'client'))
  # run_isolated setups logging by itself.
  import run_isolated
  return run_isolated.main(args)


def CMDsetup(_args):
  """"""Setup the bot to auto-start but doesn't start the bot.""""""
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))
  from bot_code import bot_main
  bot_main.setup_bot(True)
  return 0


def CMDserver(_args):
  """"""Prints the server url. It's like 'config' but easier to parse.""""""
  logging_utils.prepare_logging(None)
  from bot_code import bot_main
  print bot_main.get_config()['server']
  return 0


def CMDshell(args):
  """"""Starts a shell with api.* in..""""""
  logging_utils.prepare_logging(None)
  logging_utils.set_console_level(logging.DEBUG)

  from bot_code import bot_main
  from api import os_utilities
  from api import platforms
  local_vars = {
    'bot_main': bot_main,
    'json': json,
    'os_utilities': os_utilities,
    'platforms': platforms,
  }
  # Can't use: from api.platforms import *
  local_vars.update(
      (k, v) for k, v in platforms.__dict__.iteritems()
      if not k.startswith('_'))

  if args:
    for arg in args:
      exec code.compile_command(arg) in local_vars
  else:
    code.interact(
        'Locals:\n  ' + '\n  '.join( sorted(local_vars)), None, local_vars)
  return 0


def CMDstart_bot(args):
  """"""Starts the swarming bot.""""""
  logging_utils.prepare_logging(os.path.join('logs', 'swarming_bot.log'))
  logging.info(
      'importing bot_main: %s, %s', THIS_FILE, zip_package.generate_version())
  from bot_code import bot_main
  result = bot_main.main(args)
  logging.info('bot_main exit code: %d', result)
  return result


def CMDstart_slave(args):
  """"""Ill named command that actually sets up the bot then start it.""""""
  # TODO(maruel): Rename function.
  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))

  parser = optparse.OptionParser()
  parser.add_option(
      '--survive', action='store_true',
      help='Do not reboot the host even if bot_config.setup_bot() asked to')
  options, args = parser.parse_args(args)

  try:
    from bot_code import bot_main
    bot_main.setup_bot(options.survive)
  except Exception:
    logging.exception('bot_main.py failed.')

  logging.info('Starting the bot: %s', THIS_FILE)
  return common.exec_python([THIS_FILE, 'start_bot'])


def CMDtask_runner(args):
  """"""Internal command to run a swarming task.""""""
  logging_utils.prepare_logging(os.path.join('logs', 'task_runner.log'))
  from bot_code import task_runner
  return task_runner.main(args)


def CMDversion(_args):
  """"""Prints the version of this file and the hash of the code.""""""
  logging_utils.prepare_logging(None)
  print zip_package.generate_version()
  return 0


def main():
  if os.getenv('CHROME_REMOTE_DESKTOP_SESSION') == '1':
    # Disable itself when run under Google Chrome Remote Desktop, as it's
    # normally started at the console and starting up via Remote Desktop would
    # cause multiple bots to run concurrently on the host.
    print >> sys.stderr, (
        'Inhibiting Swarming bot under Google Chrome Remote Desktop.')
    return 0

  # Always make the current working directory the directory containing this
  # file. It simplifies assumptions.
  os.chdir(os.path.dirname(THIS_FILE))
  # Always create the logs dir first thing, before printing anything out.
  if not os.path.isdir('logs'):
    os.mkdir('logs')

  # This is necessary so os.path.join() works with unicode path. No kidding.
  # This must be done here as each of the command take wildly different code
  # path and this must be run in every case, as it causes really unexpected
  # issues otherwise, especially in module os.path.
  fix_encoding.fix_encoding()

  if os.path.basename(THIS_FILE) == 'swarming_bot.zip':
    # Self-replicate itself right away as swarming_bot.1.zip and restart as it.
    print >> sys.stderr, 'Self replicating pid:%d.' % os.getpid()
    if os.path.isfile('swarming_bot.1.zip'):
      os.remove('swarming_bot.1.zip')
    shutil.copyfile('swarming_bot.zip', 'swarming_bot.1.zip')
    cmd = ['swarming_bot.1.zip'] + sys.argv[1:]
    print >> sys.stderr, 'cmd: %s' % cmd
    return common.exec_python(cmd)

  # sys.argv[0] is the zip file itself.
  cmd = 'start_slave'
  args = []
  if len(sys.argv) > 1:
    cmd = sys.argv[1]
    args = sys.argv[2:]

  fn = getattr(sys.modules[__name__], 'CMD%s' % cmd, None)
  if fn:
    try:
      return fn(args)
    except ImportError:
      logging.exception('Failed to run %s', cmd)
      with zipfile.ZipFile(THIS_FILE, 'r') as f:
        logging.error('Files in %s:\n%s', THIS_FILE, f.namelist())
      return 1

  print >> sys.stderr, 'Unknown command %s' % cmd
  return 1


if __name__ == '__main__':
  sys.exit(main())
/n/n/n/appengine/swarming/swarming_bot/api/bot.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Bot interface used in bot_config.py.""""""

import logging
import os
import threading
import time

import os_utilities
from utils import zip_package

THIS_FILE = os.path.abspath(zip_package.get_main_script_path())

# Method could be a function - pylint: disable=R0201


class Bot(object):
  def __init__(
      self, remote, attributes, server, server_version, base_dir,
      shutdown_hook):
    # Do not expose attributes nor remote for now, as attributes will be
    # refactored soon and remote would have a lot of side effects if used by
    # bot_config.
    self._attributes = attributes
    self._base_dir = base_dir
    self._remote = remote
    self._server = server
    self._server_version = server_version
    self._shutdown_hook = shutdown_hook
    self._timers = []
    self._timers_dying = False
    self._timers_lock = threading.Lock()

  @property
  def base_dir(self):
    """"""Returns the working directory.

    It is normally the current workind directory, e.g. os.getcwd() but it is
    preferable to not assume that.
    """"""
    return self._base_dir

  @property
  def dimensions(self):
    """"""The bot's current dimensions.

    Dimensions are relatively static and not expected to change much. They
    should change only when it effectively affects the bot's capacity to execute
    tasks.
    """"""
    return self._attributes.get('dimensions', {}).copy()

  @property
  def id(self):
    """"""Returns the bot's ID.""""""
    return self.dimensions.get('id', ['unknown'])[0]

  @property
  def remote(self):
    """"""XsrfClient instance to talk to the server.

    Should not be normally used by bot_config.py for now.
    """"""
    return self._remote

  @property
  def server(self):
    """"""URL of the swarming server this bot is connected to.

    It includes the https:// prefix but without trailing /, so it looks like
    ""https://foo-bar.appspot.com"".
    """"""
    return self._server

  @property
  def server_version(self):
    """"""Version of the server's implementation.

    The form is nnn-hhhhhhh for pristine version and nnn-hhhhhhh-tainted-uuuu
    for non-upstreamed code base:
      nnn: revision pseudo number
      hhhhhhh: git commit hash
      uuuu: username
    """"""
    return self._server_version

  @property
  def state(self):
    return self._attributes['state']

  @property
  def swarming_bot_zip(self):
    """"""Absolute path to the swarming_bot.zip file.

    The bot itself is run as swarming_bot.1.zip or swarming_bot.2.zip. Always
    return swarming_bot.zip since this is the script that must be used when
    starting up.
    """"""
    return os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')

  def post_event(self, event_type, message):
    """"""Posts an event to the server.""""""
    data = self._attributes.copy()
    data['event'] = event_type
    data['message'] = message
    self._remote.url_read_json('/swarming/api/v1/bot/event', data=data)

  def post_error(self, message):
    """"""Posts given string as a failure.

    This is used in case of internal code error. It traps exception.
    """"""
    logging.error('Error: %s\n%s', self._attributes, message)
    try:
      self.post_event('bot_error', message)
    except Exception:
      logging.exception('post_error(%s) failed.', message)

  def restart(self, message):
    """"""Reboots the machine.

    If the reboot is successful, never returns: the process should just be
    killed by OS.

    If reboot fails, logs the error to the server and moves the bot to
    quarantined mode.
    """"""
    self.post_event('bot_rebooting', message)
    self.cancel_all_timers()
    if self._shutdown_hook:
      try:
        self._shutdown_hook(self)
      except Exception as e:
        logging.exception('shutdown hook failed: %s', e)
    # os_utilities.restart should never return, unless restart is not happening.
    # If restart is taking longer than N minutes, it probably not going to
    # finish at all. Report this to the server.
    try:
      os_utilities.restart(message, timeout=15*60)
    except LookupError:
      # This is a special case where OSX is deeply hosed. In that case the disk
      # is likely in read-only mode and there isn't much that can be done. This
      # exception is deep inside pickle.py. So notify the server then hang in
      # there.
      self.post_error('This host partition is bad; please fix the host')
      while True:
        time.sleep(1)
    self.post_error('Bot is stuck restarting for: %s' % message)

  def call_later(self, delay_sec, callback):
    """"""Schedules a function to be called later (if bot is still running).

    All calls are executed in a separate internal thread, be careful with what
    you call from there (Bot object is generally not thread safe).

    Multiple callbacks can be executed concurrently. It is safe to call
    'call_later' from the callback.
    """"""
    timer = None

    def call_wrapper():
      with self._timers_lock:
        # Canceled already?
        if timer not in self._timers:
          return
        self._timers.remove(timer)
      try:
        callback()
      except Exception:
        logging.exception('Timer callback failed')

    with self._timers_lock:
      if not self._timers_dying:
        timer = threading.Timer(delay_sec, call_wrapper)
        self._timers.append(timer)
        timer.daemon = True
        timer.start()

  def cancel_all_timers(self):
    """"""Cancels all pending 'call_later' calls and forbids adding new ones.""""""
    timers = None
    with self._timers_lock:
      self._timers_dying = True
      for t in self._timers:
        t.cancel()
      timers, self._timers = self._timers, []
    for t in timers:
      t.join(timeout=5)
      if t.isAlive():
        logging.error('Timer thread did not terminate fast enough: %s', t)

  def update_dimensions(self, new_dimensions):
    """"""Called internally to update Bot.dimensions.""""""
    self._attributes['dimensions'] = new_dimensions

  def update_state(self, new_state):
    """"""Called internally to update Bot.state.""""""
    self._attributes['state'] = new_state
/n/n/n/appengine/swarming/swarming_bot/api/bot_test.py/n/n#!/usr/bin/env python
# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import os
import sys
import unittest
import threading

THIS_FILE = os.path.abspath(__file__)

import test_env_api
test_env_api.setup_test_env()

import bot


class TestBot(unittest.TestCase):
  def test_bot(self):
    obj = bot.Bot(
        None,
        {'dimensions': {'foo': 'bar'}},
        'https://localhost:1/',
        '1234-1a2b3c4-tainted-joe',
        'base_dir',
        None)
    self.assertEqual({'foo': 'bar'}, obj.dimensions)
    self.assertEqual(
        os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip'),
        obj.swarming_bot_zip)
    self.assertEqual('1234-1a2b3c4-tainted-joe', obj.server_version)
    self.assertEqual('base_dir', obj.base_dir)

  def test_bot_call_later(self):
    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',
                  'base_dir', None)
    ev = threading.Event()
    obj.call_later(0.001, ev.set)
    self.assertTrue(ev.wait(1))

  def test_bot_call_later_cancel(self):
    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',
                  'base_dir', None)
    ev = threading.Event()
    obj.call_later(0.1, ev.set)
    obj.cancel_all_timers()
    self.assertFalse(ev.wait(0.3))


if __name__ == '__main__':
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  unittest.main()
/n/n/n/appengine/swarming/swarming_bot/bot_code/bot_main_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import json
import logging
import os
import shutil
import sys
import tempfile
import threading
import time
import unittest
import zipfile

import test_env_bot_code
test_env_bot_code.setup_test_env()

# Creates a server mock for functions in net.py.
import net_utils

import bot_main
import xsrf_client
from api import bot
from api import os_utilities
from depot_tools import fix_encoding
from utils import file_path
from utils import logging_utils
from utils import net
from utils import subprocess42
from utils import zip_package


# Access to a protected member XX of a client class - pylint: disable=W0212


class TestBotMain(net_utils.TestCase):
  maxDiff = 2000

  def setUp(self):
    super(TestBotMain, self).setUp()
    os.environ.pop('SWARMING_LOAD_TEST', None)
    self.root_dir = tempfile.mkdtemp(prefix='bot_main')
    self.old_cwd = os.getcwd()
    os.chdir(self.root_dir)
    # __main__ does it for us.
    os.mkdir('logs')
    self.server = xsrf_client.XsrfRemote('https://localhost:1/')
    self.attributes = {
      'dimensions': {
        'foo': ['bar'],
        'id': ['localhost'],
        'pool': ['default'],
      },
      'state': {
        'cost_usd_hour': 3600.,
      },
      'version': '123',
    }
    self.mock(zip_package, 'generate_version', lambda: '123')
    self.bot = bot.Bot(
        self.server, self.attributes, 'https://localhost:1/', 'version1',
        self.root_dir, self.fail)
    self.mock(self.bot, 'post_error', self.fail)
    self.mock(self.bot, 'restart', self.fail)
    self.mock(subprocess42, 'call', self.fail)
    self.mock(time, 'time', lambda: 100.)
    config_path = os.path.join(
        test_env_bot_code.BOT_DIR, 'config', 'config.json')
    with open(config_path, 'rb') as f:
      config = json.load(f)
    self.mock(bot_main, 'get_config', lambda: config)
    self.mock(
        bot_main, 'THIS_FILE',
        os.path.join(test_env_bot_code.BOT_DIR, 'swarming_bot.zip'))

  def tearDown(self):
    os.environ.pop('SWARMING_BOT_ID', None)
    os.chdir(self.old_cwd)
    file_path.rmtree(self.root_dir)
    super(TestBotMain, self).tearDown()

  def test_get_dimensions(self):
    dimensions = set(bot_main.get_dimensions(None))
    dimensions.discard('hidpi')
    dimensions.discard('zone')  # Only set on GCE bots.
    expected = {'cores', 'cpu', 'gpu', 'id', 'machine_type', 'os', 'pool'}
    self.assertEqual(expected, dimensions)

  def test_get_dimensions_load_test(self):
    os.environ['SWARMING_LOAD_TEST'] = '1'
    self.assertEqual(['id', 'load_test'], sorted(bot_main.get_dimensions(None)))

  def test_generate_version(self):
    self.assertEqual('123', bot_main.generate_version())

  def test_get_state(self):
    self.mock(time, 'time', lambda: 126.0)
    expected = os_utilities.get_state()
    expected['sleep_streak'] = 12
    # During the execution of this test case, the free disk space could have
    # changed.
    for disk in expected['disks'].itervalues():
      self.assertGreater(disk.pop('free_mb'), 1.)
    actual = bot_main.get_state(None, 12)
    for disk in actual['disks'].itervalues():
      self.assertGreater(disk.pop('free_mb'), 1.)
    self.assertGreater(actual.pop('nb_files_in_temp'), 0)
    self.assertGreater(expected.pop('nb_files_in_temp'), 0)
    self.assertGreater(actual.pop('uptime'), 0)
    self.assertGreater(expected.pop('uptime'), 0)
    self.assertEqual(sorted(expected.pop('temp', {})),
                     sorted(actual.pop('temp', {})))
    self.assertEqual(expected, actual)

  def test_setup_bot(self):
    self.mock(bot_main, 'get_remote', lambda: self.server)
    setup_bots = []
    def setup_bot(_bot):
      setup_bots.append(1)
      return False
    from config import bot_config
    self.mock(bot_config, 'setup_bot', setup_bot)
    restarts = []
    post_event = []
    self.mock(
        os_utilities, 'restart', lambda *a, **kw: restarts.append((a, kw)))
    self.mock(
        bot.Bot, 'post_event', lambda *a, **kw: post_event.append((a, kw)))
    self.expected_requests([])
    bot_main.setup_bot(False)
    expected = [
      (('Starting new swarming bot: %s' % bot_main.THIS_FILE,),
        {'timeout': 900}),
    ]
    self.assertEqual(expected, restarts)
    # It is called twice, one as part of setup_bot(False), another as part of
    # on_shutdown_hook().
    self.assertEqual([1, 1], setup_bots)
    expected = [
      'Starting new swarming bot: %s' % bot_main.THIS_FILE,
      'Bot is stuck restarting for: Starting new swarming bot: %s' %
        bot_main.THIS_FILE,
    ]
    self.assertEqual(expected, [i[0][2] for i in post_event])

  def test_post_error_task(self):
    self.mock(time, 'time', lambda: 126.0)
    self.mock(logging, 'error', lambda *_, **_kw: None)
    self.mock(bot_main, 'get_remote', lambda: self.server)
    # get_state() return value changes over time. Hardcode its value for the
    # duration of this test.
    self.mock(os_utilities, 'get_state', lambda : {'foo': 'bar'})
    expected_attribs = bot_main.get_attributes(None)
    self.expected_requests(
        [
          (
            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',
            {
              'data': expected_attribs,
              'headers': {'X-XSRF-Token-Request': '1'},
            },
            {'xsrf_token': 'token'},
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/task_error/23',
            {
              'data': {
                'id': expected_attribs['dimensions']['id'][0],
                'message': 'error',
                'task_id': 23,
              },
              'headers': {'X-XSRF-Token': 'token'},
            },
            {},
          ),
        ])
    botobj = bot_main.get_bot()
    bot_main.post_error_task(botobj, 'error', 23)

  def test_run_bot(self):
    # Test the run_bot() loop. Does not use self.bot.
    self.mock(time, 'time', lambda: 126.0)
    class Foo(Exception):
      pass

    def poll_server(botobj, _):
      sleep_streak = botobj.state['sleep_streak']
      self.assertEqual(botobj.remote, self.server)
      if sleep_streak == 5:
        raise Exception('Jumping out of the loop')
      return False
    self.mock(bot_main, 'poll_server', poll_server)

    def post_error(botobj, e):
      self.assertEqual(self.server, botobj._remote)
      lines = e.splitlines()
      self.assertEqual('Jumping out of the loop', lines[0])
      self.assertEqual('Traceback (most recent call last):', lines[1])
      raise Foo('Necessary to get out of the loop')
    self.mock(bot.Bot, 'post_error', post_error)

    self.mock(bot_main, 'get_remote', lambda: self.server)

    # Method should have ""self"" as first argument - pylint: disable=E0213
    # pylint: disable=unused-argument
    class Popen(object):
      def __init__(
          self2, cmd, detached, cwd, stdout, stderr, stdin, close_fds):
        self2.returncode = None
        expected = [sys.executable, bot_main.THIS_FILE, 'run_isolated']
        self.assertEqual(expected, cmd[:len(expected)])
        self.assertEqual(True, detached)
        self.assertEqual(subprocess42.PIPE, stdout)
        self.assertEqual(subprocess42.STDOUT, stderr)
        self.assertEqual(subprocess42.PIPE, stdin)
        self.assertEqual(sys.platform != 'win32', close_fds)

      def communicate(self2, i):
        self.assertEqual(None, i)
        self2.returncode = 0
        return '', None
    self.mock(subprocess42, 'Popen', Popen)

    self.expected_requests(
        [
          (
            'https://localhost:1/swarming/api/v1/bot/server_ping',
            {}, 'foo', None,
          ),
        ])

    with self.assertRaises(Foo):
      bot_main.run_bot(None)
    self.assertEqual(
        os_utilities.get_hostname_short(), os.environ['SWARMING_BOT_ID'])

  def test_poll_server_sleep(self):
    slept = []
    bit = threading.Event()
    self.mock(bit, 'wait', slept.append)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', self.fail)

    self.expected_requests(
        [
          (
            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {'xsrf_token': 'token'},
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {
              'data': self.attributes,
              'headers': {'X-XSRF-Token': 'token'},
            },
            {
              'cmd': 'sleep',
              'duration': 1.24,
            },
          ),
        ])
    self.assertFalse(bot_main.poll_server(self.bot, bit))
    self.assertEqual([1.24], slept)

  def test_poll_server_run(self):
    manifest = []
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', lambda *args: manifest.append(args))
    self.mock(bot_main, 'update_bot', self.fail)

    self.expected_requests(
        [
          (
            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {'xsrf_token': 'token'},
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {
              'data': self.bot._attributes,
              'headers': {'X-XSRF-Token': 'token'},
            },
            {
              'cmd': 'run',
              'manifest': {'foo': 'bar'},
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))
    expected = [(self.bot, {'foo': 'bar'}, time.time())]
    self.assertEqual(expected, manifest)

  def test_poll_server_update(self):
    update = []
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', lambda *args: update.append(args))

    self.expected_requests(
        [
          (
            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {'xsrf_token': 'token'},
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {
              'data': self.attributes,
              'headers': {'X-XSRF-Token': 'token'},
            },
            {
              'cmd': 'update',
              'version': '123',
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))
    self.assertEqual([(self.bot, '123')], update)

  def test_poll_server_restart(self):
    restart = []
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', self.fail)
    self.mock(self.bot, 'restart', lambda *args: restart.append(args))

    self.expected_requests(
        [
          (
            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {'xsrf_token': 'token'},
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {
              'data': self.attributes,
              'headers': {'X-XSRF-Token': 'token'},
            },
            {
              'cmd': 'restart',
              'message': 'Please die now',
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))
    self.assertEqual([('Please die now',)], restart)

  def test_poll_server_restart_load_test(self):
    os.environ['SWARMING_LOAD_TEST'] = '1'
    bit = threading.Event()
    self.mock(bit, 'wait', self.fail)
    self.mock(bot_main, 'run_manifest', self.fail)
    self.mock(bot_main, 'update_bot', self.fail)
    self.mock(self.bot, 'restart', self.fail)

    self.expected_requests(
        [
          (
            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {'xsrf_token': 'token'},
          ),
          (
            'https://localhost:1/swarming/api/v1/bot/poll',
            {
              'data': self.attributes,
              'headers': {'X-XSRF-Token': 'token'},
            },
            {
              'cmd': 'restart',
              'message': 'Please die now',
            },
          ),
        ])
    self.assertTrue(bot_main.poll_server(self.bot, bit))

  def _mock_popen(self, returncode=0, exit_code=0, url='https://localhost:1'):
    result = {
      'exit_code': exit_code,
      'must_signal_internal_failure': None,
      'version': 3,
    }
    # Method should have ""self"" as first argument - pylint: disable=E0213
    class Popen(object):
      def __init__(
          self2, cmd, detached, cwd, env, stdout, stderr, stdin, close_fds):
        self2.returncode = None
        self2._out_file = os.path.join(
            self.root_dir, 'work', 'task_runner_out.json')
        expected = [
          sys.executable, bot_main.THIS_FILE, 'task_runner',
          '--swarming-server', url,
          '--in-file',
          os.path.join(self.root_dir, 'work', 'task_runner_in.json'),
          '--out-file', self2._out_file,
          '--cost-usd-hour', '3600.0', '--start', '100.0',
          '--min-free-space',
          str(int(
            (os_utilities.get_min_free_space(bot_main.THIS_FILE) + 250.) *
            1024 * 1024)),
        ]
        self.assertEqual(expected, cmd)
        self.assertEqual(True, detached)
        self.assertEqual(self.bot.base_dir, cwd)
        self.assertEqual('24', env['SWARMING_TASK_ID'])
        self.assertTrue(stdout)
        self.assertEqual(subprocess42.STDOUT, stderr)
        self.assertEqual(subprocess42.PIPE, stdin)
        self.assertEqual(sys.platform != 'win32', close_fds)

      def wait(self2, timeout=None): # pylint: disable=unused-argument
        self2.returncode = returncode
        with open(self2._out_file, 'wb') as f:
          json.dump(result, f)
        return 0

    self.mock(subprocess42, 'Popen', Popen)
    return result

  def test_run_manifest(self):
    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))
    def call_hook(botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(self.attributes['dimensions'], botobj.dimensions)
        self.assertEqual(False, failure)
        self.assertEqual(False, internal_failure)
        self.assertEqual({'os': 'Amiga', 'pool': 'default'}, dimensions)
        self.assertEqual(result, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    result = self._mock_popen(url='https://localhost:3')

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'os': 'Amiga', 'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'host': 'https://localhost:3',
      'task_id': '24',
    }
    self.assertEqual(self.root_dir, self.bot.base_dir)
    bot_main.run_manifest(self.bot, manifest, time.time())

  def test_run_manifest_task_failure(self):
    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))
    def call_hook(_botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(True, failure)
        self.assertEqual(False, internal_failure)
        self.assertEqual({'pool': 'default'}, dimensions)
        self.assertEqual(result, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    result = self._mock_popen(exit_code=1)

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'io_timeout': 60,
      'task_id': '24',
    }
    bot_main.run_manifest(self.bot, manifest, time.time())

  def test_run_manifest_internal_failure(self):
    posted = []
    self.mock(bot_main, 'post_error_task', lambda *args: posted.append(args))
    def call_hook(_botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(False, failure)
        self.assertEqual(True, internal_failure)
        self.assertEqual({'pool': 'default'}, dimensions)
        self.assertEqual(result, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    result = self._mock_popen(returncode=1)

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'io_timeout': 60,
      'task_id': '24',
    }
    bot_main.run_manifest(self.bot, manifest, time.time())
    expected = [(self.bot, 'Execution failed: internal error (1).', '24')]
    self.assertEqual(expected, posted)

  def test_run_manifest_exception(self):
    posted = []
    def post_error_task(botobj, msg, task_id):
      posted.append((botobj, msg.splitlines()[0], task_id))
    self.mock(bot_main, 'post_error_task', post_error_task)
    def call_hook(_botobj, name, *args):
      if name == 'on_after_task':
        failure, internal_failure, dimensions, summary = args
        self.assertEqual(False, failure)
        self.assertEqual(True, internal_failure)
        self.assertEqual({'pool': 'default'}, dimensions)
        self.assertEqual({}, summary)
    self.mock(bot_main, 'call_hook', call_hook)
    def raiseOSError(*_a, **_k):
      raise OSError('Dang')
    self.mock(subprocess42, 'Popen', raiseOSError)

    manifest = {
      'command': ['echo', 'hi'],
      'dimensions': {'pool': 'default'},
      'grace_period': 30,
      'hard_timeout': 60,
      'task_id': '24',
    }
    bot_main.run_manifest(self.bot, manifest, time.time())
    expected = [(self.bot, 'Internal exception occured: Dang', '24')]
    self.assertEqual(expected, posted)

  def test_update_bot(self):
    # In a real case 'update_bot' never exits and doesn't call 'post_error'.
    # Under the test however forever-blocking calls finish, and post_error is
    # called.
    self.mock(self.bot, 'post_error', lambda *_: None)
    # Mock the file to download in the temporary directory.
    self.mock(
        bot_main, 'THIS_FILE',
        os.path.join(self.root_dir, 'swarming_bot.1.zip'))
    new_zip = os.path.join(self.root_dir, 'swarming_bot.2.zip')
    # This is necessary otherwise zipfile will crash.
    self.mock(time, 'time', lambda: 1400000000)
    def url_retrieve(f, url):
      self.assertEqual(
          'https://localhost:1/swarming/api/v1/bot/bot_code/123', url)
      self.assertEqual(new_zip, f)
      # Create a valid zip that runs properly.
      with zipfile.ZipFile(f, 'w') as z:
        z.writestr('__main__.py', 'print(""hi"")')
      return True
    self.mock(net, 'url_retrieve', url_retrieve)

    calls = []
    def exec_python(args):
      calls.append(args)
      return 23
    self.mock(bot_main.common, 'exec_python', exec_python)

    with self.assertRaises(SystemExit) as e:
      bot_main.update_bot(self.bot, '123')
    self.assertEqual(23, e.exception.code)

    self.assertEqual([[new_zip, 'start_slave', '--survive']], calls)

  def test_main(self):
    def check(x):
      self.assertEqual(logging.WARNING, x)
    self.mock(logging_utils, 'set_console_level', check)

    def run_bot(error):
      self.assertEqual(None, error)
      return 0
    self.mock(bot_main, 'run_bot', run_bot)

    class Singleton(object):
      # pylint: disable=no-self-argument
      def acquire(self2):
        return True
      def release(self2):
        self.fail()
    self.mock(bot_main, 'SINGLETON', Singleton())

    self.assertEqual(0, bot_main.main([]))


if __name__ == '__main__':
  fix_encoding.fix_encoding()
  if '-v' in sys.argv:
    unittest.TestCase.maxDiff = None
  logging.basicConfig(
      level=logging.DEBUG if '-v' in sys.argv else logging.CRITICAL)
  unittest.main()
/n/n/n/appengine/swarming/swarming_bot/bot_code/task_runner.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Runs a Swarming task.

Downloads all the necessary files to run the task, executes the command and
streams results back to the Swarming server.

The process exit code is 0 when the task was executed, even if the task itself
failed. If there's any failure in the setup or teardown, like invalid packet
response, failure to contact the server, etc, a non zero exit code is used. It's
up to the calling process (bot_main.py) to signal that there was an internal
failure and to cancel this task run and ask the server to retry it.
""""""

import base64
import json
import logging
import optparse
import os
import signal
import sys
import time

import xsrf_client
from utils import net
from utils import on_error
from utils import subprocess42
from utils import zip_package


# Path to this file or the zip containing this file.
THIS_FILE = os.path.abspath(zip_package.get_main_script_path())


# Sends a maximum of 100kb of stdout per task_update packet.
MAX_CHUNK_SIZE = 102400


# Maximum wait between task_update packet when there's no output.
MAX_PACKET_INTERVAL = 30


# Minimum wait between task_update packet when there's output.
MIN_PACKET_INTERNAL = 10


# Current task_runner_out version.
OUT_VERSION = 3


# On Windows, SIGTERM is actually sent as SIGBREAK since there's no real
# SIGTERM.  SIGBREAK is not defined on posix since it's a pure Windows concept.
SIG_BREAK_OR_TERM = (
    signal.SIGBREAK if sys.platform == 'win32' else signal.SIGTERM)


# Used to implement monotonic_time for a clock that never goes backward.
_last_now = 0


def monotonic_time():
  """"""Returns monotonically increasing time.""""""
  global _last_now
  now = time.time()
  if now > _last_now:
    # TODO(maruel): If delta is large, probably worth alerting via ereporter2.
    _last_now = now
  return _last_now


def get_run_isolated():
  """"""Returns the path to itself to run run_isolated.

  Mocked in test to point to the real run_isolated.py script.
  """"""
  return [sys.executable, THIS_FILE, 'run_isolated']


def get_isolated_cmd(
    work_dir, task_details, isolated_result, min_free_space):
  """"""Returns the command to call run_isolated. Mocked in tests.""""""
  bot_dir = os.path.dirname(work_dir)
  if os.path.isfile(isolated_result):
    os.remove(isolated_result)
  cmd = get_run_isolated()
  cmd.extend(
      [
        '--isolated', task_details.inputs_ref['isolated'].encode('utf-8'),
        '--namespace', task_details.inputs_ref['namespace'].encode('utf-8'),
        '-I', task_details.inputs_ref['isolatedserver'].encode('utf-8'),
        '--json', isolated_result,
        '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),
        '--cache', os.path.join(bot_dir, 'cache'),
        '--root-dir', os.path.join(work_dir, 'isolated'),
      ])
  if min_free_space:
    cmd.extend(('--min-free-space', str(min_free_space)))

  if task_details.hard_timeout:
    cmd.extend(('--hard-timeout', str(task_details.hard_timeout)))
  if task_details.grace_period:
    cmd.extend(('--grace-period', str(task_details.grace_period)))
  if task_details.extra_args:
    cmd.append('--')
    cmd.extend(task_details.extra_args)
  return cmd


class TaskDetails(object):
  def __init__(self, data):
    """"""Loads the raw data.

    It is expected to have at least:
     - bot_id
     - command as a list of str
     - data as a list of urls
     - env as a dict
     - hard_timeout
     - io_timeout
     - task_id
    """"""
    logging.info('TaskDetails(%s)', data)
    if not isinstance(data, dict):
      raise ValueError('Expected dict, got %r' % data)

    # Get all the data first so it fails early if the task details is invalid.
    self.bot_id = data['bot_id']

    # Raw command. Only self.command or self.inputs_ref can be set.
    self.command = data['command'] or []

    # Isolated command. Is a serialized version of task_request.FilesRef.
    self.inputs_ref = data['inputs_ref']
    self.extra_args = data['extra_args']

    self.env = {
      k.encode('utf-8'): v.encode('utf-8') for k, v in data['env'].iteritems()
    }
    self.grace_period = data['grace_period']
    self.hard_timeout = data['hard_timeout']
    self.io_timeout = data['io_timeout']
    self.task_id = data['task_id']


class MustExit(Exception):
  """"""Raised on signal that the process must exit immediately.""""""
  def __init__(self, sig):
    super(MustExit, self).__init__()
    self.signal = sig


def load_and_run(
    in_file, swarming_server, cost_usd_hour, start, out_file, min_free_space):
  """"""Loads the task's metadata and execute it.

  This may throw all sorts of exceptions in case of failure. It's up to the
  caller to trap them. These shall be considered 'internal_failure' instead of
  'failure' from a TaskRunResult standpoint.
  """"""
  # The work directory is guaranteed to exist since it was created by
  # bot_main.py and contains the manifest. Temporary files will be downloaded
  # there. It's bot_main.py that will delete the directory afterward. Tests are
  # not run from there.
  task_result = None
  def handler(sig, _):
    logging.info('Got signal %s', sig)
    raise MustExit(sig)
  work_dir = os.path.dirname(out_file)
  try:
    with subprocess42.set_signal_handler([SIG_BREAK_OR_TERM], handler):
      if not os.path.isdir(work_dir):
        raise ValueError('%s expected to exist' % work_dir)

      with open(in_file, 'rb') as f:
        task_details = TaskDetails(json.load(f))

      task_result = run_command(
          swarming_server, task_details, work_dir, cost_usd_hour, start,
          min_free_space)
  except MustExit as e:
    # This normally means run_command() didn't get the chance to run, as it
    # itself trap MustExit and will report accordingly. In this case, we want
    # the parent process to send the message instead.
    if not task_result:
      task_result = {
        u'exit_code': None,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure':
            u'task_runner received signal %s' % e.signal,
        u'version': OUT_VERSION,
      }
  finally:
    # We've found tests to delete 'work' when quitting, causing an exception
    # here. Try to recreate the directory if necessary.
    if not os.path.isdir(work_dir):
      os.mkdir(work_dir)
    with open(out_file, 'wb') as f:
      json.dump(task_result, f)


def post_update(swarming_server, params, exit_code, stdout, output_chunk_start):
  """"""Posts task update to task_update.

  Arguments:
    swarming_server: XsrfRemote instance.
    params: Default JSON parameters for the POST.
    exit_code: Process exit code, only when a command completed.
    stdout: Incremental output since last call, if any.
    output_chunk_start: Total number of stdout previously sent, for coherency
        with the server.
  """"""
  params = params.copy()
  if exit_code is not None:
    params['exit_code'] = exit_code
  if stdout:
    # The output_chunk_start is used by the server to make sure that the stdout
    # chunks are processed and saved in the DB in order.
    params['output'] = base64.b64encode(stdout)
    params['output_chunk_start'] = output_chunk_start
  # TODO(maruel): Support early cancellation.
  # https://code.google.com/p/swarming/issues/detail?id=62
  resp = swarming_server.url_read_json(
      '/swarming/api/v1/bot/task_update/%s' % params['task_id'], data=params)
  logging.debug('post_update() = %s', resp)
  if resp.get('error'):
    # Abandon it. This will force a process exit.
    raise ValueError(resp.get('error'))


def should_post_update(stdout, now, last_packet):
  """"""Returns True if it's time to send a task_update packet via post_update().

  Sends a packet when one of this condition is met:
  - more than MAX_CHUNK_SIZE of stdout is buffered.
  - last packet was sent more than MIN_PACKET_INTERNAL seconds ago and there was
    stdout.
  - last packet was sent more than MAX_PACKET_INTERVAL seconds ago.
  """"""
  packet_interval = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  return len(stdout) >= MAX_CHUNK_SIZE or (now - last_packet) > packet_interval


def calc_yield_wait(task_details, start, last_io, timed_out, stdout):
  """"""Calculates the maximum number of seconds to wait in yield_any().""""""
  now = monotonic_time()
  if timed_out:
    # Give a |grace_period| seconds delay.
    if task_details.grace_period:
      return max(now - timed_out - task_details.grace_period, 0.)
    return 0.

  out = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL
  if task_details.hard_timeout:
    out = min(out, start + task_details.hard_timeout - now)
  if task_details.io_timeout:
    out = min(out, last_io + task_details.io_timeout - now)
  out = max(out, 0)
  logging.debug('calc_yield_wait() = %d', out)
  return out


def kill_and_wait(proc, grace_period, reason):
  logging.warning('SIGTERM finally due to %s', reason)
  proc.terminate()
  try:
    proc.wait(grace_period)
  except subprocess42.TimeoutError:
    logging.warning('SIGKILL finally due to %s', reason)
    proc.kill()
  exit_code = proc.wait()
  logging.info('Waiting for proces exit in finally - done')
  return exit_code


def run_command(
    swarming_server, task_details, work_dir, cost_usd_hour, task_start,
    min_free_space):
  """"""Runs a command and sends packets to the server to stream results back.

  Implements both I/O and hard timeouts. Sends the packets numbered, so the
  server can ensure they are processed in order.

  Returns:
    Metadata about the command.
  """"""
  # TODO(maruel): This function is incomprehensible, split and refactor.
  # Signal the command is about to be started.
  last_packet = start = now = monotonic_time()
  params = {
    'cost_usd': cost_usd_hour * (now - task_start) / 60. / 60.,
    'id': task_details.bot_id,
    'task_id': task_details.task_id,
  }
  post_update(swarming_server, params, None, '', 0)

  if task_details.command:
    # Raw command.
    cmd = task_details.command
    isolated_result = None
  else:
    # Isolated task.
    isolated_result = os.path.join(work_dir, 'isolated_result.json')
    cmd = get_isolated_cmd(
        work_dir, task_details, isolated_result, min_free_space)
    # Hard timeout enforcement is deferred to run_isolated. Grace is doubled to
    # give one 'grace_period' slot to the child process and one slot to upload
    # the results back.
    task_details.hard_timeout = 0
    if task_details.grace_period:
      task_details.grace_period *= 2

  try:
    # TODO(maruel): Support both channels independently and display stderr in
    # red.
    env = None
    if task_details.env:
      env = os.environ.copy()
      for key, value in task_details.env.iteritems():
        if not value:
          env.pop(key, None)
        else:
          env[key] = value
    logging.info('cmd=%s', cmd)
    logging.info('env=%s', env)
    try:
      proc = subprocess42.Popen(
          cmd,
          env=env,
          cwd=work_dir,
          detached=True,
          stdout=subprocess42.PIPE,
          stderr=subprocess42.STDOUT,
          stdin=subprocess42.PIPE)
    except OSError as e:
      stdout = 'Command ""%s"" failed to start.\nError: %s' % (' '.join(cmd), e)
      now = monotonic_time()
      params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
      params['duration'] = now - start
      params['io_timeout'] = False
      params['hard_timeout'] = False
      post_update(swarming_server, params, 1, stdout, 0)
      return {
        u'exit_code': -1,
        u'hard_timeout': False,
        u'io_timeout': False,
        u'must_signal_internal_failure': None,
        u'version': OUT_VERSION,
      }

    output_chunk_start = 0
    stdout = ''
    exit_code = None
    had_hard_timeout = False
    had_io_timeout = False
    must_signal_internal_failure = None
    kill_sent = False
    timed_out = None
    try:
      calc = lambda: calc_yield_wait(
          task_details, start, last_io, timed_out, stdout)
      maxsize = lambda: MAX_CHUNK_SIZE - len(stdout)
      last_io = monotonic_time()
      for _, new_data in proc.yield_any(maxsize=maxsize, timeout=calc):
        now = monotonic_time()
        if new_data:
          stdout += new_data
          last_io = now

        # Post update if necessary.
        if should_post_update(stdout, now, last_packet):
          last_packet = monotonic_time()
          params['cost_usd'] = (
              cost_usd_hour * (last_packet - task_start) / 60. / 60.)
          post_update(swarming_server, params, None, stdout, output_chunk_start)
          output_chunk_start += len(stdout)
          stdout = ''

        # Send signal on timeout if necessary. Both are failures, not
        # internal_failures.
        # Eventually kill but return 0 so bot_main.py doesn't cancel the task.
        if not timed_out:
          if (task_details.io_timeout and
              now - last_io > task_details.io_timeout):
            had_io_timeout = True
            logging.warning('I/O timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
          elif (task_details.hard_timeout and
              now - start > task_details.hard_timeout):
            had_hard_timeout = True
            logging.warning('Hard timeout; sending SIGTERM')
            proc.terminate()
            timed_out = monotonic_time()
        else:
          # During grace period.
          if not kill_sent and now >= timed_out + task_details.grace_period:
            # Now kill for real. The user can distinguish between the following
            # states:
            # - signal but process exited within grace period,
            #   (hard_|io_)_timed_out will be set but the process exit code will
            #   be script provided.
            # - processed exited late, exit code will be -9 on posix.
            logging.warning('Grace exhausted; sending SIGKILL')
            proc.kill()
            kill_sent = True
      logging.info('Waiting for proces exit')
      exit_code = proc.wait()
    except MustExit as e:
      # TODO(maruel): Do the send SIGTERM to child process and give it
      # task_details.grace_period to terminate.
      must_signal_internal_failure = (
          u'task_runner received signal %s' % e.signal)
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'signal %d' % e.signal)
    except (IOError, OSError):
      # Something wrong happened, try to kill the child process.
      had_hard_timeout = True
      exit_code = kill_and_wait(
          proc, task_details.grace_period, 'exception %s' % e)

    # This is the very last packet for this command. It if was an isolated task,
    # include the output reference to the archived .isolated file.
    now = monotonic_time()
    params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.
    params['duration'] = now - start
    params['io_timeout'] = had_io_timeout
    params['hard_timeout'] = had_hard_timeout
    if isolated_result:
      try:
        if ((had_io_timeout or had_hard_timeout) and
            not os.path.isfile(isolated_result)):
          # It's possible that run_isolated failed to quit quickly enough; it
          # could be because there was too much data to upload back or something
          # else. Do not create an internal error, just send back the (partial)
          # view as task_runner saw it, for example the real exit_code is
          # unknown.
          logging.warning('TIMED_OUT and there\'s no result file')
          exit_code = -1
        else:
          # See run_isolated.py for the format.
          with open(isolated_result, 'rb') as f:
            run_isolated_result = json.load(f)
          logging.debug('run_isolated:\n%s', run_isolated_result)
          # TODO(maruel): Grab statistics (cache hit rate, data downloaded,
          # mapping time, etc) from run_isolated and push them to the server.
          if run_isolated_result['outputs_ref']:
            params['outputs_ref'] = run_isolated_result['outputs_ref']
          had_hard_timeout = (
              had_hard_timeout or run_isolated_result['had_hard_timeout'])
          params['hard_timeout'] = had_hard_timeout
          if not had_io_timeout and not had_hard_timeout:
            if run_isolated_result['internal_failure']:
              must_signal_internal_failure = (
                  run_isolated_result['internal_failure'])
              logging.error('%s', must_signal_internal_failure)
            elif exit_code:
              # TODO(maruel): Grab stdout from run_isolated.
              must_signal_internal_failure = (
                  'run_isolated internal failure %d' % exit_code)
              logging.error('%s', must_signal_internal_failure)
          exit_code = run_isolated_result['exit_code']
          if run_isolated_result.get('duration') is not None:
            # Calculate the real task duration as measured by run_isolated and
            # calculate the remaining overhead.
            params['bot_overhead'] = params['duration']
            params['duration'] = run_isolated_result['duration']
            params['bot_overhead'] -= params['duration']
            params['bot_overhead'] -= run_isolated_result.get(
                'download', {}).get('duration', 0)
            params['bot_overhead'] -= run_isolated_result.get(
                'upload', {}).get('duration', 0)
            if params['bot_overhead'] < 0:
              params['bot_overhead'] = 0
          stats = run_isolated_result.get('stats')
          if stats:
            params['isolated_stats'] = stats
      except (IOError, OSError, ValueError) as e:
        logging.error('Swallowing error: %s', e)
        if not must_signal_internal_failure:
          must_signal_internal_failure = str(e)
    # TODO(maruel): Send the internal failure here instead of sending it through
    # bot_main, this causes a race condition.
    if exit_code is None:
      exit_code = -1
    post_update(swarming_server, params, exit_code, stdout, output_chunk_start)
    return {
      u'exit_code': exit_code,
      u'hard_timeout': had_hard_timeout,
      u'io_timeout': had_io_timeout,
      u'must_signal_internal_failure': must_signal_internal_failure,
      u'version': OUT_VERSION,
    }
  finally:
    if isolated_result:
      try:
        os.remove(isolated_result)
      except OSError:
        pass


def main(args):
  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)
  parser.add_option('--in-file', help='Name of the request file')
  parser.add_option(
      '--out-file', help='Name of the JSON file to write a task summary to')
  parser.add_option(
      '--swarming-server', help='Swarming server to send data back')
  parser.add_option(
      '--cost-usd-hour', type='float', help='Cost of this VM in $/h')
  parser.add_option('--start', type='float', help='Time this task was started')
  parser.add_option(
      '--min-free-space', type='int',
      help='Value to send down to run_isolated')

  options, args = parser.parse_args(args)
  if not options.in_file or not options.out_file or args:
    parser.error('task_runner is meant to be used by swarming_bot.')

  on_error.report_on_exception_exit(options.swarming_server)

  logging.info('starting')
  remote = xsrf_client.XsrfRemote(options.swarming_server)

  now = monotonic_time()
  if options.start > now:
    options.start = now

  try:
    load_and_run(
        options.in_file, remote, options.cost_usd_hour, options.start,
        options.out_file, options.min_free_space)
    return 0
  finally:
    logging.info('quitting')
/n/n/n/appengine/swarming/swarming_bot/bot_code/xsrf_client.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Wraps URL requests with an XSRF token using components/auth based service.""""""

import datetime
import logging
import os
import sys

THIS_DIR = os.path.dirname(os.path.abspath(__file__))

sys.path.insert(0, os.path.join(THIS_DIR, 'third_party'))

from utils import net


class Error(Exception):
  pass


def _utcnow():
  """"""So it can be mocked.""""""
  return datetime.datetime.utcnow()


class XsrfRemote(object):
  """"""Transparently adds XSRF token to requests.""""""
  TOKEN_RESOURCE = '/auth/api/v1/accounts/self/xsrf_token'

  def __init__(self, url, token_resource=None):
    self.url = url.rstrip('/')
    self.token = None
    self.token_resource = token_resource or self.TOKEN_RESOURCE
    self.expiration = None
    self.xsrf_request_params = {}

  def url_read(self, resource, **kwargs):
    url = self.url + resource
    if kwargs.get('data') == None:
      # No XSRF token for GET.
      return net.url_read(url, **kwargs)

    if self.need_refresh():
      self.refresh_token()
    resp = self._url_read_post(url, **kwargs)
    if resp is None:
      raise Error('Failed to connect to %s; %s' % (url, self.expiration))
    return resp

  def url_read_json(self, resource, **kwargs):
    url = self.url + resource
    if kwargs.get('data') == None:
      # No XSRF token required for GET.
      return net.url_read_json(url, **kwargs)

    if self.need_refresh():
      self.refresh_token()
    resp = self._url_read_json_post(url, **kwargs)
    if resp is None:
      raise Error('Failed to connect to %s; %s' % (url, self.expiration))
    return resp

  def refresh_token(self):
    """"""Returns a fresh token. Necessary as the token may expire after an hour.
    """"""
    url = self.url + self.token_resource
    resp = net.url_read_json(
        url,
        headers={'X-XSRF-Token-Request': '1'},
        data=self.xsrf_request_params)
    if resp is None:
      raise Error('Failed to connect to %s' % url)
    self.token = resp['xsrf_token']
    if resp.get('expiration_sec'):
      exp = resp['expiration_sec']
      exp -= min(round(exp * 0.1), 600)
      self.expiration = _utcnow() + datetime.timedelta(seconds=exp)
    return self.token

  def need_refresh(self):
    """"""Returns True if the XSRF token needs to be refreshed.""""""
    return (
        not self.token or (self.expiration and self.expiration <= _utcnow()))

  def _url_read_post(self, url, **kwargs):
    headers = (kwargs.pop('headers', None) or {}).copy()
    headers['X-XSRF-Token'] = self.token
    return net.url_read(url, headers=headers, **kwargs)

  def _url_read_json_post(self, url, **kwargs):
    headers = (kwargs.pop('headers', None) or {}).copy()
    headers['X-XSRF-Token'] = self.token
    return net.url_read_json(url, headers=headers, **kwargs)
/n/n/n/appengine/swarming/swarming_bot/bot_code/xsrf_client_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import datetime
import logging
import os
import sys
import time
import unittest

import test_env_bot_code
test_env_bot_code.setup_test_env()

# Creates a server mock for functions in net.py.
import net_utils

import xsrf_client


class UrlHelperTest(net_utils.TestCase):
  def setUp(self):
    super(UrlHelperTest, self).setUp()
    self.mock(logging, 'error', lambda *_: None)
    self.mock(logging, 'exception', lambda *_: None)
    self.mock(logging, 'info', lambda *_: None)
    self.mock(logging, 'warning', lambda *_: None)
    self.mock(time, 'sleep', lambda _: None)

  def testXsrfRemoteGET(self):
    self.expected_requests([('http://localhost/a', {}, 'foo', None)])

    remote = xsrf_client.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a'))

  def testXsrfRemoteSimple(self):
    self.expected_requests(
        [
          (
            'http://localhost/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {
              'expiration_sec': 100,
              'xsrf_token': 'token',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},
            'foo',
            None,
          ),
        ])

    remote = xsrf_client.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))

  def testXsrfRemoteRefresh(self):
    self.expected_requests(
        [
          (
            'http://localhost/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {
              'expiration_sec': 100,
              'xsrf_token': 'token',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},
            'bar',
            None,
          ),
          (
            'http://localhost/auth/api/v1/accounts/self/xsrf_token',
            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},
            {
              'expiration_sec': 100,
              'xsrf_token': 'token2',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token2'}},
            'foo',
            None,
          ),
        ])

    now = xsrf_client._utcnow()
    remote = xsrf_client.XsrfRemote('http://localhost/')
    remote.url_read('/a', data={'foo': 'bar'})
    self.mock(
        xsrf_client, '_utcnow', lambda: now + datetime.timedelta(seconds=91))
    remote.url_read('/a', data={'foo': 'bar'})

  def testXsrfRemoteCustom(self):
    # Use the new swarming bot API as an example of custom XSRF request handler.
    self.expected_requests(
        [
          (
            'http://localhost/swarming/api/v1/bot/handshake',
            {
              'data': {'attributes': 'b'},
              'headers': {'X-XSRF-Token-Request': '1'},
            },
            {
              'expiration_sec': 100,
              'ignored': True,
              'xsrf_token': 'token',
            },
          ),
          (
            'http://localhost/a',
            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},
            'foo',
            None,
          ),
        ])

    remote = xsrf_client.XsrfRemote(
        'http://localhost/',
        '/swarming/api/v1/bot/handshake')
    remote.xsrf_request_params = {'attributes': 'b'}
    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))


if __name__ == '__main__':
  logging.basicConfig(level=logging.ERROR)
  unittest.main()
/n/n/n/client/tests/net_utils.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import logging
import os
import sys
import threading

TEST_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(TEST_DIR)
sys.path.insert(0, ROOT_DIR)
sys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))

from depot_tools import auto_stub
from utils import net


def make_fake_response(content, url, headers=None):
  """"""Returns HttpResponse with predefined content, useful in tests.""""""
  headers = dict(headers or {})
  headers['Content-Length'] = len(content)
  class _Fake(object):
    def __init__(self):
      self.content = content
    def iter_content(self, chunk_size):
      c = self.content
      while c:
        yield c[:chunk_size]
        c = c[chunk_size:]
    def read(self):
      return self.content
  return net.HttpResponse(_Fake(), url, headers)


class TestCase(auto_stub.TestCase):
  """"""Mocks out url_open() calls.""""""
  def setUp(self):
    super(TestCase, self).setUp()
    self.mock(net, 'url_open', self._url_open)
    self.mock(net, 'url_read_json', self._url_read_json)
    self.mock(net, 'sleep_before_retry', lambda *_: None)
    self._lock = threading.Lock()
    self._requests = []

  def tearDown(self):
    try:
      if not self.has_failed():
        self.assertEqual([], self._requests)
    finally:
      super(TestCase, self).tearDown()

  def expected_requests(self, requests):
    """"""Registers the expected requests along their reponses.

    Arguments:
      request: list of tuple(url, kwargs, response, headers) for normal requests
          and tuple(url, kwargs, response) for json requests. kwargs can be a
          callable. In that case, it's called with the actual kwargs. It's
          useful when the kwargs values are not deterministic.
    """"""
    requests = requests[:]
    for request in requests:
      self.assertEqual(tuple, request.__class__)
      # 3 = json request (url_read_json).
      # 4 = normal request (url_open).
      self.assertIn(len(request), (3, 4))

    with self._lock:
      self.assertEqual([], self._requests)
      self._requests = requests

  def _url_open(self, url, **kwargs):
    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 4:
            self.fail('Expected normal request, got json data; %s' % url)
          _, expected_kwargs, result, headers = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return make_fake_response(result, url, headers)
          return None
    self.fail('Unknown request %s' % url)

  def _url_read_json(self, url, **kwargs):
    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])
    with self._lock:
      if not self._requests:
        return None
      # Ignore 'stream' argument, it's not important for these tests.
      kwargs.pop('stream', None)
      for i, n in enumerate(self._requests):
        if n[0] == url:
          data = self._requests.pop(i)
          if len(data) != 3:
            self.fail('Expected json request, got normal data; %s' % url)
          _, expected_kwargs, result = data
          if callable(expected_kwargs):
            expected_kwargs(kwargs)
          else:
            self.assertEqual(expected_kwargs, kwargs)
          if result is not None:
            return result
          return None
    self.fail('Unknown request %s' % url)
/n/n/n",1
84,481a3e8120787d449ad7bbc6a627d8450bceb85c,"appengine/components/components/auth/ui/ui.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Auth management UI handlers.""""""

import functools
import json
import os
import re
import webapp2

from components import template
from components import utils

from . import acl
from . import rest_api

from .. import api
from .. import change_log
from .. import handler
from .. import model
from .. import replication


# templates/.
TEMPLATES_DIR = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), 'templates')


# Global static configuration set in 'configure_ui'.
_ui_app_name = 'Unknown'
_ui_data_callback = None
_ui_navbar_tabs = ()


def configure_ui(app_name, ui_tabs=None, ui_data_callback=None):
  """"""Modifies global configuration of Auth UI.

  Args:
    app_name: name of the service (visible in page headers, titles, etc.)
    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or
        None to show the standard set of tabs.
    ui_data_callback: an argumentless callable that returns a dict with
        additional data to return to authenticated users. It can be used by
        server and client side code to render templates. Used by auth_service.
  """"""
  global _ui_app_name
  global _ui_data_callback
  global _ui_navbar_tabs
  _ui_app_name = app_name
  _ui_data_callback = ui_data_callback
  if ui_tabs is not None:
    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)
    _ui_navbar_tabs = tuple(ui_tabs)
  template.bootstrap({'auth': TEMPLATES_DIR})


def get_ui_routes():
  """"""Returns a list of routes with auth UI handlers.""""""
  routes = []
  if not utils.should_disable_ui_routes():
    # Routes for registered navbar tabs.
    for cls in _ui_navbar_tabs:
      routes.extend(cls.get_webapp2_routes())
    # Routes for everything else.
    routes.extend([
      webapp2.Route(r'/auth', MainHandler),
      webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),
      webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),
      webapp2.Route(r'/auth/link', LinkToPrimaryHandler),
    ])
  return routes


def forbid_ui_on_replica(method):
  """"""Decorator for methods that are not allowed to be called on Replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 405 ""Method Not Allowed"".
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      self.abort(
          405,
          detail='Not allowed on a replica, see primary at %s' % primary_url)
    return method(self, *args, **kwargs)
  return wrapper


def redirect_ui_on_replica(method):
  """"""Decorator for methods that redirect to Primary when called on replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 302 redirect to corresponding method on Primary.
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    assert self.request.method == 'GET'
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      protocol = 'http://' if utils.is_local_dev_server() else 'https://'
      assert primary_url and primary_url.startswith(protocol), primary_url
      assert self.request.path_qs.startswith('/'), self.request.path_qs
      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)
    return method(self, *args, **kwargs)
  return wrapper


################################################################################
## Admin routes. The use cookies and GAE's ""is_current_user_admin"" for authn.


class AdminPageHandler(handler.AuthenticatingHandler):
  """"""Base class for handlers involved in bootstrap processes.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  @classmethod
  def get_auth_methods(cls, conf):
    # This method sets 'is_superuser' bit for GAE-level admins.
    return [handler.gae_cookie_authentication]

  def reply(self, path, env=None, status=200):
    """"""Render template |path| to response using given environment.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    full_env = {
      'app_name': _ui_app_name,
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html
      'xsrf_token': self.generate_xsrf_token(),
    }
    full_env.update(env or {})
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=403)


class BootstrapHandler(AdminPageHandler):
  """"""Creates Administrators group (if necessary) and adds current caller to it.

  Requires Appengine level Admin access for its handlers, since Administrators
  group may not exist yet.

  Used during bootstrap of a new service instance.
  """"""

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'return_url': self.request.get('r') or '',
    }
    self.reply('auth/admin/bootstrap.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    added = model.bootstrap_group(
        model.ADMIN_GROUP, [api.get_current_identity()],
        'Users that can manage groups')
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'added': added,
      'return_url': self.request.get('return_url') or '',
    }
    self.reply('auth/admin/bootstrap_done.html', env)


class BootstrapOAuthHandler(AdminPageHandler):
  """"""Page to set OAuth2 client ID used by the main web UI.

  Requires Appengine level Admin access for its handlers, since without client
  ID there's no UI yet to configure Administrators group.

  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is
  also available after the service is linked to some primary Auth service.
  """"""

  @api.require(api.is_superuser)
  def get(self):
    self.show_page(web_client_id=api.get_web_client_id_uncached())

  @api.require(api.is_superuser)
  def post(self):
    web_client_id = self.request.POST['web_client_id']
    api.set_web_client_id(web_client_id)
    self.show_page(web_client_id=web_client_id, saved=True)

  def show_page(self, web_client_id, saved=False):
    env = {
      'page_title': 'OAuth2 web client ID',
      'web_client_id': web_client_id or '',
      'saved': saved,
    }
    self.reply('auth/admin/bootstrap_oauth.html', env)


class LinkToPrimaryHandler(AdminPageHandler):
  """"""A page with confirmation of Primary <-> Replica linking request.

  URL to that page is generated by a Primary service.
  """"""

  def decode_link_ticket(self):
    """"""Extracts ServiceLinkTicket from 't' GET parameter.""""""
    try:
      return replication.decode_link_ticket(
          self.request.get('t').encode('ascii'))
    except (KeyError, ValueError):
      self.abort(400)
      return

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    ticket = self.decode_link_ticket()
    env = {
      'generated_by': ticket.generated_by,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
    }
    self.reply('auth/admin/linking.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    ticket = self.decode_link_ticket()
    success = True
    error_msg = None
    try:
      replication.become_replica(ticket, api.get_current_identity())
    except replication.ProtocolError as exc:
      success = False
      error_msg = exc.message
    env = {
      'error_msg': error_msg,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
      'success': success,
    }
    self.reply('auth/admin/linking_done.html', env)


################################################################################
## Web UI routes.

# TODO(vadimsh): Switch them to use OAuth for authentication.


class UIHandler(handler.AuthenticatingHandler):
  """"""Renders Jinja templates extending base.html.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  def reply(self, path, env=None, status=200):
    """"""Renders template |path| to the HTTP response using given environment.

    Optional keys from |env| that base.html uses:
      css_file: URL to a file with page specific styles, relative to site root.
      js_file: URL to a file with page specific Javascript code, relative to
          site root. File should define global object named same as a filename,
          i.e. '/auth/static/js/api.js' should define global object 'api' that
          incapsulates functionality implemented in the module.
      navbar_tab_id: id of a navbar tab to highlight.
      page_title: title of an HTML page.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    env = (env or {}).copy()
    env.setdefault('css_file', None)
    env.setdefault('js_file', None)
    env.setdefault('navbar_tab_id', None)
    env.setdefault('page_title', 'Untitled')

    # This goes to both Jinja2 env and Javascript config object.
    user = self.get_current_user()
    common = {
      'account_picture': user.picture() if user else None,
      'auth_service_config_locked': False, # overridden in auth_service
      'is_admin': api.is_admin(),
      'login_url': self.create_login_url(self.request.url),
      'logout_url': self.create_logout_url('/'),
      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,
      'xsrf_token': self.generate_xsrf_token(),
    }
    if _ui_data_callback:
      common.update(_ui_data_callback())

    # Name of Javascript module with page code.
    js_module_name = None
    if env['js_file']:
      assert env['js_file'].endswith('.js')
      js_module_name = os.path.basename(env['js_file'])[:-3]

    # This will be accessible from Javascript as global 'config' variable.
    js_config = {
      'identity': api.get_current_identity().to_bytes(),
    }
    js_config.update(common)

    # Jinja2 environment to use to render a template.
    full_env = {
      'app_name': _ui_app_name,
      'app_revision_url': utils.get_app_revision_url(),
      'app_version': utils.get_app_version(),
      'config': json.dumps(js_config),
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'js_module_name': js_module_name,
      'navbar': [
        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)
        for cls in _ui_navbar_tabs
        if cls.is_visible()
      ],
    }
    full_env.update(common)
    full_env.update(env)

    # Render it.
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=403)


class MainHandler(UIHandler):
  """"""Redirects to first navbar tab.""""""
  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    assert _ui_navbar_tabs
    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)


class UINavbarTabHandler(UIHandler):
  """"""Handler for a navbar tab page.""""""
  # List of routes to register, default is [navbar_tab_url].
  routes = []
  # URL to the tab (relative to site root).
  navbar_tab_url = None
  # ID of the tab, will be used in DOM.
  navbar_tab_id = None
  # Title of the tab, will be used in tab title and page title.
  navbar_tab_title = None
  # Relative URL to CSS file with tab's styles.
  css_file = None
  # Relative URL to javascript file with tab's logic.
  js_file_url = None
  # Path to a Jinja2 template with tab's markup.
  template_file = None

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self, **_params):
    """"""Renders page HTML to HTTP response stream.""""""
    env = {
      'css_file': self.css_file,
      'js_file': self.js_file_url,
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
    }
    self.reply(self.template_file, env)

  @classmethod
  def get_webapp2_routes(cls):
    routes = cls.routes or [cls.navbar_tab_url]
    return [webapp2.Route(r, cls) for r in routes]

  @classmethod
  def is_visible(cls):
    """"""Subclasses may return False to hide the tab from tab bar.""""""
    return True


################################################################################
## Default tabs.


class GroupsHandler(UINavbarTabHandler):
  """"""Page with Groups management.""""""
  routes = [
    '/auth/groups',
    '/auth/groups/<group:.*>',  # 'group' is handled by js code
  ]
  navbar_tab_url = '/auth/groups'
  navbar_tab_id = 'groups'
  navbar_tab_title = 'Groups'
  css_file = '/auth/static/css/groups.css'
  js_file_url = '/auth/static/js/groups.js'
  template_file = 'auth/groups.html'


class ChangeLogHandler(UINavbarTabHandler):
  """"""Page with a log of changes to some groups.""""""
  navbar_tab_url = '/auth/change_log'
  navbar_tab_id = 'change_log'
  navbar_tab_title = 'Change Log'
  js_file_url = '/auth/static/js/change_log.js'
  template_file = 'auth/change_log.html'

  @classmethod
  def is_visible(cls):
    # Hide 'Change Log' tab if there are no change log indexes in the datastore.
    # It happens on services that use components.auth, but do not modify
    # index.yaml. Don't try too hard to hide the log though. If user happes to
    # stumble on Change log page (e.g. by using direct URL), it handles
    # NeedIndexError gracefully (explaining how to configure indexes).
    return change_log.is_changle_log_indexed()


class OAuthConfigHandler(UINavbarTabHandler):
  """"""Page with OAuth configuration.""""""
  navbar_tab_url = '/auth/oauth_config'
  navbar_tab_id = 'oauth_config'
  navbar_tab_title = 'OAuth'
  js_file_url = '/auth/static/js/oauth_config.js'
  template_file = 'auth/oauth_config.html'


class IPWhitelistsHandler(UINavbarTabHandler):
  """"""Page with IP whitelists configuration.""""""
  navbar_tab_url = '/auth/ip_whitelists'
  navbar_tab_id = 'ip_whitelists'
  navbar_tab_title = 'IP Whitelists'
  js_file_url = '/auth/static/js/ip_whitelists.js'
  template_file = 'auth/ip_whitelists.html'


class ApiDocHandler(UINavbarTabHandler):
  """"""Page with API documentation extracted from rest_api.py.""""""
  navbar_tab_url = '/auth/api'
  navbar_tab_id = 'api'
  navbar_tab_title = 'API'

  # These can be used as 'request_type' and 'response_type' in api_doc.
  doc_types = [
    {
      'name': 'Status',
      'doc': 'Outcome of some operation.',
      'example': {'ok': True},
    },
    {
      'name': 'Self info',
      'doc': 'Information about the requester.',
      'example': {
        'identity': 'user:someone@example.com',
        'ip': '192.168.0.1',
      },
    },
    {
      'name': 'Group',
      'doc': 'Represents a group, as stored in the database.',
      'example': {
        'group': {
          'caller_can_modify': True,
          'created_by': 'user:someone@example.com',
          'created_ts': 1409250754978540,
          'description': 'Some free form description',
          'globs': ['user:*@example.com'],
          'members': ['user:a@example.com', 'anonymous:anonymous'],
          'modified_by': 'user:someone@example.com',
          'modified_ts': 1470871200558130,
          'name': 'Some group',
          'nested': ['Some nested group', 'Another nested group'],
          'owners': 'Owning group',
        },
      },
    },
    {
      'name': 'Group listing',
      'doc':
        'All groups, along with their metadata. Does not include members '
        'listings.',
      'example': {
        'groups': [
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Some free form description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Some group',
            'owners': 'Owning group',
          },
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Another description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Another group',
            'owners': 'Owning group',
          },
        ],
      },
    },
  ]

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    """"""Extracts API doc for registered webapp2 API routes.""""""
    doc_types = []

    def add_doc_type(tp):
      """"""Adds a request or response format definition to the documentation page.

      'tp' can either reference a globally known doc type by name
      (see ApiDocHandler.doc_types), or can itself be a dict with doc type
      definition.

      Returns the name of the doc type.
      """"""
      if not tp:
        return None
      # If referenced by name, try to find it among globally known types.
      if isinstance(tp, basestring):
        for d in self.doc_types:
          if d['name'] == tp:
            tp = d
            break
        else:
          return tp  # not found, return original name as is
      # Add, if not already there. Serialize the example first, since doing it
      # from Jinja is a bit more complicated.
      if not any(d['name'] == tp['name'] for d in doc_types):
        tp = tp.copy()
        tp['example'] = json.dumps(
            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)
        doc_types.append(tp)
      return tp['name']

    api_methods = []
    for route in rest_api.get_rest_api_routes():
      # Remove API parameter regexps from route template, they are mostly noise.
      simplified = re.sub(r'\:.*\>', '>', route.template)
      for doc in getattr(route.handler, 'api_doc', []):
        path = simplified
        if 'params' in doc:
          path += '?' + doc['params']
        api_methods.append({
          'verb': doc['verb'],
          'path': path,
          'doc': doc['doc'],
          'request_type': add_doc_type(doc.get('request_type')),
          'response_type': add_doc_type(doc.get('response_type')),
        })

    env = {
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
      'api_methods': api_methods,
      'doc_types': doc_types,
    }
    self.reply('auth/api.html', env)


# Register them as default tabs. Order is important.
_ui_navbar_tabs = (
  GroupsHandler,
  ChangeLogHandler,
  OAuthConfigHandler,
  IPWhitelistsHandler,
  ApiDocHandler,
)
/n/n/nappengine/components/components/ereporter2/handlers.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""HTTP Handlers.""""""

import datetime
import itertools
import json
import time

import webapp2

from google.appengine.api import app_identity
from google.appengine.datastore import datastore_query
from google.appengine.ext import ndb

from components import auth
from components import decorators
from components import template
from components import utils

from . import acl
from . import logscraper
from . import models
from . import on_error
from . import ui


# Access to a protected member XXX of a client class - pylint: disable=W0212


### Admin pages.


class RestrictedEreporter2Report(auth.AuthenticatingHandler):
  """"""Returns all the recent errors as a web page.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    """"""Reports the errors logged and ignored.

    Arguments:
      start: epoch time to start looking at. Defaults to the messages since the
             last email.
      end: epoch time to stop looking at. Defaults to now.
      modules: comma separated modules to look at.
      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.
    """"""
    # TODO(maruel): Be consistent about using either epoch or human readable
    # formatted datetime.
    end = int(float(self.request.get('end', 0)) or time.time())
    start = int(
        float(self.request.get('start', 0)) or
        ui._get_default_start_time() or 0)
    modules = self.request.get('modules')
    if modules:
      modules = modules.split(',')
    tainted = bool(int(self.request.get('tainted', '1')))
    module_versions = utils.get_module_version_list(modules, tainted)
    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(
        start, end, module_versions)

    params = {
      'errors': errors,
      'errors_count': sum(len(e.events) for e in errors),
      'errors_version_count':
          len(set(itertools.chain.from_iterable(e.versions for e in errors))),
      'ignored': ignored,
      'ignored_count': sum(len(i.events) for i in ignored),
      'ignored_version_count':
          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),
      'xsrf_token': self.generate_xsrf_token(),
    }
    params.update(ui._get_template_env(start, end, module_versions))
    self.response.write(template.render('ereporter2/requests.html', params))


class RestrictedEreporter2Request(auth.AuthenticatingHandler):
  """"""Dumps information about single logged request.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, request_id):
    data = logscraper._log_request_id(request_id)
    if not data:
      self.abort(404, detail='Request id was not found.')
    self.response.write(
        template.render('ereporter2/request.html', {'request': data}))


class RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    limit = int(self.request.get('limit', 100))
    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))
    errors_found, cursor, more = models.Error.query().order(
        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)
    params = {
      'cursor': cursor.urlsafe() if cursor and more else None,
      'errors': errors_found,
      'limit': limit,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/errors.html', params))


class RestrictedEreporter2Error(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, error_id):
    error = models.Error.get_by_id(int(error_id))
    if not error:
      self.abort(404, 'Error not found')
    params = {
      'error': error,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/error.html', params))


class RestrictedEreporter2Silence(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    # Due to historical reasons where created_ts had indexed=False,, do not use
    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all
    # objects have been updated.
    items = models.ErrorReportingMonitoring.query().fetch()
    items.sort(key=lambda x: x.created_ts)
    params = {
      'silenced': items,
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.out.write(template.render('ereporter2/silence.html', params))

  @auth.require(acl.is_ereporter2_editor)
  def post(self):
    to_delete = self.request.get('to_delete')
    if to_delete:
      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()
    else:
      mute_type = self.request.get('mute_type')
      error = None
      if mute_type in ('exception_type', 'signature'):
        error = self.request.get(mute_type)
      if not error:
        self.abort(400)
      silenced = self.request.get('silenced')
      silenced_until = self.request.get('silenced_until')
      if silenced_until == 'T':
        silenced_until = ''
      threshold = self.request.get('threshold')
      key = models.ErrorReportingMonitoring.error_to_key(error)
      if not silenced and not silenced_until and not threshold:
        key.delete()
      else:
        item = models.ErrorReportingMonitoring(key=key, error=error)
        if silenced:
          item.silenced = True
        if silenced_until:
          item.silenced_until = datetime.datetime.strptime(
              silenced_until, '%Y-%m-%dT%H:%M')
        if threshold:
          item.threshold = int(threshold)
        item.put()

    self.get()


### Cron jobs.


class CronEreporter2Mail(webapp2.RequestHandler):
  """"""Generate and emails an exception report.""""""
  @decorators.require_cronjob
  def get(self):
    """"""Sends email(s) containing the errors logged.""""""
    # Do not use self.request.host_url because it will be http:// and will point
    # to the backend, with an host format that breaks the SSL certificate.
    # TODO(maruel): On the other hand, Google Apps instances are not hosted on
    # appspot.com.
    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()
    request_id_url = host_url + '/restricted/ereporter2/request/'
    report_url = host_url + '/restricted/ereporter2/report'
    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())
    result = ui._generate_and_email_report(
        utils.get_module_version_list(None, False),
        recipients,
        request_id_url,
        report_url,
        {})
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    if result:
      self.response.write('Success.')
    else:
      # Do not HTTP 500 since we do not want it to be retried.
      self.response.write('Failed.')


class CronEreporter2Cleanup(webapp2.RequestHandler):
  """"""Deletes old error reports.""""""
  @decorators.require_cronjob
  def get(self):
    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE
    items = models.Error.query(
        models.Error.created_ts < old_cutoff,
        default_options=ndb.QueryOptions(keys_only=True))
    out = len(ndb.delete_multi(items))
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write(str(out))


### Public API.


class OnErrorHandler(auth.AuthenticatingHandler):
  """"""Adds an error report.

  This one is open so errors like authentication reports are logged in too.
  This means we could get spammed a lot about it. Implement DDoS protection by
  rate limiting once a kid figures out.
  """"""
  xsrf_token_enforce_on = ()

  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be
  # factored out.
  def parse_body(self):
    """"""Parse JSON body and verifies it's a dict.""""""
    expected = ('application/json', 'application/json; charset=utf-8')
    if self.request.headers.get('Content-Type').lower() not in expected:
      msg = 'Expecting JSON body with content type \'application/json\''
      self.abort(400, msg)
    try:
      body = json.loads(self.request.body)
      if not isinstance(body, dict):
        raise ValueError()
    except ValueError:
      self.abort(400, 'Not a valid json dict body')
    return body

  @auth.public
  def post(self):
    body = self.parse_body()
    version = body.get('v')
    # Do not enforce version for now, just assert it is present.
    if not version:
      self.abort(400, 'Missing version')

    report = body.get('r')
    if not report:
      self.abort(400, 'Missing report')

    kwargs = dict(
        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))
    report_id = on_error.log_request(self.request, add_params=False, **kwargs)
    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'
    body = {
      'id': report_id,
      'url':
          '%s/restricted/ereporter2/errors/%d' %
          (self.request.host_url, report_id),
    }
    self.response.write(utils.encode_to_json(body))


def get_frontend_routes():
  routes = [
    # Public API.
    webapp2.Route(
      '/ereporter2/api/v1/on_error', OnErrorHandler),
  ]
  if not utils.should_disable_ui_routes():
    routes.extend([
      webapp2.Route(
        r'/restricted/ereporter2/errors',
        RestrictedEreporter2ErrorsList),
      webapp2.Route(
        r'/restricted/ereporter2/errors/<error_id:\d+>',
        RestrictedEreporter2Error),
      webapp2.Route(
        r'/restricted/ereporter2/report',
        RestrictedEreporter2Report),
      webapp2.Route(
        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',
        RestrictedEreporter2Request),
      webapp2.Route(
        r'/restricted/ereporter2/silence',
        RestrictedEreporter2Silence),
    ])

  return routes


def get_backend_routes():
  # This requires a cron job to this URL.
  return [
    webapp2.Route(
        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),
    webapp2.Route(
        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),
  ]
/n/n/nappengine/components/components/utils.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Mixed bag of utilities.""""""

# Disable 'Access to a protected member ...'. NDB uses '_' for other purposes.
# pylint: disable=W0212

# Disable: 'Method could be a function'. It can't: NDB expects a method.
# pylint: disable=R0201

import binascii
import datetime
import functools
import hashlib
import inspect
import json
import logging
import os
import re
import sys
import threading
import urlparse

from email import utils as email_utils

from google.appengine import runtime
from google.appengine.api import app_identity
from google.appengine.api import memcache as gae_memcache
from google.appengine.api import modules
from google.appengine.api import taskqueue
from google.appengine.ext import ndb

from protorpc import messages
from protorpc.remote import protojson

THIS_DIR = os.path.dirname(os.path.abspath(__file__))

DATETIME_FORMAT = u'%Y-%m-%d %H:%M:%S'
DATE_FORMAT = u'%Y-%m-%d'
VALID_DATETIME_FORMATS = ('%Y-%m-%d', '%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S')


# UTC datetime corresponding to zero Unix timestamp.
EPOCH = datetime.datetime.utcfromtimestamp(0)

# Module to run task queue tasks on by default. Used by get_task_queue_host
# function. Can be changed by 'set_task_queue_module' function.
_task_queue_module = 'backend'


def should_disable_ui_routes():
    return os.environ.get('LUCI_DISABLE_UI_ROUTES', '0') == '1'


def is_local_dev_server():
  """"""Returns True if running on local development server or in unit tests.

  This function is safe to run outside the scope of a HTTP request.
  """"""
  return os.environ.get('SERVER_SOFTWARE', '').startswith('Development')


def is_dev():
  """"""Returns True if the server is running a development/staging instance.

  We define a 'development instance' as an instance that has the suffix '-dev'
  in its instance name.

  This function is safe to run outside the scope of a HTTP request.
  """"""
  return os.environ['APPLICATION_ID'].endswith('-dev')


def is_unit_test():
  """"""Returns True if running in a unit test.

  Don't abuse it, use only if really desperate. For example, in a component that
  is included by many-many projects across many repos, when mocking some
  component behavior in all unit tests that indirectly invoke it is infeasible.
  """"""
  if not is_local_dev_server():
    return False
  # devappserver2 sets up some sort of a sandbox that is not activated for
  # unit tests. So differentiate based on that.
  return all(
      'google.appengine.tools.devappserver2' not in str(p)
      for p in sys.meta_path)


def get_module_version_list(module_list, tainted):
  """"""Returns a list of pairs (module name, version name) to fetch logs for.

  Arguments:
    module_list: list of modules to list, defaults to all modules.
    tainted: if False, excludes versions with '-tainted' in their name.
  """"""
  result = []
  if not module_list:
    # If the function it called too often, it'll raise a OverQuotaError. So
    # cache it for 10 minutes.
    module_list = gae_memcache.get('modules_list')
    if not module_list:
      module_list = modules.get_modules()
      gae_memcache.set('modules_list', module_list, time=10*60)

  for module in module_list:
    # If the function it called too often, it'll raise a OverQuotaError.
    # Versions is a bit more tricky since we'll loose data, since versions are
    # changed much more often than modules. So cache it for 1 minute.
    key = 'modules_list-' + module
    version_list = gae_memcache.get(key)
    if not version_list:
      version_list = modules.get_versions(module)
      gae_memcache.set(key, version_list, time=60)
    result.extend(
        (module, v) for v in version_list if tainted or '-tainted' not in v)
  return result


def get_request_as_int(request, key, default, min_value, max_value):
  """"""Returns a request value as int.""""""
  value = request.params.get(key, '')
  try:
    value = int(value)
  except ValueError:
    return default
  return min(max_value, max(min_value, value))


def parse_datetime(text):
  """"""Converts text to datetime.datetime instance or None.""""""
  for f in VALID_DATETIME_FORMATS:
    try:
      return datetime.datetime.strptime(text, f)
    except ValueError:
      continue
  return None


def parse_rfc3339_datetime(value):
  """"""Parses RFC 3339 datetime string (as used in Timestamp proto JSON encoding).

  Keeps only microsecond precision (dropping nanoseconds).

  Examples of the input:
    2017-08-17T04:21:32.722952943Z
    1972-01-01T10:00:20.021-05:00

  Returns:
    datetime.datetime in UTC (regardless of timezone of the original string).

  Raises:
    ValueError on errors.
  """"""
  # Adapted from protobuf/internal/well_known_types.py Timestamp.FromJsonString.
  # We can't use the original, since it's marked as internal. Also instantiating
  # proto messages here to parse a string would been odd.
  timezone_offset = value.find('Z')
  if timezone_offset == -1:
    timezone_offset = value.find('+')
  if timezone_offset == -1:
    timezone_offset = value.rfind('-')
  if timezone_offset == -1:
    raise ValueError('Failed to parse timestamp: missing valid timezone offset')
  time_value = value[0:timezone_offset]
  # Parse datetime and nanos.
  point_position = time_value.find('.')
  if point_position == -1:
    second_value = time_value
    nano_value = ''
  else:
    second_value = time_value[:point_position]
    nano_value = time_value[point_position + 1:]
  date_object = datetime.datetime.strptime(second_value, '%Y-%m-%dT%H:%M:%S')
  td = date_object - EPOCH
  seconds = td.seconds + td.days * 86400
  if len(nano_value) > 9:
    raise ValueError(
        'Failed to parse timestamp: nanos %r more than 9 fractional digits'
        % nano_value)
  if nano_value:
    nanos = round(float('0.' + nano_value) * 1e9)
  else:
    nanos = 0
  # Parse timezone offsets.
  if value[timezone_offset] == 'Z':
    if len(value) != timezone_offset + 1:
      raise ValueError(
          'Failed to parse timestamp: invalid trailing data %r' % value)
  else:
    timezone = value[timezone_offset:]
    pos = timezone.find(':')
    if pos == -1:
      raise ValueError('Invalid timezone offset value: %r' % timezone)
    if timezone[0] == '+':
      seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
    else:
      seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
  return timestamp_to_datetime(int(seconds)*1e6 + int(nanos)/1e3)


def constant_time_equals(a, b):
  """"""Compares two strings in constant time regardless of theirs content.""""""
  if len(a) != len(b):
    return False
  result = 0
  for x, y in zip(a, b):
    result |= ord(x) ^ ord(y)
  return result == 0


def to_units(number):
  """"""Convert a string to numbers.""""""
  UNITS = ('', 'k', 'm', 'g', 't', 'p', 'e', 'z', 'y')
  unit = 0
  while number >= 1024.:
    unit += 1
    number = number / 1024.
    if unit == len(UNITS) - 1:
      break
  if unit:
    return '%.2f%s' % (number, UNITS[unit])
  return '%d' % number


def validate_root_service_url(url):
  """"""Raises ValueError if the URL doesn't look like https://<host>.""""""
  schemes = ('https', 'http') if is_local_dev_server() else ('https',)
  parsed = urlparse.urlparse(url)
  if parsed.scheme not in schemes:
    raise ValueError('unsupported protocol %r' % str(parsed.scheme))
  if not parsed.netloc:
    raise ValueError('missing hostname')
  stripped = urlparse.urlunparse((parsed[0], parsed[1], '', '', '', ''))
  if stripped != url:
    raise ValueError('expecting root host URL, e.g. %r)' % str(stripped))


### Time


def utcnow():
  """"""Returns datetime.utcnow(), used for testing.

  Use this function so it can be mocked everywhere.
  """"""
  return datetime.datetime.utcnow()


def time_time():
  """"""Returns the equivalent of time.time() as mocked if applicable.""""""
  return (utcnow() - EPOCH).total_seconds()


def milliseconds_since_epoch(now):
  """"""Returns the number of milliseconds since unix epoch as an int.""""""
  now = now or utcnow()
  return int(round((now - EPOCH).total_seconds() * 1000.))


def datetime_to_rfc2822(dt):
  """"""datetime -> string value for Last-Modified header as defined by RFC2822.""""""
  if not isinstance(dt, datetime.datetime):
    raise TypeError(
        'Expecting datetime object, got %s instead' % type(dt).__name__)
  assert dt.tzinfo is None, 'Expecting UTC timestamp: %s' % dt
  return email_utils.formatdate(datetime_to_timestamp(dt) / 1000000.0)


def datetime_to_timestamp(value):
  """"""Converts UTC datetime to integer timestamp in microseconds since epoch.""""""
  if not isinstance(value, datetime.datetime):
    raise ValueError(
        'Expecting datetime object, got %s instead' % type(value).__name__)
  if value.tzinfo is not None:
    raise ValueError('Only UTC datetime is supported')
  dt = value - EPOCH
  return dt.microseconds + 1000 * 1000 * (dt.seconds + 24 * 3600 * dt.days)


def timestamp_to_datetime(value):
  """"""Converts integer timestamp in microseconds since epoch to UTC datetime.""""""
  if not isinstance(value, (int, long, float)):
    raise ValueError(
        'Expecting a number, got %s instead' % type(value).__name__)
  return EPOCH + datetime.timedelta(microseconds=value)


### Cache


class _Cache(object):
  """"""Holds state of a cache for cache_with_expiration and cache decorators.

  May call func more than once.
  Thread- and NDB tasklet-safe.
  """"""

  def __init__(self, func, expiration_sec):
    self.func = func
    self.expiration_sec = expiration_sec
    self.lock = threading.Lock()
    self.value = None
    self.value_is_set = False
    self.expires = None

  def get_value(self):
    """"""Returns a cached value refreshing it if it has expired.""""""
    with self.lock:
      if self.value_is_set and (not self.expires or time_time() < self.expires):
        return self.value

    new_value = self.func()

    with self.lock:
      self.value = new_value
      self.value_is_set = True
      if self.expiration_sec:
        self.expires = time_time() + self.expiration_sec

    return self.value

  def clear(self):
    """"""Clears stored cached value.""""""
    with self.lock:
      self.value = None
      self.value_is_set = False
      self.expires = None

  def get_wrapper(self):
    """"""Returns a callable object that can be used in place of |func|.

    It's basically self.get_value, updated by functools.wraps to look more like
    original function.
    """"""
    # functools.wraps doesn't like 'instancemethod', use lambda as a proxy.
    # pylint: disable=W0108
    wrapper = functools.wraps(self.func)(lambda: self.get_value())
    wrapper.__parent_cache__ = self
    return wrapper


def cache(func):
  """"""Decorator that implements permanent cache of a zero-parameter function.""""""
  return _Cache(func, None).get_wrapper()


def cache_with_expiration(expiration_sec):
  """"""Decorator that implements in-memory cache for a zero-parameter function.""""""
  def decorator(func):
    return _Cache(func, expiration_sec).get_wrapper()
  return decorator


def clear_cache(func):
  """"""Given a function decorated with @cache, resets cached value.""""""
  func.__parent_cache__.clear()


# ignore time parameter warning | pylint: disable=redefined-outer-name
def memcache_async(key, key_args=None, time=None):
  """"""Decorator that implements memcache-based cache for a function.

  The generated cache key contains current application version and values of
  |key_args| arguments converted to string using `repr`.

  Args:
    key (str): unique string that will be used as a part of cache key.
    key_args (list of str): list of function argument names to include
      in the generated cache key.
    time (int): optional expiration time.

  Example:
    @memcache('f', ['a', 'b'])
    def f(a, b=2, not_used_in_cache_key=6):
      # Heavy computation
      return 42

  Decorator raises:
    NotImplementedError if function uses varargs or kwargs.
  """"""
  assert isinstance(key, basestring), key
  key_args = key_args or []
  assert isinstance(key_args, list), key_args
  assert all(isinstance(a, basestring) for a in key_args), key_args
  assert all(key_args), key_args

  memcache_set_kwargs = {}
  if time is not None:
    memcache_set_kwargs['time'] = time

  def decorator(func):
    unwrapped = func
    while True:
      deeper = getattr(unwrapped, '__wrapped__', None)
      if not deeper:
        break
      unwrapped = deeper

    argspec = inspect.getargspec(unwrapped)
    if argspec.varargs:
      raise NotImplementedError(
          'varargs in memcached functions are not supported')
    if argspec.keywords:
      raise NotImplementedError(
          'kwargs in memcached functions are not supported')

    # List of arg names and indexes. Has same order as |key_args|.
    arg_indexes = []
    for name in key_args:
      try:
        i = argspec.args.index(name)
      except ValueError:
        raise KeyError(
            'key_format expects ""%s"" parameter, but it was not found among '
            'function parameters' % name)
      arg_indexes.append((name, i))

    @functools.wraps(func)
    @ndb.tasklet
    def decorated(*args, **kwargs):
      arg_values = []
      for name, i in arg_indexes:
        if i < len(args):
          arg_value = args[i]
        elif name in kwargs:
          arg_value = kwargs[name]
        else:
          # argspec.defaults contains _last_ default values, so we need to shift
          # |i| left.
          default_value_index = i - (len(argspec.args) - len(argspec.defaults))
          if default_value_index < 0:
            # Parameter not provided. Call function to cause TypeError
            func(*args, **kwargs)
            assert False, 'Function call did not fail'
          arg_value = argspec.defaults[default_value_index]
        arg_values.append(arg_value)

      # Instead of putting a raw value to memcache, put tuple (value,)
      # so we can distinguish a cached None value and absence of the value.

      cache_key = 'utils.memcache/%s/%s%s' % (
          get_app_version(), key, repr(arg_values))

      ctx = ndb.get_context()
      result = yield ctx.memcache_get(cache_key)
      if isinstance(result, tuple) and len(result) == 1:
        raise ndb.Return(result[0])

      result = func(*args, **kwargs)
      if isinstance(result, ndb.Future):
        result = yield result
      yield ctx.memcache_set(cache_key, (result,), **memcache_set_kwargs)
      raise ndb.Return(result)

    return decorated
  return decorator


def memcache(*args, **kwargs):
  """"""Blocking version of memcache_async.""""""
  decorator_async = memcache_async(*args, **kwargs)
  def decorator(func):
    decorated_async = decorator_async(func)
    @functools.wraps(func)
    def decorated(*args, **kwargs):
      return decorated_async(*args, **kwargs).get_result()
    return decorated
  return decorator


@cache
def get_app_version():
  """"""Returns currently running version (not necessary a default one).""""""
  # Sadly, this causes an RPC and when called too frequently, throws quota
  # errors.
  return modules.get_current_version_name() or 'N/A'


@cache
def get_versioned_hosturl():
  """"""Returns the url hostname of this instance locked to the currently running
  version.

  This function hides the fact that app_identity.get_default_version_hostname()
  returns None on the dev server and modules.get_hostname() returns incorrectly
  qualified hostname for HTTPS usage on the prod server. <3
  """"""
  if is_local_dev_server():
    # TODO(maruel): It'd be nice if it were easier to use a ephemeral SSL
    # certificate here and not assume unsecured connection.
    return 'http://' + modules.get_hostname()

  return 'https://%s-dot-%s' % (
      get_app_version(), app_identity.get_default_version_hostname())


@cache
def get_urlfetch_service_id():
  """"""Returns a value for X-URLFetch-Service-Id header for GAE <-> GAE calls.

  Usually it can be omitted. It is required in certain environments.
  """"""
  if is_local_dev_server():
    return 'LOCAL'
  hostname = app_identity.get_default_version_hostname().split('.')
  return hostname[-2].upper() if len(hostname) >= 3 else 'APPSPOT'


@cache
def get_app_revision_url():
  """"""Returns URL of a git revision page for currently running app version.

  Works only for non-tainted versions uploaded with tools/update.py: app version
  should look like '162-efaec47'. Assumes all services that use 'components'
  live in a single repository.

  Returns None if a version is tainted or has unexpected name.
  """"""
  rev = re.match(r'\d+-([a-f0-9]+)$', get_app_version())
  template = 'https://chromium.googlesource.com/infra/luci/luci-py/+/%s'
  return template % rev.group(1) if rev else None


@cache
def get_service_account_name():
  """"""Same as app_identity.get_service_account_name(), but caches the result.

  app_identity.get_service_account_name() does an RPC on each call, yet the
  result is always the same.
  """"""
  return app_identity.get_service_account_name()


### Task queue


@cache
def get_task_queue_host():
  """"""Returns domain name of app engine instance to run a task queue task on.

  By default will use 'backend' module. Can be changed by calling
  set_task_queue_module during application startup.

  This domain name points to a matching version of appropriate app engine
  module - <version>.<module>.<app-id>.appspot.com where:
    version: version of the module that is calling this function.
    module: app engine module to execute task on.

  That way a task enqueued from version 'A' of default module would be executed
  on same version 'A' of backend module.
  """"""
  # modules.get_hostname sometimes fails with unknown internal error.
  # Cache its result in a memcache to avoid calling it too often.
  cache_key = 'task_queue_host:%s:%s' % (_task_queue_module, get_app_version())
  value = gae_memcache.get(cache_key)
  if not value:
    value = modules.get_hostname(module=_task_queue_module)
    gae_memcache.set(cache_key, value)
  return value


def set_task_queue_module(module):
  """"""Changes a module used by get_task_queue_host() function.

  Should be called during application initialization if default 'backend' module
  is not appropriate.
  """"""
  global _task_queue_module
  _task_queue_module = module
  clear_cache(get_task_queue_host)


@ndb.tasklet
def enqueue_task_async(
    url,
    queue_name,
    params=None,
    payload=None,
    name=None,
    countdown=None,
    use_dedicated_module=True,
    transactional=False):
  """"""Adds a task to a task queue.

  If |use_dedicated_module| is True (default) the task will be executed by
  a separate backend module instance that runs same version as currently
  executing instance. Otherwise it will run on a current version of default
  module.

  Returns True if the task was successfully added or a task with such name
  existed before (i.e. on TombstonedTaskError exception): deduplicated task is
  not a error.

  Logs an error and returns False if task queue is acting up.
  """"""
  try:
    headers = None
    if use_dedicated_module:
      headers = {'Host': get_task_queue_host()}
    # Note that just using 'target=module' here would redirect task request to
    # a default version of a module, not the curently executing one.
    task = taskqueue.Task(
        url=url,
        params=params,
        payload=payload,
        name=name,
        countdown=countdown,
        headers=headers)
    yield task.add_async(queue_name=queue_name, transactional=transactional)
    raise ndb.Return(True)
  except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError):
    logging.info(
        'Task %r deduplicated (already exists in queue %r)',
        name, queue_name)
    raise ndb.Return(True)
  except (
      taskqueue.Error,
      runtime.DeadlineExceededError,
      runtime.apiproxy_errors.CancelledError,
      runtime.apiproxy_errors.DeadlineExceededError,
      runtime.apiproxy_errors.OverQuotaError) as e:
    logging.warning(
        'Problem adding task %r to task queue %r (%s): %s',
        url, queue_name, e.__class__.__name__, e)
    raise ndb.Return(False)


def enqueue_task(*args, **kwargs):
  """"""Adds a task to a task queue.

  Returns:
    True if the task was enqueued, False otherwise.
  """"""
  return enqueue_task_async(*args, **kwargs).get_result()


## JSON


def to_json_encodable(data):
  """"""Converts data into json-compatible data.""""""
  if isinstance(data, messages.Message):
    # protojson.encode_message returns a string that is already encoded json.
    # Load it back into a json-compatible representation of the data.
    return json.loads(protojson.encode_message(data))
  if isinstance(data, unicode) or data is None:
    return data
  if isinstance(data, str):
    return data.decode('utf-8')
  if isinstance(data, (int, float, long)):
    # Note: overflowing is an issue with int and long.
    return data
  if isinstance(data, (list, set, tuple)):
    return [to_json_encodable(i) for i in data]
  if isinstance(data, dict):
    assert all(isinstance(k, basestring) for k in data), data
    return {
      to_json_encodable(k): to_json_encodable(v) for k, v in data.iteritems()
    }

  if isinstance(data, datetime.datetime):
    # Convert datetime objects into a string, stripping off milliseconds. Only
    # accept naive objects.
    if data.tzinfo is not None:
      raise ValueError('Can only serialize naive datetime instance')
    return data.strftime(DATETIME_FORMAT)
  if isinstance(data, datetime.date):
    return data.strftime(DATE_FORMAT)
  if isinstance(data, datetime.timedelta):
    # Convert timedelta into seconds, stripping off milliseconds.
    return int(data.total_seconds())

  if hasattr(data, 'to_dict') and callable(data.to_dict):
    # This takes care of ndb.Model.
    return to_json_encodable(data.to_dict())

  if hasattr(data, 'urlsafe') and callable(data.urlsafe):
    # This takes care of ndb.Key.
    return to_json_encodable(data.urlsafe())

  if inspect.isgenerator(data) or isinstance(data, xrange):
    # Handle it like a list. Sadly, xrange is not a proper generator so it has
    # to be checked manually.
    return [to_json_encodable(i) for i in data]

  assert False, 'Don\'t know how to handle %r' % data


def encode_to_json(data):
  """"""Converts any data as a json string.""""""
  return json.dumps(
      to_json_encodable(data),
      sort_keys=True,
      separators=(',', ':'),
      encoding='utf-8')


## General


def get_token_fingerprint(blob):
  """"""Given a blob with a token returns first 16 bytes of its SHA256 as hex.

  It can be used to identify this particular token in logs without revealing it.
  """"""
  assert isinstance(blob, basestring)
  if isinstance(blob, unicode):
    blob = blob.encode('ascii', 'ignore')
  return binascii.hexlify(hashlib.sha256(blob).digest()[:16])


## Hacks


def fix_protobuf_package():
  """"""Modifies 'google' package to include path to 'google.protobuf' package.

  Prefer our own proto package on the server. Note that this functions is not
  used on the Swarming bot nor any other client.
  """"""
  # google.__path__[0] will be google_appengine/google.
  import google
  if len(google.__path__) > 1:
    return

  # We do not mind what 'google' get used, inject protobuf in there.
  path = os.path.join(THIS_DIR, 'third_party', 'protobuf', 'google')
  google.__path__.append(path)

  # six is needed for oauth2client and webtest (local testing).
  six_path = os.path.join(THIS_DIR, 'third_party', 'six')
  if six_path not in sys.path:
    sys.path.insert(0, six_path)


def import_jinja2():
  """"""Remove any existing jinja2 package and add ours.""""""
  for i in sys.path[:]:
    if os.path.basename(i) == 'jinja2':
      sys.path.remove(i)
  sys.path.append(os.path.join(THIS_DIR, 'third_party'))


def sync_of(async_fn):
  """"""Returns a synchronous version of an asynchronous function.""""""
  is_static_method = isinstance(async_fn, staticmethod)
  is_class_method = isinstance(async_fn, classmethod)
  if is_static_method or is_class_method:
    async_fn = async_fn.__func__

  @functools.wraps(async_fn)
  def sync(*args, **kwargs):
    return async_fn(*args, **kwargs).get_result()

  if is_static_method:
    sync = staticmethod(sync)
  elif is_class_method:
    sync = classmethod(sync)
  return sync
/n/n/nappengine/isolate/handlers_frontend.py/n/n# Copyright 2012 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""This module defines Isolate Server frontend url handlers.""""""

import collections
import datetime
import json
import logging

import webapp2

import cloudstorage
from google.appengine.api import modules

import acl
import config
import gcs
import handlers_endpoints_v1
import mapreduce_jobs
import model
import stats
import template
from components import auth
from components import stats_framework
from components import stats_framework_gviz
from components import utils
from gviz import gviz_api


# GViz data description.
_GVIZ_DESCRIPTION = {
  'failures': ('number', 'Failures'),
  'requests': ('number', 'Total'),
  'other_requests': ('number', 'Other'),
  'uploads': ('number', 'Uploads'),
  'uploads_bytes': ('number', 'Uploaded'),
  'downloads': ('number', 'Downloads'),
  'downloads_bytes': ('number', 'Downloaded'),
  'contains_requests': ('number', 'Lookups'),
  'contains_lookups': ('number', 'Items looked up'),
}

# Warning: modifying the order here requires updating templates/stats.html.
_GVIZ_COLUMNS_ORDER = (
  'key',
  'requests',
  'other_requests',
  'failures',
  'uploads',
  'downloads',
  'contains_requests',
  'uploads_bytes',
  'downloads_bytes',
  'contains_lookups',
)

_ISOLATED_ROOT_MEMBERS = (
  'algo',
  'command',
  'files',
  'includes',
  'read_only',
  'relative_cwd',
  'version',
)


### Restricted handlers


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    self.common(None)

  @staticmethod
  def cast_to_type(param_name, value):
    def to_bool(value):
      if type(value) is bool:
        return value
      return {'True': True, 'False': False}.get(value, False)

    cast = {
        'enable_ts_monitoring': to_bool,
    }.get(param_name, str)
    return cast(value)

  @auth.require(auth.is_admin)
  def post(self):
    # Convert MultiDict into a dict.
    params = {
      k: self.cast_to_type(k, self.request.params.getone(k))
      for k in self.request.params
      if k not in ('keyid', 'xsrf_token')
    }
    cfg = config.settings(fresh=True)
    keyid = int(self.request.get('keyid', '0'))
    if cfg.key.integer_id() != keyid:
      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))
      return
    cfg.populate(**params)
    try:
      # Ensure key is correct, it's easy to make a mistake when creating it.
      gcs.URLSigner.load_private_key(cfg.gs_private_key)
    except Exception as exc:
      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)
      self.response.write('Bad private key: %s' % exc)
      return
    cfg.store(updated_by=auth.get_current_identity().to_bytes())
    self.common('Settings updated')

  def common(self, note):
    params = config.settings_info()
    params.update({
        'note': note,
        'path': self.request.path,
        'xsrf_token': self.generate_xsrf_token(),
    })
    self.response.write(
        template.render('isolate/restricted_config.html', params))


class RestrictedPurgeHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    params = {
      'digest': '',
      'message': '',
      'namespace': '',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('isolate/restricted_purge.html', params))

  @auth.require(auth.is_admin)
  def post(self):
    namespace = self.request.get('namespace')
    digest = self.request.get('digest')
    params = {
      'digest': digest,
      'message': '',
      'namespace': namespace,
      'xsrf_token': self.generate_xsrf_token(),
    }
    try:
      key = model.get_entry_key(namespace, digest)
    except ValueError as e:
      params['message'] = 'Invalid entry: %s' % e
      key = None
    if key:
      model.delete_entry_and_gs_entry([key])
      params['message'] = 'Done'
    self.response.write(
        template.render('isolate/restricted_purge.html', params))


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(auth.is_admin)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    # Do not use 'backend' module when running from dev appserver. Mapreduce
    # generates URLs that are incompatible with dev appserver URL routing when
    # using custom modules.
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=not utils.is_local_dev_server())
    # New tasks should show up on the status page.
    if success:
      self.redirect('/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Non-restricted handlers


class BrowseHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    # Support 'hash' for compatibility with old links. To remove eventually.
    digest = self.request.get('digest', '') or self.request.get('hash', '')
    save_as = self.request.get('as', '')
    params = {
      u'as': unicode(save_as),
      u'digest': unicode(digest),
      u'namespace': unicode(namespace),
    }
    # Check for existence of element, so we can 400/404
    if digest and namespace:
      try:
        model.get_content(namespace, digest)
      except ValueError:
        self.abort(400, 'Invalid key')
      except LookupError:
        self.abort(404, 'Unable to retrieve the entry')
    self.response.write(template.render('isolate/browse.html', params))

  def get_content_security_policy(self):
    csp = super(BrowseHandler, self).get_content_security_policy()
    csp.setdefault('child-src', []).append(""'self'"")
    return csp


class ContentHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    digest = self.request.get('digest', '')
    content = None
    if not digest:
      self.abort(400, 'Missing digest')
    if not namespace:
      self.abort(400, 'Missing namespace')

    try:
      raw_data, entity = model.get_content(namespace, digest)
    except ValueError:
      self.abort(400, 'Invalid key')
    except LookupError:
      self.abort(404, 'Unable to retrieve the entry')

    logging.info('%s', entity)
    if not raw_data:
      try:
        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())
        content = ''.join(model.expand_content(namespace, stream))
      except cloudstorage.NotFoundError:
        logging.error('Entity in DB but not in GCS: deleting entity in DB')
        entity.key.delete()
        self.abort(404, 'Unable to retrieve the file from GCS')
    else:
      content = ''.join(model.expand_content(namespace, [raw_data]))

    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    # We delete Content-Type before storing to it to avoid having two (yes,
    # two) Content-Type headers.
    del self.response.headers['Content-Type']

    # Apparently, setting the content type to text/plain encourages the
    # browser (Chrome, at least) to sniff the mime type and display
    # things like images.  Images are autowrapped in <img> and text is
    # wrapped in <pre>.
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'

    # App Engine puts a limit of 33554432 bytes on a request, which includes
    # headers. Headers are ~150 bytes.  If the content + headers might
    # exceed that limit, we give the user an option to workround getting
    # their file.
    if len(content) > 33554000:
      host = modules.get_hostname(module='default', version='default')
      # host is something like default.default.myisolateserver.appspot.com
      host = host.replace('default.default.','')
      sizeInMib = len(content) / (1024.0 * 1024.0)
      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'
      ' App Engine limit.\nTo work around this, run the following command:\n'
      '    python isolateserver.py download -I %s --namespace %s -f %s %s'
      % (sizeInMib, host, namespace, digest, digest))
    else:
      self.response.headers['Content-Disposition'] = str(
        'filename=%s' % self.request.get('as') or digest)
      try:
        json_data = json.loads(content)
        if self._is_isolated_format(json_data):
          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
          json_data['files'] = collections.OrderedDict(
            sorted(
              json_data['files'].items(),
              key=lambda (filepath, data): filepath))
          params = {
            'namespace': namespace,
            'isolated': json_data,
          }
          content = template.render('isolate/isolated.html', params)
      except ValueError:
        pass

    self.response.write(content)

  @staticmethod
  def _is_isolated_format(json_data):
    """"""Checks if json_data is a valid .isolated format.""""""
    if not isinstance(json_data, dict):
      return False
    actual = set(json_data)
    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual


class StatsHandler(webapp2.RequestHandler):
  """"""Returns the statistics web page.""""""
  def get(self):
    """"""Presents nice recent statistics.

    It fetches data from the 'JSON' API.
    """"""
    # Preloads the data to save a complete request.
    resolution = self.request.params.get('resolution', 'hours')
    if resolution not in ('days', 'hours', 'minutes'):
      resolution = 'hours'
    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)

    description = _GVIZ_DESCRIPTION.copy()
    description.update(stats_framework_gviz.get_description_key(resolution))
    table = stats_framework.get_stats(
        stats.STATS_HANDLER, resolution, None, duration, True)
    params = {
      'duration': duration,
      'initial_data': gviz_api.DataTable(description, table).ToJSon(
          columns_order=_GVIZ_COLUMNS_ORDER),
      'now': datetime.datetime.utcnow(),
      'resolution': resolution,
    }
    self.response.write(template.render('isolate/stats.html', params))


class StatsGvizHandlerBase(webapp2.RequestHandler):
  RESOLUTION = None

  def get(self):
    description = _GVIZ_DESCRIPTION.copy()
    description.update(
        stats_framework_gviz.get_description_key(self.RESOLUTION))
    try:
      stats_framework_gviz.get_json(
          self.request,
          self.response,
          stats.STATS_HANDLER,
          self.RESOLUTION,
          description,
          _GVIZ_COLUMNS_ORDER)
    except ValueError as e:
      self.abort(400, str(e))


class StatsGvizDaysHandler(StatsGvizHandlerBase):
  RESOLUTION = 'days'


class StatsGvizHoursHandler(StatsGvizHandlerBase):
  RESOLUTION = 'hours'


class StatsGvizMinutesHandler(StatsGvizHandlerBase):
  RESOLUTION = 'minutes'


###  Public pages.


class RootHandler(auth.AuthenticatingHandler):
  """"""Tells the user to RTM.""""""

  @auth.public
  def get(self):
    params = {
      'is_admin': auth.is_admin(),
      'is_user': acl.isolate_readable(),
      'mapreduce_jobs': [],
      'user_type': acl.get_user_type(),
    }
    if auth.is_admin():
      params['mapreduce_jobs'] = [
        {'id': job_id, 'name': job_def['job_name']}
        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()
      ]
      params['xsrf_token'] = self.generate_xsrf_token()
    self.response.write(template.render('isolate/root.html', params))


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.
  """"""
  @auth.public
  def get(self):
    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'isolate/public_isolate_index.html', params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    config.warmup()
    auth.warmup()
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # AppEngine-specific urls:
      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),
      webapp2.Route(r'/_ah/warmup', WarmupHandler),
  ]
  if not utils.should_disable_ui_routes():
    routes.extend([
      # Administrative urls.
      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),
      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),

      # Mapreduce related urls.
      webapp2.Route(
          r'/restricted/launch_mapreduce',
          RestrictedLaunchMapReduceJob),

      # User web pages.
      webapp2.Route(r'/browse', BrowseHandler),
      webapp2.Route(r'/content', ContentHandler),
      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz
      # is just too sorry.
      #webapp2.Route(r'/stats', StatsHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),
      webapp2.Route(r'/', RootHandler),
      webapp2.Route(r'/newui', UIHandler),
    ])
  routes.extend(handlers_endpoints_v1.get_routes())
  return routes


def create_application(debug):
  """"""Creates the url router.

  The basic layouts is as follow:
  - /restricted/.* requires being an instance administrator.
  - /stats/.* has statistics.
  """"""
  acl.bootstrap()
  template.bootstrap()
  return webapp2.WSGIApplication(get_routes(), debug=debug)
/n/n/nappengine/machine_provider/handlers_frontend.py/n/n# Copyright 2016 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Front-end UI.""""""

import logging
import os

import webapp2

from components import auth
from components import datastore_utils
from components import template
from components import utils

import handlers_endpoints
import models


THIS_DIR = os.path.dirname(os.path.abspath(__file__))


class CatalogHandler(auth.AuthenticatingHandler):
  """"""Catalog handler.""""""

  @auth.require(auth.is_admin)
  def get(self, machine_id=None):
    params = {
        'machines': [],
        'next_page_token': None,
    }
    if machine_id:
      machine = models.CatalogMachineEntry.get_by_id(machine_id)
      if not machine:
        self.abort(404)
      params['machines'] = [machine]
    else:
      query = models.CatalogMachineEntry.query().order(
          models.CatalogMachineEntry.dimensions.hostname)
      page_token = self.request.get('page_token') or ''
      params['machines'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(
        template.render('templates/catalog.html', params=params))


class LeaseRequestHandler(auth.AuthenticatingHandler):
  """"""Lease request handler.""""""

  @auth.require(auth.is_admin)
  def get(self, lease_id=None):
    params = {
        'lease_requests': [],
        'next_page_token': None,
        'now_ts': utils.time_time(),
    }
    if lease_id:
      lease_request = models.LeaseRequest.get_by_id(lease_id)
      if not lease_request:
        self.abort(404)
      params['lease_requests'] = [lease_request]
    else:
      query = models.LeaseRequest.query().order(
          -models.LeaseRequest.last_modified_ts)
      page_token = self.request.get('page_token') or ''
      params['lease_requests'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(template.render('templates/leases.html', params=params))


class RootHandler(auth.AuthenticatingHandler):
  """"""Root handler.""""""

  @auth.public
  def get(self):
    params = {
        'is_admin': auth.is_admin(),
    }

    self.response.write(template.render('templates/root.html', params=params))


def get_routes():
  return [
      webapp2.Route('/', handler=RootHandler),
      webapp2.Route('/catalog', handler=CatalogHandler),
      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),
      webapp2.Route('/leases', handler=LeaseRequestHandler),
      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),
  ]


def create_frontend_app():
  template.bootstrap({
      'templates': os.path.join(THIS_DIR, 'templates'),
  })
  routes = []
  if not utils.should_disable_ui_routes():
    routes.extend(get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes)
/n/n/nappengine/swarming/handlers_frontend.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Main entry point for Swarming service.

This file contains the URL handlers for all the Swarming service URLs,
implemented using the webapp2 framework.
""""""

import collections
import os

import webapp2

import handlers_bot
import handlers_endpoints
import mapreduce_jobs
import template
from components import auth
from components import utils
from server import acl
from server import bot_code
from server import config


ROOT_DIR = os.path.dirname(os.path.abspath(__file__))


# Helper class for displaying the sort options in html templates.
SortOptions = collections.namedtuple('SortOptions', ['key', 'name'])


### is_admin pages.


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    # Template parameters schema matches settings_info() return value.
    self.response.write(template.render(
        'swarming/restricted_config.html', config.settings_info()))


class UploadBotConfigHandler(auth.AuthenticatingHandler):
  """"""Stores a new bot_config.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bot_config = bot_code.get_bot_config()
    params = {
      'content': bot_config.content.decode('utf-8'),
      'path': self.request.path,
      'version': bot_config.version,
      'when': bot_config.when,
      'who': bot_config.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bot_config.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bot_config(self.request.host_url, script)
    self.get()


class UploadBootstrapHandler(auth.AuthenticatingHandler):
  """"""Stores a new bootstrap.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bootstrap = bot_code.get_bootstrap(self.request.host_url)
    params = {
      'content': bootstrap.content.decode('utf-8'),
      'path': self.request.path,
      'version': bootstrap.version,
      'when': bootstrap.when,
      'who': bootstrap.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bootstrap.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bootstrap(script)
    self.get()


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(acl.can_edit_config)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=False)
    # New tasks should show up on the status page.
    if success:
      self.redirect('/restricted/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Redirectors.


class BotsListHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of known bots.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))

    dimensions = (
      l.strip() for l in self.request.get('dimensions', '').splitlines()
    )
    dimensions = [i for i in dimensions if i]

    new_ui_link = '/botlist?l=%d' % limit
    if dimensions:
      new_ui_link += '&f=' + '&f='.join(dimensions)

    self.redirect(new_ui_link)


class BotHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page about the bot, including last tasks and events.""""""

  @auth.public
  def get(self, bot_id):
    self.redirect('/bot?id=%s' % bot_id)


class TasksHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of all task requests.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))
    task_tags = [
      line for line in self.request.get('task_tag', '').splitlines() if line
    ]

    new_ui_link = '/tasklist?l=%d' % limit
    if task_tags:
      new_ui_link += '&f=' + '&f='.join(task_tags)

    self.redirect(new_ui_link)


class TaskHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page containing task request and result.""""""

  @auth.public
  def get(self, task_id):
    self.redirect('/task?id=%s' % task_id)


### Public pages.


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.""""""
  @auth.public
  def get(self, page):
    if not page:
      page = 'swarming'

    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'swarming/public_%s_index.html' % page, params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')

  def get_content_security_policy(self):
    # We use iframes to display pages at display_server_url_template. Need to
    # allow it in CSP.
    csp = super(UIHandler, self).get_content_security_policy()
    tmpl = config.settings().display_server_url_template
    if tmpl:
      if tmpl.startswith('/'):
        csp['child-src'].append(""'self'"")
      else:
        # We assume the template specifies '%s' in its last path component.
        # We strip it to get a ""parent"" path that we can put into CSP. Note that
        # whitelisting an entire display server domain is unnecessary wide.
        assert tmpl.startswith('https://'), tmpl
        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])
    return csp


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    auth.warmup()
    bot_code.get_swarming_bot_zip(self.request.host_url)
    utils.get_module_version_list(None, None)
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      ('/_ah/mail/<to:.+>', EmailHandler),
      ('/_ah/warmup', WarmupHandler),
  ]

  if not utils.should_disable_ui_routes():
    routes.extend([
      # Frontend pages. They return HTML.
      # Public pages.
      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),

      # Redirects to Polymer UI
      ('/user/tasks', TasksHandler),
      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),
      ('/restricted/bots', BotsListHandler),
      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),

      # Admin pages.
      # TODO(maruel): Get rid of them.
      ('/restricted/config', RestrictedConfigHandler),
      ('/restricted/upload/bot_config', UploadBotConfigHandler),
      ('/restricted/upload/bootstrap', UploadBootstrapHandler),

      # Mapreduce related urls.
      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),
    ])

  return [webapp2.Route(*i) for i in routes]


def create_application(debug):
  routes = []
  routes.extend(get_routes())
  routes.extend(handlers_bot.get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes, debug=debug)
/n/n/n",0
85,481a3e8120787d449ad7bbc6a627d8450bceb85c,"/appengine/components/components/auth/ui/ui.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Auth management UI handlers.""""""

import functools
import json
import os
import re
import webapp2

from components import template
from components import utils

from . import acl
from . import rest_api

from .. import api
from .. import change_log
from .. import handler
from .. import model
from .. import replication


# templates/.
TEMPLATES_DIR = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), 'templates')


# Global static configuration set in 'configure_ui'.
_ui_app_name = 'Unknown'
_ui_data_callback = None
_ui_navbar_tabs = ()


def configure_ui(app_name, ui_tabs=None, ui_data_callback=None):
  """"""Modifies global configuration of Auth UI.

  Args:
    app_name: name of the service (visible in page headers, titles, etc.)
    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or
        None to show the standard set of tabs.
    ui_data_callback: an argumentless callable that returns a dict with
        additional data to return to authenticated users. It can be used by
        server and client side code to render templates. Used by auth_service.
  """"""
  global _ui_app_name
  global _ui_data_callback
  global _ui_navbar_tabs
  _ui_app_name = app_name
  _ui_data_callback = ui_data_callback
  if ui_tabs is not None:
    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)
    _ui_navbar_tabs = tuple(ui_tabs)
  template.bootstrap({'auth': TEMPLATES_DIR})


def get_ui_routes():
  """"""Returns a list of routes with auth UI handlers.""""""
  # Routes for registered navbar tabs.
  routes = []
  for cls in _ui_navbar_tabs:
    routes.extend(cls.get_webapp2_routes())
  # Routes for everything else.
  routes.extend([
    webapp2.Route(r'/auth', MainHandler),
    webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),
    webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),
    webapp2.Route(r'/auth/link', LinkToPrimaryHandler),
  ])
  return routes


def forbid_ui_on_replica(method):
  """"""Decorator for methods that are not allowed to be called on Replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 405 ""Method Not Allowed"".
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      self.abort(
          405,
          detail='Not allowed on a replica, see primary at %s' % primary_url)
    return method(self, *args, **kwargs)
  return wrapper


def redirect_ui_on_replica(method):
  """"""Decorator for methods that redirect to Primary when called on replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 302 redirect to corresponding method on Primary.
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    assert self.request.method == 'GET'
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      protocol = 'http://' if utils.is_local_dev_server() else 'https://'
      assert primary_url and primary_url.startswith(protocol), primary_url
      assert self.request.path_qs.startswith('/'), self.request.path_qs
      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)
    return method(self, *args, **kwargs)
  return wrapper


################################################################################
## Admin routes. The use cookies and GAE's ""is_current_user_admin"" for authn.


class AdminPageHandler(handler.AuthenticatingHandler):
  """"""Base class for handlers involved in bootstrap processes.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  @classmethod
  def get_auth_methods(cls, conf):
    # This method sets 'is_superuser' bit for GAE-level admins.
    return [handler.gae_cookie_authentication]

  def reply(self, path, env=None, status=200):
    """"""Render template |path| to response using given environment.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    full_env = {
      'app_name': _ui_app_name,
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html
      'xsrf_token': self.generate_xsrf_token(),
    }
    full_env.update(env or {})
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=403)


class BootstrapHandler(AdminPageHandler):
  """"""Creates Administrators group (if necessary) and adds current caller to it.

  Requires Appengine level Admin access for its handlers, since Administrators
  group may not exist yet.

  Used during bootstrap of a new service instance.
  """"""

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'return_url': self.request.get('r') or '',
    }
    self.reply('auth/admin/bootstrap.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    added = model.bootstrap_group(
        model.ADMIN_GROUP, [api.get_current_identity()],
        'Users that can manage groups')
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'added': added,
      'return_url': self.request.get('return_url') or '',
    }
    self.reply('auth/admin/bootstrap_done.html', env)


class BootstrapOAuthHandler(AdminPageHandler):
  """"""Page to set OAuth2 client ID used by the main web UI.

  Requires Appengine level Admin access for its handlers, since without client
  ID there's no UI yet to configure Administrators group.

  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is
  also available after the service is linked to some primary Auth service.
  """"""

  @api.require(api.is_superuser)
  def get(self):
    self.show_page(web_client_id=api.get_web_client_id_uncached())

  @api.require(api.is_superuser)
  def post(self):
    web_client_id = self.request.POST['web_client_id']
    api.set_web_client_id(web_client_id)
    self.show_page(web_client_id=web_client_id, saved=True)

  def show_page(self, web_client_id, saved=False):
    env = {
      'page_title': 'OAuth2 web client ID',
      'web_client_id': web_client_id or '',
      'saved': saved,
    }
    self.reply('auth/admin/bootstrap_oauth.html', env)


class LinkToPrimaryHandler(AdminPageHandler):
  """"""A page with confirmation of Primary <-> Replica linking request.

  URL to that page is generated by a Primary service.
  """"""

  def decode_link_ticket(self):
    """"""Extracts ServiceLinkTicket from 't' GET parameter.""""""
    try:
      return replication.decode_link_ticket(
          self.request.get('t').encode('ascii'))
    except (KeyError, ValueError):
      self.abort(400)
      return

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    ticket = self.decode_link_ticket()
    env = {
      'generated_by': ticket.generated_by,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
    }
    self.reply('auth/admin/linking.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    ticket = self.decode_link_ticket()
    success = True
    error_msg = None
    try:
      replication.become_replica(ticket, api.get_current_identity())
    except replication.ProtocolError as exc:
      success = False
      error_msg = exc.message
    env = {
      'error_msg': error_msg,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
      'success': success,
    }
    self.reply('auth/admin/linking_done.html', env)


################################################################################
## Web UI routes.

# TODO(vadimsh): Switch them to use OAuth for authentication.


class UIHandler(handler.AuthenticatingHandler):
  """"""Renders Jinja templates extending base.html.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  def reply(self, path, env=None, status=200):
    """"""Renders template |path| to the HTTP response using given environment.

    Optional keys from |env| that base.html uses:
      css_file: URL to a file with page specific styles, relative to site root.
      js_file: URL to a file with page specific Javascript code, relative to
          site root. File should define global object named same as a filename,
          i.e. '/auth/static/js/api.js' should define global object 'api' that
          incapsulates functionality implemented in the module.
      navbar_tab_id: id of a navbar tab to highlight.
      page_title: title of an HTML page.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    env = (env or {}).copy()
    env.setdefault('css_file', None)
    env.setdefault('js_file', None)
    env.setdefault('navbar_tab_id', None)
    env.setdefault('page_title', 'Untitled')

    # This goes to both Jinja2 env and Javascript config object.
    user = self.get_current_user()
    common = {
      'account_picture': user.picture() if user else None,
      'auth_service_config_locked': False, # overridden in auth_service
      'is_admin': api.is_admin(),
      'login_url': self.create_login_url(self.request.url),
      'logout_url': self.create_logout_url('/'),
      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,
      'xsrf_token': self.generate_xsrf_token(),
    }
    if _ui_data_callback:
      common.update(_ui_data_callback())

    # Name of Javascript module with page code.
    js_module_name = None
    if env['js_file']:
      assert env['js_file'].endswith('.js')
      js_module_name = os.path.basename(env['js_file'])[:-3]

    # This will be accessible from Javascript as global 'config' variable.
    js_config = {
      'identity': api.get_current_identity().to_bytes(),
    }
    js_config.update(common)

    # Jinja2 environment to use to render a template.
    full_env = {
      'app_name': _ui_app_name,
      'app_revision_url': utils.get_app_revision_url(),
      'app_version': utils.get_app_version(),
      'config': json.dumps(js_config),
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'js_module_name': js_module_name,
      'navbar': [
        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)
        for cls in _ui_navbar_tabs
        if cls.is_visible()
      ],
    }
    full_env.update(common)
    full_env.update(env)

    # Render it.
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=403)


class MainHandler(UIHandler):
  """"""Redirects to first navbar tab.""""""
  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    assert _ui_navbar_tabs
    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)


class UINavbarTabHandler(UIHandler):
  """"""Handler for a navbar tab page.""""""
  # List of routes to register, default is [navbar_tab_url].
  routes = []
  # URL to the tab (relative to site root).
  navbar_tab_url = None
  # ID of the tab, will be used in DOM.
  navbar_tab_id = None
  # Title of the tab, will be used in tab title and page title.
  navbar_tab_title = None
  # Relative URL to CSS file with tab's styles.
  css_file = None
  # Relative URL to javascript file with tab's logic.
  js_file_url = None
  # Path to a Jinja2 template with tab's markup.
  template_file = None

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self, **_params):
    """"""Renders page HTML to HTTP response stream.""""""
    env = {
      'css_file': self.css_file,
      'js_file': self.js_file_url,
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
    }
    self.reply(self.template_file, env)

  @classmethod
  def get_webapp2_routes(cls):
    routes = cls.routes or [cls.navbar_tab_url]
    return [webapp2.Route(r, cls) for r in routes]

  @classmethod
  def is_visible(cls):
    """"""Subclasses may return False to hide the tab from tab bar.""""""
    return True


################################################################################
## Default tabs.


class GroupsHandler(UINavbarTabHandler):
  """"""Page with Groups management.""""""
  routes = [
    '/auth/groups',
    '/auth/groups/<group:.*>',  # 'group' is handled by js code
  ]
  navbar_tab_url = '/auth/groups'
  navbar_tab_id = 'groups'
  navbar_tab_title = 'Groups'
  css_file = '/auth/static/css/groups.css'
  js_file_url = '/auth/static/js/groups.js'
  template_file = 'auth/groups.html'


class ChangeLogHandler(UINavbarTabHandler):
  """"""Page with a log of changes to some groups.""""""
  navbar_tab_url = '/auth/change_log'
  navbar_tab_id = 'change_log'
  navbar_tab_title = 'Change Log'
  js_file_url = '/auth/static/js/change_log.js'
  template_file = 'auth/change_log.html'

  @classmethod
  def is_visible(cls):
    # Hide 'Change Log' tab if there are no change log indexes in the datastore.
    # It happens on services that use components.auth, but do not modify
    # index.yaml. Don't try too hard to hide the log though. If user happes to
    # stumble on Change log page (e.g. by using direct URL), it handles
    # NeedIndexError gracefully (explaining how to configure indexes).
    return change_log.is_changle_log_indexed()


class OAuthConfigHandler(UINavbarTabHandler):
  """"""Page with OAuth configuration.""""""
  navbar_tab_url = '/auth/oauth_config'
  navbar_tab_id = 'oauth_config'
  navbar_tab_title = 'OAuth'
  js_file_url = '/auth/static/js/oauth_config.js'
  template_file = 'auth/oauth_config.html'


class IPWhitelistsHandler(UINavbarTabHandler):
  """"""Page with IP whitelists configuration.""""""
  navbar_tab_url = '/auth/ip_whitelists'
  navbar_tab_id = 'ip_whitelists'
  navbar_tab_title = 'IP Whitelists'
  js_file_url = '/auth/static/js/ip_whitelists.js'
  template_file = 'auth/ip_whitelists.html'


class ApiDocHandler(UINavbarTabHandler):
  """"""Page with API documentation extracted from rest_api.py.""""""
  navbar_tab_url = '/auth/api'
  navbar_tab_id = 'api'
  navbar_tab_title = 'API'

  # These can be used as 'request_type' and 'response_type' in api_doc.
  doc_types = [
    {
      'name': 'Status',
      'doc': 'Outcome of some operation.',
      'example': {'ok': True},
    },
    {
      'name': 'Self info',
      'doc': 'Information about the requester.',
      'example': {
        'identity': 'user:someone@example.com',
        'ip': '192.168.0.1',
      },
    },
    {
      'name': 'Group',
      'doc': 'Represents a group, as stored in the database.',
      'example': {
        'group': {
          'caller_can_modify': True,
          'created_by': 'user:someone@example.com',
          'created_ts': 1409250754978540,
          'description': 'Some free form description',
          'globs': ['user:*@example.com'],
          'members': ['user:a@example.com', 'anonymous:anonymous'],
          'modified_by': 'user:someone@example.com',
          'modified_ts': 1470871200558130,
          'name': 'Some group',
          'nested': ['Some nested group', 'Another nested group'],
          'owners': 'Owning group',
        },
      },
    },
    {
      'name': 'Group listing',
      'doc':
        'All groups, along with their metadata. Does not include members '
        'listings.',
      'example': {
        'groups': [
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Some free form description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Some group',
            'owners': 'Owning group',
          },
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Another description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Another group',
            'owners': 'Owning group',
          },
        ],
      },
    },
  ]

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    """"""Extracts API doc for registered webapp2 API routes.""""""
    doc_types = []

    def add_doc_type(tp):
      """"""Adds a request or response format definition to the documentation page.

      'tp' can either reference a globally known doc type by name
      (see ApiDocHandler.doc_types), or can itself be a dict with doc type
      definition.

      Returns the name of the doc type.
      """"""
      if not tp:
        return None
      # If referenced by name, try to find it among globally known types.
      if isinstance(tp, basestring):
        for d in self.doc_types:
          if d['name'] == tp:
            tp = d
            break
        else:
          return tp  # not found, return original name as is
      # Add, if not already there. Serialize the example first, since doing it
      # from Jinja is a bit more complicated.
      if not any(d['name'] == tp['name'] for d in doc_types):
        tp = tp.copy()
        tp['example'] = json.dumps(
            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)
        doc_types.append(tp)
      return tp['name']

    api_methods = []
    for route in rest_api.get_rest_api_routes():
      # Remove API parameter regexps from route template, they are mostly noise.
      simplified = re.sub(r'\:.*\>', '>', route.template)
      for doc in getattr(route.handler, 'api_doc', []):
        path = simplified
        if 'params' in doc:
          path += '?' + doc['params']
        api_methods.append({
          'verb': doc['verb'],
          'path': path,
          'doc': doc['doc'],
          'request_type': add_doc_type(doc.get('request_type')),
          'response_type': add_doc_type(doc.get('response_type')),
        })

    env = {
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
      'api_methods': api_methods,
      'doc_types': doc_types,
    }
    self.reply('auth/api.html', env)


# Register them as default tabs. Order is important.
_ui_navbar_tabs = (
  GroupsHandler,
  ChangeLogHandler,
  OAuthConfigHandler,
  IPWhitelistsHandler,
  ApiDocHandler,
)
/n/n/n/appengine/components/components/ereporter2/handlers.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""HTTP Handlers.""""""

import datetime
import itertools
import json
import time

import webapp2

from google.appengine.api import app_identity
from google.appengine.datastore import datastore_query
from google.appengine.ext import ndb

from components import auth
from components import decorators
from components import template
from components import utils

from . import acl
from . import logscraper
from . import models
from . import on_error
from . import ui


# Access to a protected member XXX of a client class - pylint: disable=W0212


### Admin pages.


class RestrictedEreporter2Report(auth.AuthenticatingHandler):
  """"""Returns all the recent errors as a web page.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    """"""Reports the errors logged and ignored.

    Arguments:
      start: epoch time to start looking at. Defaults to the messages since the
             last email.
      end: epoch time to stop looking at. Defaults to now.
      modules: comma separated modules to look at.
      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.
    """"""
    # TODO(maruel): Be consistent about using either epoch or human readable
    # formatted datetime.
    end = int(float(self.request.get('end', 0)) or time.time())
    start = int(
        float(self.request.get('start', 0)) or
        ui._get_default_start_time() or 0)
    modules = self.request.get('modules')
    if modules:
      modules = modules.split(',')
    tainted = bool(int(self.request.get('tainted', '1')))
    module_versions = utils.get_module_version_list(modules, tainted)
    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(
        start, end, module_versions)

    params = {
      'errors': errors,
      'errors_count': sum(len(e.events) for e in errors),
      'errors_version_count':
          len(set(itertools.chain.from_iterable(e.versions for e in errors))),
      'ignored': ignored,
      'ignored_count': sum(len(i.events) for i in ignored),
      'ignored_version_count':
          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),
      'xsrf_token': self.generate_xsrf_token(),
    }
    params.update(ui._get_template_env(start, end, module_versions))
    self.response.write(template.render('ereporter2/requests.html', params))


class RestrictedEreporter2Request(auth.AuthenticatingHandler):
  """"""Dumps information about single logged request.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, request_id):
    data = logscraper._log_request_id(request_id)
    if not data:
      self.abort(404, detail='Request id was not found.')
    self.response.write(
        template.render('ereporter2/request.html', {'request': data}))


class RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    limit = int(self.request.get('limit', 100))
    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))
    errors_found, cursor, more = models.Error.query().order(
        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)
    params = {
      'cursor': cursor.urlsafe() if cursor and more else None,
      'errors': errors_found,
      'limit': limit,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/errors.html', params))


class RestrictedEreporter2Error(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, error_id):
    error = models.Error.get_by_id(int(error_id))
    if not error:
      self.abort(404, 'Error not found')
    params = {
      'error': error,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/error.html', params))


class RestrictedEreporter2Silence(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    # Due to historical reasons where created_ts had indexed=False,, do not use
    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all
    # objects have been updated.
    items = models.ErrorReportingMonitoring.query().fetch()
    items.sort(key=lambda x: x.created_ts)
    params = {
      'silenced': items,
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.out.write(template.render('ereporter2/silence.html', params))

  @auth.require(acl.is_ereporter2_editor)
  def post(self):
    to_delete = self.request.get('to_delete')
    if to_delete:
      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()
    else:
      mute_type = self.request.get('mute_type')
      error = None
      if mute_type in ('exception_type', 'signature'):
        error = self.request.get(mute_type)
      if not error:
        self.abort(400)
      silenced = self.request.get('silenced')
      silenced_until = self.request.get('silenced_until')
      if silenced_until == 'T':
        silenced_until = ''
      threshold = self.request.get('threshold')
      key = models.ErrorReportingMonitoring.error_to_key(error)
      if not silenced and not silenced_until and not threshold:
        key.delete()
      else:
        item = models.ErrorReportingMonitoring(key=key, error=error)
        if silenced:
          item.silenced = True
        if silenced_until:
          item.silenced_until = datetime.datetime.strptime(
              silenced_until, '%Y-%m-%dT%H:%M')
        if threshold:
          item.threshold = int(threshold)
        item.put()

    self.get()


### Cron jobs.


class CronEreporter2Mail(webapp2.RequestHandler):
  """"""Generate and emails an exception report.""""""
  @decorators.require_cronjob
  def get(self):
    """"""Sends email(s) containing the errors logged.""""""
    # Do not use self.request.host_url because it will be http:// and will point
    # to the backend, with an host format that breaks the SSL certificate.
    # TODO(maruel): On the other hand, Google Apps instances are not hosted on
    # appspot.com.
    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()
    request_id_url = host_url + '/restricted/ereporter2/request/'
    report_url = host_url + '/restricted/ereporter2/report'
    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())
    result = ui._generate_and_email_report(
        utils.get_module_version_list(None, False),
        recipients,
        request_id_url,
        report_url,
        {})
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    if result:
      self.response.write('Success.')
    else:
      # Do not HTTP 500 since we do not want it to be retried.
      self.response.write('Failed.')


class CronEreporter2Cleanup(webapp2.RequestHandler):
  """"""Deletes old error reports.""""""
  @decorators.require_cronjob
  def get(self):
    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE
    items = models.Error.query(
        models.Error.created_ts < old_cutoff,
        default_options=ndb.QueryOptions(keys_only=True))
    out = len(ndb.delete_multi(items))
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write(str(out))


### Public API.


class OnErrorHandler(auth.AuthenticatingHandler):
  """"""Adds an error report.

  This one is open so errors like authentication reports are logged in too.
  This means we could get spammed a lot about it. Implement DDoS protection by
  rate limiting once a kid figures out.
  """"""
  xsrf_token_enforce_on = ()

  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be
  # factored out.
  def parse_body(self):
    """"""Parse JSON body and verifies it's a dict.""""""
    expected = ('application/json', 'application/json; charset=utf-8')
    if self.request.headers.get('Content-Type').lower() not in expected:
      msg = 'Expecting JSON body with content type \'application/json\''
      self.abort(400, msg)
    try:
      body = json.loads(self.request.body)
      if not isinstance(body, dict):
        raise ValueError()
    except ValueError:
      self.abort(400, 'Not a valid json dict body')
    return body

  @auth.public
  def post(self):
    body = self.parse_body()
    version = body.get('v')
    # Do not enforce version for now, just assert it is present.
    if not version:
      self.abort(400, 'Missing version')

    report = body.get('r')
    if not report:
      self.abort(400, 'Missing report')

    kwargs = dict(
        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))
    report_id = on_error.log_request(self.request, add_params=False, **kwargs)
    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'
    body = {
      'id': report_id,
      'url':
          '%s/restricted/ereporter2/errors/%d' %
          (self.request.host_url, report_id),
    }
    self.response.write(utils.encode_to_json(body))


def get_frontend_routes():
  return [
    webapp2.Route(
        r'/restricted/ereporter2/errors',
        RestrictedEreporter2ErrorsList),
    webapp2.Route(
        r'/restricted/ereporter2/errors/<error_id:\d+>',
        RestrictedEreporter2Error),
    webapp2.Route(
        r'/restricted/ereporter2/report',
        RestrictedEreporter2Report),
    webapp2.Route(
        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',
        RestrictedEreporter2Request),
    webapp2.Route(
        r'/restricted/ereporter2/silence',
        RestrictedEreporter2Silence),

    # Public API.
    webapp2.Route(
      '/ereporter2/api/v1/on_error', OnErrorHandler),
  ]


def get_backend_routes():
  # This requires a cron job to this URL.
  return [
    webapp2.Route(
        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),
    webapp2.Route(
        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),
  ]
/n/n/n/appengine/isolate/handlers_frontend.py/n/n# Copyright 2012 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""This module defines Isolate Server frontend url handlers.""""""

import collections
import datetime
import json
import logging

import webapp2

import cloudstorage
from google.appengine.api import modules

import acl
import config
import gcs
import handlers_endpoints_v1
import mapreduce_jobs
import model
import stats
import template
from components import auth
from components import stats_framework
from components import stats_framework_gviz
from components import utils
from gviz import gviz_api


# GViz data description.
_GVIZ_DESCRIPTION = {
  'failures': ('number', 'Failures'),
  'requests': ('number', 'Total'),
  'other_requests': ('number', 'Other'),
  'uploads': ('number', 'Uploads'),
  'uploads_bytes': ('number', 'Uploaded'),
  'downloads': ('number', 'Downloads'),
  'downloads_bytes': ('number', 'Downloaded'),
  'contains_requests': ('number', 'Lookups'),
  'contains_lookups': ('number', 'Items looked up'),
}

# Warning: modifying the order here requires updating templates/stats.html.
_GVIZ_COLUMNS_ORDER = (
  'key',
  'requests',
  'other_requests',
  'failures',
  'uploads',
  'downloads',
  'contains_requests',
  'uploads_bytes',
  'downloads_bytes',
  'contains_lookups',
)

_ISOLATED_ROOT_MEMBERS = (
  'algo',
  'command',
  'files',
  'includes',
  'read_only',
  'relative_cwd',
  'version',
)


### Restricted handlers


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    self.common(None)

  @staticmethod
  def cast_to_type(param_name, value):
    def to_bool(value):
      if type(value) is bool:
        return value
      return {'True': True, 'False': False}.get(value, False)

    cast = {
        'enable_ts_monitoring': to_bool,
    }.get(param_name, str)
    return cast(value)

  @auth.require(auth.is_admin)
  def post(self):
    # Convert MultiDict into a dict.
    params = {
      k: self.cast_to_type(k, self.request.params.getone(k))
      for k in self.request.params
      if k not in ('keyid', 'xsrf_token')
    }
    cfg = config.settings(fresh=True)
    keyid = int(self.request.get('keyid', '0'))
    if cfg.key.integer_id() != keyid:
      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))
      return
    cfg.populate(**params)
    try:
      # Ensure key is correct, it's easy to make a mistake when creating it.
      gcs.URLSigner.load_private_key(cfg.gs_private_key)
    except Exception as exc:
      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)
      self.response.write('Bad private key: %s' % exc)
      return
    cfg.store(updated_by=auth.get_current_identity().to_bytes())
    self.common('Settings updated')

  def common(self, note):
    params = config.settings_info()
    params.update({
        'note': note,
        'path': self.request.path,
        'xsrf_token': self.generate_xsrf_token(),
    })
    self.response.write(
        template.render('isolate/restricted_config.html', params))


class RestrictedPurgeHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    params = {
      'digest': '',
      'message': '',
      'namespace': '',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('isolate/restricted_purge.html', params))

  @auth.require(auth.is_admin)
  def post(self):
    namespace = self.request.get('namespace')
    digest = self.request.get('digest')
    params = {
      'digest': digest,
      'message': '',
      'namespace': namespace,
      'xsrf_token': self.generate_xsrf_token(),
    }
    try:
      key = model.get_entry_key(namespace, digest)
    except ValueError as e:
      params['message'] = 'Invalid entry: %s' % e
      key = None
    if key:
      model.delete_entry_and_gs_entry([key])
      params['message'] = 'Done'
    self.response.write(
        template.render('isolate/restricted_purge.html', params))


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(auth.is_admin)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    # Do not use 'backend' module when running from dev appserver. Mapreduce
    # generates URLs that are incompatible with dev appserver URL routing when
    # using custom modules.
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=not utils.is_local_dev_server())
    # New tasks should show up on the status page.
    if success:
      self.redirect('/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Non-restricted handlers


class BrowseHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    # Support 'hash' for compatibility with old links. To remove eventually.
    digest = self.request.get('digest', '') or self.request.get('hash', '')
    save_as = self.request.get('as', '')
    params = {
      u'as': unicode(save_as),
      u'digest': unicode(digest),
      u'namespace': unicode(namespace),
    }
    # Check for existence of element, so we can 400/404
    if digest and namespace:
      try:
        model.get_content(namespace, digest)
      except ValueError:
        self.abort(400, 'Invalid key')
      except LookupError:
        self.abort(404, 'Unable to retrieve the entry')
    self.response.write(template.render('isolate/browse.html', params))

  def get_content_security_policy(self):
    csp = super(BrowseHandler, self).get_content_security_policy()
    csp.setdefault('child-src', []).append(""'self'"")
    return csp


class ContentHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    digest = self.request.get('digest', '')
    content = None
    if not digest:
      self.abort(400, 'Missing digest')
    if not namespace:
      self.abort(400, 'Missing namespace')

    try:
      raw_data, entity = model.get_content(namespace, digest)
    except ValueError:
      self.abort(400, 'Invalid key')
    except LookupError:
      self.abort(404, 'Unable to retrieve the entry')

    logging.info('%s', entity)
    if not raw_data:
      try:
        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())
        content = ''.join(model.expand_content(namespace, stream))
      except cloudstorage.NotFoundError:
        logging.error('Entity in DB but not in GCS: deleting entity in DB')
        entity.key.delete()
        self.abort(404, 'Unable to retrieve the file from GCS')
    else:
      content = ''.join(model.expand_content(namespace, [raw_data]))

    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    # We delete Content-Type before storing to it to avoid having two (yes,
    # two) Content-Type headers.
    del self.response.headers['Content-Type']

    # Apparently, setting the content type to text/plain encourages the
    # browser (Chrome, at least) to sniff the mime type and display
    # things like images.  Images are autowrapped in <img> and text is
    # wrapped in <pre>.
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'

    # App Engine puts a limit of 33554432 bytes on a request, which includes
    # headers. Headers are ~150 bytes.  If the content + headers might
    # exceed that limit, we give the user an option to workround getting
    # their file.
    if len(content) > 33554000:
      host = modules.get_hostname(module='default', version='default')
      # host is something like default.default.myisolateserver.appspot.com
      host = host.replace('default.default.','')
      sizeInMib = len(content) / (1024.0 * 1024.0)
      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'
      ' App Engine limit.\nTo work around this, run the following command:\n'
      '    python isolateserver.py download -I %s --namespace %s -f %s %s'
      % (sizeInMib, host, namespace, digest, digest))
    else:
      self.response.headers['Content-Disposition'] = str(
        'filename=%s' % self.request.get('as') or digest)
      try:
        json_data = json.loads(content)
        if self._is_isolated_format(json_data):
          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
          json_data['files'] = collections.OrderedDict(
            sorted(
              json_data['files'].items(),
              key=lambda (filepath, data): filepath))
          params = {
            'namespace': namespace,
            'isolated': json_data,
          }
          content = template.render('isolate/isolated.html', params)
      except ValueError:
        pass

    self.response.write(content)

  @staticmethod
  def _is_isolated_format(json_data):
    """"""Checks if json_data is a valid .isolated format.""""""
    if not isinstance(json_data, dict):
      return False
    actual = set(json_data)
    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual


class StatsHandler(webapp2.RequestHandler):
  """"""Returns the statistics web page.""""""
  def get(self):
    """"""Presents nice recent statistics.

    It fetches data from the 'JSON' API.
    """"""
    # Preloads the data to save a complete request.
    resolution = self.request.params.get('resolution', 'hours')
    if resolution not in ('days', 'hours', 'minutes'):
      resolution = 'hours'
    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)

    description = _GVIZ_DESCRIPTION.copy()
    description.update(stats_framework_gviz.get_description_key(resolution))
    table = stats_framework.get_stats(
        stats.STATS_HANDLER, resolution, None, duration, True)
    params = {
      'duration': duration,
      'initial_data': gviz_api.DataTable(description, table).ToJSon(
          columns_order=_GVIZ_COLUMNS_ORDER),
      'now': datetime.datetime.utcnow(),
      'resolution': resolution,
    }
    self.response.write(template.render('isolate/stats.html', params))


class StatsGvizHandlerBase(webapp2.RequestHandler):
  RESOLUTION = None

  def get(self):
    description = _GVIZ_DESCRIPTION.copy()
    description.update(
        stats_framework_gviz.get_description_key(self.RESOLUTION))
    try:
      stats_framework_gviz.get_json(
          self.request,
          self.response,
          stats.STATS_HANDLER,
          self.RESOLUTION,
          description,
          _GVIZ_COLUMNS_ORDER)
    except ValueError as e:
      self.abort(400, str(e))


class StatsGvizDaysHandler(StatsGvizHandlerBase):
  RESOLUTION = 'days'


class StatsGvizHoursHandler(StatsGvizHandlerBase):
  RESOLUTION = 'hours'


class StatsGvizMinutesHandler(StatsGvizHandlerBase):
  RESOLUTION = 'minutes'


###  Public pages.


class RootHandler(auth.AuthenticatingHandler):
  """"""Tells the user to RTM.""""""

  @auth.public
  def get(self):
    params = {
      'is_admin': auth.is_admin(),
      'is_user': acl.isolate_readable(),
      'mapreduce_jobs': [],
      'user_type': acl.get_user_type(),
    }
    if auth.is_admin():
      params['mapreduce_jobs'] = [
        {'id': job_id, 'name': job_def['job_name']}
        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()
      ]
      params['xsrf_token'] = self.generate_xsrf_token()
    self.response.write(template.render('isolate/root.html', params))


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.
  """"""
  @auth.public
  def get(self):
    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'isolate/public_isolate_index.html', params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    config.warmup()
    auth.warmup()
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # Administrative urls.
      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),
      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),

      # Mapreduce related urls.
      webapp2.Route(
          r'/restricted/launch_mapreduce',
          RestrictedLaunchMapReduceJob),

      # User web pages.
      webapp2.Route(r'/browse', BrowseHandler),
      webapp2.Route(r'/content', ContentHandler),
      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz
      # is just too sorry.
      #webapp2.Route(r'/stats', StatsHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),
      webapp2.Route(r'/', RootHandler),
      webapp2.Route(r'/newui', UIHandler),

      # AppEngine-specific urls:
      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),
      webapp2.Route(r'/_ah/warmup', WarmupHandler),
  ]
  routes.extend(handlers_endpoints_v1.get_routes())
  return routes


def create_application(debug):
  """"""Creates the url router.

  The basic layouts is as follow:
  - /restricted/.* requires being an instance administrator.
  - /stats/.* has statistics.
  """"""
  acl.bootstrap()
  template.bootstrap()
  return webapp2.WSGIApplication(get_routes(), debug=debug)
/n/n/n/appengine/machine_provider/handlers_frontend.py/n/n# Copyright 2016 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Front-end UI.""""""

import logging
import os

import webapp2

from components import auth
from components import datastore_utils
from components import template
from components import utils

import handlers_endpoints
import models


THIS_DIR = os.path.dirname(os.path.abspath(__file__))


class CatalogHandler(auth.AuthenticatingHandler):
  """"""Catalog handler.""""""

  @auth.require(auth.is_admin)
  def get(self, machine_id=None):
    params = {
        'machines': [],
        'next_page_token': None,
    }
    if machine_id:
      machine = models.CatalogMachineEntry.get_by_id(machine_id)
      if not machine:
        self.abort(404)
      params['machines'] = [machine]
    else:
      query = models.CatalogMachineEntry.query().order(
          models.CatalogMachineEntry.dimensions.hostname)
      page_token = self.request.get('page_token') or ''
      params['machines'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(
        template.render('templates/catalog.html', params=params))


class LeaseRequestHandler(auth.AuthenticatingHandler):
  """"""Lease request handler.""""""

  @auth.require(auth.is_admin)
  def get(self, lease_id=None):
    params = {
        'lease_requests': [],
        'next_page_token': None,
        'now_ts': utils.time_time(),
    }
    if lease_id:
      lease_request = models.LeaseRequest.get_by_id(lease_id)
      if not lease_request:
        self.abort(404)
      params['lease_requests'] = [lease_request]
    else:
      query = models.LeaseRequest.query().order(
          -models.LeaseRequest.last_modified_ts)
      page_token = self.request.get('page_token') or ''
      params['lease_requests'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(template.render('templates/leases.html', params=params))


class RootHandler(auth.AuthenticatingHandler):
  """"""Root handler.""""""

  @auth.public
  def get(self):
    params = {
        'is_admin': auth.is_admin(),
    }

    self.response.write(template.render('templates/root.html', params=params))


def get_routes():
  return [
      webapp2.Route('/', handler=RootHandler),
      webapp2.Route('/catalog', handler=CatalogHandler),
      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),
      webapp2.Route('/leases', handler=LeaseRequestHandler),
      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),
  ]


def create_frontend_app():
  template.bootstrap({
      'templates': os.path.join(THIS_DIR, 'templates'),
  })
  routes = get_routes()
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes)
/n/n/n/appengine/swarming/handlers_frontend.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Main entry point for Swarming service.

This file contains the URL handlers for all the Swarming service URLs,
implemented using the webapp2 framework.
""""""

import collections
import os

import webapp2

import handlers_bot
import handlers_endpoints
import mapreduce_jobs
import template
from components import auth
from components import utils
from server import acl
from server import bot_code
from server import config


ROOT_DIR = os.path.dirname(os.path.abspath(__file__))


# Helper class for displaying the sort options in html templates.
SortOptions = collections.namedtuple('SortOptions', ['key', 'name'])


### is_admin pages.


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    # Template parameters schema matches settings_info() return value.
    self.response.write(template.render(
        'swarming/restricted_config.html', config.settings_info()))


class UploadBotConfigHandler(auth.AuthenticatingHandler):
  """"""Stores a new bot_config.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bot_config = bot_code.get_bot_config()
    params = {
      'content': bot_config.content.decode('utf-8'),
      'path': self.request.path,
      'version': bot_config.version,
      'when': bot_config.when,
      'who': bot_config.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bot_config.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bot_config(self.request.host_url, script)
    self.get()


class UploadBootstrapHandler(auth.AuthenticatingHandler):
  """"""Stores a new bootstrap.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bootstrap = bot_code.get_bootstrap(self.request.host_url)
    params = {
      'content': bootstrap.content.decode('utf-8'),
      'path': self.request.path,
      'version': bootstrap.version,
      'when': bootstrap.when,
      'who': bootstrap.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bootstrap.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bootstrap(script)
    self.get()


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(acl.can_edit_config)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=False)
    # New tasks should show up on the status page.
    if success:
      self.redirect('/restricted/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Redirectors.


class BotsListHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of known bots.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))

    dimensions = (
      l.strip() for l in self.request.get('dimensions', '').splitlines()
    )
    dimensions = [i for i in dimensions if i]

    new_ui_link = '/botlist?l=%d' % limit
    if dimensions:
      new_ui_link += '&f=' + '&f='.join(dimensions)

    self.redirect(new_ui_link)


class BotHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page about the bot, including last tasks and events.""""""

  @auth.public
  def get(self, bot_id):
    self.redirect('/bot?id=%s' % bot_id)


class TasksHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of all task requests.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))
    task_tags = [
      line for line in self.request.get('task_tag', '').splitlines() if line
    ]

    new_ui_link = '/tasklist?l=%d' % limit
    if task_tags:
      new_ui_link += '&f=' + '&f='.join(task_tags)

    self.redirect(new_ui_link)


class TaskHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page containing task request and result.""""""

  @auth.public
  def get(self, task_id):
    self.redirect('/task?id=%s' % task_id)


### Public pages.


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.""""""
  @auth.public
  def get(self, page):
    if not page:
      page = 'swarming'

    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'swarming/public_%s_index.html' % page, params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')

  def get_content_security_policy(self):
    # We use iframes to display pages at display_server_url_template. Need to
    # allow it in CSP.
    csp = super(UIHandler, self).get_content_security_policy()
    tmpl = config.settings().display_server_url_template
    if tmpl:
      if tmpl.startswith('/'):
        csp['child-src'].append(""'self'"")
      else:
        # We assume the template specifies '%s' in its last path component.
        # We strip it to get a ""parent"" path that we can put into CSP. Note that
        # whitelisting an entire display server domain is unnecessary wide.
        assert tmpl.startswith('https://'), tmpl
        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])
    return csp


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    auth.warmup()
    bot_code.get_swarming_bot_zip(self.request.host_url)
    utils.get_module_version_list(None, None)
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # Frontend pages. They return HTML.
      # Public pages.
      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),

      # Redirects to Polymer UI
      ('/user/tasks', TasksHandler),
      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),
      ('/restricted/bots', BotsListHandler),
      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),

      # Admin pages.
      # TODO(maruel): Get rid of them.
      ('/restricted/config', RestrictedConfigHandler),
      ('/restricted/upload/bot_config', UploadBotConfigHandler),
      ('/restricted/upload/bootstrap', UploadBootstrapHandler),

      # Mapreduce related urls.
      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),

      ('/_ah/mail/<to:.+>', EmailHandler),
      ('/_ah/warmup', WarmupHandler),
  ]
  return [webapp2.Route(*i) for i in routes]


def create_application(debug):
  routes = []
  routes.extend(get_routes())
  routes.extend(handlers_bot.get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes, debug=debug)
/n/n/n",1
86,2b70b391b0792c90ed71fd23ab36a6b7c60fb1e5,"src/veil/backend/redis/client/client.py/n/nfrom __future__ import unicode_literals, print_function, division, absolute_import
from redis.client import Redis
from logging import getLogger
from veil.environment.setting import *
from veil.development.test import *

LOGGER = getLogger(__name__)

registry = {} # purpose => get_redis_options
instances = {} # purpose => instance (a.k.a Redis class instance)

def register_redis(purpose):
    if purpose not in registry:
        registry[purpose] = register_redis_options(purpose)
    return lambda: require_redis(purpose)


def register_redis_options(purpose):
    section = '{}_redis'.format(purpose) # for example cache_redis
    get_redis_host = register_option(section, 'host')
    get_redis_port = register_option(section, 'port', int)
    get_redis_password = register_option(section, 'password')

    def get_redis_options():
        return {
            'host': get_redis_host(),
            'port': get_redis_port(),
            'password': get_redis_password()
        }

    return get_redis_options


def require_redis(purpose):
    if purpose not in registry:
        raise Exception('redis for purpose {} is not registered'.format(purpose))
    if purpose not in instances:
        get_redis_options = registry[purpose]
        instances[purpose] = Redis(**get_redis_options())
    executing_test = get_executing_test(optional=True)
    if executing_test:
        executing_test.addCleanup(lambda :instances[purpose].flushall())
    return instances[purpose]
/n/n/nsrc/veil/development/browser/browser.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import threading
import time
import traceback
import lxml.html
import os.path
import spynner
import selenium.webdriver
import os
from veil.utility.path import *
from veil.development.test import *
from veil.profile.web import *
from veil.frontend.web.static_file import *

LOGGER = logging.getLogger(__name__)
latest_page = None

def start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):
    @route('POST', '/-test/stop', website=website)
    def stop_test():
        stop_browser()

    @route('POST', '/-test/fail', website=website)
    def fail_test():
        message = get_http_argument('message')
        LOGGER.error(message)
        get_executing_test().error = message

    @route('POST', '/-test/log', website=website)
    def log_from_test():
        LOGGER.info(get_http_argument('message'))

    @route('GET', '/-test/veil-test.js', website=website)
    def veil_test_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil-test.js').text()

    @route('GET', '/-test/jquery.js', website=website)
    def jquery_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery.js').text()

    @route('GET', '/-test/jquery-cookie.js', website=website)
    def jquery_cookie_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()

    @route('GET', '/-test/veil.js', website=website)
    def veil_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil.js').text()

    page_interactions = list(reversed(page_interactions))
    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))
    http_server = start_test_website(website)
    domain = get_website_option(website, 'domain')
    if domain:
        url = 'http://{}{}'.format(domain, path)
    else:
        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)
    threading.Thread(target=lambda: execute_io_loop(timeout)).start()
    start_browser(url, browser)


def execute_io_loop(timeout):
    get_executing_test().addCleanup(require_io_loop_executor().stop)
    try:
        require_io_loop_executor().execute(timeout=timeout)
    except:
        get_executing_test().error = traceback.format_exc()
        raise


def start_browser(url, browser_type):
    if os.getenv('VEIL_REMOTE_BROWSER'):
        browser_type = 'remote'
    get_executing_test().browser_type = browser_type
    test = get_executing_test()
    test.addCleanup(stop_browser)
    if 'spynner' == browser_type:
        start_spynner_browser(url)
    elif 'chrome' == browser_type:
        start_chrome_browser(url)
    elif 'remote' == browser_type:
        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))
        start_remote_browser(url, command_executor)
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def start_spynner_browser(url, visible=False):
    test = get_executing_test()
    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)
    if visible:
        test.spynner_browser.show(maximized=False)
    try:
        test.spynner_browser.load(url)
    except:
        pass
    while test.spynner_browser:
        try:
            test.spynner_browser._events_loop()
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_chrome_browser(url):
    test = get_executing_test()
    old_cwd = os.getcwd()
    os.chdir('/tmp')
    test.webdriver = selenium.webdriver.Chrome()
    os.chdir(old_cwd)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_remote_browser(url, command_executor):
    test = get_executing_test()
    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER
    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def check_is_test_failed(test):
    message = getattr(test, 'error', None)
    if message is not None:
        stop_browser()
        LOGGER.info('Latest page: {}'.format(latest_page))
        test.fail(message)


def stop_browser():
    test = get_executing_test()
    if 'spynner' == test.browser_type:
        stop_spynner_browser()
    elif test.browser_type in ['chrome', 'remote']:
        stop_webdriver()
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def stop_spynner_browser():
    test = get_executing_test()
    browser = test.spynner_browser
    if browser:
        test.spynner_browser = None
        browser.close()


def stop_webdriver():
    test = get_executing_test()
    webdriver = getattr(test, 'webdriver', None)
    if webdriver:
        test.webdriver = None
        webdriver.close()


def inject_page_interaction(html, page_interactions):
    global latest_page
    request = get_current_http_request()
    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):
        return html
    if request.path.startswith('/-test/'):
        return html
    if not page_interactions:
        return html
    fragment = lxml.html.document_fromstring(html)
    script = fragment.makeelement(
        'script', attrib={
            'type': 'text/javascript',
            'src': '/-test/veil-test.js'
        })
    fragment.find('body').append(script)
    script = fragment.makeelement(
        'script', attrib={'type': 'text/javascript'})
    script.text =\
    """"""
    $(document).ready(function() {
        %s
    });
    """""" % page_interactions.pop()
    fragment.find('body').append(script)
    latest_page = open_closed_tags(lxml.html.tostring(fragment, method='xml'))
    return latest_page/n/n/nsrc/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *
from tornado.escape import xhtml_escape

LOGGER = getLogger(__name__)

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        if not token:
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assign XSRF token {} from {} {}'.format(token, request.method, request.path))
        request._xsrf_token = token
    if 'GET' != request.method.upper():
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token missing, request: {}'.format(request))
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.debug('expected token: {}'.format(expected_token))
            LOGGER.debug('actual token: {}'.format(token))
            LOGGER.warn('XSRF token invalid, request: {}'.format(request))
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type=""hidden"" name=""_xsrf"" value=""{}""/>'.format(xhtml_escape(xsrf_token())))/n/n/nsrc/veil/model/binding/__init__.py/n/nimport veil.component

with veil.component.init_component(__name__):
    from .invalid import Invalid
    from .field_binder import not_empty
    from .field_binder import one_of
    from .field_binder import clamp_length
    from .field_binder import clamp
    from .field_binder import not_duplicate
    from .field_binder import anything
    from .field_binder import is_not
    from .field_binder import is_email
    from .field_binder import is_mobile
    from .field_binder import is_landline
    from .field_binder import is_list
    from .field_binder import to_integer
    from .field_binder import to_float
    from .field_binder import to_bool
    from .field_binder import to_date
    from .field_binder import to_time
    from .field_binder import to_datetime
    from .field_binder import to_datetime_via_parse
    from .field_binder import to_datetime_with_minute_precision_from_iso8601
    from .field_binder import to_timezone
    from .binder_maker import each
    from .binder_maker import optional
    from .object_binder import ObjectBinder

    __all__ = [
        # from invalid
        Invalid.__name__,
        # from field_binder
        not_empty.__name__,
        one_of.__name__,
        clamp_length.__name__,
        clamp.__name__,
        not_duplicate.__name__,
        anything.__name__,
        is_not.__name__,
        is_email.__name__,
        is_mobile.__name__,
        is_landline.__name__,
        is_list.__name__,
        to_integer.__name__,
        to_float.__name__,
        to_bool.__name__,
        to_date.__name__,
        to_time.__name__,
        to_datetime.__name__,
        to_datetime_via_parse.__name__,
        to_datetime_with_minute_precision_from_iso8601.__name__,
        to_timezone.__name__,
        # from binder_maker
        each.__name__,
        optional.__name__,
        # from object_binder
        ObjectBinder.__name__
    ]
/n/n/nsrc/veil/model/binding/field_binder.py/n/n# -*- coding: utf-8 -*-
""""""
field binder takes single value and returns transformed single value in expected case
otherwise throw Invalid exception
""""""
from __future__ import unicode_literals, print_function, division
import re
from datetime import datetime, time
import pytz
from pytz import timezone, UnknownTimeZoneError
from dateutil.parser import parse
from veil.model.binding.invalid import Invalid


_EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9_=%.+-]+@([a-zA-Z0-9_=%+-]+\.)+[a-zA-Z]{2,6}$')

# reference to http://www.cnfgg.com/article/Asp/Asp_phoneCheck.htm
_MOBILE_PATTERN = re.compile(r'^0?1[3458]\d{9}$')
_LANDLIINE_PATTERN = re.compile(r'^(\d{2,4}[-.\s_]?)?\d{3,8}([-.\s_]?\d{3,8})?([-.\s_]?\d{1,7})?$')


def anything(value):
    return value


def is_not(v):
    def bind(value):
        if value == bind.v:
            raise Invalid('{}{}'.format(_(''), bind.v))
        return value
    bind.v = v
    return bind


def not_empty(value):
    if value is not None and value != '':
        return value
    raise Invalid(_(''))


def is_list(value):
    if isinstance(value, (list, tuple)):
        return value
    raise Invalid(_(''))


def one_of(seq):
    assert seq is not None
    def bind(value):
        if value not in bind.seq:
            raise Invalid(_(''))
        return value
    bind.seq = seq
    return bind


def is_email(value):
    if _EMAIL_PATTERN.match(value) is None:
        raise Invalid(_(''))
    return value


def is_mobile(value):
    if _MOBILE_PATTERN.match(value) is None:
        raise Invalid(_(''))
    return value


def is_landline(value):
    if _LANDLIINE_PATTERN.match(value) is None:
        raise Invalid(_(''))
    return value


def to_integer(value):
    try:
        return int(value)
    except (TypeError, ValueError):
        raise Invalid(_(''))


def to_float(value):
    try:
        return float(value)
    except (TypeError, ValueError):
        raise Invalid(_(''))


def to_bool(value):
    if value in ['0', 'false', 'False']:
        return False
    return bool(value)


def to_time(value):
    try:
        dt = datetime.strptime(value, '%I:%M %p')
    except ValueError:
        raise Invalid(_(''))
    else:
        return time(dt.hour, dt.minute)


def to_date(format='%Y-%m-%d'):
    def bind(value):
        if isinstance(value, datetime):
            return value.date()
        try:
            dt = datetime.strptime(value, bind.format)
        except ValueError:
            raise Invalid(_(''))
        else:
            return dt.date()
    bind.format = format
    return bind


def to_datetime_via_parse(value):
    try:
        return parse(value, yearfirst=True)
    except ValueError:
        raise Invalid(_(''))


def to_datetime(format='%Y-%m-%d %H:%M:%S'):
    def bind(value):
        if isinstance(value, datetime):
            return value
        else:
            try:
                return datetime.strptime(value, bind.format)
            except ValueError:
                raise Invalid(_(''))
    bind.format = format
    return bind


ISO8601_REGEX = re.compile(r'(?P<year>[0-9]{4})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2}) (?P<hour>[0-9]{2}):(?P<minute>[0-9]{2}) ?(?P<prefix>[+-])(?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})')

def to_datetime_with_minute_precision_from_iso8601(value):
    """"""
    Valid formats:
        YYYY-MM-DD hh:mm hh:mm
        YYYY-MM-DD hh:mm hhmm
        YYYY-MM-DD hh:mmhhmm
    """"""
    try:
        m = ISO8601_REGEX.match(value)
        if not m:
            raise Exception('Unable to parse date string %r' % value)
        groups = m.groupdict()
        hours, minutes = int(groups['hours']), int(groups['minutes'])
        if groups['prefix'] == '-':
            hours = -hours
            minutes = -minutes
        tz = pytz.FixedOffset(hours * 60 + minutes)
        return datetime(int(groups['year']), int(groups['month']), int(groups['day']), int(groups['hour']),
            int(groups['minute']), tzinfo=tz)
    except:
        raise Invalid(_(''))


def to_timezone(value):
    try:
        return timezone(value)
    except UnknownTimeZoneError:
        raise Invalid(_(''))


def clamp_length(min=None, max=None):
    """"""
    clamp a value between minimum and maximum lengths (either
    of which are optional).
    """"""
    def bind(value):
        value_length = len(value)
        if bind.min is not None and value_length < bind.min:
            raise Invalid(_(''))
        if bind.max is not None and value_length > bind.max:
            raise Invalid(_(''))
        return value
    bind.min = min
    bind.max = max
    return bind

def clamp(min=None, max=None):
    """"""
    clamp a value between minimum and maximum lengths (either
    of which are optional).
    """"""
    def bind(value):
        if bind.min is not None and value < bind.min:
            raise Invalid(_(''))
        if bind.max is not None and value > bind.max:
            raise Invalid(_(''))
        return value
    bind.min = min
    bind.max = max
    return bind


def not_duplicate(value):
    if len(set(value)) != len(value):
        raise Invalid(_(''))
    return value/n/n/n",0
87,2b70b391b0792c90ed71fd23ab36a6b7c60fb1e5,"/src/veil/development/browser/browser.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import threading
import time
import traceback
import lxml.html
import os.path
import spynner
import selenium.webdriver
import os
from veil.utility.path import *
from veil.development.test import *
from veil.profile.web import *
from veil.frontend.web.static_file import *

LOGGER = logging.getLogger(__name__)

def start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):
    @route('POST', '/-test/stop', website=website)
    def stop_test():
        stop_browser()

    @route('POST', '/-test/fail', website=website)
    def fail_test():
        message = get_http_argument('message')
        LOGGER.error(message)
        get_executing_test().error = message

    @route('POST', '/-test/log', website=website)
    def log_from_test():
        LOGGER.info(get_http_argument('message'))

    @route('GET', '/-test/veil-test.js', website=website)
    def veil_test_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil-test.js').text()

    @route('GET', '/-test/jquery.js', website=website)
    def jquery_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery.js').text()

    @route('GET', '/-test/jquery-cookie.js', website=website)
    def jquery_cookie_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()

    @route('GET', '/-test/veil.js', website=website)
    def veil_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil.js').text()

    page_interactions = list(reversed(page_interactions))
    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))
    http_server = start_test_website(website)
    domain = get_website_option(website, 'domain')
    if domain:
        url = 'http://{}{}'.format(domain, path)
    else:
        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)
    threading.Thread(target=lambda: execute_io_loop(timeout)).start()
    start_browser(url, browser)


def execute_io_loop(timeout):
    get_executing_test().addCleanup(require_io_loop_executor().stop)
    try:
        require_io_loop_executor().execute(timeout=timeout)
    except:
        get_executing_test().error = traceback.format_exc()
        raise


def start_browser(url, browser_type):
    if os.getenv('VEIL_REMOTE_BROWSER'):
        browser_type = 'remote'
    get_executing_test().browser_type = browser_type
    test = get_executing_test()
    test.addCleanup(stop_browser)
    if 'spynner' == browser_type:
        start_spynner_browser(url)
    elif 'chrome' == browser_type:
        start_chrome_browser(url)
    elif 'remote' == browser_type:
        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))
        start_remote_browser(url, command_executor)
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def start_spynner_browser(url, visible=False):
    test = get_executing_test()
    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)
    if visible:
        test.spynner_browser.show(maximized=False)
    try:
        test.spynner_browser.load(url)
    except:
        pass
    while test.spynner_browser:
        try:
            test.spynner_browser._events_loop()
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_chrome_browser(url):
    test = get_executing_test()
    old_cwd = os.getcwd()
    os.chdir('/tmp')
    test.webdriver = selenium.webdriver.Chrome()
    os.chdir(old_cwd)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_remote_browser(url, command_executor):
    test = get_executing_test()
    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER
    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def check_is_test_failed(test):
    message = getattr(test, 'error', None)
    if message is not None:
        stop_browser()
        test.fail(message)


def stop_browser():
    test = get_executing_test()
    if 'spynner' == test.browser_type:
        stop_spynner_browser()
    elif test.browser_type in ['chrome', 'remote']:
        stop_webdriver()
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def stop_spynner_browser():
    test = get_executing_test()
    browser = test.spynner_browser
    if browser:
        test.spynner_browser = None
        browser.close()


def stop_webdriver():
    test = get_executing_test()
    webdriver = getattr(test, 'webdriver', None)
    if webdriver:
        test.webdriver = None
        webdriver.close()


def inject_page_interaction(html, page_interactions):
    request = get_current_http_request()
    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):
        return html
    if request.path.startswith('/-test/'):
        return html
    if not page_interactions:
        return html
    fragment = lxml.html.document_fromstring(html)
    script = fragment.makeelement(
        'script', attrib={
            'type': 'text/javascript',
            'src': '/-test/veil-test.js'
        })
    fragment.find('body').append(script)
    script = fragment.makeelement(
        'script', attrib={'type': 'text/javascript'})
    script.text =\
    """"""
    $(document).ready(function() {
        %s
    });
    """""" % page_interactions.pop()
    fragment.find('body').append(script)
    return open_closed_tags(lxml.html.tostring(fragment, method='xml'))/n/n/n",1
88,87009916aaa8086704dd5d9bd99dd858278c1234,"src/veil/frontend/web/website_launcher.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import argparse
from jinja2.loaders import FileSystemLoader
from veil.frontend.template import *
from veil.frontend.cli import *
from veil.environment import *
from veil.environment.setting import *
from .tornado import *
from .locale import *
from .routing import  *
from .static_file import *
from .xsrf import *
from .web_installer import load_website_config

LOGGER = logging.getLogger(__name__)

additional_context_managers = {}

def register_website_context_manager(website, context_manager):
    additional_context_managers.setdefault(website.lower(), []).append(context_manager)


@script('up')
def bring_up_website(*argv):
    argument_parser = argparse.ArgumentParser('Website')
    argument_parser.add_argument('purpose', help='which website to bring up')
    argument_parser.add_argument('--dependency', type=str,
        help='where @periodic_job is defined', nargs='+', dest='dependencies')
    args = argument_parser.parse_args(argv)
    for dependency in args.dependencies:
        __import__(dependency)
    start_website(args.purpose)


def start_test_website(purpose, **kwargs):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config, **kwargs)
    http_server = start_test_http_server(
        http_handler,
        host=config.host,
        port=config.port)
    http_server.purpose = purpose
    return http_server


def start_website(purpose):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config)
    io_loop = IOLoop.instance()
    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))
    start_http_server(
        http_handler, io_loop=io_loop,
        host=config.host, port=config.port)


def create_website_http_handler(purpose, config):
    locale_provider = lambda: None
    if config.secure_cookie_salt:
        set_secure_cookie_salt(config.secure_cookie_salt)
    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')
    set_external_static_files_directory(VEIL_HOME / 'static')
    master_template_directory = config.master_template_directory
    if master_template_directory:
        register_template_loader('master', FileSystemLoader(master_template_directory))
    website_context_managers = [create_stack_context(install_translations, locale_provider)]
    if config.prevents_xsrf:
        register_page_post_processor(set_xsrf_cookie_for_page)
        website_context_managers.append(prevent_xsrf)
    if config.recalculates_static_file_hash:
        website_context_managers.append(clear_static_file_hashes)
    if config.clears_template_cache:
        website_context_managers.append(clear_template_caches)
    website_context_managers.extend(additional_context_managers.get(purpose, []))
    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)
/n/n/n",0
89,87009916aaa8086704dd5d9bd99dd858278c1234,"/src/veil/frontend/web/website_launcher.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import argparse
from jinja2.loaders import FileSystemLoader
from veil.frontend.template import *
from veil.frontend.cli import *
from veil.environment import *
from veil.environment.setting import *
from .tornado import *
from .locale import *
from .routing import  *
from .static_file import *
from .xsrf import *
from .web_installer import load_website_config

LOGGER = logging.getLogger(__name__)

additional_context_managers = {}

def register_website_context_manager(website, context_manager):
    additional_context_managers.setdefault(website.lower(), []).append(context_manager)


@script('up')
def bring_up_website(*argv):
    argument_parser = argparse.ArgumentParser('Website')
    argument_parser.add_argument('purpose', help='which website to bring up')
    argument_parser.add_argument('--dependency', type=str,
        help='where @periodic_job is defined', nargs='+', dest='dependencies')
    args = argument_parser.parse_args(argv)
    for dependency in args.dependencies:
        __import__(dependency)
    start_website(args.purpose)


def start_test_website(purpose, **kwargs):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, **kwargs)
    http_server = start_test_http_server(
        http_handler,
        host=config.host,
        port=config.port)
    http_server.purpose = purpose
    return http_server


def start_website(purpose):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config)
    io_loop = IOLoop.instance()
    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))
    start_http_server(
        http_handler, io_loop=io_loop,
        host=config.host, port=config.port)


def create_website_http_handler(purpose, config):
    locale_provider = lambda: None
    if config.secure_cookie_salt:
        set_secure_cookie_salt(config.secure_cookie_salt)
    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')
    set_external_static_files_directory(VEIL_HOME / 'static')
    master_template_directory = config.master_template_directory
    if master_template_directory:
        register_template_loader('master', FileSystemLoader(master_template_directory))
    website_context_managers = [create_stack_context(install_translations, locale_provider)]
    if config.prevents_xsrf:
        register_page_post_processor(set_xsrf_cookie_for_page)
        website_context_managers.append(prevent_xsrf)
    if config.recalculates_static_file_hash:
        website_context_managers.append(clear_static_file_hashes)
    if config.clears_template_cache:
        website_context_managers.append(clear_template_caches)
    website_context_managers.extend(additional_context_managers.get(purpose, []))
    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)
/n/n/n",1
90,21a72f4ce71f05b6e574f2f3e564c087870f7314,"src/veil/frontend/web/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .website_launcher import start_website
    from .website_launcher import start_test_website
    from .website_launcher import register_website_context_manager
    from .website_installer import get_website_url_prefix
    from .website_installer import website_resource
    from .client import start_website_and_client
    from .routing import route
    from .routing import route_for
    from .routing import async_route
    from .routing import public_route
    from .routing import is_public_route
    from .routing import RoutingHTTPHandler
    from .routing import get_routes
    from .routing import register_page_post_processor
    from .routing import TAG_NO_POST_PROCESS
    from .routing import publish_new_website_event
    from .static_file import static_url
    from .static_file import process_script_elements
    from .tornado import get_current_http_context
    from .tornado import get_current_http_request
    from .tornado import get_current_http_response
    from .tornado import start_http_server
    from .tornado import start_test_http_server
    from .tornado import create_stack_context
    from .tornado import set_http_status_code
    from .tornado import HTTPError
    from .tornado import end_http_request_processing
    from .tornado import get_secure_cookie
    from .tornado import set_secure_cookie
    from .tornado import get_cookies
    from .tornado import get_cookie
    from .tornado import clear_cookies
    from .tornado import clear_cookie
    from .tornado import set_cookie
    from .tornado import redirect_to
    from .tornado import get_http_argument
    from .tornado import get_http_arguments
    from .tornado import get_http_file
    from .tornado import get_http_files
    from .tornado import delete_http_argument
    from .tornado import clear_http_arguments
    from .tornado import require_io_loop_executor
    from .xsrf import xsrf_token
    from .xsrf import TAG_NO_XSRF_CHECK

    __all__ = [
        # from website
        start_website.__name__,
        start_test_website.__name__,
        register_website_context_manager.__name__,
        # from website_installer
        get_website_url_prefix.__name__,
        website_resource.__name__,
        # from client
        start_website_and_client.__name__,
        # from routing
        route.__name__,
        route_for.__name__,
        async_route.__name__,
        public_route.__name__,
        is_public_route.__name__,
        RoutingHTTPHandler.__name__,
        get_routes.__name__,
        register_page_post_processor.__name__,
        'TAG_NO_POST_PROCESS',
        publish_new_website_event.__name__,
        # from static_file
        static_url.__name__,
        process_script_elements.__name__,
        # from tornado
        get_current_http_context.__name__,
        get_current_http_request.__name__,
        get_current_http_response.__name__,
        start_http_server.__name__,
        start_test_http_server.__name__,
        create_stack_context.__name__,
        set_http_status_code.__name__,
        HTTPError.__name__,
        end_http_request_processing.__name__,
        get_secure_cookie.__name__,
        set_secure_cookie.__name__,
        get_cookies.__name__,
        get_cookie.__name__,
        clear_cookies.__name__,
        clear_cookie.__name__,
        set_cookie.__name__,
        redirect_to.__name__,
        get_http_argument.__name__,
        get_http_arguments.__name__,
        get_http_file.__name__,
        get_http_files.__name__,
        delete_http_argument.__name__,
        clear_http_arguments.__name__,
        require_io_loop_executor.__name__,
        # from xsrf
        xsrf_token.__name__,
        'TAG_NO_XSRF_CHECK'
    ]
/n/n/nsrc/veil/frontend/web/xsrf/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .xsrf import xsrf_token
    from .xsrf import prevent_xsrf
    from .xsrf import set_xsrf_cookie_for_page
    from .xsrf import TAG_NO_XSRF_CHECK

    __all__ = [
        # from xsrf
        xsrf_token.__name__,
        prevent_xsrf.__name__,
        set_xsrf_cookie_for_page.__name__,
        'TAG_NO_XSRF_CHECK'
    ]/n/n/nsrc/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from tornado.escape import xhtml_escape
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *

LOGGER = getLogger(__name__)
TAG_NO_XSRF_CHECK = 'NO-XSRF'

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        request.is_new_xsrf_token = False
        if not token:
            request.is_new_xsrf_token = True
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {
                'token': token,
                'method': request.method,
                'path': request.path
            })
        request._xsrf_token = token
    if 'GET' != request.method.upper() and TAG_NO_XSRF_CHECK not in get_current_http_context().route.tags:
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {
                'request': request,
                'expected_token': expected_token,
                'token': token
            })
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


def set_xsrf_cookie_for_page(route_handler, data):
    if get_current_http_request().is_new_xsrf_token:
        if data and '<html' in data.lower():
            # only set to page to avoid concurrent http request issue
            set_cookie(name='_xsrf', value=xsrf_token())
    return data


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type=""hidden"" name=""_xsrf"" value=""{}""/>'.format(xhtml_escape(xsrf_token())))/n/n/n",0
91,21a72f4ce71f05b6e574f2f3e564c087870f7314,"/src/veil/frontend/web/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .website_launcher import start_website
    from .website_launcher import start_test_website
    from .website_launcher import register_website_context_manager
    from .website_installer import get_website_url_prefix
    from .website_installer import website_resource
    from .client import start_website_and_client
    from .routing import route
    from .routing import route_for
    from .routing import async_route
    from .routing import public_route
    from .routing import is_public_route
    from .routing import RoutingHTTPHandler
    from .routing import get_routes
    from .routing import register_page_post_processor
    from .routing import TAG_NO_POST_PROCESS
    from .routing import publish_new_website_event
    from .static_file import static_url
    from .static_file import process_script_elements
    from .tornado import get_current_http_context
    from .tornado import get_current_http_request
    from .tornado import get_current_http_response
    from .tornado import start_http_server
    from .tornado import start_test_http_server
    from .tornado import create_stack_context
    from .tornado import set_http_status_code
    from .tornado import HTTPError
    from .tornado import end_http_request_processing
    from .tornado import get_secure_cookie
    from .tornado import set_secure_cookie
    from .tornado import get_cookies
    from .tornado import get_cookie
    from .tornado import clear_cookies
    from .tornado import clear_cookie
    from .tornado import set_cookie
    from .tornado import redirect_to
    from .tornado import get_http_argument
    from .tornado import get_http_arguments
    from .tornado import get_http_file
    from .tornado import get_http_files
    from .tornado import delete_http_argument
    from .tornado import clear_http_arguments
    from .tornado import require_io_loop_executor
    from .xsrf import xsrf_token

    __all__ = [
        # from website
        start_website.__name__,
        start_test_website.__name__,
        register_website_context_manager.__name__,
        # from website_installer
        get_website_url_prefix.__name__,
        website_resource.__name__,
        # from client
        start_website_and_client.__name__,
        # from routing
        route.__name__,
        route_for.__name__,
        async_route.__name__,
        public_route.__name__,
        is_public_route.__name__,
        RoutingHTTPHandler.__name__,
        get_routes.__name__,
        register_page_post_processor.__name__,
        'TAG_NO_POST_PROCESS',
        publish_new_website_event.__name__,
        # from static_file
        static_url.__name__,
        process_script_elements.__name__,
        # from tornado
        get_current_http_context.__name__,
        get_current_http_request.__name__,
        get_current_http_response.__name__,
        start_http_server.__name__,
        start_test_http_server.__name__,
        create_stack_context.__name__,
        set_http_status_code.__name__,
        HTTPError.__name__,
        end_http_request_processing.__name__,
        get_secure_cookie.__name__,
        set_secure_cookie.__name__,
        get_cookies.__name__,
        get_cookie.__name__,
        clear_cookies.__name__,
        clear_cookie.__name__,
        set_cookie.__name__,
        redirect_to.__name__,
        get_http_argument.__name__,
        get_http_arguments.__name__,
        get_http_file.__name__,
        get_http_files.__name__,
        delete_http_argument.__name__,
        clear_http_arguments.__name__,
        require_io_loop_executor.__name__,
        # from xsrf
        xsrf_token.__name__
    ]
/n/n/n/src/veil/frontend/web/xsrf/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .xsrf import xsrf_token
    from .xsrf import prevent_xsrf
    from .xsrf import set_xsrf_cookie_for_page

    __all__ = [
        # from xsrf
        xsrf_token.__name__,
        prevent_xsrf.__name__,
        set_xsrf_cookie_for_page.__name__
    ]/n/n/n/src/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from tornado.escape import xhtml_escape
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *

LOGGER = getLogger(__name__)

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        request.is_new_xsrf_token = False
        if not token:
            request.is_new_xsrf_token = True
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {
                'token': token,
                'method': request.method,
                'path': request.path
            })
        request._xsrf_token = token
    if 'GET' != request.method.upper():
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {
                'request': request,
                'expected_token': expected_token,
                'token': token
            })
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


def set_xsrf_cookie_for_page(route_handler, data):
    if get_current_http_request().is_new_xsrf_token:
        if data and '<html' in data.lower():
            # only set to page to avoid concurrent http request issue
            set_cookie(name='_xsrf', value=xsrf_token())
    return data


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type=""hidden"" name=""_xsrf"" value=""{}""/>'.format(xhtml_escape(xsrf_token())))/n/n/n",1
