,Unnamed: 0,id,code,label
74,74,1c2a256addf7a5273a40963f92a6351e5d053ae0,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers',
                        'accept, content-type, authorization, x-xsrftoken')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",0
75,75,1c2a256addf7a5273a40963f92a6351e5d053ae0,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",1
36,36,9d083ef1bc9cf41ff4e5a065c3196270effe3b5f,"setup.py/n/nfrom setuptools import find_packages, setup

setup(
    name='jupyter-notebook-gist',
    version='0.4.0',
    description='Create a gist from the Jupyter Notebook UI',
    author='Mozilla Firefox Data Platform',
    author_email='fx-data-platform@mozilla.com',
    packages=find_packages(where='src'),
    package_dir={'': 'src'},
    include_package_data=True,
    license='MPL2',
    install_requires=[
        'ipython >= 4',
        'notebook >= 4.3.1',
        'jupyter',
        'requests',
        'six',
        'widgetsnbextension',
    ],
    url='https://github.com/mozilla/jupyter-notebook-gist',
    zip_safe=False,
)
/n/n/n",0
37,37,9d083ef1bc9cf41ff4e5a065c3196270effe3b5f,"/setup.py/n/nfrom setuptools import find_packages, setup

setup(
    name='jupyter-notebook-gist',
    version='0.4.0',
    description='Create a gist from the Jupyter Notebook UI',
    author='Mozilla Firefox Data Platform',
    author_email='fx-data-platform@mozilla.com',
    packages=find_packages(where='src'),
    package_dir={'': 'src'},
    include_package_data=True,
    license='MPL2',
    install_requires=[
        'ipython >= 4',
        'notebook >= 4.2',
        'jupyter',
        'requests',
        'six',
        'widgetsnbextension',
    ],
    url='https://github.com/mozilla/jupyter-notebook-gist',
    zip_safe=False,
)
/n/n/n",1
8,8,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
9,9,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
54,54,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
55,55,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
12,12,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
13,13,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
18,18,3d7fb2f1011883da7b627693e001b132bdebf4ea,"aeoid/handlers.py/n/n#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import logging
import os

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template
from openid.consumer.consumer import Consumer
from openid.consumer.discover import DiscoveryFailure
from openid.extensions import sreg
from openid.extensions import ax

from aeoid import store
from aeoid import users


class BaseHandler(webapp.RequestHandler):
  def initialize(self, request, response):
    super(BaseHandler, self).initialize(request, response)
    self.session = self.request.environ.get('aeoid.beaker.session')

  def render_template(self, filename, template_args=None):
    if not template_args:
      template_args = {}
    path = os.path.join(os.path.dirname(__file__), 'templates', filename)
    self.response.out.write(template.render(path, template_args))

  def get_consumer(self):
    return Consumer(self.session, store.AppEngineStore())


class BeginLoginHandler(BaseHandler):
  def get(self):
    openid_url = self.request.get('openid_url')
    if not openid_url:
      self.render_template('login.html', {
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
      return

    try:
      consumer = self.get_consumer()
      request = consumer.begin(openid_url)
			
      # TODO: Support custom specification of extensions
      # TODO: Don't ask for data we already have, perhaps?
      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    
      ax_req = ax.FetchRequest()
      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))
      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))
      request.addExtension(ax_req)
      
      continue_url = self.request.get('continue', '/')
      return_to = ""%s%s?continue=%s"" % (self.request.host_url,
                                        users.OPENID_FINISH_PATH, continue_url)
      self.redirect(request.redirectURL(self.request.host_url, return_to))
      self.session.save()
    except DiscoveryFailure, ex:
      logging.error(""Unexpected error in OpenID authentication: %s"" % ex)
      self.render_template('error.html', {'identity_url': openid_url})


  def post(self):
    self.get()


class FinishLoginHandler(BaseHandler):
  def finish_login(self, response):
    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}
    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    #if ax_fetch:
    #  ax_data = ax_fetch.getExtensionArgs();
    #else:
    #  ax_data = {}
      
    #for k, v in ax_data.items():
    #  logging.info(""key: "" + k + "", value: "" + v)
    
    #user_info = users.UserInfo.update_or_insert(
    #    response.endpoint.claimed_id,
    #    server_url=response.endpoint.server_url,
    #    **dict(sreg_data))

    ax_data = {}
    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    if ax_fetch:
      args = ax_fetch.getExtensionArgs()
      i = 0
      while ""type.ext%i"" % i in args:
        t = args[""type.ext%i"" % i]
        logging.info(""type: %s"" % t)
        if t == ""http://axschema.org/namePerson/first"":
          p = ""nickname""
        elif t == ""http://axschema.org/contact/email"":
          p = ""email""
        else:
          p = ""unknown""
        ax_data[p] = args[""value.ext%i.1"" % i]
        i = i + 1

    res_data = {}
    res_data.update(sreg_data)
    res_data.update(ax_data)
    
    user_info = users.UserInfo.update_or_insert(
        response.endpoint.claimed_id,
        server_url=response.endpoint.server_url,
        **dict(res_data))
    
    self.session['aeoid.user'] = str(user_info.key())
    self.session.save()
    users._current_user = users.User(None, _from_model_key=user_info.key(),
                                     _from_model=user_info)
    self.redirect(self.request.get('continue', '/'))

  def get(self):
    consumer = self.get_consumer()
    response = consumer.complete(self.request.GET, self.request.url)
    if response.status == 'success':
      self.finish_login(response)
    elif response.status in ('failure', 'cancel'):
      self.render_template('failure.html', {
          'response': response,
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
    else:
      logging.error(""Unexpected error in OpenID authentication: %s"", response)
      self.render_template('error.html', {'identity_url': response.identity_url()})


class LogoutHandler(BaseHandler):
  def get(self):
    # before logging user out, check that http referer contains the current hostname
    httphost = str(self.request.environ.get('HTTP_HOST'))
    httprefer = str(self.request.environ.get('HTTP_REFERER'))
    # if it does, log them out as expected
    if httprefer.startswith(('http://'+httphost,'https://'+httphost)):
      if 'aeoid.user' in self.session:
        del self.session['aeoid.user']
      self.session.save()
      self.redirect(self.request.get('continue', '/'))
    # if it doesn't, prompt them via an interstitial page
    else:
      self.render_template('logout.html', {
          'confirmurl': '?continue='+self.request.get('continue', '/'),
          'cancelurl': self.request.get('continue', '/')
      })


# highly modified from example at:
# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/
class StaticHandler(webapp.RequestHandler):
  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }
  
  def get(self, filepath, fileext):
    # build full system path to requested file
    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )
    
    # only allow specified file extensions
    if not self.allowed_exts.has_key(fileext):
      logging.error(""Not an allowed file extension: %s"" % fileext)
      self.error(404)
      return
    
    # file must exist before we can return it
    if not os.path.isfile(resourcepath):
      logging.error(""Not an existing file: '%s'"" % resourcepath)
      self.error(404)
      return
    
    # only allow absolute paths (no symlinks or up-level references, for example)
    testpath = os.path.normcase(resourcepath)
    if testpath != os.path.abspath(testpath):
      logging.error(""Not an absolute path to file: '%s' != '%s'"" % (testpath, os.path.abspath(testpath)) )
      self.error(403)
      return
    
    # set appropriate content-type
    self.response.headers['Content-Type'] = self.allowed_exts[fileext]
    
    # serve file (supporting client-side caching)
    try:
      import datetime
      fileinfo = os.stat(resourcepath)
      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])
      if self.request.headers.has_key('If-Modified-Since'):
        dt = self.request.headers.get('If-Modified-Since').split(';')[0]
        modsince = datetime.datetime.strptime(dt, ""%a, %d %b %Y %H:%M:%S %Z"")
        if modsince >= lastmod:
        # The file is older than the cached copy (or exactly the same)
          self.error(304)
          return
        else:
        # The file is newer
          self.output_file(resourcepath, lastmod)
      else:
        self.output_file(resourcepath, lastmod)
    except Exception, e:
      logging.error(""Failed to serve file: %s"" % e)
      self.error(404)
      return

  def output_file(self, resourcepath, lastmod):
    import datetime
    try:
      self.response.headers['Cache-Control']='public, max-age=31536000'
      self.response.headers['Last-Modified'] = lastmod.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      expires=lastmod+datetime.timedelta(days=365)
      self.response.headers['Expires'] = expires.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      self.response.out.write( file(resourcepath, 'rb').read() )
      return
    except IOError, e:
      logging.error(""Failed to output file: %s"" % e)
      self.error(404)
      return


handler_map = [
    (users.OPENID_LOGIN_PATH, BeginLoginHandler),
    (users.OPENID_FINISH_PATH, FinishLoginHandler),
    (users.OPENID_LOGOUT_PATH, LogoutHandler),
    (users.OPENID_STATIC_PATH, StaticHandler),
]
/n/n/n",0
19,19,3d7fb2f1011883da7b627693e001b132bdebf4ea,"/aeoid/handlers.py/n/n#!/usr/bin/env python
#
# Copyright 2007 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import logging
import os

from google.appengine.ext import webapp
from google.appengine.ext.webapp import template
from openid.consumer.consumer import Consumer
from openid.consumer.discover import DiscoveryFailure
from openid.extensions import sreg
from openid.extensions import ax

from aeoid import store
from aeoid import users


class BaseHandler(webapp.RequestHandler):
  def initialize(self, request, response):
    super(BaseHandler, self).initialize(request, response)
    self.session = self.request.environ.get('aeoid.beaker.session')

  def render_template(self, filename, template_args=None):
    if not template_args:
      template_args = {}
    path = os.path.join(os.path.dirname(__file__), 'templates', filename)
    self.response.out.write(template.render(path, template_args))

  def get_consumer(self):
    return Consumer(self.session, store.AppEngineStore())


class BeginLoginHandler(BaseHandler):
  def get(self):
    openid_url = self.request.get('openid_url')
    if not openid_url:
      self.render_template('login.html', {
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
      return

    try:
      consumer = self.get_consumer()
      request = consumer.begin(openid_url)
			
      # TODO: Support custom specification of extensions
      # TODO: Don't ask for data we already have, perhaps?
      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    
      ax_req = ax.FetchRequest()
      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))
      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))
      request.addExtension(ax_req)
      
      continue_url = self.request.get('continue', '/')
      return_to = ""%s%s?continue=%s"" % (self.request.host_url,
                                        users.OPENID_FINISH_PATH, continue_url)
      self.redirect(request.redirectURL(self.request.host_url, return_to))
      self.session.save()
    except DiscoveryFailure, ex:
      logging.error(""Unexpected error in OpenID authentication: %s"" % ex)
      self.render_template('error.html', {'identity_url': openid_url})


  def post(self):
    self.get()


class FinishLoginHandler(BaseHandler):
  def finish_login(self, response):
    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}
    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    #if ax_fetch:
    #  ax_data = ax_fetch.getExtensionArgs();
    #else:
    #  ax_data = {}
      
    #for k, v in ax_data.items():
    #  logging.info(""key: "" + k + "", value: "" + v)
    
    #user_info = users.UserInfo.update_or_insert(
    #    response.endpoint.claimed_id,
    #    server_url=response.endpoint.server_url,
    #    **dict(sreg_data))

    ax_data = {}
    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)
    if ax_fetch:
      args = ax_fetch.getExtensionArgs()
      i = 0
      while ""type.ext%i"" % i in args:
        t = args[""type.ext%i"" % i]
        logging.info(""type: %s"" % t)
        if t == ""http://axschema.org/namePerson/first"":
          p = ""nickname""
        elif t == ""http://axschema.org/contact/email"":
          p = ""email""
        else:
          p = ""unknown""
        ax_data[p] = args[""value.ext%i.1"" % i]
        i = i + 1

    res_data = {}
    res_data.update(sreg_data)
    res_data.update(ax_data)
    
    user_info = users.UserInfo.update_or_insert(
        response.endpoint.claimed_id,
        server_url=response.endpoint.server_url,
        **dict(res_data))
    
    self.session['aeoid.user'] = str(user_info.key())
    self.session.save()
    users._current_user = users.User(None, _from_model_key=user_info.key(),
                                     _from_model=user_info)
    self.redirect(self.request.get('continue', '/'))

  def get(self):
    consumer = self.get_consumer()
    response = consumer.complete(self.request.GET, self.request.url)
    if response.status == 'success':
      self.finish_login(response)
    elif response.status in ('failure', 'cancel'):
      self.render_template('failure.html', {
          'response': response,
          'login_url': users.OPENID_LOGIN_PATH,
          'continue': self.request.get('continue', '/')
      })
    else:
      logging.error(""Unexpected error in OpenID authentication: %s"", response)
      self.render_template('error.html', {'identity_url': response.identity_url()})


class LogoutHandler(BaseHandler):
  def get(self):
    # TODO: Handle the possibility of XSRF forcing a user to log out
    if 'aeoid.user' in self.session:
      del self.session['aeoid.user']
    self.session.save()
    self.redirect(self.request.get('continue', '/'))


# highly modified from example at:
# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/
class StaticHandler(webapp.RequestHandler):
  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }
  
  def get(self, filepath, fileext):
    # build full system path to requested file
    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )
    
    # only allow specified file extensions
    if not self.allowed_exts.has_key(fileext):
      logging.error(""Not an allowed file extension: %s"" % fileext)
      self.error(404)
      return
    
    # file must exist before we can return it
    if not os.path.isfile(resourcepath):
      logging.error(""Not an existing file: '%s'"" % resourcepath)
      self.error(404)
      return
    
    # only allow absolute paths (no symlinks or up-level references, for example)
    testpath = os.path.normcase(resourcepath)
    if testpath != os.path.abspath(testpath):
      logging.error(""Not an absolute path to file: '%s' != '%s'"" % (testpath, os.path.abspath(testpath)) )
      self.error(403)
      return
    
    # set appropriate content-type
    self.response.headers['Content-Type'] = self.allowed_exts[fileext]
    
    # serve file (supporting client-side caching)
    try:
      import datetime
      fileinfo = os.stat(resourcepath)
      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])
      if self.request.headers.has_key('If-Modified-Since'):
        dt = self.request.headers.get('If-Modified-Since').split(';')[0]
        modsince = datetime.datetime.strptime(dt, ""%a, %d %b %Y %H:%M:%S %Z"")
        if modsince >= lastmod:
        # The file is older than the cached copy (or exactly the same)
          self.error(304)
          return
        else:
        # The file is newer
          self.output_file(resourcepath, lastmod)
      else:
        self.output_file(resourcepath, lastmod)
    except Exception, e:
      logging.error(""Failed to serve file: %s"" % e)
      self.error(404)
      return

  def output_file(self, resourcepath, lastmod):
    import datetime
    try:
      self.response.headers['Cache-Control']='public, max-age=31536000'
      self.response.headers['Last-Modified'] = lastmod.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      expires=lastmod+datetime.timedelta(days=365)
      self.response.headers['Expires'] = expires.strftime(""%a, %d %b %Y %H:%M:%S GMT"")
      self.response.out.write( file(resourcepath, 'rb').read() )
      return
    except IOError, e:
      logging.error(""Failed to output file: %s"" % e)
      self.error(404)
      return


handler_map = [
    (users.OPENID_LOGIN_PATH, BeginLoginHandler),
    (users.OPENID_FINISH_PATH, FinishLoginHandler),
    (users.OPENID_LOGOUT_PATH, LogoutHandler),
    (users.OPENID_STATIC_PATH, StaticHandler),
]
/n/n/n",1
44,44,85094ff8caac585cbff260fe89a6f21df241fd47,"service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = xsrf_token or request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",0
45,45,85094ff8caac585cbff260fe89a6f21df241fd47,"/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",1
42,42,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP(port=8889)
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.client.stop()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def stop(self):
        reactor.stop()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n",0
43,43,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"/service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP()
    proxy = Proxy(proxy_port='8889', app_port='4567')
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client
    context.call_to_terminate_proxy = proxy.run_on_a_thread()

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.call_to_terminate_proxy()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/n",1
48,48,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP(port=8889)
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.client.stop()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def stop(self):
        reactor.stop()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n",0
49,49,dbb434b56e6b161a3b851ae6a81f96dff14a29da,"/service/test/functional/features/environment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import logging
import uuid

from crochet import setup, wait_for
from leap.common.events.server import ensure_server
from twisted.internet import defer

from pixelated.application import UserAgentMode
from pixelated.config.site import PixelatedSite
from test.support.dispatcher.proxy import Proxy
from test.support.integration import AppTestClient
from selenium import webdriver

from pixelated.resources.features_resource import FeaturesResource
from steps.common import *
import os

setup()


@wait_for(timeout=5.0)
def start_app_test_client(client, mode):
    return client.start_client(mode=mode)


def before_all(context):
    ensure_server()
    logging.disable('INFO')
    PixelatedSite.disable_csp_requests()
    client = AppTestClient()
    start_app_test_client(client, UserAgentMode(is_single_user=True))
    client.listenTCP()
    proxy = Proxy(proxy_port='8889', app_port='4567')
    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')
    context.client = client
    context.call_to_terminate_proxy = proxy.run_on_a_thread()

    multi_user_client = AppTestClient()
    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))
    multi_user_client.listenTCP(port=MULTI_USER_PORT)
    context.multi_user_client = multi_user_client


def after_all(context):
    context.call_to_terminate_proxy()


def before_feature(context, feature):
    # context.browser = webdriver.Chrome()
    # context.browser = webdriver.Firefox()
    context.browser = webdriver.PhantomJS()
    context.browser.set_window_size(1280, 1024)
    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)
    context.browser.set_page_load_timeout(60)  # wait for data
    context.browser.get(HOMEPAGE_URL)


def after_step(context, step):
    if step.status == 'failed':
        id = str(uuid.uuid4())
        os.chdir(""screenshots"")
        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + "".png"")
        save_source(context, 'failed ' + str(step.name) + '_' + id + "".html"")
        os.chdir(""../"")


def after_feature(context, feature):
    context.browser.quit()

    cleanup_all_mails(context)
    context.last_mail = None


@wait_for(timeout=10.0)
def cleanup_all_mails(context):
    @defer.inlineCallbacks
    def _delete_all_mails():
        mails = yield context.client.mail_store.all_mails()
        for mail in mails:
            yield context.client.mail_store.delete_mail(mail.ident)

    return _delete_all_mails()


def save_source(context, filename='/tmp/source.html'):
    with open(filename, 'w') as out:
        out.write(context.browser.page_source.encode('utf8'))
/n/n/n",1
4,4,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
5,5,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
56,56,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
57,57,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
34,34,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"jupyter-5.0-default-jupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/njupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/n",0
35,35,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"/jupyter_notebook_config.py/n/n# Copyright (c) Jupyter Development Team.
from jupyter_core.paths import jupyter_data_dir
import subprocess
import os

PEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')

c = get_config()
c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'
c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)
c.NotebookApp.open_browser = False

# Set a certificate if USE_HTTPS is set to any value
if 'USE_HTTPS' in os.environ:
    if not os.path.isfile(PEM_FILE):
        # Generate a certificate if one doesn't exist on disk
        subprocess.check_call(['openssl', 'req', '-new', 
            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',
            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',
            '-keyout', PEM_FILE, '-out', PEM_FILE])
    c.NotebookApp.certfile = PEM_FILE

# Set a password if PASSWORD is set
if 'PASSWORD' in os.environ:
    from IPython.lib import passwd
    c.NotebookApp.password = passwd(os.environ['PASSWORD'])
    del os.environ['PASSWORD']
/n/n/n",1
78,78,7b18349622ca2f78a4aeb14ba2eb1e7fc224911d,"services/swarming/swarm_bot/url_helper.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""A helper script for wrapping url calls.""""""

import hashlib
import httplib
import logging
import math
import os
import random
import socket
import time
import urllib
import urllib2
import urlparse

from common import swarm_constants  # pylint: disable=W0403


# The index of the query elements from urlparse.
QUERY_INDEX = 4

# The timeout to apply whenever opening a url.
URL_OPEN_TIMEOUT = 5 * 60


class XsrfRemote(object):
  """"""Transparently adds XSRF token to requests.""""""

  def __init__(self, url):
    self.url = url.rstrip('/')
    self.token = None
    self.max_tries = 40

  def url_read(self, resource, **kwargs):
    url = self.url + resource
    if kwargs.get('method') == 'GET':
      return UrlOpen(url, max_tries=self.max_tries, **kwargs)

    if not self.token:
      self.token = self.refresh_token()
    headers = {'X-XSRF-Token': self.token}
    resp = UrlOpen(url, headers=headers, max_tries=self.max_tries, **kwargs)
    if not resp:
      # This includes 403 because the XSRF token expired. Renew the token.
      # TODO(maruel): It'd be great if it were transparent.
      headers = {'X-XSRF-Token': self.refresh_token()}
      resp = UrlOpen(url, headers=headers, max_tries=self.max_tries, **kwargs)
    return resp

  def refresh_token(self):
    """"""Returns a fresh token. Necessary as the token may expire after an hour.
    """"""
    url = self.url + '/auth/api/v1/accounts/self/xsrf_token'
    self.token = UrlOpen(url, max_tries=self.max_tries, method='GET')
    return self.token


def UrlOpen(url, data=None, files=None, max_tries=5, wait_duration=None,
            method='POST', headers=None):
  """"""Attempts to open the given url multiple times.

  UrlOpen will attempt to open the the given url several times, stopping
  if it succeeds at reaching the url. It also includes an additional data pair
  in the data that is sent to indicate how many times it has attempted to
  connect so far.

  Args:
    url: The url to open.
    data: The unencoded data to send to the url. This must be a mapping object.
    files: Files to upload with the url, in the format (key, filename, value).
        This is only valid when the method is POSTFORM.
    max_tries: The maximum number of times to try sending this data. Must be
        greater than 0.
    wait_duration: The number of seconds to wait between successive attempts.
        This must be greater than or equal to 0. If no value is given then a
        random value between 0.1 and 10 will be chosen each time (with
        exponential back off to give later retries a longer wait).
    method: Indicates if the request should be a GET or POST request.
    headers: List of HTTP headers to add.

  Returns:
    The reponse from the url contacted. If it failed to connect or is given
    invalid arguments, then it returns None.
  """"""
  if max_tries <= 0:
    logging.error('UrlOpen(%s): Invalid number of tries: %d', url, max_tries)
    return None

  if wait_duration and wait_duration < 0:
    logging.error('UrlOpen(%s): Invalid wait duration: %d', url, wait_duration)
    return None

  data = data or {}

  if swarm_constants.COUNT_KEY in data:
    logging.error(
        'UrlOpen(%s): key \'%s\' is duplicate.', url, swarm_constants.COUNT_KEY)
    return None

  url_response = None
  for attempt in range(max_tries):
    data[swarm_constants.COUNT_KEY] = attempt
    try:
      # urlencode requires that all strings be in ASCII form.
      for key, value in data.iteritems():
        if isinstance(value, basestring):
          data[key] = value.encode('utf-8', 'xmlcharrefreplace')

      encoded_data = urllib.urlencode(data)

      if method == 'POSTFORM':
        content_type, body = EncodeMultipartFormData(fields=data.iteritems(),
                                                     files=files)
        # We must ensure body isn't None to ensure the request is a POST.
        body = body or ''
        request = urllib2.Request(url, data=body)
        request.add_header('Content-Type', content_type)
        request.add_header('Content-Length', len(body))
      elif method == 'POST':
        # Simply specifying data to urlopen makes it a POST.
        request = urllib2.Request(url, encoded_data)
      else:
        url_parts = list(urlparse.urlparse(url))
        url_parts[QUERY_INDEX] = encoded_data
        url = urlparse.urlunparse(url_parts)
        request = urllib2.Request(url)

      for header, value in (headers or {}).iteritems():
        request.add_header(header, value)
      url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()
    except urllib2.HTTPError as e:
      if e.code >= 500:
        # The HTTPError was due to a server error, so retry the attempt.
        logging.warning('UrlOpen(%s): attempt %d: %s ', url, attempt, e)
      else:
        # This HTTPError means we reached the server and there was a problem
        # with the request, so don't retry.
        logging.exception('UrlOpen(%s): %s', url, e)
        return None
    except (httplib.HTTPException, socket.error, urllib2.URLError) as e:
      logging.warning('UrlOpen(%s): attempt %d: %s', url, attempt, e)

    if url_response is not None:
      logging.info('UrlOpen(%s) got %d bytes.', url, len(url_response))
      return url_response
    elif attempt != max_tries - 1:
      # Only sleep if we are going to try and connect again.
      if wait_duration is None:
        duration = random.random() * 3 + math.pow(1.5, (attempt + 1))
        duration = min(10, max(0.1, duration))
      else:
        duration = wait_duration

      time.sleep(duration)

  logging.error('UrlOpen(%s): Unable to open after %d attempts', url, max_tries)
  return None


def DownloadFile(local_file, url):
  """"""Downloads the data from the given url and saves it in the local_file.

  Args:
    local_file: Where to save the data downloaded from the url.
    url: Where to fetch the data from.

  Returns:
    True if the file is successfully downloaded.
  """"""
  local_file = os.path.abspath(local_file)

  url_data = UrlOpen(url, method='GET')

  if url_data is None:
    return False

  try:
    with open(local_file, 'wb') as f:
      f.write(url_data)
  except IOError as e:
    logging.error('Failed to write to %s\n%s', local_file, e)
    return False

  return True


def _ConvertToAscii(value):
  """"""Convert the given value to an ascii string.

  Args:
    value: The value to convert.

  Returns:
    The value as an ascii string.
  """"""
  if isinstance(value, str):
    return value
  if isinstance(value, unicode):
    return value.encode('utf-8')

  return str(value)


def EncodeMultipartFormData(fields=None, files=None):
  """"""Encodes a Multipart form data object.

  This recipe is taken from http://code.activestate.com/recipes/146306/,
  although it has been slighly modified.

  Args:
    fields: a sequence (name, value) elements for
      regular form fields.
    files: a sequence of (name, filename, value) elements for data to be
      uploaded as files.

  Returns:
    content_type: for httplib.HTTP instance
    body: for httplib.HTTP instance
  """"""
  fields = fields or []
  files = files or []

  boundary = hashlib.md5(str(time.time())).hexdigest()
  body_list = []
  for (key, value) in fields:
    key = _ConvertToAscii(key)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""' % key)
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  for (key, filename, value) in files:
    key = _ConvertToAscii(key)
    filename = _ConvertToAscii(filename)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""; '
                     'filename=""%s""' % (key, filename))
    # Other contents types are possible, but swarm is currently only using
    # this type.
    body_list.append('Content-Type: application/octet-stream')
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  if len(body_list) > 1:
    body_list[-2] += '--'

  body = '\r\n'.join(body_list)
  content_type = 'multipart/form-data; boundary=%s' % boundary

  return content_type, body
/n/n/nservices/swarming/swarm_bot/url_helper_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Unittest to exercise the code in url_helper.py.""""""


import logging
import os
import stat
import StringIO
import sys
import tempfile
import time
import unittest
import urllib
import urllib2

ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, ROOT_DIR)

import test_env

test_env.setup_test_env()

from depot_tools import auto_stub
from third_party.mox import mox

import url_helper  # pylint: disable=W0403


class UrlHelperTest(auto_stub.TestCase):
  def setUp(self):
    self._mox = mox.Mox()

    self.mock(logging, 'error', lambda *_: None)
    self.mock(logging, 'exception', lambda *_: None)
    self.mock(logging, 'info', lambda *_: None)
    self.mock(logging, 'warning', lambda *_: None)
    self._mox.StubOutWithMock(time, 'sleep')
    self._mox.StubOutWithMock(urllib2, 'urlopen')

  def tearDown(self):
    self._mox.UnsetStubs()

  def testXsrfRemoteGET(self):
    def assert_url(url):
      def has_url(req):
        self.assertEqual(url, req.get_full_url())
        return True
      return mox.Func(has_url)

    url_helper.urllib2.urlopen(
        assert_url('http://localhost/a?UrlOpenAttempt=0'),
        timeout=300).AndReturn(StringIO.StringIO('foo'))
    self._mox.ReplayAll()

    remote = url_helper.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a', method='GET'))
    self._mox.VerifyAll()

  def testXsrfRemoteSimple(self):
    def assert_url(url):
      def has_url(req):
        self.assertEqual(url, req.get_full_url())
        return True
      return mox.Func(has_url)

    xsrf_url = (
      'http://localhost/auth/api/v1/accounts/self/xsrf_token?UrlOpenAttempt=0')
    url_helper.urllib2.urlopen(
        assert_url(xsrf_url), timeout=300).AndReturn(StringIO.StringIO('token'))
    url_helper.urllib2.urlopen(
        assert_url('http://localhost/a'),
        timeout=300).AndReturn(StringIO.StringIO('foo'))
    self._mox.ReplayAll()

    remote = url_helper.XsrfRemote('http://localhost/')
    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))
    self._mox.VerifyAll()

  def testXsrfRemoteRefresh(self):
    self._mox.StubOutWithMock(url_helper, 'UrlOpen')

    url_helper.UrlOpen(
        'http://localhost/auth/api/v1/accounts/self/xsrf_token',
        max_tries=40, method='GET').AndReturn('token')
    url_helper.UrlOpen(
        'http://localhost/a', data={'foo': 'bar'}, max_tries=40,
        headers={'X-XSRF-Token': 'token'}
        ).AndReturn(None)
    url_helper.UrlOpen(
        'http://localhost/auth/api/v1/accounts/self/xsrf_token',
        max_tries=40, method='GET').AndReturn('token2')
    url_helper.UrlOpen(
        'http://localhost/a', data={'foo': 'bar'}, max_tries=40,
        headers={'X-XSRF-Token': 'token2'}
        ).AndReturn('foo')
    self._mox.ReplayAll()

    remote = url_helper.XsrfRemote('http://localhost/')
    remote.url_read('/a', data={'foo': 'bar'})
    #self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))
    self._mox.VerifyAll()

  def testUrlOpenInvalidTryCount(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenInvalidWaitDuration(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', wait_duration=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenGETSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='GET'), response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POST'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTFORMSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(
        mox.IsA(urllib2.Request), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POSTFORM'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenSuccessAfterFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    time.sleep(mox.IgnoreArg())
    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=2), response)

    self._mox.VerifyAll()

  def testUrlOpenFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    self._mox.ReplayAll()

    self.assertIsNone(url_helper.UrlOpen('url', max_tries=1))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorNoRetry(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 400, 'error message', None, None))
    self._mox.ReplayAll()

    # Even though we set max_tries to 10, we should only try once since
    # we get an HTTPError.
    self.assertIsNone(url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorWithRetry(self):
    response = 'response'

    # Urlopen failure attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 500, 'error message', None, None))
    time.sleep(mox.IgnoreArg())

    # Urlopen success attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    # Since the HTTPError was a server error, we should retry and get the
    # desired response after the error.
    self.assertEqual(response, url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testEnsureCountKeyIncludedInOpen(self):
    def assert_data(url):
      def has_data(req):
        self.assertEqual(url, req.get_data())
        return True
      return mox.Func(has_data)

    attempts = 5
    for i in range(attempts):
      encoded_data = urllib.urlencode({url_helper.swarm_constants.COUNT_KEY: i})
      url_helper.urllib2.urlopen(
          assert_data(encoded_data), timeout=mox.IgnoreArg()).AndRaise(
              urllib2.URLError('url'))
      if i != attempts - 1:
        time.sleep(mox.IgnoreArg())
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=attempts), None)
    self._mox.VerifyAll()

  def testCountKeyInData(self):
    data = {url_helper.swarm_constants.COUNT_KEY: 1}
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', data=data), None)
    self._mox.VerifyAll()

  def testNonAcsiiData(self):
    data = {'r': u'not ascii \xa3 \u04bb'}
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, data=data), response)

    self._mox.VerifyAll()

  def testDownloadFile(self):
    local_file = None
    try:
      local_file = tempfile.NamedTemporaryFile(delete=False)
      local_file.close()

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      file_data = 'data'
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(file_data)
      self._mox.ReplayAll()

      self.assertTrue(url_helper.DownloadFile(local_file.name,
                                              'http://www.fakeurl.com'))
      with open(local_file.name) as f:
        self.assertEqual(file_data, f.read())

      self._mox.VerifyAll()
    finally:
      if local_file:
        os.remove(local_file.name)

  def testDownloadFileDownloadError(self):
    try:
      fake_file = 'fake_local_file.fake'

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(None)
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(fake_file,
                                               'http://www.fakeurl.com'))
      self._mox.VerifyAll()
    finally:
      if os.path.exists(fake_file):
        os.remove(fake_file)

  def testDownloadFileSavingErrors(self):
    file_readonly = None
    try:
      file_readonly = tempfile.NamedTemporaryFile(delete=False)
      file_readonly.close()
      os.chmod(file_readonly.name, stat.S_IREAD)

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')

      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn('data')
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(file_readonly.name,
                                               'http://www.fakeurl.com'))

      self._mox.VerifyAll()
    finally:
      if file_readonly:
        os.remove(file_readonly.name)

  def testEncodeMultipartFormData(self):
    fields = [('x', 'y'), (1, 2)]
    files = [('key', 'filename', 'file data')]

    # Ensure that EncodeMultipartFormData works with any combination of fields
    # and files.
    content_type, body = url_helper.EncodeMultipartFormData()
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertEqual('', body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""key""; filename=""filename""' in body, body)
    self.assertTrue('file data' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields,
                                                            files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)


if __name__ == '__main__':
  # We don't want the application logs to interfere with our own messages.
  # You can comment it out for more information when debugging.
  logging.disable(logging.FATAL)
  unittest.main()
/n/n/n",0
79,79,7b18349622ca2f78a4aeb14ba2eb1e7fc224911d,"/services/swarming/swarm_bot/url_helper.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""A helper script for wrapping url calls.""""""

import hashlib
import httplib
import logging
import math
import os
import random
import socket
import time
import urllib
import urllib2
import urlparse

from common import swarm_constants  # pylint: disable=W0403


# The index of the query elements from urlparse.
QUERY_INDEX = 4

# The timeout to apply whenever opening a url.
URL_OPEN_TIMEOUT = 5 * 60


def UrlOpen(url, data=None, files=None, max_tries=5, wait_duration=None,
            method='POST'):
  """"""Attempts to open the given url multiple times.

  UrlOpen will attempt to open the the given url several times, stopping
  if it succeeds at reaching the url. It also includes an additional data pair
  in the data that is sent to indicate how many times it has attempted to
  connect so far.

  Args:
    url: The url to open.
    data: The unencoded data to send to the url. This must be a mapping object.
    files: Files to upload with the url, in the format (key, filename, value).
        This is only valid when the method is POSTFORM.
    max_tries: The maximum number of times to try sending this data. Must be
        greater than 0.
    wait_duration: The number of seconds to wait between successive attempts.
        This must be greater than or equal to 0. If no value is given then a
        random value between 0.1 and 10 will be chosen each time (with
        exponential back off to give later retries a longer wait).
    method: Indicates if the request should be a GET or POST request.

  Returns:
    The reponse from the url contacted. If it failed to connect or is given
    invalid arguments, then it returns None.
  """"""
  if max_tries <= 0:
    logging.error('UrlOpen(%s): Invalid number of tries: %d', url, max_tries)
    return None

  if wait_duration and wait_duration < 0:
    logging.error('UrlOpen(%s): Invalid wait duration: %d', url, wait_duration)
    return None

  data = data or {}

  if swarm_constants.COUNT_KEY in data:
    logging.error(
        'UrlOpen(%s): key \'%s\' is duplicate.', url, swarm_constants.COUNT_KEY)
    return None

  url_response = None
  for attempt in range(max_tries):
    data[swarm_constants.COUNT_KEY] = attempt
    try:
      # urlencode requires that all strings be in ASCII form.
      for key, value in data.iteritems():
        if isinstance(value, basestring):
          data[key] = value.encode('utf-8', 'xmlcharrefreplace')

      encoded_data = urllib.urlencode(data)

      if method == 'POSTFORM':
        content_type, body = EncodeMultipartFormData(fields=data.iteritems(),
                                                     files=files)
        # We must ensure body isn't None to ensure the request is a POST.
        body = body or ''
        request = urllib2.Request(url, data=body)
        request.add_header('Content-Type', content_type)
        request.add_header('Content-Length', len(body))

        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()
      elif method == 'POST':
        # Simply specifying data to urlopen makes it a POST.
        url_response = urllib2.urlopen(url, encoded_data,
                                       timeout=URL_OPEN_TIMEOUT).read()
      else:
        url_parts = list(urlparse.urlparse(url))
        url_parts[QUERY_INDEX] = encoded_data
        url = urlparse.urlunparse(url_parts)
        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()
    except urllib2.HTTPError as e:
      if e.code >= 500:
        # The HTTPError was due to a server error, so retry the attempt.
        logging.warning('UrlOpen(%s): attempt %d: %s ', url, attempt, e)
      else:
        # This HTTPError means we reached the server and there was a problem
        # with the request, so don't retry.
        logging.exception('UrlOpen(%s): %s', url, e)
        return None
    except (httplib.HTTPException, socket.error, urllib2.URLError) as e:
      logging.warning('UrlOpen(%s): attempt %d: %s', url, attempt, e)

    if url_response is not None:
      logging.info('UrlOpen(%s) got %d bytes.', url, len(url_response))
      return url_response
    elif attempt != max_tries - 1:
      # Only sleep if we are going to try and connect again.
      if wait_duration is None:
        duration = random.random() * 3 + math.pow(1.5, (attempt + 1))
        duration = min(10, max(0.1, duration))
      else:
        duration = wait_duration

      time.sleep(duration)

  logging.error('UrlOpen(%s): Unable to open after %d attempts', url, max_tries)
  return None


def DownloadFile(local_file, url):
  """"""Downloads the data from the given url and saves it in the local_file.

  Args:
    local_file: Where to save the data downloaded from the url.
    url: Where to fetch the data from.

  Returns:
    True if the file is successfully downloaded.
  """"""
  local_file = os.path.abspath(local_file)

  url_data = UrlOpen(url, method='GET')

  if url_data is None:
    return False

  try:
    with open(local_file, 'wb') as f:
      f.write(url_data)
  except IOError as e:
    logging.error('Failed to write to %s\n%s', local_file, e)
    return False

  return True


def _ConvertToAscii(value):
  """"""Convert the given value to an ascii string.

  Args:
    value: The value to convert.

  Returns:
    The value as an ascii string.
  """"""
  if isinstance(value, str):
    return value
  if isinstance(value, unicode):
    return value.encode('utf-8')

  return str(value)


def EncodeMultipartFormData(fields=None, files=None):
  """"""Encodes a Multipart form data object.

  This recipe is taken from http://code.activestate.com/recipes/146306/,
  although it has been slighly modified.

  Args:
    fields: a sequence (name, value) elements for
      regular form fields.
    files: a sequence of (name, filename, value) elements for data to be
      uploaded as files.

  Returns:
    content_type: for httplib.HTTP instance
    body: for httplib.HTTP instance
  """"""
  fields = fields or []
  files = files or []

  boundary = hashlib.md5(str(time.time())).hexdigest()
  body_list = []
  for (key, value) in fields:
    key = _ConvertToAscii(key)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""' % key)
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  for (key, filename, value) in files:
    key = _ConvertToAscii(key)
    filename = _ConvertToAscii(filename)
    value = _ConvertToAscii(value)

    body_list.append('--' + boundary)
    body_list.append('Content-Disposition: form-data; name=""%s""; '
                     'filename=""%s""' % (key, filename))
    # Other contents types are possible, but swarm is currently only using
    # this type.
    body_list.append('Content-Type: application/octet-stream')
    body_list.append('')
    body_list.append(value)
    body_list.append('--' + boundary)
    body_list.append('')

  if len(body_list) > 1:
    body_list[-2] += '--'

  body = '\r\n'.join(body_list)
  content_type = 'multipart/form-data; boundary=%s' % boundary

  return content_type, body
/n/n/n/services/swarming/swarm_bot/url_helper_test.py/n/n#!/usr/bin/env python
# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

""""""Unittest to exercise the code in url_helper.py.""""""


import logging
import os
import stat
import StringIO
import sys
import tempfile
import time
import unittest
import urllib
import urllib2

ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, ROOT_DIR)

import test_env

test_env.setup_test_env()

from depot_tools import auto_stub
from third_party.mox import mox

import url_helper  # pylint: disable=W0403


class UrlHelperTest(auto_stub.TestCase):
  def setUp(self):
    self._mox = mox.Mox()

    self.mock(logging, 'error', lambda *_: None)
    self.mock(logging, 'exception', lambda *_: None)
    self.mock(logging, 'info', lambda *_: None)
    self.mock(logging, 'warning', lambda *_: None)
    self._mox.StubOutWithMock(time, 'sleep')
    self._mox.StubOutWithMock(urllib2, 'urlopen')

  def tearDown(self):
    self._mox.UnsetStubs()

  def testUrlOpenInvalidTryCount(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenInvalidWaitDuration(self):
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', wait_duration=-1), None)

    self._mox.VerifyAll()

  def testUrlOpenGETSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.StrContains(url),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='GET'), response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POST'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenPOSTFORMSuccess(self):
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(
        mox.IsA(urllib2.Request), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, method='POSTFORM'),
                     response)

    self._mox.VerifyAll()

  def testUrlOpenSuccessAfterFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    time.sleep(mox.IgnoreArg())
    response = 'True'
    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=2), response)

    self._mox.VerifyAll()

  def testUrlOpenFailure(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.URLError('url'))
    self._mox.ReplayAll()

    self.assertIsNone(url_helper.UrlOpen('url', max_tries=1))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorNoRetry(self):
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 400, 'error message', None, None))
    self._mox.ReplayAll()

    # Even though we set max_tries to 10, we should only try once since
    # we get an HTTPError.
    self.assertIsNone(url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testUrlOpenHTTPErrorWithRetry(self):
    response = 'response'

    # Urlopen failure attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(
            urllib2.HTTPError('url', 500, 'error message', None, None))
    time.sleep(mox.IgnoreArg())

    # Urlopen success attempt.
    url_helper.urllib2.urlopen(
        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(
            StringIO.StringIO(response))

    self._mox.ReplayAll()

    # Since the HTTPError was a server error, we should retry and get the
    # desired response after the error.
    self.assertEqual(response, url_helper.UrlOpen('url', max_tries=10))

    self._mox.VerifyAll()

  def testEnsureCountKeyIncludedInOpen(self):
    attempts = 5
    for i in range(attempts):
      encoded_data = urllib.urlencode({url_helper.swarm_constants.COUNT_KEY: i})

      url_helper.urllib2.urlopen(
          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(
              urllib2.URLError('url'))
      if i != attempts - 1:
        time.sleep(mox.IgnoreArg())
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', max_tries=attempts), None)
    self._mox.VerifyAll()

  def testCountKeyInData(self):
    data = {url_helper.swarm_constants.COUNT_KEY: 1}
    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen('url', data=data), None)
    self._mox.VerifyAll()

  def testNonAcsiiData(self):
    data = {'r': u'not ascii \xa3 \u04bb'}
    url = 'http://my.url.com'

    response = 'True'
    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),
                               timeout=mox.IgnoreArg()).AndReturn(
                                   StringIO.StringIO(response))

    self._mox.ReplayAll()

    self.assertEqual(url_helper.UrlOpen(url, data=data), response)

    self._mox.VerifyAll()

  def testDownloadFile(self):
    local_file = None
    try:
      local_file = tempfile.NamedTemporaryFile(delete=False)
      local_file.close()

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      file_data = 'data'
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(file_data)
      self._mox.ReplayAll()

      self.assertTrue(url_helper.DownloadFile(local_file.name,
                                              'http://www.fakeurl.com'))
      with open(local_file.name) as f:
        self.assertEqual(file_data, f.read())

      self._mox.VerifyAll()
    finally:
      if local_file:
        os.remove(local_file.name)

  def testDownloadFileDownloadError(self):
    try:
      fake_file = 'fake_local_file.fake'

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')
      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(None)
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(fake_file,
                                               'http://www.fakeurl.com'))
      self._mox.VerifyAll()
    finally:
      if os.path.exists(fake_file):
        os.remove(fake_file)

  def testDownloadFileSavingErrors(self):
    file_readonly = None
    try:
      file_readonly = tempfile.NamedTemporaryFile(delete=False)
      file_readonly.close()
      os.chmod(file_readonly.name, stat.S_IREAD)

      self._mox.StubOutWithMock(url_helper, 'UrlOpen')

      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn('data')
      self._mox.ReplayAll()

      self.assertFalse(url_helper.DownloadFile(file_readonly.name,
                                               'http://www.fakeurl.com'))

      self._mox.VerifyAll()
    finally:
      if file_readonly:
        os.remove(file_readonly.name)

  def testEncodeMultipartFormData(self):
    fields = [('x', 'y'), (1, 2)]
    files = [('key', 'filename', 'file data')]

    # Ensure that EncodeMultipartFormData works with any combination of fields
    # and files.
    content_type, body = url_helper.EncodeMultipartFormData()
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertEqual('', body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""key""; filename=""filename""' in body, body)
    self.assertTrue('file data' in body, body)

    content_type, body = url_helper.EncodeMultipartFormData(fields=fields,
                                                            files=files)
    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))
    self.assertTrue('name=""x""\r\n\r\ny' in body, body)
    self.assertTrue('name=""1""\r\n\r\n2' in body, body)


if __name__ == '__main__':
  # We don't want the application logs to interfere with our own messages.
  # You can comment it out for more information when debugging.
  logging.disable(logging.FATAL)
  unittest.main()
/n/n/n",1
84,84,481a3e8120787d449ad7bbc6a627d8450bceb85c,"appengine/components/components/auth/ui/ui.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Auth management UI handlers.""""""

import functools
import json
import os
import re
import webapp2

from components import template
from components import utils

from . import acl
from . import rest_api

from .. import api
from .. import change_log
from .. import handler
from .. import model
from .. import replication


# templates/.
TEMPLATES_DIR = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), 'templates')


# Global static configuration set in 'configure_ui'.
_ui_app_name = 'Unknown'
_ui_data_callback = None
_ui_navbar_tabs = ()


def configure_ui(app_name, ui_tabs=None, ui_data_callback=None):
  """"""Modifies global configuration of Auth UI.

  Args:
    app_name: name of the service (visible in page headers, titles, etc.)
    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or
        None to show the standard set of tabs.
    ui_data_callback: an argumentless callable that returns a dict with
        additional data to return to authenticated users. It can be used by
        server and client side code to render templates. Used by auth_service.
  """"""
  global _ui_app_name
  global _ui_data_callback
  global _ui_navbar_tabs
  _ui_app_name = app_name
  _ui_data_callback = ui_data_callback
  if ui_tabs is not None:
    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)
    _ui_navbar_tabs = tuple(ui_tabs)
  template.bootstrap({'auth': TEMPLATES_DIR})


def get_ui_routes():
  """"""Returns a list of routes with auth UI handlers.""""""
  routes = []
  if not utils.should_disable_ui_routes():
    # Routes for registered navbar tabs.
    for cls in _ui_navbar_tabs:
      routes.extend(cls.get_webapp2_routes())
    # Routes for everything else.
    routes.extend([
      webapp2.Route(r'/auth', MainHandler),
      webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),
      webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),
      webapp2.Route(r'/auth/link', LinkToPrimaryHandler),
    ])
  return routes


def forbid_ui_on_replica(method):
  """"""Decorator for methods that are not allowed to be called on Replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 405 ""Method Not Allowed"".
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      self.abort(
          405,
          detail='Not allowed on a replica, see primary at %s' % primary_url)
    return method(self, *args, **kwargs)
  return wrapper


def redirect_ui_on_replica(method):
  """"""Decorator for methods that redirect to Primary when called on replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 302 redirect to corresponding method on Primary.
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    assert self.request.method == 'GET'
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      protocol = 'http://' if utils.is_local_dev_server() else 'https://'
      assert primary_url and primary_url.startswith(protocol), primary_url
      assert self.request.path_qs.startswith('/'), self.request.path_qs
      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)
    return method(self, *args, **kwargs)
  return wrapper


################################################################################
## Admin routes. The use cookies and GAE's ""is_current_user_admin"" for authn.


class AdminPageHandler(handler.AuthenticatingHandler):
  """"""Base class for handlers involved in bootstrap processes.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  @classmethod
  def get_auth_methods(cls, conf):
    # This method sets 'is_superuser' bit for GAE-level admins.
    return [handler.gae_cookie_authentication]

  def reply(self, path, env=None, status=200):
    """"""Render template |path| to response using given environment.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    full_env = {
      'app_name': _ui_app_name,
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html
      'xsrf_token': self.generate_xsrf_token(),
    }
    full_env.update(env or {})
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=403)


class BootstrapHandler(AdminPageHandler):
  """"""Creates Administrators group (if necessary) and adds current caller to it.

  Requires Appengine level Admin access for its handlers, since Administrators
  group may not exist yet.

  Used during bootstrap of a new service instance.
  """"""

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'return_url': self.request.get('r') or '',
    }
    self.reply('auth/admin/bootstrap.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    added = model.bootstrap_group(
        model.ADMIN_GROUP, [api.get_current_identity()],
        'Users that can manage groups')
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'added': added,
      'return_url': self.request.get('return_url') or '',
    }
    self.reply('auth/admin/bootstrap_done.html', env)


class BootstrapOAuthHandler(AdminPageHandler):
  """"""Page to set OAuth2 client ID used by the main web UI.

  Requires Appengine level Admin access for its handlers, since without client
  ID there's no UI yet to configure Administrators group.

  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is
  also available after the service is linked to some primary Auth service.
  """"""

  @api.require(api.is_superuser)
  def get(self):
    self.show_page(web_client_id=api.get_web_client_id_uncached())

  @api.require(api.is_superuser)
  def post(self):
    web_client_id = self.request.POST['web_client_id']
    api.set_web_client_id(web_client_id)
    self.show_page(web_client_id=web_client_id, saved=True)

  def show_page(self, web_client_id, saved=False):
    env = {
      'page_title': 'OAuth2 web client ID',
      'web_client_id': web_client_id or '',
      'saved': saved,
    }
    self.reply('auth/admin/bootstrap_oauth.html', env)


class LinkToPrimaryHandler(AdminPageHandler):
  """"""A page with confirmation of Primary <-> Replica linking request.

  URL to that page is generated by a Primary service.
  """"""

  def decode_link_ticket(self):
    """"""Extracts ServiceLinkTicket from 't' GET parameter.""""""
    try:
      return replication.decode_link_ticket(
          self.request.get('t').encode('ascii'))
    except (KeyError, ValueError):
      self.abort(400)
      return

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    ticket = self.decode_link_ticket()
    env = {
      'generated_by': ticket.generated_by,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
    }
    self.reply('auth/admin/linking.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    ticket = self.decode_link_ticket()
    success = True
    error_msg = None
    try:
      replication.become_replica(ticket, api.get_current_identity())
    except replication.ProtocolError as exc:
      success = False
      error_msg = exc.message
    env = {
      'error_msg': error_msg,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
      'success': success,
    }
    self.reply('auth/admin/linking_done.html', env)


################################################################################
## Web UI routes.

# TODO(vadimsh): Switch them to use OAuth for authentication.


class UIHandler(handler.AuthenticatingHandler):
  """"""Renders Jinja templates extending base.html.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  def reply(self, path, env=None, status=200):
    """"""Renders template |path| to the HTTP response using given environment.

    Optional keys from |env| that base.html uses:
      css_file: URL to a file with page specific styles, relative to site root.
      js_file: URL to a file with page specific Javascript code, relative to
          site root. File should define global object named same as a filename,
          i.e. '/auth/static/js/api.js' should define global object 'api' that
          incapsulates functionality implemented in the module.
      navbar_tab_id: id of a navbar tab to highlight.
      page_title: title of an HTML page.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    env = (env or {}).copy()
    env.setdefault('css_file', None)
    env.setdefault('js_file', None)
    env.setdefault('navbar_tab_id', None)
    env.setdefault('page_title', 'Untitled')

    # This goes to both Jinja2 env and Javascript config object.
    user = self.get_current_user()
    common = {
      'account_picture': user.picture() if user else None,
      'auth_service_config_locked': False, # overridden in auth_service
      'is_admin': api.is_admin(),
      'login_url': self.create_login_url(self.request.url),
      'logout_url': self.create_logout_url('/'),
      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,
      'xsrf_token': self.generate_xsrf_token(),
    }
    if _ui_data_callback:
      common.update(_ui_data_callback())

    # Name of Javascript module with page code.
    js_module_name = None
    if env['js_file']:
      assert env['js_file'].endswith('.js')
      js_module_name = os.path.basename(env['js_file'])[:-3]

    # This will be accessible from Javascript as global 'config' variable.
    js_config = {
      'identity': api.get_current_identity().to_bytes(),
    }
    js_config.update(common)

    # Jinja2 environment to use to render a template.
    full_env = {
      'app_name': _ui_app_name,
      'app_revision_url': utils.get_app_revision_url(),
      'app_version': utils.get_app_version(),
      'config': json.dumps(js_config),
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'js_module_name': js_module_name,
      'navbar': [
        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)
        for cls in _ui_navbar_tabs
        if cls.is_visible()
      ],
    }
    full_env.update(common)
    full_env.update(env)

    # Render it.
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=403)


class MainHandler(UIHandler):
  """"""Redirects to first navbar tab.""""""
  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    assert _ui_navbar_tabs
    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)


class UINavbarTabHandler(UIHandler):
  """"""Handler for a navbar tab page.""""""
  # List of routes to register, default is [navbar_tab_url].
  routes = []
  # URL to the tab (relative to site root).
  navbar_tab_url = None
  # ID of the tab, will be used in DOM.
  navbar_tab_id = None
  # Title of the tab, will be used in tab title and page title.
  navbar_tab_title = None
  # Relative URL to CSS file with tab's styles.
  css_file = None
  # Relative URL to javascript file with tab's logic.
  js_file_url = None
  # Path to a Jinja2 template with tab's markup.
  template_file = None

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self, **_params):
    """"""Renders page HTML to HTTP response stream.""""""
    env = {
      'css_file': self.css_file,
      'js_file': self.js_file_url,
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
    }
    self.reply(self.template_file, env)

  @classmethod
  def get_webapp2_routes(cls):
    routes = cls.routes or [cls.navbar_tab_url]
    return [webapp2.Route(r, cls) for r in routes]

  @classmethod
  def is_visible(cls):
    """"""Subclasses may return False to hide the tab from tab bar.""""""
    return True


################################################################################
## Default tabs.


class GroupsHandler(UINavbarTabHandler):
  """"""Page with Groups management.""""""
  routes = [
    '/auth/groups',
    '/auth/groups/<group:.*>',  # 'group' is handled by js code
  ]
  navbar_tab_url = '/auth/groups'
  navbar_tab_id = 'groups'
  navbar_tab_title = 'Groups'
  css_file = '/auth/static/css/groups.css'
  js_file_url = '/auth/static/js/groups.js'
  template_file = 'auth/groups.html'


class ChangeLogHandler(UINavbarTabHandler):
  """"""Page with a log of changes to some groups.""""""
  navbar_tab_url = '/auth/change_log'
  navbar_tab_id = 'change_log'
  navbar_tab_title = 'Change Log'
  js_file_url = '/auth/static/js/change_log.js'
  template_file = 'auth/change_log.html'

  @classmethod
  def is_visible(cls):
    # Hide 'Change Log' tab if there are no change log indexes in the datastore.
    # It happens on services that use components.auth, but do not modify
    # index.yaml. Don't try too hard to hide the log though. If user happes to
    # stumble on Change log page (e.g. by using direct URL), it handles
    # NeedIndexError gracefully (explaining how to configure indexes).
    return change_log.is_changle_log_indexed()


class OAuthConfigHandler(UINavbarTabHandler):
  """"""Page with OAuth configuration.""""""
  navbar_tab_url = '/auth/oauth_config'
  navbar_tab_id = 'oauth_config'
  navbar_tab_title = 'OAuth'
  js_file_url = '/auth/static/js/oauth_config.js'
  template_file = 'auth/oauth_config.html'


class IPWhitelistsHandler(UINavbarTabHandler):
  """"""Page with IP whitelists configuration.""""""
  navbar_tab_url = '/auth/ip_whitelists'
  navbar_tab_id = 'ip_whitelists'
  navbar_tab_title = 'IP Whitelists'
  js_file_url = '/auth/static/js/ip_whitelists.js'
  template_file = 'auth/ip_whitelists.html'


class ApiDocHandler(UINavbarTabHandler):
  """"""Page with API documentation extracted from rest_api.py.""""""
  navbar_tab_url = '/auth/api'
  navbar_tab_id = 'api'
  navbar_tab_title = 'API'

  # These can be used as 'request_type' and 'response_type' in api_doc.
  doc_types = [
    {
      'name': 'Status',
      'doc': 'Outcome of some operation.',
      'example': {'ok': True},
    },
    {
      'name': 'Self info',
      'doc': 'Information about the requester.',
      'example': {
        'identity': 'user:someone@example.com',
        'ip': '192.168.0.1',
      },
    },
    {
      'name': 'Group',
      'doc': 'Represents a group, as stored in the database.',
      'example': {
        'group': {
          'caller_can_modify': True,
          'created_by': 'user:someone@example.com',
          'created_ts': 1409250754978540,
          'description': 'Some free form description',
          'globs': ['user:*@example.com'],
          'members': ['user:a@example.com', 'anonymous:anonymous'],
          'modified_by': 'user:someone@example.com',
          'modified_ts': 1470871200558130,
          'name': 'Some group',
          'nested': ['Some nested group', 'Another nested group'],
          'owners': 'Owning group',
        },
      },
    },
    {
      'name': 'Group listing',
      'doc':
        'All groups, along with their metadata. Does not include members '
        'listings.',
      'example': {
        'groups': [
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Some free form description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Some group',
            'owners': 'Owning group',
          },
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Another description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Another group',
            'owners': 'Owning group',
          },
        ],
      },
    },
  ]

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    """"""Extracts API doc for registered webapp2 API routes.""""""
    doc_types = []

    def add_doc_type(tp):
      """"""Adds a request or response format definition to the documentation page.

      'tp' can either reference a globally known doc type by name
      (see ApiDocHandler.doc_types), or can itself be a dict with doc type
      definition.

      Returns the name of the doc type.
      """"""
      if not tp:
        return None
      # If referenced by name, try to find it among globally known types.
      if isinstance(tp, basestring):
        for d in self.doc_types:
          if d['name'] == tp:
            tp = d
            break
        else:
          return tp  # not found, return original name as is
      # Add, if not already there. Serialize the example first, since doing it
      # from Jinja is a bit more complicated.
      if not any(d['name'] == tp['name'] for d in doc_types):
        tp = tp.copy()
        tp['example'] = json.dumps(
            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)
        doc_types.append(tp)
      return tp['name']

    api_methods = []
    for route in rest_api.get_rest_api_routes():
      # Remove API parameter regexps from route template, they are mostly noise.
      simplified = re.sub(r'\:.*\>', '>', route.template)
      for doc in getattr(route.handler, 'api_doc', []):
        path = simplified
        if 'params' in doc:
          path += '?' + doc['params']
        api_methods.append({
          'verb': doc['verb'],
          'path': path,
          'doc': doc['doc'],
          'request_type': add_doc_type(doc.get('request_type')),
          'response_type': add_doc_type(doc.get('response_type')),
        })

    env = {
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
      'api_methods': api_methods,
      'doc_types': doc_types,
    }
    self.reply('auth/api.html', env)


# Register them as default tabs. Order is important.
_ui_navbar_tabs = (
  GroupsHandler,
  ChangeLogHandler,
  OAuthConfigHandler,
  IPWhitelistsHandler,
  ApiDocHandler,
)
/n/n/nappengine/components/components/ereporter2/handlers.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""HTTP Handlers.""""""

import datetime
import itertools
import json
import time

import webapp2

from google.appengine.api import app_identity
from google.appengine.datastore import datastore_query
from google.appengine.ext import ndb

from components import auth
from components import decorators
from components import template
from components import utils

from . import acl
from . import logscraper
from . import models
from . import on_error
from . import ui


# Access to a protected member XXX of a client class - pylint: disable=W0212


### Admin pages.


class RestrictedEreporter2Report(auth.AuthenticatingHandler):
  """"""Returns all the recent errors as a web page.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    """"""Reports the errors logged and ignored.

    Arguments:
      start: epoch time to start looking at. Defaults to the messages since the
             last email.
      end: epoch time to stop looking at. Defaults to now.
      modules: comma separated modules to look at.
      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.
    """"""
    # TODO(maruel): Be consistent about using either epoch or human readable
    # formatted datetime.
    end = int(float(self.request.get('end', 0)) or time.time())
    start = int(
        float(self.request.get('start', 0)) or
        ui._get_default_start_time() or 0)
    modules = self.request.get('modules')
    if modules:
      modules = modules.split(',')
    tainted = bool(int(self.request.get('tainted', '1')))
    module_versions = utils.get_module_version_list(modules, tainted)
    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(
        start, end, module_versions)

    params = {
      'errors': errors,
      'errors_count': sum(len(e.events) for e in errors),
      'errors_version_count':
          len(set(itertools.chain.from_iterable(e.versions for e in errors))),
      'ignored': ignored,
      'ignored_count': sum(len(i.events) for i in ignored),
      'ignored_version_count':
          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),
      'xsrf_token': self.generate_xsrf_token(),
    }
    params.update(ui._get_template_env(start, end, module_versions))
    self.response.write(template.render('ereporter2/requests.html', params))


class RestrictedEreporter2Request(auth.AuthenticatingHandler):
  """"""Dumps information about single logged request.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, request_id):
    data = logscraper._log_request_id(request_id)
    if not data:
      self.abort(404, detail='Request id was not found.')
    self.response.write(
        template.render('ereporter2/request.html', {'request': data}))


class RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    limit = int(self.request.get('limit', 100))
    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))
    errors_found, cursor, more = models.Error.query().order(
        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)
    params = {
      'cursor': cursor.urlsafe() if cursor and more else None,
      'errors': errors_found,
      'limit': limit,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/errors.html', params))


class RestrictedEreporter2Error(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, error_id):
    error = models.Error.get_by_id(int(error_id))
    if not error:
      self.abort(404, 'Error not found')
    params = {
      'error': error,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/error.html', params))


class RestrictedEreporter2Silence(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    # Due to historical reasons where created_ts had indexed=False,, do not use
    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all
    # objects have been updated.
    items = models.ErrorReportingMonitoring.query().fetch()
    items.sort(key=lambda x: x.created_ts)
    params = {
      'silenced': items,
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.out.write(template.render('ereporter2/silence.html', params))

  @auth.require(acl.is_ereporter2_editor)
  def post(self):
    to_delete = self.request.get('to_delete')
    if to_delete:
      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()
    else:
      mute_type = self.request.get('mute_type')
      error = None
      if mute_type in ('exception_type', 'signature'):
        error = self.request.get(mute_type)
      if not error:
        self.abort(400)
      silenced = self.request.get('silenced')
      silenced_until = self.request.get('silenced_until')
      if silenced_until == 'T':
        silenced_until = ''
      threshold = self.request.get('threshold')
      key = models.ErrorReportingMonitoring.error_to_key(error)
      if not silenced and not silenced_until and not threshold:
        key.delete()
      else:
        item = models.ErrorReportingMonitoring(key=key, error=error)
        if silenced:
          item.silenced = True
        if silenced_until:
          item.silenced_until = datetime.datetime.strptime(
              silenced_until, '%Y-%m-%dT%H:%M')
        if threshold:
          item.threshold = int(threshold)
        item.put()

    self.get()


### Cron jobs.


class CronEreporter2Mail(webapp2.RequestHandler):
  """"""Generate and emails an exception report.""""""
  @decorators.require_cronjob
  def get(self):
    """"""Sends email(s) containing the errors logged.""""""
    # Do not use self.request.host_url because it will be http:// and will point
    # to the backend, with an host format that breaks the SSL certificate.
    # TODO(maruel): On the other hand, Google Apps instances are not hosted on
    # appspot.com.
    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()
    request_id_url = host_url + '/restricted/ereporter2/request/'
    report_url = host_url + '/restricted/ereporter2/report'
    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())
    result = ui._generate_and_email_report(
        utils.get_module_version_list(None, False),
        recipients,
        request_id_url,
        report_url,
        {})
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    if result:
      self.response.write('Success.')
    else:
      # Do not HTTP 500 since we do not want it to be retried.
      self.response.write('Failed.')


class CronEreporter2Cleanup(webapp2.RequestHandler):
  """"""Deletes old error reports.""""""
  @decorators.require_cronjob
  def get(self):
    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE
    items = models.Error.query(
        models.Error.created_ts < old_cutoff,
        default_options=ndb.QueryOptions(keys_only=True))
    out = len(ndb.delete_multi(items))
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write(str(out))


### Public API.


class OnErrorHandler(auth.AuthenticatingHandler):
  """"""Adds an error report.

  This one is open so errors like authentication reports are logged in too.
  This means we could get spammed a lot about it. Implement DDoS protection by
  rate limiting once a kid figures out.
  """"""
  xsrf_token_enforce_on = ()

  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be
  # factored out.
  def parse_body(self):
    """"""Parse JSON body and verifies it's a dict.""""""
    expected = ('application/json', 'application/json; charset=utf-8')
    if self.request.headers.get('Content-Type').lower() not in expected:
      msg = 'Expecting JSON body with content type \'application/json\''
      self.abort(400, msg)
    try:
      body = json.loads(self.request.body)
      if not isinstance(body, dict):
        raise ValueError()
    except ValueError:
      self.abort(400, 'Not a valid json dict body')
    return body

  @auth.public
  def post(self):
    body = self.parse_body()
    version = body.get('v')
    # Do not enforce version for now, just assert it is present.
    if not version:
      self.abort(400, 'Missing version')

    report = body.get('r')
    if not report:
      self.abort(400, 'Missing report')

    kwargs = dict(
        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))
    report_id = on_error.log_request(self.request, add_params=False, **kwargs)
    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'
    body = {
      'id': report_id,
      'url':
          '%s/restricted/ereporter2/errors/%d' %
          (self.request.host_url, report_id),
    }
    self.response.write(utils.encode_to_json(body))


def get_frontend_routes():
  routes = [
    # Public API.
    webapp2.Route(
      '/ereporter2/api/v1/on_error', OnErrorHandler),
  ]
  if not utils.should_disable_ui_routes():
    routes.extend([
      webapp2.Route(
        r'/restricted/ereporter2/errors',
        RestrictedEreporter2ErrorsList),
      webapp2.Route(
        r'/restricted/ereporter2/errors/<error_id:\d+>',
        RestrictedEreporter2Error),
      webapp2.Route(
        r'/restricted/ereporter2/report',
        RestrictedEreporter2Report),
      webapp2.Route(
        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',
        RestrictedEreporter2Request),
      webapp2.Route(
        r'/restricted/ereporter2/silence',
        RestrictedEreporter2Silence),
    ])

  return routes


def get_backend_routes():
  # This requires a cron job to this URL.
  return [
    webapp2.Route(
        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),
    webapp2.Route(
        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),
  ]
/n/n/nappengine/components/components/utils.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Mixed bag of utilities.""""""

# Disable 'Access to a protected member ...'. NDB uses '_' for other purposes.
# pylint: disable=W0212

# Disable: 'Method could be a function'. It can't: NDB expects a method.
# pylint: disable=R0201

import binascii
import datetime
import functools
import hashlib
import inspect
import json
import logging
import os
import re
import sys
import threading
import urlparse

from email import utils as email_utils

from google.appengine import runtime
from google.appengine.api import app_identity
from google.appengine.api import memcache as gae_memcache
from google.appengine.api import modules
from google.appengine.api import taskqueue
from google.appengine.ext import ndb

from protorpc import messages
from protorpc.remote import protojson

THIS_DIR = os.path.dirname(os.path.abspath(__file__))

DATETIME_FORMAT = u'%Y-%m-%d %H:%M:%S'
DATE_FORMAT = u'%Y-%m-%d'
VALID_DATETIME_FORMATS = ('%Y-%m-%d', '%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S')


# UTC datetime corresponding to zero Unix timestamp.
EPOCH = datetime.datetime.utcfromtimestamp(0)

# Module to run task queue tasks on by default. Used by get_task_queue_host
# function. Can be changed by 'set_task_queue_module' function.
_task_queue_module = 'backend'


def should_disable_ui_routes():
    return os.environ.get('LUCI_DISABLE_UI_ROUTES', '0') == '1'


def is_local_dev_server():
  """"""Returns True if running on local development server or in unit tests.

  This function is safe to run outside the scope of a HTTP request.
  """"""
  return os.environ.get('SERVER_SOFTWARE', '').startswith('Development')


def is_dev():
  """"""Returns True if the server is running a development/staging instance.

  We define a 'development instance' as an instance that has the suffix '-dev'
  in its instance name.

  This function is safe to run outside the scope of a HTTP request.
  """"""
  return os.environ['APPLICATION_ID'].endswith('-dev')


def is_unit_test():
  """"""Returns True if running in a unit test.

  Don't abuse it, use only if really desperate. For example, in a component that
  is included by many-many projects across many repos, when mocking some
  component behavior in all unit tests that indirectly invoke it is infeasible.
  """"""
  if not is_local_dev_server():
    return False
  # devappserver2 sets up some sort of a sandbox that is not activated for
  # unit tests. So differentiate based on that.
  return all(
      'google.appengine.tools.devappserver2' not in str(p)
      for p in sys.meta_path)


def get_module_version_list(module_list, tainted):
  """"""Returns a list of pairs (module name, version name) to fetch logs for.

  Arguments:
    module_list: list of modules to list, defaults to all modules.
    tainted: if False, excludes versions with '-tainted' in their name.
  """"""
  result = []
  if not module_list:
    # If the function it called too often, it'll raise a OverQuotaError. So
    # cache it for 10 minutes.
    module_list = gae_memcache.get('modules_list')
    if not module_list:
      module_list = modules.get_modules()
      gae_memcache.set('modules_list', module_list, time=10*60)

  for module in module_list:
    # If the function it called too often, it'll raise a OverQuotaError.
    # Versions is a bit more tricky since we'll loose data, since versions are
    # changed much more often than modules. So cache it for 1 minute.
    key = 'modules_list-' + module
    version_list = gae_memcache.get(key)
    if not version_list:
      version_list = modules.get_versions(module)
      gae_memcache.set(key, version_list, time=60)
    result.extend(
        (module, v) for v in version_list if tainted or '-tainted' not in v)
  return result


def get_request_as_int(request, key, default, min_value, max_value):
  """"""Returns a request value as int.""""""
  value = request.params.get(key, '')
  try:
    value = int(value)
  except ValueError:
    return default
  return min(max_value, max(min_value, value))


def parse_datetime(text):
  """"""Converts text to datetime.datetime instance or None.""""""
  for f in VALID_DATETIME_FORMATS:
    try:
      return datetime.datetime.strptime(text, f)
    except ValueError:
      continue
  return None


def parse_rfc3339_datetime(value):
  """"""Parses RFC 3339 datetime string (as used in Timestamp proto JSON encoding).

  Keeps only microsecond precision (dropping nanoseconds).

  Examples of the input:
    2017-08-17T04:21:32.722952943Z
    1972-01-01T10:00:20.021-05:00

  Returns:
    datetime.datetime in UTC (regardless of timezone of the original string).

  Raises:
    ValueError on errors.
  """"""
  # Adapted from protobuf/internal/well_known_types.py Timestamp.FromJsonString.
  # We can't use the original, since it's marked as internal. Also instantiating
  # proto messages here to parse a string would been odd.
  timezone_offset = value.find('Z')
  if timezone_offset == -1:
    timezone_offset = value.find('+')
  if timezone_offset == -1:
    timezone_offset = value.rfind('-')
  if timezone_offset == -1:
    raise ValueError('Failed to parse timestamp: missing valid timezone offset')
  time_value = value[0:timezone_offset]
  # Parse datetime and nanos.
  point_position = time_value.find('.')
  if point_position == -1:
    second_value = time_value
    nano_value = ''
  else:
    second_value = time_value[:point_position]
    nano_value = time_value[point_position + 1:]
  date_object = datetime.datetime.strptime(second_value, '%Y-%m-%dT%H:%M:%S')
  td = date_object - EPOCH
  seconds = td.seconds + td.days * 86400
  if len(nano_value) > 9:
    raise ValueError(
        'Failed to parse timestamp: nanos %r more than 9 fractional digits'
        % nano_value)
  if nano_value:
    nanos = round(float('0.' + nano_value) * 1e9)
  else:
    nanos = 0
  # Parse timezone offsets.
  if value[timezone_offset] == 'Z':
    if len(value) != timezone_offset + 1:
      raise ValueError(
          'Failed to parse timestamp: invalid trailing data %r' % value)
  else:
    timezone = value[timezone_offset:]
    pos = timezone.find(':')
    if pos == -1:
      raise ValueError('Invalid timezone offset value: %r' % timezone)
    if timezone[0] == '+':
      seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
    else:
      seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60
  return timestamp_to_datetime(int(seconds)*1e6 + int(nanos)/1e3)


def constant_time_equals(a, b):
  """"""Compares two strings in constant time regardless of theirs content.""""""
  if len(a) != len(b):
    return False
  result = 0
  for x, y in zip(a, b):
    result |= ord(x) ^ ord(y)
  return result == 0


def to_units(number):
  """"""Convert a string to numbers.""""""
  UNITS = ('', 'k', 'm', 'g', 't', 'p', 'e', 'z', 'y')
  unit = 0
  while number >= 1024.:
    unit += 1
    number = number / 1024.
    if unit == len(UNITS) - 1:
      break
  if unit:
    return '%.2f%s' % (number, UNITS[unit])
  return '%d' % number


def validate_root_service_url(url):
  """"""Raises ValueError if the URL doesn't look like https://<host>.""""""
  schemes = ('https', 'http') if is_local_dev_server() else ('https',)
  parsed = urlparse.urlparse(url)
  if parsed.scheme not in schemes:
    raise ValueError('unsupported protocol %r' % str(parsed.scheme))
  if not parsed.netloc:
    raise ValueError('missing hostname')
  stripped = urlparse.urlunparse((parsed[0], parsed[1], '', '', '', ''))
  if stripped != url:
    raise ValueError('expecting root host URL, e.g. %r)' % str(stripped))


### Time


def utcnow():
  """"""Returns datetime.utcnow(), used for testing.

  Use this function so it can be mocked everywhere.
  """"""
  return datetime.datetime.utcnow()


def time_time():
  """"""Returns the equivalent of time.time() as mocked if applicable.""""""
  return (utcnow() - EPOCH).total_seconds()


def milliseconds_since_epoch(now):
  """"""Returns the number of milliseconds since unix epoch as an int.""""""
  now = now or utcnow()
  return int(round((now - EPOCH).total_seconds() * 1000.))


def datetime_to_rfc2822(dt):
  """"""datetime -> string value for Last-Modified header as defined by RFC2822.""""""
  if not isinstance(dt, datetime.datetime):
    raise TypeError(
        'Expecting datetime object, got %s instead' % type(dt).__name__)
  assert dt.tzinfo is None, 'Expecting UTC timestamp: %s' % dt
  return email_utils.formatdate(datetime_to_timestamp(dt) / 1000000.0)


def datetime_to_timestamp(value):
  """"""Converts UTC datetime to integer timestamp in microseconds since epoch.""""""
  if not isinstance(value, datetime.datetime):
    raise ValueError(
        'Expecting datetime object, got %s instead' % type(value).__name__)
  if value.tzinfo is not None:
    raise ValueError('Only UTC datetime is supported')
  dt = value - EPOCH
  return dt.microseconds + 1000 * 1000 * (dt.seconds + 24 * 3600 * dt.days)


def timestamp_to_datetime(value):
  """"""Converts integer timestamp in microseconds since epoch to UTC datetime.""""""
  if not isinstance(value, (int, long, float)):
    raise ValueError(
        'Expecting a number, got %s instead' % type(value).__name__)
  return EPOCH + datetime.timedelta(microseconds=value)


### Cache


class _Cache(object):
  """"""Holds state of a cache for cache_with_expiration and cache decorators.

  May call func more than once.
  Thread- and NDB tasklet-safe.
  """"""

  def __init__(self, func, expiration_sec):
    self.func = func
    self.expiration_sec = expiration_sec
    self.lock = threading.Lock()
    self.value = None
    self.value_is_set = False
    self.expires = None

  def get_value(self):
    """"""Returns a cached value refreshing it if it has expired.""""""
    with self.lock:
      if self.value_is_set and (not self.expires or time_time() < self.expires):
        return self.value

    new_value = self.func()

    with self.lock:
      self.value = new_value
      self.value_is_set = True
      if self.expiration_sec:
        self.expires = time_time() + self.expiration_sec

    return self.value

  def clear(self):
    """"""Clears stored cached value.""""""
    with self.lock:
      self.value = None
      self.value_is_set = False
      self.expires = None

  def get_wrapper(self):
    """"""Returns a callable object that can be used in place of |func|.

    It's basically self.get_value, updated by functools.wraps to look more like
    original function.
    """"""
    # functools.wraps doesn't like 'instancemethod', use lambda as a proxy.
    # pylint: disable=W0108
    wrapper = functools.wraps(self.func)(lambda: self.get_value())
    wrapper.__parent_cache__ = self
    return wrapper


def cache(func):
  """"""Decorator that implements permanent cache of a zero-parameter function.""""""
  return _Cache(func, None).get_wrapper()


def cache_with_expiration(expiration_sec):
  """"""Decorator that implements in-memory cache for a zero-parameter function.""""""
  def decorator(func):
    return _Cache(func, expiration_sec).get_wrapper()
  return decorator


def clear_cache(func):
  """"""Given a function decorated with @cache, resets cached value.""""""
  func.__parent_cache__.clear()


# ignore time parameter warning | pylint: disable=redefined-outer-name
def memcache_async(key, key_args=None, time=None):
  """"""Decorator that implements memcache-based cache for a function.

  The generated cache key contains current application version and values of
  |key_args| arguments converted to string using `repr`.

  Args:
    key (str): unique string that will be used as a part of cache key.
    key_args (list of str): list of function argument names to include
      in the generated cache key.
    time (int): optional expiration time.

  Example:
    @memcache('f', ['a', 'b'])
    def f(a, b=2, not_used_in_cache_key=6):
      # Heavy computation
      return 42

  Decorator raises:
    NotImplementedError if function uses varargs or kwargs.
  """"""
  assert isinstance(key, basestring), key
  key_args = key_args or []
  assert isinstance(key_args, list), key_args
  assert all(isinstance(a, basestring) for a in key_args), key_args
  assert all(key_args), key_args

  memcache_set_kwargs = {}
  if time is not None:
    memcache_set_kwargs['time'] = time

  def decorator(func):
    unwrapped = func
    while True:
      deeper = getattr(unwrapped, '__wrapped__', None)
      if not deeper:
        break
      unwrapped = deeper

    argspec = inspect.getargspec(unwrapped)
    if argspec.varargs:
      raise NotImplementedError(
          'varargs in memcached functions are not supported')
    if argspec.keywords:
      raise NotImplementedError(
          'kwargs in memcached functions are not supported')

    # List of arg names and indexes. Has same order as |key_args|.
    arg_indexes = []
    for name in key_args:
      try:
        i = argspec.args.index(name)
      except ValueError:
        raise KeyError(
            'key_format expects ""%s"" parameter, but it was not found among '
            'function parameters' % name)
      arg_indexes.append((name, i))

    @functools.wraps(func)
    @ndb.tasklet
    def decorated(*args, **kwargs):
      arg_values = []
      for name, i in arg_indexes:
        if i < len(args):
          arg_value = args[i]
        elif name in kwargs:
          arg_value = kwargs[name]
        else:
          # argspec.defaults contains _last_ default values, so we need to shift
          # |i| left.
          default_value_index = i - (len(argspec.args) - len(argspec.defaults))
          if default_value_index < 0:
            # Parameter not provided. Call function to cause TypeError
            func(*args, **kwargs)
            assert False, 'Function call did not fail'
          arg_value = argspec.defaults[default_value_index]
        arg_values.append(arg_value)

      # Instead of putting a raw value to memcache, put tuple (value,)
      # so we can distinguish a cached None value and absence of the value.

      cache_key = 'utils.memcache/%s/%s%s' % (
          get_app_version(), key, repr(arg_values))

      ctx = ndb.get_context()
      result = yield ctx.memcache_get(cache_key)
      if isinstance(result, tuple) and len(result) == 1:
        raise ndb.Return(result[0])

      result = func(*args, **kwargs)
      if isinstance(result, ndb.Future):
        result = yield result
      yield ctx.memcache_set(cache_key, (result,), **memcache_set_kwargs)
      raise ndb.Return(result)

    return decorated
  return decorator


def memcache(*args, **kwargs):
  """"""Blocking version of memcache_async.""""""
  decorator_async = memcache_async(*args, **kwargs)
  def decorator(func):
    decorated_async = decorator_async(func)
    @functools.wraps(func)
    def decorated(*args, **kwargs):
      return decorated_async(*args, **kwargs).get_result()
    return decorated
  return decorator


@cache
def get_app_version():
  """"""Returns currently running version (not necessary a default one).""""""
  # Sadly, this causes an RPC and when called too frequently, throws quota
  # errors.
  return modules.get_current_version_name() or 'N/A'


@cache
def get_versioned_hosturl():
  """"""Returns the url hostname of this instance locked to the currently running
  version.

  This function hides the fact that app_identity.get_default_version_hostname()
  returns None on the dev server and modules.get_hostname() returns incorrectly
  qualified hostname for HTTPS usage on the prod server. <3
  """"""
  if is_local_dev_server():
    # TODO(maruel): It'd be nice if it were easier to use a ephemeral SSL
    # certificate here and not assume unsecured connection.
    return 'http://' + modules.get_hostname()

  return 'https://%s-dot-%s' % (
      get_app_version(), app_identity.get_default_version_hostname())


@cache
def get_urlfetch_service_id():
  """"""Returns a value for X-URLFetch-Service-Id header for GAE <-> GAE calls.

  Usually it can be omitted. It is required in certain environments.
  """"""
  if is_local_dev_server():
    return 'LOCAL'
  hostname = app_identity.get_default_version_hostname().split('.')
  return hostname[-2].upper() if len(hostname) >= 3 else 'APPSPOT'


@cache
def get_app_revision_url():
  """"""Returns URL of a git revision page for currently running app version.

  Works only for non-tainted versions uploaded with tools/update.py: app version
  should look like '162-efaec47'. Assumes all services that use 'components'
  live in a single repository.

  Returns None if a version is tainted or has unexpected name.
  """"""
  rev = re.match(r'\d+-([a-f0-9]+)$', get_app_version())
  template = 'https://chromium.googlesource.com/infra/luci/luci-py/+/%s'
  return template % rev.group(1) if rev else None


@cache
def get_service_account_name():
  """"""Same as app_identity.get_service_account_name(), but caches the result.

  app_identity.get_service_account_name() does an RPC on each call, yet the
  result is always the same.
  """"""
  return app_identity.get_service_account_name()


### Task queue


@cache
def get_task_queue_host():
  """"""Returns domain name of app engine instance to run a task queue task on.

  By default will use 'backend' module. Can be changed by calling
  set_task_queue_module during application startup.

  This domain name points to a matching version of appropriate app engine
  module - <version>.<module>.<app-id>.appspot.com where:
    version: version of the module that is calling this function.
    module: app engine module to execute task on.

  That way a task enqueued from version 'A' of default module would be executed
  on same version 'A' of backend module.
  """"""
  # modules.get_hostname sometimes fails with unknown internal error.
  # Cache its result in a memcache to avoid calling it too often.
  cache_key = 'task_queue_host:%s:%s' % (_task_queue_module, get_app_version())
  value = gae_memcache.get(cache_key)
  if not value:
    value = modules.get_hostname(module=_task_queue_module)
    gae_memcache.set(cache_key, value)
  return value


def set_task_queue_module(module):
  """"""Changes a module used by get_task_queue_host() function.

  Should be called during application initialization if default 'backend' module
  is not appropriate.
  """"""
  global _task_queue_module
  _task_queue_module = module
  clear_cache(get_task_queue_host)


@ndb.tasklet
def enqueue_task_async(
    url,
    queue_name,
    params=None,
    payload=None,
    name=None,
    countdown=None,
    use_dedicated_module=True,
    transactional=False):
  """"""Adds a task to a task queue.

  If |use_dedicated_module| is True (default) the task will be executed by
  a separate backend module instance that runs same version as currently
  executing instance. Otherwise it will run on a current version of default
  module.

  Returns True if the task was successfully added or a task with such name
  existed before (i.e. on TombstonedTaskError exception): deduplicated task is
  not a error.

  Logs an error and returns False if task queue is acting up.
  """"""
  try:
    headers = None
    if use_dedicated_module:
      headers = {'Host': get_task_queue_host()}
    # Note that just using 'target=module' here would redirect task request to
    # a default version of a module, not the curently executing one.
    task = taskqueue.Task(
        url=url,
        params=params,
        payload=payload,
        name=name,
        countdown=countdown,
        headers=headers)
    yield task.add_async(queue_name=queue_name, transactional=transactional)
    raise ndb.Return(True)
  except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError):
    logging.info(
        'Task %r deduplicated (already exists in queue %r)',
        name, queue_name)
    raise ndb.Return(True)
  except (
      taskqueue.Error,
      runtime.DeadlineExceededError,
      runtime.apiproxy_errors.CancelledError,
      runtime.apiproxy_errors.DeadlineExceededError,
      runtime.apiproxy_errors.OverQuotaError) as e:
    logging.warning(
        'Problem adding task %r to task queue %r (%s): %s',
        url, queue_name, e.__class__.__name__, e)
    raise ndb.Return(False)


def enqueue_task(*args, **kwargs):
  """"""Adds a task to a task queue.

  Returns:
    True if the task was enqueued, False otherwise.
  """"""
  return enqueue_task_async(*args, **kwargs).get_result()


## JSON


def to_json_encodable(data):
  """"""Converts data into json-compatible data.""""""
  if isinstance(data, messages.Message):
    # protojson.encode_message returns a string that is already encoded json.
    # Load it back into a json-compatible representation of the data.
    return json.loads(protojson.encode_message(data))
  if isinstance(data, unicode) or data is None:
    return data
  if isinstance(data, str):
    return data.decode('utf-8')
  if isinstance(data, (int, float, long)):
    # Note: overflowing is an issue with int and long.
    return data
  if isinstance(data, (list, set, tuple)):
    return [to_json_encodable(i) for i in data]
  if isinstance(data, dict):
    assert all(isinstance(k, basestring) for k in data), data
    return {
      to_json_encodable(k): to_json_encodable(v) for k, v in data.iteritems()
    }

  if isinstance(data, datetime.datetime):
    # Convert datetime objects into a string, stripping off milliseconds. Only
    # accept naive objects.
    if data.tzinfo is not None:
      raise ValueError('Can only serialize naive datetime instance')
    return data.strftime(DATETIME_FORMAT)
  if isinstance(data, datetime.date):
    return data.strftime(DATE_FORMAT)
  if isinstance(data, datetime.timedelta):
    # Convert timedelta into seconds, stripping off milliseconds.
    return int(data.total_seconds())

  if hasattr(data, 'to_dict') and callable(data.to_dict):
    # This takes care of ndb.Model.
    return to_json_encodable(data.to_dict())

  if hasattr(data, 'urlsafe') and callable(data.urlsafe):
    # This takes care of ndb.Key.
    return to_json_encodable(data.urlsafe())

  if inspect.isgenerator(data) or isinstance(data, xrange):
    # Handle it like a list. Sadly, xrange is not a proper generator so it has
    # to be checked manually.
    return [to_json_encodable(i) for i in data]

  assert False, 'Don\'t know how to handle %r' % data


def encode_to_json(data):
  """"""Converts any data as a json string.""""""
  return json.dumps(
      to_json_encodable(data),
      sort_keys=True,
      separators=(',', ':'),
      encoding='utf-8')


## General


def get_token_fingerprint(blob):
  """"""Given a blob with a token returns first 16 bytes of its SHA256 as hex.

  It can be used to identify this particular token in logs without revealing it.
  """"""
  assert isinstance(blob, basestring)
  if isinstance(blob, unicode):
    blob = blob.encode('ascii', 'ignore')
  return binascii.hexlify(hashlib.sha256(blob).digest()[:16])


## Hacks


def fix_protobuf_package():
  """"""Modifies 'google' package to include path to 'google.protobuf' package.

  Prefer our own proto package on the server. Note that this functions is not
  used on the Swarming bot nor any other client.
  """"""
  # google.__path__[0] will be google_appengine/google.
  import google
  if len(google.__path__) > 1:
    return

  # We do not mind what 'google' get used, inject protobuf in there.
  path = os.path.join(THIS_DIR, 'third_party', 'protobuf', 'google')
  google.__path__.append(path)

  # six is needed for oauth2client and webtest (local testing).
  six_path = os.path.join(THIS_DIR, 'third_party', 'six')
  if six_path not in sys.path:
    sys.path.insert(0, six_path)


def import_jinja2():
  """"""Remove any existing jinja2 package and add ours.""""""
  for i in sys.path[:]:
    if os.path.basename(i) == 'jinja2':
      sys.path.remove(i)
  sys.path.append(os.path.join(THIS_DIR, 'third_party'))


def sync_of(async_fn):
  """"""Returns a synchronous version of an asynchronous function.""""""
  is_static_method = isinstance(async_fn, staticmethod)
  is_class_method = isinstance(async_fn, classmethod)
  if is_static_method or is_class_method:
    async_fn = async_fn.__func__

  @functools.wraps(async_fn)
  def sync(*args, **kwargs):
    return async_fn(*args, **kwargs).get_result()

  if is_static_method:
    sync = staticmethod(sync)
  elif is_class_method:
    sync = classmethod(sync)
  return sync
/n/n/nappengine/isolate/handlers_frontend.py/n/n# Copyright 2012 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""This module defines Isolate Server frontend url handlers.""""""

import collections
import datetime
import json
import logging

import webapp2

import cloudstorage
from google.appengine.api import modules

import acl
import config
import gcs
import handlers_endpoints_v1
import mapreduce_jobs
import model
import stats
import template
from components import auth
from components import stats_framework
from components import stats_framework_gviz
from components import utils
from gviz import gviz_api


# GViz data description.
_GVIZ_DESCRIPTION = {
  'failures': ('number', 'Failures'),
  'requests': ('number', 'Total'),
  'other_requests': ('number', 'Other'),
  'uploads': ('number', 'Uploads'),
  'uploads_bytes': ('number', 'Uploaded'),
  'downloads': ('number', 'Downloads'),
  'downloads_bytes': ('number', 'Downloaded'),
  'contains_requests': ('number', 'Lookups'),
  'contains_lookups': ('number', 'Items looked up'),
}

# Warning: modifying the order here requires updating templates/stats.html.
_GVIZ_COLUMNS_ORDER = (
  'key',
  'requests',
  'other_requests',
  'failures',
  'uploads',
  'downloads',
  'contains_requests',
  'uploads_bytes',
  'downloads_bytes',
  'contains_lookups',
)

_ISOLATED_ROOT_MEMBERS = (
  'algo',
  'command',
  'files',
  'includes',
  'read_only',
  'relative_cwd',
  'version',
)


### Restricted handlers


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    self.common(None)

  @staticmethod
  def cast_to_type(param_name, value):
    def to_bool(value):
      if type(value) is bool:
        return value
      return {'True': True, 'False': False}.get(value, False)

    cast = {
        'enable_ts_monitoring': to_bool,
    }.get(param_name, str)
    return cast(value)

  @auth.require(auth.is_admin)
  def post(self):
    # Convert MultiDict into a dict.
    params = {
      k: self.cast_to_type(k, self.request.params.getone(k))
      for k in self.request.params
      if k not in ('keyid', 'xsrf_token')
    }
    cfg = config.settings(fresh=True)
    keyid = int(self.request.get('keyid', '0'))
    if cfg.key.integer_id() != keyid:
      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))
      return
    cfg.populate(**params)
    try:
      # Ensure key is correct, it's easy to make a mistake when creating it.
      gcs.URLSigner.load_private_key(cfg.gs_private_key)
    except Exception as exc:
      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)
      self.response.write('Bad private key: %s' % exc)
      return
    cfg.store(updated_by=auth.get_current_identity().to_bytes())
    self.common('Settings updated')

  def common(self, note):
    params = config.settings_info()
    params.update({
        'note': note,
        'path': self.request.path,
        'xsrf_token': self.generate_xsrf_token(),
    })
    self.response.write(
        template.render('isolate/restricted_config.html', params))


class RestrictedPurgeHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    params = {
      'digest': '',
      'message': '',
      'namespace': '',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('isolate/restricted_purge.html', params))

  @auth.require(auth.is_admin)
  def post(self):
    namespace = self.request.get('namespace')
    digest = self.request.get('digest')
    params = {
      'digest': digest,
      'message': '',
      'namespace': namespace,
      'xsrf_token': self.generate_xsrf_token(),
    }
    try:
      key = model.get_entry_key(namespace, digest)
    except ValueError as e:
      params['message'] = 'Invalid entry: %s' % e
      key = None
    if key:
      model.delete_entry_and_gs_entry([key])
      params['message'] = 'Done'
    self.response.write(
        template.render('isolate/restricted_purge.html', params))


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(auth.is_admin)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    # Do not use 'backend' module when running from dev appserver. Mapreduce
    # generates URLs that are incompatible with dev appserver URL routing when
    # using custom modules.
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=not utils.is_local_dev_server())
    # New tasks should show up on the status page.
    if success:
      self.redirect('/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Non-restricted handlers


class BrowseHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    # Support 'hash' for compatibility with old links. To remove eventually.
    digest = self.request.get('digest', '') or self.request.get('hash', '')
    save_as = self.request.get('as', '')
    params = {
      u'as': unicode(save_as),
      u'digest': unicode(digest),
      u'namespace': unicode(namespace),
    }
    # Check for existence of element, so we can 400/404
    if digest and namespace:
      try:
        model.get_content(namespace, digest)
      except ValueError:
        self.abort(400, 'Invalid key')
      except LookupError:
        self.abort(404, 'Unable to retrieve the entry')
    self.response.write(template.render('isolate/browse.html', params))

  def get_content_security_policy(self):
    csp = super(BrowseHandler, self).get_content_security_policy()
    csp.setdefault('child-src', []).append(""'self'"")
    return csp


class ContentHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    digest = self.request.get('digest', '')
    content = None
    if not digest:
      self.abort(400, 'Missing digest')
    if not namespace:
      self.abort(400, 'Missing namespace')

    try:
      raw_data, entity = model.get_content(namespace, digest)
    except ValueError:
      self.abort(400, 'Invalid key')
    except LookupError:
      self.abort(404, 'Unable to retrieve the entry')

    logging.info('%s', entity)
    if not raw_data:
      try:
        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())
        content = ''.join(model.expand_content(namespace, stream))
      except cloudstorage.NotFoundError:
        logging.error('Entity in DB but not in GCS: deleting entity in DB')
        entity.key.delete()
        self.abort(404, 'Unable to retrieve the file from GCS')
    else:
      content = ''.join(model.expand_content(namespace, [raw_data]))

    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    # We delete Content-Type before storing to it to avoid having two (yes,
    # two) Content-Type headers.
    del self.response.headers['Content-Type']

    # Apparently, setting the content type to text/plain encourages the
    # browser (Chrome, at least) to sniff the mime type and display
    # things like images.  Images are autowrapped in <img> and text is
    # wrapped in <pre>.
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'

    # App Engine puts a limit of 33554432 bytes on a request, which includes
    # headers. Headers are ~150 bytes.  If the content + headers might
    # exceed that limit, we give the user an option to workround getting
    # their file.
    if len(content) > 33554000:
      host = modules.get_hostname(module='default', version='default')
      # host is something like default.default.myisolateserver.appspot.com
      host = host.replace('default.default.','')
      sizeInMib = len(content) / (1024.0 * 1024.0)
      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'
      ' App Engine limit.\nTo work around this, run the following command:\n'
      '    python isolateserver.py download -I %s --namespace %s -f %s %s'
      % (sizeInMib, host, namespace, digest, digest))
    else:
      self.response.headers['Content-Disposition'] = str(
        'filename=%s' % self.request.get('as') or digest)
      try:
        json_data = json.loads(content)
        if self._is_isolated_format(json_data):
          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
          json_data['files'] = collections.OrderedDict(
            sorted(
              json_data['files'].items(),
              key=lambda (filepath, data): filepath))
          params = {
            'namespace': namespace,
            'isolated': json_data,
          }
          content = template.render('isolate/isolated.html', params)
      except ValueError:
        pass

    self.response.write(content)

  @staticmethod
  def _is_isolated_format(json_data):
    """"""Checks if json_data is a valid .isolated format.""""""
    if not isinstance(json_data, dict):
      return False
    actual = set(json_data)
    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual


class StatsHandler(webapp2.RequestHandler):
  """"""Returns the statistics web page.""""""
  def get(self):
    """"""Presents nice recent statistics.

    It fetches data from the 'JSON' API.
    """"""
    # Preloads the data to save a complete request.
    resolution = self.request.params.get('resolution', 'hours')
    if resolution not in ('days', 'hours', 'minutes'):
      resolution = 'hours'
    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)

    description = _GVIZ_DESCRIPTION.copy()
    description.update(stats_framework_gviz.get_description_key(resolution))
    table = stats_framework.get_stats(
        stats.STATS_HANDLER, resolution, None, duration, True)
    params = {
      'duration': duration,
      'initial_data': gviz_api.DataTable(description, table).ToJSon(
          columns_order=_GVIZ_COLUMNS_ORDER),
      'now': datetime.datetime.utcnow(),
      'resolution': resolution,
    }
    self.response.write(template.render('isolate/stats.html', params))


class StatsGvizHandlerBase(webapp2.RequestHandler):
  RESOLUTION = None

  def get(self):
    description = _GVIZ_DESCRIPTION.copy()
    description.update(
        stats_framework_gviz.get_description_key(self.RESOLUTION))
    try:
      stats_framework_gviz.get_json(
          self.request,
          self.response,
          stats.STATS_HANDLER,
          self.RESOLUTION,
          description,
          _GVIZ_COLUMNS_ORDER)
    except ValueError as e:
      self.abort(400, str(e))


class StatsGvizDaysHandler(StatsGvizHandlerBase):
  RESOLUTION = 'days'


class StatsGvizHoursHandler(StatsGvizHandlerBase):
  RESOLUTION = 'hours'


class StatsGvizMinutesHandler(StatsGvizHandlerBase):
  RESOLUTION = 'minutes'


###  Public pages.


class RootHandler(auth.AuthenticatingHandler):
  """"""Tells the user to RTM.""""""

  @auth.public
  def get(self):
    params = {
      'is_admin': auth.is_admin(),
      'is_user': acl.isolate_readable(),
      'mapreduce_jobs': [],
      'user_type': acl.get_user_type(),
    }
    if auth.is_admin():
      params['mapreduce_jobs'] = [
        {'id': job_id, 'name': job_def['job_name']}
        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()
      ]
      params['xsrf_token'] = self.generate_xsrf_token()
    self.response.write(template.render('isolate/root.html', params))


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.
  """"""
  @auth.public
  def get(self):
    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'isolate/public_isolate_index.html', params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    config.warmup()
    auth.warmup()
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # AppEngine-specific urls:
      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),
      webapp2.Route(r'/_ah/warmup', WarmupHandler),
  ]
  if not utils.should_disable_ui_routes():
    routes.extend([
      # Administrative urls.
      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),
      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),

      # Mapreduce related urls.
      webapp2.Route(
          r'/restricted/launch_mapreduce',
          RestrictedLaunchMapReduceJob),

      # User web pages.
      webapp2.Route(r'/browse', BrowseHandler),
      webapp2.Route(r'/content', ContentHandler),
      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz
      # is just too sorry.
      #webapp2.Route(r'/stats', StatsHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),
      webapp2.Route(r'/', RootHandler),
      webapp2.Route(r'/newui', UIHandler),
    ])
  routes.extend(handlers_endpoints_v1.get_routes())
  return routes


def create_application(debug):
  """"""Creates the url router.

  The basic layouts is as follow:
  - /restricted/.* requires being an instance administrator.
  - /stats/.* has statistics.
  """"""
  acl.bootstrap()
  template.bootstrap()
  return webapp2.WSGIApplication(get_routes(), debug=debug)
/n/n/nappengine/machine_provider/handlers_frontend.py/n/n# Copyright 2016 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Front-end UI.""""""

import logging
import os

import webapp2

from components import auth
from components import datastore_utils
from components import template
from components import utils

import handlers_endpoints
import models


THIS_DIR = os.path.dirname(os.path.abspath(__file__))


class CatalogHandler(auth.AuthenticatingHandler):
  """"""Catalog handler.""""""

  @auth.require(auth.is_admin)
  def get(self, machine_id=None):
    params = {
        'machines': [],
        'next_page_token': None,
    }
    if machine_id:
      machine = models.CatalogMachineEntry.get_by_id(machine_id)
      if not machine:
        self.abort(404)
      params['machines'] = [machine]
    else:
      query = models.CatalogMachineEntry.query().order(
          models.CatalogMachineEntry.dimensions.hostname)
      page_token = self.request.get('page_token') or ''
      params['machines'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(
        template.render('templates/catalog.html', params=params))


class LeaseRequestHandler(auth.AuthenticatingHandler):
  """"""Lease request handler.""""""

  @auth.require(auth.is_admin)
  def get(self, lease_id=None):
    params = {
        'lease_requests': [],
        'next_page_token': None,
        'now_ts': utils.time_time(),
    }
    if lease_id:
      lease_request = models.LeaseRequest.get_by_id(lease_id)
      if not lease_request:
        self.abort(404)
      params['lease_requests'] = [lease_request]
    else:
      query = models.LeaseRequest.query().order(
          -models.LeaseRequest.last_modified_ts)
      page_token = self.request.get('page_token') or ''
      params['lease_requests'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(template.render('templates/leases.html', params=params))


class RootHandler(auth.AuthenticatingHandler):
  """"""Root handler.""""""

  @auth.public
  def get(self):
    params = {
        'is_admin': auth.is_admin(),
    }

    self.response.write(template.render('templates/root.html', params=params))


def get_routes():
  return [
      webapp2.Route('/', handler=RootHandler),
      webapp2.Route('/catalog', handler=CatalogHandler),
      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),
      webapp2.Route('/leases', handler=LeaseRequestHandler),
      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),
  ]


def create_frontend_app():
  template.bootstrap({
      'templates': os.path.join(THIS_DIR, 'templates'),
  })
  routes = []
  if not utils.should_disable_ui_routes():
    routes.extend(get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes)
/n/n/nappengine/swarming/handlers_frontend.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Main entry point for Swarming service.

This file contains the URL handlers for all the Swarming service URLs,
implemented using the webapp2 framework.
""""""

import collections
import os

import webapp2

import handlers_bot
import handlers_endpoints
import mapreduce_jobs
import template
from components import auth
from components import utils
from server import acl
from server import bot_code
from server import config


ROOT_DIR = os.path.dirname(os.path.abspath(__file__))


# Helper class for displaying the sort options in html templates.
SortOptions = collections.namedtuple('SortOptions', ['key', 'name'])


### is_admin pages.


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    # Template parameters schema matches settings_info() return value.
    self.response.write(template.render(
        'swarming/restricted_config.html', config.settings_info()))


class UploadBotConfigHandler(auth.AuthenticatingHandler):
  """"""Stores a new bot_config.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bot_config = bot_code.get_bot_config()
    params = {
      'content': bot_config.content.decode('utf-8'),
      'path': self.request.path,
      'version': bot_config.version,
      'when': bot_config.when,
      'who': bot_config.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bot_config.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bot_config(self.request.host_url, script)
    self.get()


class UploadBootstrapHandler(auth.AuthenticatingHandler):
  """"""Stores a new bootstrap.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bootstrap = bot_code.get_bootstrap(self.request.host_url)
    params = {
      'content': bootstrap.content.decode('utf-8'),
      'path': self.request.path,
      'version': bootstrap.version,
      'when': bootstrap.when,
      'who': bootstrap.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bootstrap.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bootstrap(script)
    self.get()


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(acl.can_edit_config)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=False)
    # New tasks should show up on the status page.
    if success:
      self.redirect('/restricted/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Redirectors.


class BotsListHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of known bots.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))

    dimensions = (
      l.strip() for l in self.request.get('dimensions', '').splitlines()
    )
    dimensions = [i for i in dimensions if i]

    new_ui_link = '/botlist?l=%d' % limit
    if dimensions:
      new_ui_link += '&f=' + '&f='.join(dimensions)

    self.redirect(new_ui_link)


class BotHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page about the bot, including last tasks and events.""""""

  @auth.public
  def get(self, bot_id):
    self.redirect('/bot?id=%s' % bot_id)


class TasksHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of all task requests.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))
    task_tags = [
      line for line in self.request.get('task_tag', '').splitlines() if line
    ]

    new_ui_link = '/tasklist?l=%d' % limit
    if task_tags:
      new_ui_link += '&f=' + '&f='.join(task_tags)

    self.redirect(new_ui_link)


class TaskHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page containing task request and result.""""""

  @auth.public
  def get(self, task_id):
    self.redirect('/task?id=%s' % task_id)


### Public pages.


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.""""""
  @auth.public
  def get(self, page):
    if not page:
      page = 'swarming'

    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'swarming/public_%s_index.html' % page, params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')

  def get_content_security_policy(self):
    # We use iframes to display pages at display_server_url_template. Need to
    # allow it in CSP.
    csp = super(UIHandler, self).get_content_security_policy()
    tmpl = config.settings().display_server_url_template
    if tmpl:
      if tmpl.startswith('/'):
        csp['child-src'].append(""'self'"")
      else:
        # We assume the template specifies '%s' in its last path component.
        # We strip it to get a ""parent"" path that we can put into CSP. Note that
        # whitelisting an entire display server domain is unnecessary wide.
        assert tmpl.startswith('https://'), tmpl
        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])
    return csp


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    auth.warmup()
    bot_code.get_swarming_bot_zip(self.request.host_url)
    utils.get_module_version_list(None, None)
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      ('/_ah/mail/<to:.+>', EmailHandler),
      ('/_ah/warmup', WarmupHandler),
  ]

  if not utils.should_disable_ui_routes():
    routes.extend([
      # Frontend pages. They return HTML.
      # Public pages.
      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),

      # Redirects to Polymer UI
      ('/user/tasks', TasksHandler),
      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),
      ('/restricted/bots', BotsListHandler),
      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),

      # Admin pages.
      # TODO(maruel): Get rid of them.
      ('/restricted/config', RestrictedConfigHandler),
      ('/restricted/upload/bot_config', UploadBotConfigHandler),
      ('/restricted/upload/bootstrap', UploadBootstrapHandler),

      # Mapreduce related urls.
      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),
    ])

  return [webapp2.Route(*i) for i in routes]


def create_application(debug):
  routes = []
  routes.extend(get_routes())
  routes.extend(handlers_bot.get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes, debug=debug)
/n/n/n",0
85,85,481a3e8120787d449ad7bbc6a627d8450bceb85c,"/appengine/components/components/auth/ui/ui.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Auth management UI handlers.""""""

import functools
import json
import os
import re
import webapp2

from components import template
from components import utils

from . import acl
from . import rest_api

from .. import api
from .. import change_log
from .. import handler
from .. import model
from .. import replication


# templates/.
TEMPLATES_DIR = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), 'templates')


# Global static configuration set in 'configure_ui'.
_ui_app_name = 'Unknown'
_ui_data_callback = None
_ui_navbar_tabs = ()


def configure_ui(app_name, ui_tabs=None, ui_data_callback=None):
  """"""Modifies global configuration of Auth UI.

  Args:
    app_name: name of the service (visible in page headers, titles, etc.)
    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or
        None to show the standard set of tabs.
    ui_data_callback: an argumentless callable that returns a dict with
        additional data to return to authenticated users. It can be used by
        server and client side code to render templates. Used by auth_service.
  """"""
  global _ui_app_name
  global _ui_data_callback
  global _ui_navbar_tabs
  _ui_app_name = app_name
  _ui_data_callback = ui_data_callback
  if ui_tabs is not None:
    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)
    _ui_navbar_tabs = tuple(ui_tabs)
  template.bootstrap({'auth': TEMPLATES_DIR})


def get_ui_routes():
  """"""Returns a list of routes with auth UI handlers.""""""
  # Routes for registered navbar tabs.
  routes = []
  for cls in _ui_navbar_tabs:
    routes.extend(cls.get_webapp2_routes())
  # Routes for everything else.
  routes.extend([
    webapp2.Route(r'/auth', MainHandler),
    webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),
    webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),
    webapp2.Route(r'/auth/link', LinkToPrimaryHandler),
  ])
  return routes


def forbid_ui_on_replica(method):
  """"""Decorator for methods that are not allowed to be called on Replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 405 ""Method Not Allowed"".
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      self.abort(
          405,
          detail='Not allowed on a replica, see primary at %s' % primary_url)
    return method(self, *args, **kwargs)
  return wrapper


def redirect_ui_on_replica(method):
  """"""Decorator for methods that redirect to Primary when called on replica.

  If such method is called on a service in Replica mode, it would return
  HTTP 302 redirect to corresponding method on Primary.
  """"""
  @functools.wraps(method)
  def wrapper(self, *args, **kwargs):
    assert isinstance(self, webapp2.RequestHandler)
    assert self.request.method == 'GET'
    if model.is_replica():
      primary_url = model.get_replication_state().primary_url
      protocol = 'http://' if utils.is_local_dev_server() else 'https://'
      assert primary_url and primary_url.startswith(protocol), primary_url
      assert self.request.path_qs.startswith('/'), self.request.path_qs
      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)
    return method(self, *args, **kwargs)
  return wrapper


################################################################################
## Admin routes. The use cookies and GAE's ""is_current_user_admin"" for authn.


class AdminPageHandler(handler.AuthenticatingHandler):
  """"""Base class for handlers involved in bootstrap processes.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  @classmethod
  def get_auth_methods(cls, conf):
    # This method sets 'is_superuser' bit for GAE-level admins.
    return [handler.gae_cookie_authentication]

  def reply(self, path, env=None, status=200):
    """"""Render template |path| to response using given environment.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    full_env = {
      'app_name': _ui_app_name,
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html
      'xsrf_token': self.generate_xsrf_token(),
    }
    full_env.update(env or {})
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/admin/access_denied.html', env=env, status=403)


class BootstrapHandler(AdminPageHandler):
  """"""Creates Administrators group (if necessary) and adds current caller to it.

  Requires Appengine level Admin access for its handlers, since Administrators
  group may not exist yet.

  Used during bootstrap of a new service instance.
  """"""

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'return_url': self.request.get('r') or '',
    }
    self.reply('auth/admin/bootstrap.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    added = model.bootstrap_group(
        model.ADMIN_GROUP, [api.get_current_identity()],
        'Users that can manage groups')
    env = {
      'page_title': 'Bootstrap',
      'admin_group': model.ADMIN_GROUP,
      'added': added,
      'return_url': self.request.get('return_url') or '',
    }
    self.reply('auth/admin/bootstrap_done.html', env)


class BootstrapOAuthHandler(AdminPageHandler):
  """"""Page to set OAuth2 client ID used by the main web UI.

  Requires Appengine level Admin access for its handlers, since without client
  ID there's no UI yet to configure Administrators group.

  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is
  also available after the service is linked to some primary Auth service.
  """"""

  @api.require(api.is_superuser)
  def get(self):
    self.show_page(web_client_id=api.get_web_client_id_uncached())

  @api.require(api.is_superuser)
  def post(self):
    web_client_id = self.request.POST['web_client_id']
    api.set_web_client_id(web_client_id)
    self.show_page(web_client_id=web_client_id, saved=True)

  def show_page(self, web_client_id, saved=False):
    env = {
      'page_title': 'OAuth2 web client ID',
      'web_client_id': web_client_id or '',
      'saved': saved,
    }
    self.reply('auth/admin/bootstrap_oauth.html', env)


class LinkToPrimaryHandler(AdminPageHandler):
  """"""A page with confirmation of Primary <-> Replica linking request.

  URL to that page is generated by a Primary service.
  """"""

  def decode_link_ticket(self):
    """"""Extracts ServiceLinkTicket from 't' GET parameter.""""""
    try:
      return replication.decode_link_ticket(
          self.request.get('t').encode('ascii'))
    except (KeyError, ValueError):
      self.abort(400)
      return

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def get(self):
    ticket = self.decode_link_ticket()
    env = {
      'generated_by': ticket.generated_by,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
    }
    self.reply('auth/admin/linking.html', env)

  @forbid_ui_on_replica
  @api.require(api.is_superuser)
  def post(self):
    ticket = self.decode_link_ticket()
    success = True
    error_msg = None
    try:
      replication.become_replica(ticket, api.get_current_identity())
    except replication.ProtocolError as exc:
      success = False
      error_msg = exc.message
    env = {
      'error_msg': error_msg,
      'page_title': 'Switch',
      'primary_id': ticket.primary_id,
      'primary_url': ticket.primary_url,
      'success': success,
    }
    self.reply('auth/admin/linking_done.html', env)


################################################################################
## Web UI routes.

# TODO(vadimsh): Switch them to use OAuth for authentication.


class UIHandler(handler.AuthenticatingHandler):
  """"""Renders Jinja templates extending base.html.""""""

  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of
  # all 'style=...' attributes first.
  csp_use_script_nonce = True

  def reply(self, path, env=None, status=200):
    """"""Renders template |path| to the HTTP response using given environment.

    Optional keys from |env| that base.html uses:
      css_file: URL to a file with page specific styles, relative to site root.
      js_file: URL to a file with page specific Javascript code, relative to
          site root. File should define global object named same as a filename,
          i.e. '/auth/static/js/api.js' should define global object 'api' that
          incapsulates functionality implemented in the module.
      navbar_tab_id: id of a navbar tab to highlight.
      page_title: title of an HTML page.

    Args:
      path: path to a template, relative to templates/.
      env: additional environment dict to use when rendering the template.
      status: HTTP status code to return.
    """"""
    env = (env or {}).copy()
    env.setdefault('css_file', None)
    env.setdefault('js_file', None)
    env.setdefault('navbar_tab_id', None)
    env.setdefault('page_title', 'Untitled')

    # This goes to both Jinja2 env and Javascript config object.
    user = self.get_current_user()
    common = {
      'account_picture': user.picture() if user else None,
      'auth_service_config_locked': False, # overridden in auth_service
      'is_admin': api.is_admin(),
      'login_url': self.create_login_url(self.request.url),
      'logout_url': self.create_logout_url('/'),
      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,
      'xsrf_token': self.generate_xsrf_token(),
    }
    if _ui_data_callback:
      common.update(_ui_data_callback())

    # Name of Javascript module with page code.
    js_module_name = None
    if env['js_file']:
      assert env['js_file'].endswith('.js')
      js_module_name = os.path.basename(env['js_file'])[:-3]

    # This will be accessible from Javascript as global 'config' variable.
    js_config = {
      'identity': api.get_current_identity().to_bytes(),
    }
    js_config.update(common)

    # Jinja2 environment to use to render a template.
    full_env = {
      'app_name': _ui_app_name,
      'app_revision_url': utils.get_app_revision_url(),
      'app_version': utils.get_app_version(),
      'config': json.dumps(js_config),
      'csp_nonce': self.csp_nonce,
      'identity': api.get_current_identity(),
      'js_module_name': js_module_name,
      'navbar': [
        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)
        for cls in _ui_navbar_tabs
        if cls.is_visible()
      ],
    }
    full_env.update(common)
    full_env.update(env)

    # Render it.
    self.response.set_status(status)
    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
    self.response.write(template.render(path, full_env))

  def authentication_error(self, error):
    """"""Shows 'Access denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=401)

  def authorization_error(self, error):
    """"""Redirects to login or shows 'Access Denied' page.""""""
    # TODO(vadimsh): This will be deleted once we use Google Sign-In.
    # Not authenticated or used IP whitelist for auth -> redirect to login.
    # Bots doesn't use UI, and users should always use real accounts.
    ident = api.get_current_identity()
    if ident.is_anonymous or ident.is_bot:
      self.redirect(self.create_login_url(self.request.url))
      return

    # Admin group is empty -> redirect to bootstrap procedure to create it.
    if model.is_empty_group(model.ADMIN_GROUP):
      self.redirect_to('bootstrap')
      return

    # No access.
    env = {
      'page_title': 'Access Denied',
      'error': error,
    }
    self.reply('auth/access_denied.html', env=env, status=403)


class MainHandler(UIHandler):
  """"""Redirects to first navbar tab.""""""
  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    assert _ui_navbar_tabs
    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)


class UINavbarTabHandler(UIHandler):
  """"""Handler for a navbar tab page.""""""
  # List of routes to register, default is [navbar_tab_url].
  routes = []
  # URL to the tab (relative to site root).
  navbar_tab_url = None
  # ID of the tab, will be used in DOM.
  navbar_tab_id = None
  # Title of the tab, will be used in tab title and page title.
  navbar_tab_title = None
  # Relative URL to CSS file with tab's styles.
  css_file = None
  # Relative URL to javascript file with tab's logic.
  js_file_url = None
  # Path to a Jinja2 template with tab's markup.
  template_file = None

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self, **_params):
    """"""Renders page HTML to HTTP response stream.""""""
    env = {
      'css_file': self.css_file,
      'js_file': self.js_file_url,
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
    }
    self.reply(self.template_file, env)

  @classmethod
  def get_webapp2_routes(cls):
    routes = cls.routes or [cls.navbar_tab_url]
    return [webapp2.Route(r, cls) for r in routes]

  @classmethod
  def is_visible(cls):
    """"""Subclasses may return False to hide the tab from tab bar.""""""
    return True


################################################################################
## Default tabs.


class GroupsHandler(UINavbarTabHandler):
  """"""Page with Groups management.""""""
  routes = [
    '/auth/groups',
    '/auth/groups/<group:.*>',  # 'group' is handled by js code
  ]
  navbar_tab_url = '/auth/groups'
  navbar_tab_id = 'groups'
  navbar_tab_title = 'Groups'
  css_file = '/auth/static/css/groups.css'
  js_file_url = '/auth/static/js/groups.js'
  template_file = 'auth/groups.html'


class ChangeLogHandler(UINavbarTabHandler):
  """"""Page with a log of changes to some groups.""""""
  navbar_tab_url = '/auth/change_log'
  navbar_tab_id = 'change_log'
  navbar_tab_title = 'Change Log'
  js_file_url = '/auth/static/js/change_log.js'
  template_file = 'auth/change_log.html'

  @classmethod
  def is_visible(cls):
    # Hide 'Change Log' tab if there are no change log indexes in the datastore.
    # It happens on services that use components.auth, but do not modify
    # index.yaml. Don't try too hard to hide the log though. If user happes to
    # stumble on Change log page (e.g. by using direct URL), it handles
    # NeedIndexError gracefully (explaining how to configure indexes).
    return change_log.is_changle_log_indexed()


class OAuthConfigHandler(UINavbarTabHandler):
  """"""Page with OAuth configuration.""""""
  navbar_tab_url = '/auth/oauth_config'
  navbar_tab_id = 'oauth_config'
  navbar_tab_title = 'OAuth'
  js_file_url = '/auth/static/js/oauth_config.js'
  template_file = 'auth/oauth_config.html'


class IPWhitelistsHandler(UINavbarTabHandler):
  """"""Page with IP whitelists configuration.""""""
  navbar_tab_url = '/auth/ip_whitelists'
  navbar_tab_id = 'ip_whitelists'
  navbar_tab_title = 'IP Whitelists'
  js_file_url = '/auth/static/js/ip_whitelists.js'
  template_file = 'auth/ip_whitelists.html'


class ApiDocHandler(UINavbarTabHandler):
  """"""Page with API documentation extracted from rest_api.py.""""""
  navbar_tab_url = '/auth/api'
  navbar_tab_id = 'api'
  navbar_tab_title = 'API'

  # These can be used as 'request_type' and 'response_type' in api_doc.
  doc_types = [
    {
      'name': 'Status',
      'doc': 'Outcome of some operation.',
      'example': {'ok': True},
    },
    {
      'name': 'Self info',
      'doc': 'Information about the requester.',
      'example': {
        'identity': 'user:someone@example.com',
        'ip': '192.168.0.1',
      },
    },
    {
      'name': 'Group',
      'doc': 'Represents a group, as stored in the database.',
      'example': {
        'group': {
          'caller_can_modify': True,
          'created_by': 'user:someone@example.com',
          'created_ts': 1409250754978540,
          'description': 'Some free form description',
          'globs': ['user:*@example.com'],
          'members': ['user:a@example.com', 'anonymous:anonymous'],
          'modified_by': 'user:someone@example.com',
          'modified_ts': 1470871200558130,
          'name': 'Some group',
          'nested': ['Some nested group', 'Another nested group'],
          'owners': 'Owning group',
        },
      },
    },
    {
      'name': 'Group listing',
      'doc':
        'All groups, along with their metadata. Does not include members '
        'listings.',
      'example': {
        'groups': [
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Some free form description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Some group',
            'owners': 'Owning group',
          },
          {
            'caller_can_modify': True,
            'created_by': 'user:someone@example.com',
            'created_ts': 1409250754978540,
            'description': 'Another description',
            'modified_by': 'user:someone@example.com',
            'modified_ts': 1470871200558130,
            'name': 'Another group',
            'owners': 'Owning group',
          },
        ],
      },
    },
  ]

  @redirect_ui_on_replica
  @api.require(acl.has_access)
  def get(self):
    """"""Extracts API doc for registered webapp2 API routes.""""""
    doc_types = []

    def add_doc_type(tp):
      """"""Adds a request or response format definition to the documentation page.

      'tp' can either reference a globally known doc type by name
      (see ApiDocHandler.doc_types), or can itself be a dict with doc type
      definition.

      Returns the name of the doc type.
      """"""
      if not tp:
        return None
      # If referenced by name, try to find it among globally known types.
      if isinstance(tp, basestring):
        for d in self.doc_types:
          if d['name'] == tp:
            tp = d
            break
        else:
          return tp  # not found, return original name as is
      # Add, if not already there. Serialize the example first, since doing it
      # from Jinja is a bit more complicated.
      if not any(d['name'] == tp['name'] for d in doc_types):
        tp = tp.copy()
        tp['example'] = json.dumps(
            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)
        doc_types.append(tp)
      return tp['name']

    api_methods = []
    for route in rest_api.get_rest_api_routes():
      # Remove API parameter regexps from route template, they are mostly noise.
      simplified = re.sub(r'\:.*\>', '>', route.template)
      for doc in getattr(route.handler, 'api_doc', []):
        path = simplified
        if 'params' in doc:
          path += '?' + doc['params']
        api_methods.append({
          'verb': doc['verb'],
          'path': path,
          'doc': doc['doc'],
          'request_type': add_doc_type(doc.get('request_type')),
          'response_type': add_doc_type(doc.get('response_type')),
        })

    env = {
      'navbar_tab_id': self.navbar_tab_id,
      'page_title': self.navbar_tab_title,
      'api_methods': api_methods,
      'doc_types': doc_types,
    }
    self.reply('auth/api.html', env)


# Register them as default tabs. Order is important.
_ui_navbar_tabs = (
  GroupsHandler,
  ChangeLogHandler,
  OAuthConfigHandler,
  IPWhitelistsHandler,
  ApiDocHandler,
)
/n/n/n/appengine/components/components/ereporter2/handlers.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""HTTP Handlers.""""""

import datetime
import itertools
import json
import time

import webapp2

from google.appengine.api import app_identity
from google.appengine.datastore import datastore_query
from google.appengine.ext import ndb

from components import auth
from components import decorators
from components import template
from components import utils

from . import acl
from . import logscraper
from . import models
from . import on_error
from . import ui


# Access to a protected member XXX of a client class - pylint: disable=W0212


### Admin pages.


class RestrictedEreporter2Report(auth.AuthenticatingHandler):
  """"""Returns all the recent errors as a web page.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    """"""Reports the errors logged and ignored.

    Arguments:
      start: epoch time to start looking at. Defaults to the messages since the
             last email.
      end: epoch time to stop looking at. Defaults to now.
      modules: comma separated modules to look at.
      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.
    """"""
    # TODO(maruel): Be consistent about using either epoch or human readable
    # formatted datetime.
    end = int(float(self.request.get('end', 0)) or time.time())
    start = int(
        float(self.request.get('start', 0)) or
        ui._get_default_start_time() or 0)
    modules = self.request.get('modules')
    if modules:
      modules = modules.split(',')
    tainted = bool(int(self.request.get('tainted', '1')))
    module_versions = utils.get_module_version_list(modules, tainted)
    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(
        start, end, module_versions)

    params = {
      'errors': errors,
      'errors_count': sum(len(e.events) for e in errors),
      'errors_version_count':
          len(set(itertools.chain.from_iterable(e.versions for e in errors))),
      'ignored': ignored,
      'ignored_count': sum(len(i.events) for i in ignored),
      'ignored_version_count':
          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),
      'xsrf_token': self.generate_xsrf_token(),
    }
    params.update(ui._get_template_env(start, end, module_versions))
    self.response.write(template.render('ereporter2/requests.html', params))


class RestrictedEreporter2Request(auth.AuthenticatingHandler):
  """"""Dumps information about single logged request.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, request_id):
    data = logscraper._log_request_id(request_id)
    if not data:
      self.abort(404, detail='Request id was not found.')
    self.response.write(
        template.render('ereporter2/request.html', {'request': data}))


class RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    limit = int(self.request.get('limit', 100))
    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))
    errors_found, cursor, more = models.Error.query().order(
        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)
    params = {
      'cursor': cursor.urlsafe() if cursor and more else None,
      'errors': errors_found,
      'limit': limit,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/errors.html', params))


class RestrictedEreporter2Error(auth.AuthenticatingHandler):
  """"""Dumps information about reported client side errors.""""""

  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self, error_id):
    error = models.Error.get_by_id(int(error_id))
    if not error:
      self.abort(404, 'Error not found')
    params = {
      'error': error,
      'now': utils.utcnow(),
    }
    self.response.out.write(template.render('ereporter2/error.html', params))


class RestrictedEreporter2Silence(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.is_ereporter2_viewer)
  def get(self):
    # Due to historical reasons where created_ts had indexed=False,, do not use
    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all
    # objects have been updated.
    items = models.ErrorReportingMonitoring.query().fetch()
    items.sort(key=lambda x: x.created_ts)
    params = {
      'silenced': items,
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.out.write(template.render('ereporter2/silence.html', params))

  @auth.require(acl.is_ereporter2_editor)
  def post(self):
    to_delete = self.request.get('to_delete')
    if to_delete:
      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()
    else:
      mute_type = self.request.get('mute_type')
      error = None
      if mute_type in ('exception_type', 'signature'):
        error = self.request.get(mute_type)
      if not error:
        self.abort(400)
      silenced = self.request.get('silenced')
      silenced_until = self.request.get('silenced_until')
      if silenced_until == 'T':
        silenced_until = ''
      threshold = self.request.get('threshold')
      key = models.ErrorReportingMonitoring.error_to_key(error)
      if not silenced and not silenced_until and not threshold:
        key.delete()
      else:
        item = models.ErrorReportingMonitoring(key=key, error=error)
        if silenced:
          item.silenced = True
        if silenced_until:
          item.silenced_until = datetime.datetime.strptime(
              silenced_until, '%Y-%m-%dT%H:%M')
        if threshold:
          item.threshold = int(threshold)
        item.put()

    self.get()


### Cron jobs.


class CronEreporter2Mail(webapp2.RequestHandler):
  """"""Generate and emails an exception report.""""""
  @decorators.require_cronjob
  def get(self):
    """"""Sends email(s) containing the errors logged.""""""
    # Do not use self.request.host_url because it will be http:// and will point
    # to the backend, with an host format that breaks the SSL certificate.
    # TODO(maruel): On the other hand, Google Apps instances are not hosted on
    # appspot.com.
    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()
    request_id_url = host_url + '/restricted/ereporter2/request/'
    report_url = host_url + '/restricted/ereporter2/report'
    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())
    result = ui._generate_and_email_report(
        utils.get_module_version_list(None, False),
        recipients,
        request_id_url,
        report_url,
        {})
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    if result:
      self.response.write('Success.')
    else:
      # Do not HTTP 500 since we do not want it to be retried.
      self.response.write('Failed.')


class CronEreporter2Cleanup(webapp2.RequestHandler):
  """"""Deletes old error reports.""""""
  @decorators.require_cronjob
  def get(self):
    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE
    items = models.Error.query(
        models.Error.created_ts < old_cutoff,
        default_options=ndb.QueryOptions(keys_only=True))
    out = len(ndb.delete_multi(items))
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write(str(out))


### Public API.


class OnErrorHandler(auth.AuthenticatingHandler):
  """"""Adds an error report.

  This one is open so errors like authentication reports are logged in too.
  This means we could get spammed a lot about it. Implement DDoS protection by
  rate limiting once a kid figures out.
  """"""
  xsrf_token_enforce_on = ()

  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be
  # factored out.
  def parse_body(self):
    """"""Parse JSON body and verifies it's a dict.""""""
    expected = ('application/json', 'application/json; charset=utf-8')
    if self.request.headers.get('Content-Type').lower() not in expected:
      msg = 'Expecting JSON body with content type \'application/json\''
      self.abort(400, msg)
    try:
      body = json.loads(self.request.body)
      if not isinstance(body, dict):
        raise ValueError()
    except ValueError:
      self.abort(400, 'Not a valid json dict body')
    return body

  @auth.public
  def post(self):
    body = self.parse_body()
    version = body.get('v')
    # Do not enforce version for now, just assert it is present.
    if not version:
      self.abort(400, 'Missing version')

    report = body.get('r')
    if not report:
      self.abort(400, 'Missing report')

    kwargs = dict(
        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))
    report_id = on_error.log_request(self.request, add_params=False, **kwargs)
    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'
    body = {
      'id': report_id,
      'url':
          '%s/restricted/ereporter2/errors/%d' %
          (self.request.host_url, report_id),
    }
    self.response.write(utils.encode_to_json(body))


def get_frontend_routes():
  return [
    webapp2.Route(
        r'/restricted/ereporter2/errors',
        RestrictedEreporter2ErrorsList),
    webapp2.Route(
        r'/restricted/ereporter2/errors/<error_id:\d+>',
        RestrictedEreporter2Error),
    webapp2.Route(
        r'/restricted/ereporter2/report',
        RestrictedEreporter2Report),
    webapp2.Route(
        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',
        RestrictedEreporter2Request),
    webapp2.Route(
        r'/restricted/ereporter2/silence',
        RestrictedEreporter2Silence),

    # Public API.
    webapp2.Route(
      '/ereporter2/api/v1/on_error', OnErrorHandler),
  ]


def get_backend_routes():
  # This requires a cron job to this URL.
  return [
    webapp2.Route(
        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),
    webapp2.Route(
        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),
  ]
/n/n/n/appengine/isolate/handlers_frontend.py/n/n# Copyright 2012 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""This module defines Isolate Server frontend url handlers.""""""

import collections
import datetime
import json
import logging

import webapp2

import cloudstorage
from google.appengine.api import modules

import acl
import config
import gcs
import handlers_endpoints_v1
import mapreduce_jobs
import model
import stats
import template
from components import auth
from components import stats_framework
from components import stats_framework_gviz
from components import utils
from gviz import gviz_api


# GViz data description.
_GVIZ_DESCRIPTION = {
  'failures': ('number', 'Failures'),
  'requests': ('number', 'Total'),
  'other_requests': ('number', 'Other'),
  'uploads': ('number', 'Uploads'),
  'uploads_bytes': ('number', 'Uploaded'),
  'downloads': ('number', 'Downloads'),
  'downloads_bytes': ('number', 'Downloaded'),
  'contains_requests': ('number', 'Lookups'),
  'contains_lookups': ('number', 'Items looked up'),
}

# Warning: modifying the order here requires updating templates/stats.html.
_GVIZ_COLUMNS_ORDER = (
  'key',
  'requests',
  'other_requests',
  'failures',
  'uploads',
  'downloads',
  'contains_requests',
  'uploads_bytes',
  'downloads_bytes',
  'contains_lookups',
)

_ISOLATED_ROOT_MEMBERS = (
  'algo',
  'command',
  'files',
  'includes',
  'read_only',
  'relative_cwd',
  'version',
)


### Restricted handlers


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    self.common(None)

  @staticmethod
  def cast_to_type(param_name, value):
    def to_bool(value):
      if type(value) is bool:
        return value
      return {'True': True, 'False': False}.get(value, False)

    cast = {
        'enable_ts_monitoring': to_bool,
    }.get(param_name, str)
    return cast(value)

  @auth.require(auth.is_admin)
  def post(self):
    # Convert MultiDict into a dict.
    params = {
      k: self.cast_to_type(k, self.request.params.getone(k))
      for k in self.request.params
      if k not in ('keyid', 'xsrf_token')
    }
    cfg = config.settings(fresh=True)
    keyid = int(self.request.get('keyid', '0'))
    if cfg.key.integer_id() != keyid:
      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))
      return
    cfg.populate(**params)
    try:
      # Ensure key is correct, it's easy to make a mistake when creating it.
      gcs.URLSigner.load_private_key(cfg.gs_private_key)
    except Exception as exc:
      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)
      self.response.write('Bad private key: %s' % exc)
      return
    cfg.store(updated_by=auth.get_current_identity().to_bytes())
    self.common('Settings updated')

  def common(self, note):
    params = config.settings_info()
    params.update({
        'note': note,
        'path': self.request.path,
        'xsrf_token': self.generate_xsrf_token(),
    })
    self.response.write(
        template.render('isolate/restricted_config.html', params))


class RestrictedPurgeHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(auth.is_admin)
  def get(self):
    params = {
      'digest': '',
      'message': '',
      'namespace': '',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('isolate/restricted_purge.html', params))

  @auth.require(auth.is_admin)
  def post(self):
    namespace = self.request.get('namespace')
    digest = self.request.get('digest')
    params = {
      'digest': digest,
      'message': '',
      'namespace': namespace,
      'xsrf_token': self.generate_xsrf_token(),
    }
    try:
      key = model.get_entry_key(namespace, digest)
    except ValueError as e:
      params['message'] = 'Invalid entry: %s' % e
      key = None
    if key:
      model.delete_entry_and_gs_entry([key])
      params['message'] = 'Done'
    self.response.write(
        template.render('isolate/restricted_purge.html', params))


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(auth.is_admin)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    # Do not use 'backend' module when running from dev appserver. Mapreduce
    # generates URLs that are incompatible with dev appserver URL routing when
    # using custom modules.
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=not utils.is_local_dev_server())
    # New tasks should show up on the status page.
    if success:
      self.redirect('/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Non-restricted handlers


class BrowseHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    # Support 'hash' for compatibility with old links. To remove eventually.
    digest = self.request.get('digest', '') or self.request.get('hash', '')
    save_as = self.request.get('as', '')
    params = {
      u'as': unicode(save_as),
      u'digest': unicode(digest),
      u'namespace': unicode(namespace),
    }
    # Check for existence of element, so we can 400/404
    if digest and namespace:
      try:
        model.get_content(namespace, digest)
      except ValueError:
        self.abort(400, 'Invalid key')
      except LookupError:
        self.abort(404, 'Unable to retrieve the entry')
    self.response.write(template.render('isolate/browse.html', params))

  def get_content_security_policy(self):
    csp = super(BrowseHandler, self).get_content_security_policy()
    csp.setdefault('child-src', []).append(""'self'"")
    return csp


class ContentHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.isolate_readable)
  def get(self):
    namespace = self.request.get('namespace', 'default-gzip')
    digest = self.request.get('digest', '')
    content = None
    if not digest:
      self.abort(400, 'Missing digest')
    if not namespace:
      self.abort(400, 'Missing namespace')

    try:
      raw_data, entity = model.get_content(namespace, digest)
    except ValueError:
      self.abort(400, 'Invalid key')
    except LookupError:
      self.abort(404, 'Unable to retrieve the entry')

    logging.info('%s', entity)
    if not raw_data:
      try:
        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())
        content = ''.join(model.expand_content(namespace, stream))
      except cloudstorage.NotFoundError:
        logging.error('Entity in DB but not in GCS: deleting entity in DB')
        entity.key.delete()
        self.abort(404, 'Unable to retrieve the file from GCS')
    else:
      content = ''.join(model.expand_content(namespace, [raw_data]))

    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    # We delete Content-Type before storing to it to avoid having two (yes,
    # two) Content-Type headers.
    del self.response.headers['Content-Type']

    # Apparently, setting the content type to text/plain encourages the
    # browser (Chrome, at least) to sniff the mime type and display
    # things like images.  Images are autowrapped in <img> and text is
    # wrapped in <pre>.
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'

    # App Engine puts a limit of 33554432 bytes on a request, which includes
    # headers. Headers are ~150 bytes.  If the content + headers might
    # exceed that limit, we give the user an option to workround getting
    # their file.
    if len(content) > 33554000:
      host = modules.get_hostname(module='default', version='default')
      # host is something like default.default.myisolateserver.appspot.com
      host = host.replace('default.default.','')
      sizeInMib = len(content) / (1024.0 * 1024.0)
      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'
      ' App Engine limit.\nTo work around this, run the following command:\n'
      '    python isolateserver.py download -I %s --namespace %s -f %s %s'
      % (sizeInMib, host, namespace, digest, digest))
    else:
      self.response.headers['Content-Disposition'] = str(
        'filename=%s' % self.request.get('as') or digest)
      try:
        json_data = json.loads(content)
        if self._is_isolated_format(json_data):
          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'
          json_data['files'] = collections.OrderedDict(
            sorted(
              json_data['files'].items(),
              key=lambda (filepath, data): filepath))
          params = {
            'namespace': namespace,
            'isolated': json_data,
          }
          content = template.render('isolate/isolated.html', params)
      except ValueError:
        pass

    self.response.write(content)

  @staticmethod
  def _is_isolated_format(json_data):
    """"""Checks if json_data is a valid .isolated format.""""""
    if not isinstance(json_data, dict):
      return False
    actual = set(json_data)
    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual


class StatsHandler(webapp2.RequestHandler):
  """"""Returns the statistics web page.""""""
  def get(self):
    """"""Presents nice recent statistics.

    It fetches data from the 'JSON' API.
    """"""
    # Preloads the data to save a complete request.
    resolution = self.request.params.get('resolution', 'hours')
    if resolution not in ('days', 'hours', 'minutes'):
      resolution = 'hours'
    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)

    description = _GVIZ_DESCRIPTION.copy()
    description.update(stats_framework_gviz.get_description_key(resolution))
    table = stats_framework.get_stats(
        stats.STATS_HANDLER, resolution, None, duration, True)
    params = {
      'duration': duration,
      'initial_data': gviz_api.DataTable(description, table).ToJSon(
          columns_order=_GVIZ_COLUMNS_ORDER),
      'now': datetime.datetime.utcnow(),
      'resolution': resolution,
    }
    self.response.write(template.render('isolate/stats.html', params))


class StatsGvizHandlerBase(webapp2.RequestHandler):
  RESOLUTION = None

  def get(self):
    description = _GVIZ_DESCRIPTION.copy()
    description.update(
        stats_framework_gviz.get_description_key(self.RESOLUTION))
    try:
      stats_framework_gviz.get_json(
          self.request,
          self.response,
          stats.STATS_HANDLER,
          self.RESOLUTION,
          description,
          _GVIZ_COLUMNS_ORDER)
    except ValueError as e:
      self.abort(400, str(e))


class StatsGvizDaysHandler(StatsGvizHandlerBase):
  RESOLUTION = 'days'


class StatsGvizHoursHandler(StatsGvizHandlerBase):
  RESOLUTION = 'hours'


class StatsGvizMinutesHandler(StatsGvizHandlerBase):
  RESOLUTION = 'minutes'


###  Public pages.


class RootHandler(auth.AuthenticatingHandler):
  """"""Tells the user to RTM.""""""

  @auth.public
  def get(self):
    params = {
      'is_admin': auth.is_admin(),
      'is_user': acl.isolate_readable(),
      'mapreduce_jobs': [],
      'user_type': acl.get_user_type(),
    }
    if auth.is_admin():
      params['mapreduce_jobs'] = [
        {'id': job_id, 'name': job_def['job_name']}
        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()
      ]
      params['xsrf_token'] = self.generate_xsrf_token()
    self.response.write(template.render('isolate/root.html', params))


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.
  """"""
  @auth.public
  def get(self):
    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'isolate/public_isolate_index.html', params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    config.warmup()
    auth.warmup()
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # Administrative urls.
      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),
      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),

      # Mapreduce related urls.
      webapp2.Route(
          r'/restricted/launch_mapreduce',
          RestrictedLaunchMapReduceJob),

      # User web pages.
      webapp2.Route(r'/browse', BrowseHandler),
      webapp2.Route(r'/content', ContentHandler),
      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz
      # is just too sorry.
      #webapp2.Route(r'/stats', StatsHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),
      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),
      webapp2.Route(r'/', RootHandler),
      webapp2.Route(r'/newui', UIHandler),

      # AppEngine-specific urls:
      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),
      webapp2.Route(r'/_ah/warmup', WarmupHandler),
  ]
  routes.extend(handlers_endpoints_v1.get_routes())
  return routes


def create_application(debug):
  """"""Creates the url router.

  The basic layouts is as follow:
  - /restricted/.* requires being an instance administrator.
  - /stats/.* has statistics.
  """"""
  acl.bootstrap()
  template.bootstrap()
  return webapp2.WSGIApplication(get_routes(), debug=debug)
/n/n/n/appengine/machine_provider/handlers_frontend.py/n/n# Copyright 2016 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Front-end UI.""""""

import logging
import os

import webapp2

from components import auth
from components import datastore_utils
from components import template
from components import utils

import handlers_endpoints
import models


THIS_DIR = os.path.dirname(os.path.abspath(__file__))


class CatalogHandler(auth.AuthenticatingHandler):
  """"""Catalog handler.""""""

  @auth.require(auth.is_admin)
  def get(self, machine_id=None):
    params = {
        'machines': [],
        'next_page_token': None,
    }
    if machine_id:
      machine = models.CatalogMachineEntry.get_by_id(machine_id)
      if not machine:
        self.abort(404)
      params['machines'] = [machine]
    else:
      query = models.CatalogMachineEntry.query().order(
          models.CatalogMachineEntry.dimensions.hostname)
      page_token = self.request.get('page_token') or ''
      params['machines'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(
        template.render('templates/catalog.html', params=params))


class LeaseRequestHandler(auth.AuthenticatingHandler):
  """"""Lease request handler.""""""

  @auth.require(auth.is_admin)
  def get(self, lease_id=None):
    params = {
        'lease_requests': [],
        'next_page_token': None,
        'now_ts': utils.time_time(),
    }
    if lease_id:
      lease_request = models.LeaseRequest.get_by_id(lease_id)
      if not lease_request:
        self.abort(404)
      params['lease_requests'] = [lease_request]
    else:
      query = models.LeaseRequest.query().order(
          -models.LeaseRequest.last_modified_ts)
      page_token = self.request.get('page_token') or ''
      params['lease_requests'], params['next_page_token'] = (
          datastore_utils.fetch_page(query, 50, page_token))

    self.response.write(template.render('templates/leases.html', params=params))


class RootHandler(auth.AuthenticatingHandler):
  """"""Root handler.""""""

  @auth.public
  def get(self):
    params = {
        'is_admin': auth.is_admin(),
    }

    self.response.write(template.render('templates/root.html', params=params))


def get_routes():
  return [
      webapp2.Route('/', handler=RootHandler),
      webapp2.Route('/catalog', handler=CatalogHandler),
      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),
      webapp2.Route('/leases', handler=LeaseRequestHandler),
      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),
  ]


def create_frontend_app():
  template.bootstrap({
      'templates': os.path.join(THIS_DIR, 'templates'),
  })
  routes = get_routes()
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes)
/n/n/n/appengine/swarming/handlers_frontend.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.
# Use of this source code is governed under the Apache License, Version 2.0
# that can be found in the LICENSE file.

""""""Main entry point for Swarming service.

This file contains the URL handlers for all the Swarming service URLs,
implemented using the webapp2 framework.
""""""

import collections
import os

import webapp2

import handlers_bot
import handlers_endpoints
import mapreduce_jobs
import template
from components import auth
from components import utils
from server import acl
from server import bot_code
from server import config


ROOT_DIR = os.path.dirname(os.path.abspath(__file__))


# Helper class for displaying the sort options in html templates.
SortOptions = collections.namedtuple('SortOptions', ['key', 'name'])


### is_admin pages.


class RestrictedConfigHandler(auth.AuthenticatingHandler):
  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    # Template parameters schema matches settings_info() return value.
    self.response.write(template.render(
        'swarming/restricted_config.html', config.settings_info()))


class UploadBotConfigHandler(auth.AuthenticatingHandler):
  """"""Stores a new bot_config.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bot_config = bot_code.get_bot_config()
    params = {
      'content': bot_config.content.decode('utf-8'),
      'path': self.request.path,
      'version': bot_config.version,
      'when': bot_config.when,
      'who': bot_config.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bot_config.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bot_config(self.request.host_url, script)
    self.get()


class UploadBootstrapHandler(auth.AuthenticatingHandler):
  """"""Stores a new bootstrap.py script.""""""

  @auth.autologin
  @auth.require(acl.can_view_config)
  def get(self):
    bootstrap = bot_code.get_bootstrap(self.request.host_url)
    params = {
      'content': bootstrap.content.decode('utf-8'),
      'path': self.request.path,
      'version': bootstrap.version,
      'when': bootstrap.when,
      'who': bootstrap.who or 'N/A',
      'xsrf_token': self.generate_xsrf_token(),
    }
    self.response.write(
        template.render('swarming/restricted_upload_bootstrap.html', params))

  @auth.require(acl.can_edit_config)
  def post(self):
    script = self.request.get('script', '')
    if not script:
      self.abort(400, 'No script uploaded')

    # Make sure the script is valid utf-8. For some odd reason, the script
    # instead may or may not be an unicode instance. This depends if it is on
    # AppEngine production or not.
    if isinstance(script, str):
      script = script.decode('utf-8', 'replace')
    script = script.encode('utf-8')
    bot_code.store_bootstrap(script)
    self.get()


### Mapreduce related handlers


class RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):
  """"""Enqueues a task to start a map reduce job on the backend module.

  A tree of map reduce jobs inherits module and version of a handler that
  launched it. All UI handlers are executes by 'default' module. So to run a
  map reduce on a backend module one needs to pass a request to a task running
  on backend module.
  """"""

  @auth.require(acl.can_edit_config)
  def post(self):
    job_id = self.request.get('job_id')
    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS
    success = utils.enqueue_task(
        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,
        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,
        use_dedicated_module=False)
    # New tasks should show up on the status page.
    if success:
      self.redirect('/restricted/mapreduce/status')
    else:
      self.abort(500, 'Failed to launch the job')


### Redirectors.


class BotsListHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of known bots.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))

    dimensions = (
      l.strip() for l in self.request.get('dimensions', '').splitlines()
    )
    dimensions = [i for i in dimensions if i]

    new_ui_link = '/botlist?l=%d' % limit
    if dimensions:
      new_ui_link += '&f=' + '&f='.join(dimensions)

    self.redirect(new_ui_link)


class BotHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page about the bot, including last tasks and events.""""""

  @auth.public
  def get(self, bot_id):
    self.redirect('/bot?id=%s' % bot_id)


class TasksHandler(auth.AuthenticatingHandler):
  """"""Redirects to a list of all task requests.""""""

  @auth.public
  def get(self):
    limit = int(self.request.get('limit', 100))
    task_tags = [
      line for line in self.request.get('task_tag', '').splitlines() if line
    ]

    new_ui_link = '/tasklist?l=%d' % limit
    if task_tags:
      new_ui_link += '&f=' + '&f='.join(task_tags)

    self.redirect(new_ui_link)


class TaskHandler(auth.AuthenticatingHandler):
  """"""Redirects to a page containing task request and result.""""""

  @auth.public
  def get(self, task_id):
    self.redirect('/task?id=%s' % task_id)


### Public pages.


class UIHandler(auth.AuthenticatingHandler):
  """"""Serves the landing page for the new UI of the requested page.

  This landing page is stamped with the OAuth 2.0 client id from the
  configuration.""""""
  @auth.public
  def get(self, page):
    if not page:
      page = 'swarming'

    params = {
      'client_id': config.settings().ui_client_id,
    }
    # Can cache for 1 week, because the only thing that would change in this
    # template is the oauth client id, which changes very infrequently.
    self.response.cache_control.no_cache = None
    self.response.cache_control.public = True
    self.response.cache_control.max_age = 604800
    try:
      self.response.write(template.render(
        'swarming/public_%s_index.html' % page, params))
    except template.TemplateNotFound:
      self.abort(404, 'Page not found.')

  def get_content_security_policy(self):
    # We use iframes to display pages at display_server_url_template. Need to
    # allow it in CSP.
    csp = super(UIHandler, self).get_content_security_policy()
    tmpl = config.settings().display_server_url_template
    if tmpl:
      if tmpl.startswith('/'):
        csp['child-src'].append(""'self'"")
      else:
        # We assume the template specifies '%s' in its last path component.
        # We strip it to get a ""parent"" path that we can put into CSP. Note that
        # whitelisting an entire display server domain is unnecessary wide.
        assert tmpl.startswith('https://'), tmpl
        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])
    return csp


class WarmupHandler(webapp2.RequestHandler):
  def get(self):
    auth.warmup()
    bot_code.get_swarming_bot_zip(self.request.host_url)
    utils.get_module_version_list(None, None)
    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'
    self.response.write('ok')


class EmailHandler(webapp2.RequestHandler):
  """"""Blackhole any email sent.""""""
  def post(self, to):
    pass


def get_routes():
  routes = [
      # Frontend pages. They return HTML.
      # Public pages.
      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),

      # Redirects to Polymer UI
      ('/user/tasks', TasksHandler),
      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),
      ('/restricted/bots', BotsListHandler),
      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),

      # Admin pages.
      # TODO(maruel): Get rid of them.
      ('/restricted/config', RestrictedConfigHandler),
      ('/restricted/upload/bot_config', UploadBotConfigHandler),
      ('/restricted/upload/bootstrap', UploadBootstrapHandler),

      # Mapreduce related urls.
      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),

      ('/_ah/mail/<to:.+>', EmailHandler),
      ('/_ah/warmup', WarmupHandler),
  ]
  return [webapp2.Route(*i) for i in routes]


def create_application(debug):
  routes = []
  routes.extend(get_routes())
  routes.extend(handlers_bot.get_routes())
  routes.extend(handlers_endpoints.get_routes())
  return webapp2.WSGIApplication(routes, debug=debug)
/n/n/n",1
68,68,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
69,69,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
88,88,87009916aaa8086704dd5d9bd99dd858278c1234,"src/veil/frontend/web/website_launcher.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import argparse
from jinja2.loaders import FileSystemLoader
from veil.frontend.template import *
from veil.frontend.cli import *
from veil.environment import *
from veil.environment.setting import *
from .tornado import *
from .locale import *
from .routing import  *
from .static_file import *
from .xsrf import *
from .web_installer import load_website_config

LOGGER = logging.getLogger(__name__)

additional_context_managers = {}

def register_website_context_manager(website, context_manager):
    additional_context_managers.setdefault(website.lower(), []).append(context_manager)


@script('up')
def bring_up_website(*argv):
    argument_parser = argparse.ArgumentParser('Website')
    argument_parser.add_argument('purpose', help='which website to bring up')
    argument_parser.add_argument('--dependency', type=str,
        help='where @periodic_job is defined', nargs='+', dest='dependencies')
    args = argument_parser.parse_args(argv)
    for dependency in args.dependencies:
        __import__(dependency)
    start_website(args.purpose)


def start_test_website(purpose, **kwargs):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config, **kwargs)
    http_server = start_test_http_server(
        http_handler,
        host=config.host,
        port=config.port)
    http_server.purpose = purpose
    return http_server


def start_website(purpose):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config)
    io_loop = IOLoop.instance()
    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))
    start_http_server(
        http_handler, io_loop=io_loop,
        host=config.host, port=config.port)


def create_website_http_handler(purpose, config):
    locale_provider = lambda: None
    if config.secure_cookie_salt:
        set_secure_cookie_salt(config.secure_cookie_salt)
    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')
    set_external_static_files_directory(VEIL_HOME / 'static')
    master_template_directory = config.master_template_directory
    if master_template_directory:
        register_template_loader('master', FileSystemLoader(master_template_directory))
    website_context_managers = [create_stack_context(install_translations, locale_provider)]
    if config.prevents_xsrf:
        register_page_post_processor(set_xsrf_cookie_for_page)
        website_context_managers.append(prevent_xsrf)
    if config.recalculates_static_file_hash:
        website_context_managers.append(clear_static_file_hashes)
    if config.clears_template_cache:
        website_context_managers.append(clear_template_caches)
    website_context_managers.extend(additional_context_managers.get(purpose, []))
    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)
/n/n/n",0
89,89,87009916aaa8086704dd5d9bd99dd858278c1234,"/src/veil/frontend/web/website_launcher.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import argparse
from jinja2.loaders import FileSystemLoader
from veil.frontend.template import *
from veil.frontend.cli import *
from veil.environment import *
from veil.environment.setting import *
from .tornado import *
from .locale import *
from .routing import  *
from .static_file import *
from .xsrf import *
from .web_installer import load_website_config

LOGGER = logging.getLogger(__name__)

additional_context_managers = {}

def register_website_context_manager(website, context_manager):
    additional_context_managers.setdefault(website.lower(), []).append(context_manager)


@script('up')
def bring_up_website(*argv):
    argument_parser = argparse.ArgumentParser('Website')
    argument_parser.add_argument('purpose', help='which website to bring up')
    argument_parser.add_argument('--dependency', type=str,
        help='where @periodic_job is defined', nargs='+', dest='dependencies')
    args = argument_parser.parse_args(argv)
    for dependency in args.dependencies:
        __import__(dependency)
    start_website(args.purpose)


def start_test_website(purpose, **kwargs):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, **kwargs)
    http_server = start_test_http_server(
        http_handler,
        host=config.host,
        port=config.port)
    http_server.purpose = purpose
    return http_server


def start_website(purpose):
    config = load_website_config(purpose)
    http_handler = create_website_http_handler(purpose, config)
    io_loop = IOLoop.instance()
    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))
    start_http_server(
        http_handler, io_loop=io_loop,
        host=config.host, port=config.port)


def create_website_http_handler(purpose, config):
    locale_provider = lambda: None
    if config.secure_cookie_salt:
        set_secure_cookie_salt(config.secure_cookie_salt)
    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')
    set_external_static_files_directory(VEIL_HOME / 'static')
    master_template_directory = config.master_template_directory
    if master_template_directory:
        register_template_loader('master', FileSystemLoader(master_template_directory))
    website_context_managers = [create_stack_context(install_translations, locale_provider)]
    if config.prevents_xsrf:
        register_page_post_processor(set_xsrf_cookie_for_page)
        website_context_managers.append(prevent_xsrf)
    if config.recalculates_static_file_hash:
        website_context_managers.append(clear_static_file_hashes)
    if config.clears_template_cache:
        website_context_managers.append(clear_template_caches)
    website_context_managers.extend(additional_context_managers.get(purpose, []))
    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)
/n/n/n",1
90,90,21a72f4ce71f05b6e574f2f3e564c087870f7314,"src/veil/frontend/web/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .website_launcher import start_website
    from .website_launcher import start_test_website
    from .website_launcher import register_website_context_manager
    from .website_installer import get_website_url_prefix
    from .website_installer import website_resource
    from .client import start_website_and_client
    from .routing import route
    from .routing import route_for
    from .routing import async_route
    from .routing import public_route
    from .routing import is_public_route
    from .routing import RoutingHTTPHandler
    from .routing import get_routes
    from .routing import register_page_post_processor
    from .routing import TAG_NO_POST_PROCESS
    from .routing import publish_new_website_event
    from .static_file import static_url
    from .static_file import process_script_elements
    from .tornado import get_current_http_context
    from .tornado import get_current_http_request
    from .tornado import get_current_http_response
    from .tornado import start_http_server
    from .tornado import start_test_http_server
    from .tornado import create_stack_context
    from .tornado import set_http_status_code
    from .tornado import HTTPError
    from .tornado import end_http_request_processing
    from .tornado import get_secure_cookie
    from .tornado import set_secure_cookie
    from .tornado import get_cookies
    from .tornado import get_cookie
    from .tornado import clear_cookies
    from .tornado import clear_cookie
    from .tornado import set_cookie
    from .tornado import redirect_to
    from .tornado import get_http_argument
    from .tornado import get_http_arguments
    from .tornado import get_http_file
    from .tornado import get_http_files
    from .tornado import delete_http_argument
    from .tornado import clear_http_arguments
    from .tornado import require_io_loop_executor
    from .xsrf import xsrf_token
    from .xsrf import TAG_NO_XSRF_CHECK

    __all__ = [
        # from website
        start_website.__name__,
        start_test_website.__name__,
        register_website_context_manager.__name__,
        # from website_installer
        get_website_url_prefix.__name__,
        website_resource.__name__,
        # from client
        start_website_and_client.__name__,
        # from routing
        route.__name__,
        route_for.__name__,
        async_route.__name__,
        public_route.__name__,
        is_public_route.__name__,
        RoutingHTTPHandler.__name__,
        get_routes.__name__,
        register_page_post_processor.__name__,
        'TAG_NO_POST_PROCESS',
        publish_new_website_event.__name__,
        # from static_file
        static_url.__name__,
        process_script_elements.__name__,
        # from tornado
        get_current_http_context.__name__,
        get_current_http_request.__name__,
        get_current_http_response.__name__,
        start_http_server.__name__,
        start_test_http_server.__name__,
        create_stack_context.__name__,
        set_http_status_code.__name__,
        HTTPError.__name__,
        end_http_request_processing.__name__,
        get_secure_cookie.__name__,
        set_secure_cookie.__name__,
        get_cookies.__name__,
        get_cookie.__name__,
        clear_cookies.__name__,
        clear_cookie.__name__,
        set_cookie.__name__,
        redirect_to.__name__,
        get_http_argument.__name__,
        get_http_arguments.__name__,
        get_http_file.__name__,
        get_http_files.__name__,
        delete_http_argument.__name__,
        clear_http_arguments.__name__,
        require_io_loop_executor.__name__,
        # from xsrf
        xsrf_token.__name__,
        'TAG_NO_XSRF_CHECK'
    ]
/n/n/nsrc/veil/frontend/web/xsrf/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .xsrf import xsrf_token
    from .xsrf import prevent_xsrf
    from .xsrf import set_xsrf_cookie_for_page
    from .xsrf import TAG_NO_XSRF_CHECK

    __all__ = [
        # from xsrf
        xsrf_token.__name__,
        prevent_xsrf.__name__,
        set_xsrf_cookie_for_page.__name__,
        'TAG_NO_XSRF_CHECK'
    ]/n/n/nsrc/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from tornado.escape import xhtml_escape
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *

LOGGER = getLogger(__name__)
TAG_NO_XSRF_CHECK = 'NO-XSRF'

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        request.is_new_xsrf_token = False
        if not token:
            request.is_new_xsrf_token = True
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {
                'token': token,
                'method': request.method,
                'path': request.path
            })
        request._xsrf_token = token
    if 'GET' != request.method.upper() and TAG_NO_XSRF_CHECK not in get_current_http_context().route.tags:
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {
                'request': request,
                'expected_token': expected_token,
                'token': token
            })
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


def set_xsrf_cookie_for_page(route_handler, data):
    if get_current_http_request().is_new_xsrf_token:
        if data and '<html' in data.lower():
            # only set to page to avoid concurrent http request issue
            set_cookie(name='_xsrf', value=xsrf_token())
    return data


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type=""hidden"" name=""_xsrf"" value=""{}""/>'.format(xhtml_escape(xsrf_token())))/n/n/n",0
91,91,21a72f4ce71f05b6e574f2f3e564c087870f7314,"/src/veil/frontend/web/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .website_launcher import start_website
    from .website_launcher import start_test_website
    from .website_launcher import register_website_context_manager
    from .website_installer import get_website_url_prefix
    from .website_installer import website_resource
    from .client import start_website_and_client
    from .routing import route
    from .routing import route_for
    from .routing import async_route
    from .routing import public_route
    from .routing import is_public_route
    from .routing import RoutingHTTPHandler
    from .routing import get_routes
    from .routing import register_page_post_processor
    from .routing import TAG_NO_POST_PROCESS
    from .routing import publish_new_website_event
    from .static_file import static_url
    from .static_file import process_script_elements
    from .tornado import get_current_http_context
    from .tornado import get_current_http_request
    from .tornado import get_current_http_response
    from .tornado import start_http_server
    from .tornado import start_test_http_server
    from .tornado import create_stack_context
    from .tornado import set_http_status_code
    from .tornado import HTTPError
    from .tornado import end_http_request_processing
    from .tornado import get_secure_cookie
    from .tornado import set_secure_cookie
    from .tornado import get_cookies
    from .tornado import get_cookie
    from .tornado import clear_cookies
    from .tornado import clear_cookie
    from .tornado import set_cookie
    from .tornado import redirect_to
    from .tornado import get_http_argument
    from .tornado import get_http_arguments
    from .tornado import get_http_file
    from .tornado import get_http_files
    from .tornado import delete_http_argument
    from .tornado import clear_http_arguments
    from .tornado import require_io_loop_executor
    from .xsrf import xsrf_token

    __all__ = [
        # from website
        start_website.__name__,
        start_test_website.__name__,
        register_website_context_manager.__name__,
        # from website_installer
        get_website_url_prefix.__name__,
        website_resource.__name__,
        # from client
        start_website_and_client.__name__,
        # from routing
        route.__name__,
        route_for.__name__,
        async_route.__name__,
        public_route.__name__,
        is_public_route.__name__,
        RoutingHTTPHandler.__name__,
        get_routes.__name__,
        register_page_post_processor.__name__,
        'TAG_NO_POST_PROCESS',
        publish_new_website_event.__name__,
        # from static_file
        static_url.__name__,
        process_script_elements.__name__,
        # from tornado
        get_current_http_context.__name__,
        get_current_http_request.__name__,
        get_current_http_response.__name__,
        start_http_server.__name__,
        start_test_http_server.__name__,
        create_stack_context.__name__,
        set_http_status_code.__name__,
        HTTPError.__name__,
        end_http_request_processing.__name__,
        get_secure_cookie.__name__,
        set_secure_cookie.__name__,
        get_cookies.__name__,
        get_cookie.__name__,
        clear_cookies.__name__,
        clear_cookie.__name__,
        set_cookie.__name__,
        redirect_to.__name__,
        get_http_argument.__name__,
        get_http_arguments.__name__,
        get_http_file.__name__,
        get_http_files.__name__,
        delete_http_argument.__name__,
        clear_http_arguments.__name__,
        require_io_loop_executor.__name__,
        # from xsrf
        xsrf_token.__name__
    ]
/n/n/n/src/veil/frontend/web/xsrf/__init__.py/n/nimport veil_component

with veil_component.init_component(__name__):
    from .xsrf import xsrf_token
    from .xsrf import prevent_xsrf
    from .xsrf import set_xsrf_cookie_for_page

    __all__ = [
        # from xsrf
        xsrf_token.__name__,
        prevent_xsrf.__name__,
        set_xsrf_cookie_for_page.__name__
    ]/n/n/n/src/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from tornado.escape import xhtml_escape
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *

LOGGER = getLogger(__name__)

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        request.is_new_xsrf_token = False
        if not token:
            request.is_new_xsrf_token = True
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {
                'token': token,
                'method': request.method,
                'path': request.path
            })
        request._xsrf_token = token
    if 'GET' != request.method.upper():
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {
                'request': request,
                'expected_token': expected_token,
                'token': token
            })
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


def set_xsrf_cookie_for_page(route_handler, data):
    if get_current_http_request().is_new_xsrf_token:
        if data and '<html' in data.lower():
            # only set to page to avoid concurrent http request issue
            set_cookie(name='_xsrf', value=xsrf_token())
    return data


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type=""hidden"" name=""_xsrf"" value=""{}""/>'.format(xhtml_escape(xsrf_token())))/n/n/n",1
62,62,d6f091c4439c174c7700776c0cee03053403f600,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8
""""""A tornado based Jupyter notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import, print_function

import binascii
import datetime
import errno
import importlib
import io
import json
import logging
import mimetypes
import os
import random
import re
import select
import signal
import socket
import sys
import threading
import warnings
import webbrowser

try: #PY3
    from base64 import encodebytes
except ImportError: #PY2
    from base64 import encodestring as encodebytes


from jinja2 import Environment, FileSystemLoader

# Install the pyzmq ioloop. This has to be done before anything else from
# tornado is imported.
from zmq.eventloop import ioloop
ioloop.install()

# check for tornado 3.1.0
msg = ""The Jupyter Notebook requires tornado >= 4.0""
try:
    import tornado
except ImportError:
    raise ImportError(msg)
try:
    version_info = tornado.version_info
except AttributeError:
    raise ImportError(msg + "", but you have < 1.1.0"")
if version_info < (4,0):
    raise ImportError(msg + "", but you have %s"" % tornado.version)

from tornado import httpserver
from tornado import web
from tornado.httputil import url_concat
from tornado.log import LogFormatter, app_log, access_log, gen_log

from notebook import (
    DEFAULT_STATIC_FILES_PATH,
    DEFAULT_TEMPLATE_PATH_LIST,
    __version__,
)

# py23 compatibility
try:
    raw_input = raw_input
except NameError:
    raw_input = input

from .base.handlers import Template404, RedirectWithParams
from .log import log_request
from .services.kernels.kernelmanager import MappingKernelManager
from .services.config import ConfigManager
from .services.contents.manager import ContentsManager
from .services.contents.filemanager import FileContentsManager
from .services.sessions.sessionmanager import SessionManager

from .auth.login import LoginHandler
from .auth.logout import LogoutHandler
from .base.handlers import FileFindHandler

from traitlets.config import Config
from traitlets.config.application import catch_config_error, boolean_flag
from jupyter_core.application import (
    JupyterApp, base_flags, base_aliases,
)
from jupyter_client import KernelManager
from jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME
from jupyter_client.session import Session
from nbformat.sign import NotebookNotary
from traitlets import (
    Dict, Unicode, Integer, List, Bool, Bytes, Instance,
    TraitError, Type, Float, observe, default, validate
)
from ipython_genutils import py3compat
from jupyter_core.paths import jupyter_runtime_dir, jupyter_path
from notebook._sysinfo import get_sys_info

from .utils import url_path_join, check_pid, url_escape

#-----------------------------------------------------------------------------
# Module globals
#-----------------------------------------------------------------------------

_examples = """"""
jupyter notebook                       # start the notebook
jupyter notebook --certfile=mycert.pem # use SSL/TLS certificate
""""""

DEV_NOTE_NPM = """"""It looks like you're running the notebook from source.
If you're working on the Javascript of the notebook, try running

    npm run build:watch

in another terminal window to have the system incrementally
watch and build the notebook's JavaScript for you, as you make changes.
""""""

#-----------------------------------------------------------------------------
# Helper functions
#-----------------------------------------------------------------------------

def random_ports(port, n):
    """"""Generate a list of n random ports near the given port.

    The first 5 ports will be sequential, and the remaining n-5 will be
    randomly selected in the range [port-2*n, port+2*n].
    """"""
    for i in range(min(5, n)):
        yield port + i
    for i in range(n-5):
        yield max(1, port + random.randint(-2*n, 2*n))

def load_handlers(name):
    """"""Load the (URL pattern, handler) tuples for each component.""""""
    name = 'notebook.' + name
    mod = __import__(name, fromlist=['default_handlers'])
    return mod.default_handlers

#-----------------------------------------------------------------------------
# The Tornado web application
#-----------------------------------------------------------------------------

class NotebookWebApplication(web.Application):

    def __init__(self, jupyter_app, kernel_manager, contents_manager,
                 session_manager, kernel_spec_manager,
                 config_manager, log,
                 base_url, default_url, settings_overrides, jinja_env_options):

        # If the user is running the notebook in a git directory, make the assumption
        # that this is a dev install and suggest to the developer `npm run build:watch`.
        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))
        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))
        if dev_mode:
            log.info(DEV_NOTE_NPM)

        settings = self.init_settings(
            jupyter_app, kernel_manager, contents_manager,
            session_manager, kernel_spec_manager, config_manager, log, base_url,
            default_url, settings_overrides, jinja_env_options)
        handlers = self.init_handlers(settings)

        super(NotebookWebApplication, self).__init__(handlers, **settings)

    def init_settings(self, jupyter_app, kernel_manager, contents_manager,
                      session_manager, kernel_spec_manager,
                      config_manager,
                      log, base_url, default_url, settings_overrides,
                      jinja_env_options=None):

        _template_path = settings_overrides.get(
            ""template_path"",
            jupyter_app.template_file_path,
        )
        if isinstance(_template_path, py3compat.string_types):
            _template_path = (_template_path,)
        template_path = [os.path.expanduser(path) for path in _template_path]

        jenv_opt = {""autoescape"": True}
        jenv_opt.update(jinja_env_options if jinja_env_options else {})

        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)
        
        sys_info = get_sys_info()
        if sys_info['commit_source'] == 'repository':
            # don't cache (rely on 304) when working from master
            version_hash = ''
        else:
            # reset the cache on server restart
            version_hash = datetime.datetime.now().strftime(""%Y%m%d%H%M%S"")

        if jupyter_app.ignore_minified_js:
            log.warning(""""""The `ignore_minified_js` flag is deprecated and no 
                longer works.  Alternatively use `npm run build:watch` when
                working on the notebook's Javascript and LESS"""""")
            warnings.warn(""The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0"", DeprecationWarning)

        settings = dict(
            # basics
            log_function=log_request,
            base_url=base_url,
            default_url=default_url,
            template_path=template_path,
            static_path=jupyter_app.static_file_path,
            static_custom_path=jupyter_app.static_custom_path,
            static_handler_class = FileFindHandler,
            static_url_prefix = url_path_join(base_url,'/static/'),
            static_handler_args = {
                # don't cache custom.js
                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],
            },
            version_hash=version_hash,
            ignore_minified_js=jupyter_app.ignore_minified_js,
            
            # rate limits
            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,
            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,
            rate_limit_window=jupyter_app.rate_limit_window,
            
            # authentication
            cookie_secret=jupyter_app.cookie_secret,
            login_url=url_path_join(base_url,'/login'),
            login_handler_class=jupyter_app.login_handler_class,
            logout_handler_class=jupyter_app.logout_handler_class,
            password=jupyter_app.password,
            xsrf_cookies=True,
            disable_check_xsrf=ipython_app.disable_check_xsrf,

            # managers
            kernel_manager=kernel_manager,
            contents_manager=contents_manager,
            session_manager=session_manager,
            kernel_spec_manager=kernel_spec_manager,
            config_manager=config_manager,

            # IPython stuff
            jinja_template_vars=jupyter_app.jinja_template_vars,
            nbextensions_path=jupyter_app.nbextensions_path,
            websocket_url=jupyter_app.websocket_url,
            mathjax_url=jupyter_app.mathjax_url,
            mathjax_config=jupyter_app.mathjax_config,
            config=jupyter_app.config,
            config_dir=jupyter_app.config_dir,
            jinja2_env=env,
            terminals_available=False,  # Set later if terminals are available
        )

        # allow custom overrides for the tornado web app.
        settings.update(settings_overrides)
        return settings

    def init_handlers(self, settings):
        """"""Load the (URL pattern, handler) tuples for each component.""""""
        
        # Order matters. The first handler to match the URL will handle the request.
        handlers = []
        handlers.extend(load_handlers('tree.handlers'))
        handlers.extend([(r""/login"", settings['login_handler_class'])])
        handlers.extend([(r""/logout"", settings['logout_handler_class'])])
        handlers.extend(load_handlers('files.handlers'))
        handlers.extend(load_handlers('notebook.handlers'))
        handlers.extend(load_handlers('nbconvert.handlers'))
        handlers.extend(load_handlers('bundler.handlers'))
        handlers.extend(load_handlers('kernelspecs.handlers'))
        handlers.extend(load_handlers('edit.handlers'))
        handlers.extend(load_handlers('services.api.handlers'))
        handlers.extend(load_handlers('services.config.handlers'))
        handlers.extend(load_handlers('services.kernels.handlers'))
        handlers.extend(load_handlers('services.contents.handlers'))
        handlers.extend(load_handlers('services.sessions.handlers'))
        handlers.extend(load_handlers('services.nbconvert.handlers'))
        handlers.extend(load_handlers('services.kernelspecs.handlers'))
        handlers.extend(load_handlers('services.security.handlers'))
        
        # BEGIN HARDCODED WIDGETS HACK
        # TODO: Remove on notebook 5.0
        widgets = None
        try:
            import widgetsnbextension
        except:
            try:
                import ipywidgets as widgets
                handlers.append(
                    (r""/nbextensions/widgets/(.*)"", FileFindHandler, {
                        'path': widgets.find_static_assets(),
                        'no_cache_paths': ['/'], # don't cache anything in nbextensions
                    }),
                )
            except:
                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')
        # END HARDCODED WIDGETS HACK
        
        handlers.append(
            (r""/nbextensions/(.*)"", FileFindHandler, {
                'path': settings['nbextensions_path'],
                'no_cache_paths': ['/'], # don't cache anything in nbextensions
            }),
        )
        handlers.append(
            (r""/custom/(.*)"", FileFindHandler, {
                'path': settings['static_custom_path'],
                'no_cache_paths': ['/'], # don't cache anything in custom
            })
        )
        # register base handlers last
        handlers.extend(load_handlers('base.handlers'))
        # set the URL that will be redirected from `/`
        handlers.append(
            (r'/?', RedirectWithParams, {
                'url' : settings['default_url'],
                'permanent': False, # want 302, not 301
            })
        )

        # prepend base_url onto the patterns that we match
        new_handlers = []
        for handler in handlers:
            pattern = url_path_join(settings['base_url'], handler[0])
            new_handler = tuple([pattern] + list(handler[1:]))
            new_handlers.append(new_handler)
        # add 404 on the end, which will catch everything that falls through
        new_handlers.append((r'(.*)', Template404))
        return new_handlers


class NbserverListApp(JupyterApp):
    version = __version__
    description=""List currently running notebook servers.""
    
    flags = dict(
        json=({'NbserverListApp': {'json': True}},
              ""Produce machine-readable JSON output.""),
    )
    
    json = Bool(False, config=True,
          help=""If True, each line of output will be a JSON object with the ""
                  ""details from the server info file."")

    def start(self):
        if not self.json:
            print(""Currently running servers:"")
        for serverinfo in list_running_servers(self.runtime_dir):
            if self.json:
                print(json.dumps(serverinfo))
            else:
                url = serverinfo['url']
                if serverinfo.get('token'):
                    url = url + '?token=%s' % serverinfo['token']
                print(url, ""::"", serverinfo['notebook_dir'])

#-----------------------------------------------------------------------------
# Aliases and Flags
#-----------------------------------------------------------------------------

flags = dict(base_flags)
flags['no-browser']=(
    {'NotebookApp' : {'open_browser' : False}},
    ""Don't open the notebook in a browser after startup.""
)
flags['pylab']=(
    {'NotebookApp' : {'pylab' : 'warn'}},
    ""DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.""
)
flags['no-mathjax']=(
    {'NotebookApp' : {'enable_mathjax' : False}},
    """"""Disable MathJax
    
    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
    very large, so you may want to disable it if you have a slow internet
    connection, or for offline use of the notebook.
    
    When disabled, equations etc. will appear as their untransformed TeX source.
    """"""
)

flags['allow-root']=(
    {'NotebookApp' : {'allow_root' : True}},
    ""Allow the notebook to be run from root user.""
)

# Add notebook manager flags
flags.update(boolean_flag('script', 'FileContentsManager.save_script',
               'DEPRECATED, IGNORED',
               'DEPRECATED, IGNORED'))

aliases = dict(base_aliases)

aliases.update({
    'ip': 'NotebookApp.ip',
    'port': 'NotebookApp.port',
    'port-retries': 'NotebookApp.port_retries',
    'transport': 'KernelManager.transport',
    'keyfile': 'NotebookApp.keyfile',
    'certfile': 'NotebookApp.certfile',
    'client-ca': 'NotebookApp.client_ca',
    'notebook-dir': 'NotebookApp.notebook_dir',
    'browser': 'NotebookApp.browser',
    'pylab': 'NotebookApp.pylab',
})

#-----------------------------------------------------------------------------
# NotebookApp
#-----------------------------------------------------------------------------

class NotebookApp(JupyterApp):

    name = 'jupyter-notebook'
    version = __version__
    description = """"""
        The Jupyter HTML Notebook.
        
        This launches a Tornado based HTML Notebook Server that serves up an
        HTML5/Javascript Notebook client.
    """"""
    examples = _examples
    aliases = aliases
    flags = flags
    
    classes = [
        KernelManager, Session, MappingKernelManager,
        ContentsManager, FileContentsManager, NotebookNotary,
        KernelSpecManager,
    ]
    flags = Dict(flags)
    aliases = Dict(aliases)
    
    subcommands = dict(
        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),
    )

    _log_formatter_cls = LogFormatter

    @default('log_level')
    def _default_log_level(self):
        return logging.INFO

    @default('log_datefmt')
    def _default_log_datefmt(self):
        """"""Exclude date from default date format""""""
        return ""%H:%M:%S""
    
    @default('log_format')
    def _default_log_format(self):
        """"""override default log format to include time""""""
        return u""%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s""

    ignore_minified_js = Bool(False,
            config=True,
            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', 
            )

    # file to be opened in the notebook server
    file_to_run = Unicode('', config=True)

    # Network related information
    
    allow_origin = Unicode('', config=True,
        help=""""""Set the Access-Control-Allow-Origin header
        
        Use '*' to allow any origin to access your server.
        
        Takes precedence over allow_origin_pat.
        """"""
    )
    
    allow_origin_pat = Unicode('', config=True,
        help=""""""Use a regular expression for the Access-Control-Allow-Origin header
        
        Requests from an origin matching the expression will get replies with:
        
            Access-Control-Allow-Origin: origin
        
        where `origin` is the origin of the request.
        
        Ignored if allow_origin is set.
        """"""
    )
    
    allow_credentials = Bool(False, config=True,
        help=""Set the Access-Control-Allow-Credentials: true header""
    )
    
    allow_root = Bool(False, config=True, 
        help=""Whether to allow the user to run the notebook as root.""
    )

    default_url = Unicode('/tree', config=True,
        help=""The default URL to redirect to from `/`""
    )
    
    ip = Unicode('localhost', config=True,
        help=""The IP address the notebook server will listen on.""
    )

    @default('ip')
    def _default_ip(self):
        """"""Return localhost if available, 127.0.0.1 otherwise.
        
        On some (horribly broken) systems, localhost cannot be bound.
        """"""
        s = socket.socket()
        try:
            s.bind(('localhost', 0))
        except socket.error as e:
            self.log.warning(""Cannot bind to localhost, using 127.0.0.1 as default ip\n%s"", e)
            return '127.0.0.1'
        else:
            s.close()
            return 'localhost'

    @validate('ip')
    def _valdate_ip(self, proposal):
        value = proposal['value']
        if value == u'*':
            value = u''
        return value

    port = Integer(8888, config=True,
        help=""The port the notebook server will listen on.""
    )

    port_retries = Integer(50, config=True,
        help=""The number of additional ports to try if the specified port is not available.""
    )

    certfile = Unicode(u'', config=True, 
        help=""""""The full path to an SSL/TLS certificate file.""""""
    )
    
    keyfile = Unicode(u'', config=True, 
        help=""""""The full path to a private key file for usage with SSL/TLS.""""""
    )
    
    client_ca = Unicode(u'', config=True,
        help=""""""The full path to a certificate authority certificate for SSL/TLS client authentication.""""""
    )
    
    cookie_secret_file = Unicode(config=True,
        help=""""""The file where the cookie secret is stored.""""""
    )

    @default('cookie_secret_file')
    def _default_cookie_secret_file(self):
        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')
    
    cookie_secret = Bytes(b'', config=True,
        help=""""""The random bytes used to secure cookies.
        By default this is a new random number every time you start the Notebook.
        Set it to a value in a config file to enable logins to persist across server sessions.
        
        Note: Cookie secrets should be kept private, do not share config files with
        cookie_secret stored in plaintext (you can read the value from a file).
        """"""
    )
    
    @default('cookie_secret')
    def _default_cookie_secret(self):
        if os.path.exists(self.cookie_secret_file):
            with io.open(self.cookie_secret_file, 'rb') as f:
                return f.read()
        else:
            secret = encodebytes(os.urandom(1024))
            self._write_cookie_secret_file(secret)
            return secret
    
    def _write_cookie_secret_file(self, secret):
        """"""write my secret to my secret_file""""""
        self.log.info(""Writing notebook server cookie secret to %s"", self.cookie_secret_file)
        with io.open(self.cookie_secret_file, 'wb') as f:
            f.write(secret)
        try:
            os.chmod(self.cookie_secret_file, 0o600)
        except OSError:
            self.log.warning(
                ""Could not set permissions on %s"",
                self.cookie_secret_file
            )

    token = Unicode('<generated>',
        help=""""""Token used for authenticating first-time connections to the server.

        When no password is enabled,
        the default is to generate a new, random token.

        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.
        """"""
    ).tag(config=True)

    one_time_token = Unicode(
        help=""""""One-time token used for opening a browser.

        Once used, this token cannot be used again.
        """"""
    )

    _token_generated = True

    @default('token')
    def _token_default(self):
        if self.password:
            # no token if password is enabled
            self._token_generated = False
            return u''
        else:
            self._token_generated = True
            return binascii.hexlify(os.urandom(24)).decode('ascii')

    @observe('token')
    def _token_changed(self, change):
        self._token_generated = False

    password = Unicode(u'', config=True,
                      help=""""""Hashed password to use for web authentication.

                      To generate, type in a python/IPython shell:

                        from notebook.auth import passwd; passwd()

                      The string should be of the form type:salt:hashed-password.
                      """"""
    )

    password_required = Bool(False, config=True,
                      help=""""""Forces users to use a password for the Notebook server.
                      This is useful in a multi user environment, for instance when
                      everybody in the LAN can access each other's machine though ssh.

                      In such a case, server the notebook server on localhost is not secure
                      since any user can connect to the notebook server via ssh.

                      """"""

    disable_check_xsrf = Bool(False, config=True,
        help=""""""Disable cross-site-request-forgery protection

        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,
        requiring API requests to either:

        - originate from the (validated with XSRF cookie and token), or
        - authenticate with a token

        Some anonymous compute resources still desire the ability to run code,
        completely without authentication.
        These services can disable all authentication and security checks,
        with the full knowledge of what that implies.
        """"""
    )

    open_browser = Bool(True, config=True,
                        help=""""""Whether to open in a browser after starting.
                        The specific browser used is platform dependent and
                        determined by the python standard library `webbrowser`
                        module, unless it is overridden using the --browser
                        (NotebookApp.browser) configuration option.
                        """""")

    browser = Unicode(u'', config=True,
                      help=""""""Specify what command to use to invoke a web
                      browser when opening the notebook. If not specified, the
                      default browser will be determined by the `webbrowser`
                      standard library module, which allows setting of the
                      BROWSER environment variable to override it.
                      """""")
    
    webapp_settings = Dict(config=True,
        help=""DEPRECATED, use tornado_settings""
    )

    @observe('webapp_settings') 
    def _update_webapp_settings(self, change):
        self.log.warning(""\n    webapp_settings is deprecated, use tornado_settings.\n"")
        self.tornado_settings = change['new']
    
    tornado_settings = Dict(config=True,
            help=""Supply overrides for the tornado.web.Application that the ""
                 ""Jupyter notebook uses."")
    
    terminado_settings = Dict(config=True,
            help='Supply overrides for terminado. Currently only supports ""shell_command"".')

    cookie_options = Dict(config=True,
        help=""Extra keyword arguments to pass to `set_secure_cookie`.""
             "" See tornado's set_secure_cookie docs for details.""
    )
    ssl_options = Dict(config=True,
            help=""""""Supply SSL options for the tornado HTTPServer.
            See the tornado docs for details."""""")
    
    jinja_environment_options = Dict(config=True, 
            help=""Supply extra arguments that will be passed to Jinja environment."")

    jinja_template_vars = Dict(
        config=True,
        help=""Extra variables to supply to jinja templates when rendering."",
    )
    
    enable_mathjax = Bool(True, config=True,
        help=""""""Whether to enable MathJax for typesetting math/TeX

        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
        very large, so you may want to disable it if you have a slow internet
        connection, or for offline use of the notebook.

        When disabled, equations etc. will appear as their untransformed TeX source.
        """"""
    )

    @observe('enable_mathjax')
    def _update_enable_mathjax(self, change):
        """"""set mathjax url to empty if mathjax is disabled""""""
        if not change['new']:
            self.mathjax_url = u''

    base_url = Unicode('/', config=True,
                               help='''The base URL for the notebook server.

                               Leading and trailing slashes can be omitted,
                               and will automatically be added.
                               ''')

    @validate('base_url')
    def _update_base_url(self, proposal):
        value = proposal['value']
        if not value.startswith('/'):
            value = '/' + value
        elif not value.endswith('/'):
            value = value + '/'
        return value
    
    base_project_url = Unicode('/', config=True, help=""""""DEPRECATED use base_url"""""")

    @observe('base_project_url')
    def _update_base_project_url(self, change):
        self.log.warning(""base_project_url is deprecated, use base_url"")
        self.base_url = change['new']

    extra_static_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving static files.
        
        This allows adding javascript/css to be available from the notebook server machine,
        or overriding individual files in the IPython""""""
    )
    
    @property
    def static_file_path(self):
        """"""return extra paths + the default location""""""
        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]
    
    static_custom_path = List(Unicode(),
        help=""""""Path to search for custom.js, css""""""
    )

    @default('static_custom_path')
    def _default_static_custom_path(self):
        return [
            os.path.join(d, 'custom') for d in (
                self.config_dir,
                DEFAULT_STATIC_FILES_PATH)
        ]

    extra_template_paths = List(Unicode(), config=True,
        help=""""""Extra paths to search for serving jinja templates.

        Can be used to override templates from notebook.templates.""""""
    )

    @property
    def template_file_path(self):
        """"""return extra paths + the default locations""""""
        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST

    extra_nbextensions_path = List(Unicode(), config=True,
        help=""""""extra paths to look for Javascript notebook extensions""""""
    )
    
    @property
    def nbextensions_path(self):
        """"""The path to look for Javascript notebook extensions""""""
        path = self.extra_nbextensions_path + jupyter_path('nbextensions')
        # FIXME: remove IPython nbextensions path after a migration period
        try:
            from IPython.paths import get_ipython_dir
        except ImportError:
            pass
        else:
            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))
        return path

    websocket_url = Unicode("""", config=True,
        help=""""""The base URL for websockets,
        if it differs from the HTTP server (hint: it almost certainly doesn't).
        
        Should be in the form of an HTTP origin: ws[s]://hostname[:port]
        """"""
    )

    mathjax_url = Unicode("""", config=True,
        help=""""""A custom url for MathJax.js.
        Should be in the form of a case-sensitive url to MathJax,
        for example:  /static/components/MathJax/MathJax.js
        """"""
    )

    @default('mathjax_url')
    def _default_mathjax_url(self):
        if not self.enable_mathjax:
            return u''
        static_url_prefix = self.tornado_settings.get(""static_url_prefix"", ""static"")
        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')
    
    @observe('mathjax_url')
    def _update_mathjax_url(self, change):
        new = change['new']
        if new and not self.enable_mathjax:
            # enable_mathjax=False overrides mathjax_url
            self.mathjax_url = u''
        else:
            self.log.info(""Using MathJax: %s"", new)

    mathjax_config = Unicode(""TeX-AMS-MML_HTMLorMML-full,Safe"", config=True,
        help=""""""The MathJax.js configuration file that is to be used.""""""
    )

    @observe('mathjax_config')
    def _update_mathjax_config(self, change):
        self.log.info(""Using MathJax configuration file: %s"", change['new'])

    contents_manager_class = Type(
        default_value=FileContentsManager,
        klass=ContentsManager,
        config=True,
        help='The notebook manager class to use.'
    )

    kernel_manager_class = Type(
        default_value=MappingKernelManager,
        config=True,
        help='The kernel manager class to use.'
    )

    session_manager_class = Type(
        default_value=SessionManager,
        config=True,
        help='The session manager class to use.'
    )

    config_manager_class = Type(
        default_value=ConfigManager,
        config = True,
        help='The config manager class to use'
    )

    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)

    kernel_spec_manager_class = Type(
        default_value=KernelSpecManager,
        config=True,
        help=""""""
        The kernel spec manager class to use. Should be a subclass
        of `jupyter_client.kernelspec.KernelSpecManager`.

        The Api of KernelSpecManager is provisional and might change
        without warning between this version of Jupyter and the next stable one.
        """"""
    )

    login_handler_class = Type(
        default_value=LoginHandler,
        klass=web.RequestHandler,
        config=True,
        help='The login handler class to use.',
    )

    logout_handler_class = Type(
        default_value=LogoutHandler,
        klass=web.RequestHandler,
        config=True,
        help='The logout handler class to use.',
    )

    trust_xheaders = Bool(False, config=True,
        help=(""Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers""
              ""sent by the upstream reverse proxy. Necessary if the proxy handles SSL"")
    )

    info_file = Unicode()

    @default('info_file')
    def _default_info_file(self):
        info_file = ""nbserver-%s.json"" % os.getpid()
        return os.path.join(self.runtime_dir, info_file)
    
    pylab = Unicode('disabled', config=True,
        help=""""""
        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
        """"""
    )

    @observe('pylab')
    def _update_pylab(self, change):
        """"""when --pylab is specified, display a warning and exit""""""
        if change['new'] != 'warn':
            backend = ' %s' % change['new']
        else:
            backend = ''
        self.log.error(""Support for specifying --pylab on the command line has been removed."")
        self.log.error(
            ""Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself."".format(backend)
        )
        self.exit(1)

    notebook_dir = Unicode(config=True,
        help=""The directory to use for notebooks and kernels.""
    )

    @default('notebook_dir')
    def _default_notebook_dir(self):
        if self.file_to_run:
            return os.path.dirname(os.path.abspath(self.file_to_run))
        else:
            return py3compat.getcwd()

    @validate('notebook_dir')
    def _notebook_dir_validate(self, proposal):
        value = proposal['value']
        # Strip any trailing slashes
        # *except* if it's root
        _, path = os.path.splitdrive(value)
        if path == os.sep:
            return value
        value = value.rstrip(os.sep)
        if not os.path.isabs(value):
            # If we receive a non-absolute path, make it absolute.
            value = os.path.abspath(value)
        if not os.path.isdir(value):
            raise TraitError(""No such notebook dir: %r"" % value)
        return value

    @observe('notebook_dir')
    def _update_notebook_dir(self, change):
        """"""Do a bit of validation of the notebook dir.""""""
        # setting App.notebook_dir implies setting notebook and kernel dirs as well
        new = change['new']
        self.config.FileContentsManager.root_dir = new
        self.config.MappingKernelManager.root_dir = new

    # TODO: Remove me in notebook 5.0
    server_extensions = List(Unicode(), config=True,
        help=(""DEPRECATED use the nbserver_extensions dict instead"")
    )
    
    @observe('server_extensions')
    def _update_server_extensions(self, change):
        self.log.warning(""server_extensions is deprecated, use nbserver_extensions"")
        self.server_extensions = change['new']
        
    nbserver_extensions = Dict({}, config=True,
        help=(""Dict of Python modules to load as notebook server extensions.""
              ""Entry values can be used to enable and disable the loading of""
              ""the extensions. The extensions will be loaded in alphabetical ""
              ""order."")
    )

    reraise_server_extension_failures = Bool(
        False,
        config=True,
        help=""Reraise exceptions encountered loading server extensions?"",
    )

    iopub_msg_rate_limit = Float(1000, config=True, help=""""""(msgs/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    iopub_data_rate_limit = Float(1000000, config=True, help=""""""(bytes/sec)
        Maximum rate at which messages can be sent on iopub before they are
        limited."""""")

    rate_limit_window = Float(3, config=True, help=""""""(sec) Time window used to 
        check the message and data rate limits."""""")

    def parse_command_line(self, argv=None):
        super(NotebookApp, self).parse_command_line(argv)

        if self.extra_args:
            arg0 = self.extra_args[0]
            f = os.path.abspath(arg0)
            self.argv.remove(arg0)
            if not os.path.exists(f):
                self.log.critical(""No such file or directory: %s"", f)
                self.exit(1)
            
            # Use config here, to ensure that it takes higher priority than
            # anything that comes from the config dirs.
            c = Config()
            if os.path.isdir(f):
                c.NotebookApp.notebook_dir = f
            elif os.path.isfile(f):
                c.NotebookApp.file_to_run = f
            self.update_config(c)

    def init_configurables(self):
        self.kernel_spec_manager = self.kernel_spec_manager_class(
            parent=self,
        )
        self.kernel_manager = self.kernel_manager_class(
            parent=self,
            log=self.log,
            connection_dir=self.runtime_dir,
            kernel_spec_manager=self.kernel_spec_manager,
        )
        self.contents_manager = self.contents_manager_class(
            parent=self,
            log=self.log,
        )
        self.session_manager = self.session_manager_class(
            parent=self,
            log=self.log,
            kernel_manager=self.kernel_manager,
            contents_manager=self.contents_manager,
        )
        self.config_manager = self.config_manager_class(
            parent=self,
            log=self.log,
            config_dir=os.path.join(self.config_dir, 'nbconfig'),
        )

    def init_logging(self):
        # This prevents double log messages because tornado use a root logger that
        # self.log is a child of. The logging module dipatches log messages to a log
        # and all of its ancenstors until propagate is set to False.
        self.log.propagate = False
        
        for log in app_log, access_log, gen_log:
            # consistent log output name (NotebookApp instead of tornado.access, etc.)
            log.name = self.log.name
        # hook up tornado 3's loggers to our app handlers
        logger = logging.getLogger('tornado')
        logger.propagate = True
        logger.parent = self.log
        logger.setLevel(self.log.level)
    
    def init_webapp(self):
        """"""initialize tornado webapp and httpserver""""""
        self.tornado_settings['allow_origin'] = self.allow_origin
        if self.allow_origin_pat:
            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)
        self.tornado_settings['allow_credentials'] = self.allow_credentials
        self.tornado_settings['cookie_options'] = self.cookie_options
        self.tornado_settings['token'] = self.token
        if (self.open_browser or self.file_to_run) and not self.password:
            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')
            self.tornado_settings['one_time_token'] = self.one_time_token

        # ensure default_url starts with base_url
        if not self.default_url.startswith(self.base_url):
            self.default_url = url_path_join(self.base_url, self.default_url)

        if self.password_required and (not self.password):
            self.log.critical(""Notebook servers are configured to only be run with a password."")
            self.log.critical(""Hint: run the following command to set a password"")
            self.log.critical(""\t$ python -m notebook.auth password"")
            sys.exit(1)

        self.web_app = NotebookWebApplication(
            self, self.kernel_manager, self.contents_manager,
            self.session_manager, self.kernel_spec_manager,
            self.config_manager,
            self.log, self.base_url, self.default_url, self.tornado_settings,
            self.jinja_environment_options
        )
        ssl_options = self.ssl_options
        if self.certfile:
            ssl_options['certfile'] = self.certfile
        if self.keyfile:
            ssl_options['keyfile'] = self.keyfile
        if self.client_ca:
            ssl_options['ca_certs'] = self.client_ca
        if not ssl_options:
            # None indicates no SSL config
            ssl_options = None
        else:
            # SSL may be missing, so only import it if it's to be used
            import ssl
            # Disable SSLv3 by default, since its use is discouraged.
            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)
            if ssl_options.get('ca_certs', False):
                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)
        
        self.login_handler_class.validate_security(self, ssl_options=ssl_options)
        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,
                                                 xheaders=self.trust_xheaders)

        success = None
        for port in random_ports(self.port, self.port_retries+1):
            try:
                self.http_server.listen(port, self.ip)
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    self.log.info('The port %i is already in use, trying another port.' % port)
                    continue
                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):
                    self.log.warning(""Permission to listen on port %i denied"" % port)
                    continue
                else:
                    raise
            else:
                self.port = port
                success = True
                break
        if not success:
            self.log.critical('ERROR: the notebook server could not be started because '
                              'no available port could be found.')
            self.exit(1)
    
    @property
    def display_url(self):
        ip = self.ip if self.ip else '[all ip addresses on your system]'
        url = self._url(ip)
        if self.token:
            # Don't log full token if it came from config
            token = self.token if self._token_generated else '...'
            url = url_concat(url, {'token': token})
        return url

    @property
    def connection_url(self):
        ip = self.ip if self.ip else 'localhost'
        return self._url(ip)

    def _url(self, ip):
        proto = 'https' if self.certfile else 'http'
        return ""%s://%s:%i%s"" % (proto, ip, self.port, self.base_url)

    def init_terminals(self):
        try:
            from .terminal import initialize
            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)
            self.web_app.settings['terminals_available'] = True
        except ImportError as e:
            log = self.log.debug if sys.platform == 'win32' else self.log.warning
            log(""Terminals not available (error was %s)"", e)

    def init_signal(self):
        if not sys.platform.startswith('win') and sys.stdin.isatty():
            signal.signal(signal.SIGINT, self._handle_sigint)
        signal.signal(signal.SIGTERM, self._signal_stop)
        if hasattr(signal, 'SIGUSR1'):
            # Windows doesn't support SIGUSR1
            signal.signal(signal.SIGUSR1, self._signal_info)
        if hasattr(signal, 'SIGINFO'):
            # only on BSD-based systems
            signal.signal(signal.SIGINFO, self._signal_info)
    
    def _handle_sigint(self, sig, frame):
        """"""SIGINT handler spawns confirmation dialog""""""
        # register more forceful signal handler for ^C^C case
        signal.signal(signal.SIGINT, self._signal_stop)
        # request confirmation dialog in bg thread, to avoid
        # blocking the App
        thread = threading.Thread(target=self._confirm_exit)
        thread.daemon = True
        thread.start()
    
    def _restore_sigint_handler(self):
        """"""callback for restoring original SIGINT handler""""""
        signal.signal(signal.SIGINT, self._handle_sigint)
    
    def _confirm_exit(self):
        """"""confirm shutdown on ^C
        
        A second ^C, or answering 'y' within 5s will cause shutdown,
        otherwise original SIGINT handler will be restored.
        
        This doesn't work on Windows.
        """"""
        info = self.log.info
        info('interrupted')
        print(self.notebook_info())
        sys.stdout.write(""Shutdown this notebook server (y/[n])? "")
        sys.stdout.flush()
        r,w,x = select.select([sys.stdin], [], [], 5)
        if r:
            line = sys.stdin.readline()
            if line.lower().startswith('y') and 'n' not in line.lower():
                self.log.critical(""Shutdown confirmed"")
                ioloop.IOLoop.current().stop()
                return
        else:
            print(""No answer for 5s:"", end=' ')
        print(""resuming operation..."")
        # no answer, or answer is no:
        # set it back to original SIGINT handler
        # use IOLoop.add_callback because signal.signal must be called
        # from main thread
        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)
    
    def _signal_stop(self, sig, frame):
        self.log.critical(""received signal %s, stopping"", sig)
        ioloop.IOLoop.current().stop()

    def _signal_info(self, sig, frame):
        print(self.notebook_info())
    
    def init_components(self):
        """"""Check the components submodule, and warn if it's unclean""""""
        # TODO: this should still check, but now we use bower, not git submodule
        pass

    def init_server_extensions(self):
        """"""Load any extensions specified by config.

        Import the module, then call the load_jupyter_server_extension function,
        if one exists.
        
        The extension API is experimental, and may change in future releases.
        """"""
        
        # TODO: Remove me in notebook 5.0
        for modulename in self.server_extensions:
            # Don't override disable state of the extension if it already exist
            # in the new traitlet
            if not modulename in self.nbserver_extensions:
                self.nbserver_extensions[modulename] = True
        
        for modulename in sorted(self.nbserver_extensions):
            if self.nbserver_extensions[modulename]:
                try:
                    mod = importlib.import_module(modulename)
                    func = getattr(mod, 'load_jupyter_server_extension', None)
                    if func is not None:
                        func(self)
                except Exception:
                    if self.reraise_server_extension_failures:
                        raise
                    self.log.warning(""Error loading server extension %s"", modulename,
                                  exc_info=True)

    def init_mime_overrides(self):
        # On some Windows machines, an application has registered an incorrect
        # mimetype for CSS in the registry. Tornado uses this when serving
        # .css files, causing browsers to reject the stylesheet. We know the
        # mimetype always needs to be text/css, so we override it here.
        mimetypes.add_type('text/css', '.css')

    @catch_config_error
    def initialize(self, argv=None):
        super(NotebookApp, self).initialize(argv)
        self.init_logging()
        if self._dispatching:
            return
        self.init_configurables()
        self.init_components()
        self.init_webapp()
        self.init_terminals()
        self.init_signal()
        self.init_server_extensions()
        self.init_mime_overrides()

    def cleanup_kernels(self):
        """"""Shutdown all kernels.
        
        The kernels will shutdown themselves when this process no longer exists,
        but explicit shutdown allows the KernelManagers to cleanup the connection files.
        """"""
        self.log.info('Shutting down kernels')
        self.kernel_manager.shutdown_all()

    def notebook_info(self):
        ""Return the current working directory and the server url information""
        info = self.contents_manager.info_string() + ""\n""
        info += ""%d active kernels \n"" % len(self.kernel_manager._kernels)
        return info + ""The Jupyter Notebook is running at: %s"" % self.display_url

    def server_info(self):
        """"""Return a JSONable dict of information about this server.""""""
        return {'url': self.connection_url,
                'hostname': self.ip if self.ip else 'localhost',
                'port': self.port,
                'secure': bool(self.certfile),
                'base_url': self.base_url,
                'token': self.token,
                'notebook_dir': os.path.abspath(self.notebook_dir),
                'password': bool(self.password),
                'pid': os.getpid(),
               }

    def write_server_info_file(self):
        """"""Write the result of server_info() to the JSON file info_file.""""""
        with open(self.info_file, 'w') as f:
            json.dump(self.server_info(), f, indent=2, sort_keys=True)

    def remove_server_info_file(self):
        """"""Remove the nbserver-<pid>.json file created for this server.
        
        Ignores the error raised when the file has already been removed.
        """"""
        try:
            os.unlink(self.info_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def start(self):
        """""" Start the Notebook server app, after initialization
        
        This method takes no arguments so all configuration and initialization
        must be done prior to calling this method.""""""

        if not self.allow_root:
            # check if we are running as root, and abort if it's not allowed
            try:
                uid = os.geteuid()
            except AttributeError:
                uid = -1 # anything nonzero here, since we can't check UID assume non-root
            if uid == 0:
                self.log.critical(""Running as root is not recommended. Use --allow-root to bypass."")
                self.exit(1)

        super(NotebookApp, self).start()

        info = self.log.info
        for line in self.notebook_info().split(""\n""):
            info(line)
        info(""Use Control-C to stop this server and shut down all kernels (twice to skip confirmation)."")

        self.write_server_info_file()

        if self.open_browser or self.file_to_run:
            try:
                browser = webbrowser.get(self.browser or None)
            except webbrowser.Error as e:
                self.log.warning('No web browser found: %s.' % e)
                browser = None
            
            if self.file_to_run:
                if not os.path.exists(self.file_to_run):
                    self.log.critical(""%s does not exist"" % self.file_to_run)
                    self.exit(1)

                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)
                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))
            else:
                # default_url contains base_url, but so does connection_url
                uri = self.default_url[len(self.base_url):]
            if self.one_time_token:
                uri = url_concat(uri, {'token': self.one_time_token})
            if browser:
                b = lambda : browser.open(url_path_join(self.connection_url, uri),
                                          new=2)
                threading.Thread(target=b).start()

        if self.token and self._token_generated:
            # log full URL with generated token, so there's a copy/pasteable link
            # with auth info.
            self.log.critical('\n'.join([
                '\n',
                'Copy/paste this URL into your browser when you connect for the first time,',
                'to login with a token:',
                '    %s' % url_concat(self.connection_url, {'token': self.token}),
            ]))

        self.io_loop = ioloop.IOLoop.current()
        if sys.platform.startswith('win'):
            # add no-op to wake every 5s
            # to handle signals that may be ignored by the inner loop
            pc = ioloop.PeriodicCallback(lambda : None, 5000)
            pc.start()
        try:
            self.io_loop.start()
        except KeyboardInterrupt:
            info(""Interrupted..."")
        finally:
            self.remove_server_info_file()
            self.cleanup_kernels()

    def stop(self):
        def _stop():
            self.http_server.stop()
            self.io_loop.stop()
        self.io_loop.add_callback(_stop)


def list_running_servers(runtime_dir=None):
    """"""Iterate over the server info files of running notebook servers.
    
    Given a runtime directory, find nbserver-* files in the security directory,
    and yield dicts of their information, each one pertaining to
    a currently running notebook server instance.
    """"""
    if runtime_dir is None:
        runtime_dir = jupyter_runtime_dir()

    # The runtime dir might not exist
    if not os.path.isdir(runtime_dir):
        return

    for file in os.listdir(runtime_dir):
        if file.startswith('nbserver-'):
            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:
                info = json.load(f)

            # Simple check whether that process is really still running
            # Also remove leftover files from IPython 2.x without a pid field
            if ('pid' in info) and check_pid(info['pid']):
                yield info
            else:
                # If the process has died, try to delete its info file
                try:
                    os.unlink(os.path.join(runtime_dir, file))
                except OSError:
                    pass  # TODO: This should warn or log or something
#-----------------------------------------------------------------------------
# Main entry point
#-----------------------------------------------------------------------------

main = launch_new_instance = NotebookApp.launch_instance
/n/n/n",0
63,63,d6f091c4439c174c7700776c0cee03053403f600,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
22,22,047c9683b31aef990531ccd084962ddb25e88be5,"app/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""URL routing module.""""""

from django.conf import urls

import site_settings
import views.admin.statistics

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [('admin-statistics', r'global/admin/statistics/?',
                       views.admin.statistics.AdminStatisticsView.as_view)]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^%s$' % path_exp, view_func(), name=name)
    for (name, path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^%(prefix)s/%(path)s$' % {
                'prefix': site_settings.OPTIONAL_PATH_PREFIX,
                'path': path_exp
            },
            view_func(),
            name='prefixed:%s' % name)
        for (name, path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/napp/views/admin/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Code shared by admin view modules.""""""

import django.shortcuts
from google.appengine.api import users

import model
import utils
import views.base


class AdminBaseView(views.base.BaseView):
    """"""Base view for admin views.""""""

    _POST_PARAMETERS = {
        'xsrf_token': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        super(AdminBaseView, self).setup(request, *args, **kwargs)
        self.read_params(post_params=AdminBaseView._POST_PARAMETERS)
        self.env.show_logo = True
        self.env.enable_javascript = True
        self.env.user = users.get_current_user()
        self.env.logout_url = users.create_logout_url(self.build_absolute_uri())
        self.env.all_repo_options = [
            utils.Struct(
                repo=repo, url=self.build_absolute_path('/%s/admin' % repo))
            for repo in sorted(model.Repo.list())
        ]

    def dispatch(self, request, *args, **kwargs):
        # All the admin pages, and only the admin pages, require the user to be
        # logged in as an admin.
        # If we start requiring login for other pages, we should consider
        # refactoring this into a decorator or something like that.
        if not self.env.user:
            return django.shortcuts.redirect(
                users.create_login_url(self.build_absolute_uri()))
        if not users.is_current_user_admin():
            logout_url = users.create_logout_url(self.build_absolute_uri())
            return self.render(
                'not_admin_error.html',
                status_code=403,
                logout_url=logout_url,
                user=self.env.user)
        return super(AdminBaseView, self).dispatch(request, args, kwargs)
/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    _GET_PARAMETERS = {
        'lang': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = utils.Struct()
        self.read_params(get_params=BaseView._GET_PARAMETERS)

        # Set up env variable with data needed by the whole app.
        self.env = utils.Struct()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def read_params(self, get_params=None, post_params=None, file_params=None):
        """"""Reads CGI parameter values into self.params.

        Args:
            get_params (dict): A dictionary from GET parameter keys to validator
                functions.
            post_params (dict): A dictionary from POST parameter keys to
                validator functions.
            file_params (dict): A dictionary from POST parameter keys for
                uploaded files to validator functions.
        """"""
        if self.request.method == 'GET':
            if get_params:
                for key, validator in get_params.items():
                    if key in self.request.GET:
                        setattr(self.params, key,
                                validator(self.request.GET[key]))
        else:
            if post_params:
                for key, validator in post_params.items():
                    if key in self.request.POST:
                        setattr(self.params, key,
                                validator(self.request.POST[key]))
            if file_params:
                for key, validator in file_params.items():
                    if key in self.request.FILES:
                        setattr(self.params, key,
                                validator(self.request.FILES[key]))

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, status_code=200, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0),
            status=status_code)

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import django.urls

import urls
import views

import django_tests_base


class AccessRestrictionTests(django_tests_base.DjangoTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin-statistics': True,
    }

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = django.urls.reverse(path_name)
            assert self.client.get(path).status_code == 403
            assert self.client.post(path).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = django.urls.reverse(path_name)
            assert self.client.get(path).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = django.urls.reverse(path_name)
            assert self.client.get(path).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed:'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/n",0
23,23,047c9683b31aef990531ccd084962ddb25e88be5,"/app/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""URL routing module.""""""

from django.conf import urls

import site_settings
import views.admin.statistics

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [(r'global/admin/statistics/?',
                       views.admin.statistics.AdminStatisticsView.as_view)]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^(%s)$' % path_exp, view_func())
    for (path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^(%s)/(%s)$' % (site_settings.OPTIONAL_PATH_PREFIX, path_exp),
            view_func()) for (path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/n/app/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    _GET_PARAMETERS = {
        'lang': utils.strip,
    }

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = utils.Struct()
        self.read_params(get_params=BaseView._GET_PARAMETERS)

        # Set up env variable with data needed by the whole app.
        self.env = utils.Struct()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def read_params(self, get_params=None, post_params=None, file_params=None):
        """"""Reads CGI parameter values into self.params.

        Args:
            get_params (dict): A dictionary from GET parameter keys to validator
                functions.
            post_params (dict): A dictionary from POST parameter keys to
                validator functions.
            file_params (dict): A dictionary from POST parameter keys for
                uploaded files to validator functions.
        """"""
        if self.request.method == 'GET':
            if get_params:
                for key, validator in get_params.items():
                    if key in self.request.GET:
                        setattr(self.params, key,
                                validator(self.request.GET[key]))
        else:
            if post_params:
                for key, validator in post_params.items():
                    if key in self.request.POST:
                        setattr(self.params, key,
                                validator(self.request.POST[key]))
            if file_params:
                for key, validator in file_params.items():
                    if key in self.request.FILES:
                        setattr(self.params, key,
                                validator(self.request.FILES[key]))

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0))

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view
/n/n/n",1
86,86,2b70b391b0792c90ed71fd23ab36a6b7c60fb1e5,"src/veil/backend/redis/client/client.py/n/nfrom __future__ import unicode_literals, print_function, division, absolute_import
from redis.client import Redis
from logging import getLogger
from veil.environment.setting import *
from veil.development.test import *

LOGGER = getLogger(__name__)

registry = {} # purpose => get_redis_options
instances = {} # purpose => instance (a.k.a Redis class instance)

def register_redis(purpose):
    if purpose not in registry:
        registry[purpose] = register_redis_options(purpose)
    return lambda: require_redis(purpose)


def register_redis_options(purpose):
    section = '{}_redis'.format(purpose) # for example cache_redis
    get_redis_host = register_option(section, 'host')
    get_redis_port = register_option(section, 'port', int)
    get_redis_password = register_option(section, 'password')

    def get_redis_options():
        return {
            'host': get_redis_host(),
            'port': get_redis_port(),
            'password': get_redis_password()
        }

    return get_redis_options


def require_redis(purpose):
    if purpose not in registry:
        raise Exception('redis for purpose {} is not registered'.format(purpose))
    if purpose not in instances:
        get_redis_options = registry[purpose]
        instances[purpose] = Redis(**get_redis_options())
    executing_test = get_executing_test(optional=True)
    if executing_test:
        executing_test.addCleanup(lambda :instances[purpose].flushall())
    return instances[purpose]
/n/n/nsrc/veil/development/browser/browser.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import threading
import time
import traceback
import lxml.html
import os.path
import spynner
import selenium.webdriver
import os
from veil.utility.path import *
from veil.development.test import *
from veil.profile.web import *
from veil.frontend.web.static_file import *

LOGGER = logging.getLogger(__name__)
latest_page = None

def start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):
    @route('POST', '/-test/stop', website=website)
    def stop_test():
        stop_browser()

    @route('POST', '/-test/fail', website=website)
    def fail_test():
        message = get_http_argument('message')
        LOGGER.error(message)
        get_executing_test().error = message

    @route('POST', '/-test/log', website=website)
    def log_from_test():
        LOGGER.info(get_http_argument('message'))

    @route('GET', '/-test/veil-test.js', website=website)
    def veil_test_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil-test.js').text()

    @route('GET', '/-test/jquery.js', website=website)
    def jquery_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery.js').text()

    @route('GET', '/-test/jquery-cookie.js', website=website)
    def jquery_cookie_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()

    @route('GET', '/-test/veil.js', website=website)
    def veil_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil.js').text()

    page_interactions = list(reversed(page_interactions))
    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))
    http_server = start_test_website(website)
    domain = get_website_option(website, 'domain')
    if domain:
        url = 'http://{}{}'.format(domain, path)
    else:
        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)
    threading.Thread(target=lambda: execute_io_loop(timeout)).start()
    start_browser(url, browser)


def execute_io_loop(timeout):
    get_executing_test().addCleanup(require_io_loop_executor().stop)
    try:
        require_io_loop_executor().execute(timeout=timeout)
    except:
        get_executing_test().error = traceback.format_exc()
        raise


def start_browser(url, browser_type):
    if os.getenv('VEIL_REMOTE_BROWSER'):
        browser_type = 'remote'
    get_executing_test().browser_type = browser_type
    test = get_executing_test()
    test.addCleanup(stop_browser)
    if 'spynner' == browser_type:
        start_spynner_browser(url)
    elif 'chrome' == browser_type:
        start_chrome_browser(url)
    elif 'remote' == browser_type:
        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))
        start_remote_browser(url, command_executor)
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def start_spynner_browser(url, visible=False):
    test = get_executing_test()
    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)
    if visible:
        test.spynner_browser.show(maximized=False)
    try:
        test.spynner_browser.load(url)
    except:
        pass
    while test.spynner_browser:
        try:
            test.spynner_browser._events_loop()
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_chrome_browser(url):
    test = get_executing_test()
    old_cwd = os.getcwd()
    os.chdir('/tmp')
    test.webdriver = selenium.webdriver.Chrome()
    os.chdir(old_cwd)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_remote_browser(url, command_executor):
    test = get_executing_test()
    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER
    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def check_is_test_failed(test):
    message = getattr(test, 'error', None)
    if message is not None:
        stop_browser()
        LOGGER.info('Latest page: {}'.format(latest_page))
        test.fail(message)


def stop_browser():
    test = get_executing_test()
    if 'spynner' == test.browser_type:
        stop_spynner_browser()
    elif test.browser_type in ['chrome', 'remote']:
        stop_webdriver()
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def stop_spynner_browser():
    test = get_executing_test()
    browser = test.spynner_browser
    if browser:
        test.spynner_browser = None
        browser.close()


def stop_webdriver():
    test = get_executing_test()
    webdriver = getattr(test, 'webdriver', None)
    if webdriver:
        test.webdriver = None
        webdriver.close()


def inject_page_interaction(html, page_interactions):
    global latest_page
    request = get_current_http_request()
    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):
        return html
    if request.path.startswith('/-test/'):
        return html
    if not page_interactions:
        return html
    fragment = lxml.html.document_fromstring(html)
    script = fragment.makeelement(
        'script', attrib={
            'type': 'text/javascript',
            'src': '/-test/veil-test.js'
        })
    fragment.find('body').append(script)
    script = fragment.makeelement(
        'script', attrib={'type': 'text/javascript'})
    script.text =\
    """"""
    $(document).ready(function() {
        %s
    });
    """""" % page_interactions.pop()
    fragment.find('body').append(script)
    latest_page = open_closed_tags(lxml.html.tostring(fragment, method='xml'))
    return latest_page/n/n/nsrc/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division
import contextlib
import httplib
import uuid
from logging import getLogger
from markupsafe import Markup
from veil.frontend.template import template_utility
from veil.frontend.web.tornado import *
from tornado.escape import xhtml_escape

LOGGER = getLogger(__name__)

@contextlib.contextmanager
def prevent_xsrf():
    request = get_current_http_request()
    response = get_current_http_response()
    if not hasattr(request, '_xsrf_token'):
        token = get_cookie(name='_xsrf', request=request)
        if not token:
            token = uuid.uuid4().get_hex()
            LOGGER.debug('assign XSRF token {} from {} {}'.format(token, request.method, request.path))
        request._xsrf_token = token
    if 'GET' != request.method.upper():
        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)
        if not token:
            response.status_code = httplib.FORBIDDEN
            LOGGER.warn('XSRF token missing, request: {}'.format(request))
            raise HTTPError(403, 'XSRF token missing')
        expected_token = xsrf_token()
        if expected_token != token:
            LOGGER.debug('expected token: {}'.format(expected_token))
            LOGGER.debug('actual token: {}'.format(token))
            LOGGER.warn('XSRF token invalid, request: {}'.format(request))
            raise HTTPError(403, 'XSRF token invalid')
    request.arguments.pop('_xsrf', None)
    yield


@template_utility
def xsrf_token(request=None):
    request = request or get_current_http_request()
    assert request._xsrf_token is not None
    return request._xsrf_token


@template_utility
def xsrf_field():
    return Markup('<input type=""hidden"" name=""_xsrf"" value=""{}""/>'.format(xhtml_escape(xsrf_token())))/n/n/nsrc/veil/model/binding/__init__.py/n/nimport veil.component

with veil.component.init_component(__name__):
    from .invalid import Invalid
    from .field_binder import not_empty
    from .field_binder import one_of
    from .field_binder import clamp_length
    from .field_binder import clamp
    from .field_binder import not_duplicate
    from .field_binder import anything
    from .field_binder import is_not
    from .field_binder import is_email
    from .field_binder import is_mobile
    from .field_binder import is_landline
    from .field_binder import is_list
    from .field_binder import to_integer
    from .field_binder import to_float
    from .field_binder import to_bool
    from .field_binder import to_date
    from .field_binder import to_time
    from .field_binder import to_datetime
    from .field_binder import to_datetime_via_parse
    from .field_binder import to_datetime_with_minute_precision_from_iso8601
    from .field_binder import to_timezone
    from .binder_maker import each
    from .binder_maker import optional
    from .object_binder import ObjectBinder

    __all__ = [
        # from invalid
        Invalid.__name__,
        # from field_binder
        not_empty.__name__,
        one_of.__name__,
        clamp_length.__name__,
        clamp.__name__,
        not_duplicate.__name__,
        anything.__name__,
        is_not.__name__,
        is_email.__name__,
        is_mobile.__name__,
        is_landline.__name__,
        is_list.__name__,
        to_integer.__name__,
        to_float.__name__,
        to_bool.__name__,
        to_date.__name__,
        to_time.__name__,
        to_datetime.__name__,
        to_datetime_via_parse.__name__,
        to_datetime_with_minute_precision_from_iso8601.__name__,
        to_timezone.__name__,
        # from binder_maker
        each.__name__,
        optional.__name__,
        # from object_binder
        ObjectBinder.__name__
    ]
/n/n/nsrc/veil/model/binding/field_binder.py/n/n# -*- coding: utf-8 -*-
""""""
field binder takes single value and returns transformed single value in expected case
otherwise throw Invalid exception
""""""
from __future__ import unicode_literals, print_function, division
import re
from datetime import datetime, time
import pytz
from pytz import timezone, UnknownTimeZoneError
from dateutil.parser import parse
from veil.model.binding.invalid import Invalid


_EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9_=%.+-]+@([a-zA-Z0-9_=%+-]+\.)+[a-zA-Z]{2,6}$')

# reference to http://www.cnfgg.com/article/Asp/Asp_phoneCheck.htm
_MOBILE_PATTERN = re.compile(r'^0?1[3458]\d{9}$')
_LANDLIINE_PATTERN = re.compile(r'^(\d{2,4}[-.\s_]?)?\d{3,8}([-.\s_]?\d{3,8})?([-.\s_]?\d{1,7})?$')


def anything(value):
    return value


def is_not(v):
    def bind(value):
        if value == bind.v:
            raise Invalid('{}{}'.format(_(''), bind.v))
        return value
    bind.v = v
    return bind


def not_empty(value):
    if value is not None and value != '':
        return value
    raise Invalid(_(''))


def is_list(value):
    if isinstance(value, (list, tuple)):
        return value
    raise Invalid(_(''))


def one_of(seq):
    assert seq is not None
    def bind(value):
        if value not in bind.seq:
            raise Invalid(_(''))
        return value
    bind.seq = seq
    return bind


def is_email(value):
    if _EMAIL_PATTERN.match(value) is None:
        raise Invalid(_(''))
    return value


def is_mobile(value):
    if _MOBILE_PATTERN.match(value) is None:
        raise Invalid(_(''))
    return value


def is_landline(value):
    if _LANDLIINE_PATTERN.match(value) is None:
        raise Invalid(_(''))
    return value


def to_integer(value):
    try:
        return int(value)
    except (TypeError, ValueError):
        raise Invalid(_(''))


def to_float(value):
    try:
        return float(value)
    except (TypeError, ValueError):
        raise Invalid(_(''))


def to_bool(value):
    if value in ['0', 'false', 'False']:
        return False
    return bool(value)


def to_time(value):
    try:
        dt = datetime.strptime(value, '%I:%M %p')
    except ValueError:
        raise Invalid(_(''))
    else:
        return time(dt.hour, dt.minute)


def to_date(format='%Y-%m-%d'):
    def bind(value):
        if isinstance(value, datetime):
            return value.date()
        try:
            dt = datetime.strptime(value, bind.format)
        except ValueError:
            raise Invalid(_(''))
        else:
            return dt.date()
    bind.format = format
    return bind


def to_datetime_via_parse(value):
    try:
        return parse(value, yearfirst=True)
    except ValueError:
        raise Invalid(_(''))


def to_datetime(format='%Y-%m-%d %H:%M:%S'):
    def bind(value):
        if isinstance(value, datetime):
            return value
        else:
            try:
                return datetime.strptime(value, bind.format)
            except ValueError:
                raise Invalid(_(''))
    bind.format = format
    return bind


ISO8601_REGEX = re.compile(r'(?P<year>[0-9]{4})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2}) (?P<hour>[0-9]{2}):(?P<minute>[0-9]{2}) ?(?P<prefix>[+-])(?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})')

def to_datetime_with_minute_precision_from_iso8601(value):
    """"""
    Valid formats:
        YYYY-MM-DD hh:mm hh:mm
        YYYY-MM-DD hh:mm hhmm
        YYYY-MM-DD hh:mmhhmm
    """"""
    try:
        m = ISO8601_REGEX.match(value)
        if not m:
            raise Exception('Unable to parse date string %r' % value)
        groups = m.groupdict()
        hours, minutes = int(groups['hours']), int(groups['minutes'])
        if groups['prefix'] == '-':
            hours = -hours
            minutes = -minutes
        tz = pytz.FixedOffset(hours * 60 + minutes)
        return datetime(int(groups['year']), int(groups['month']), int(groups['day']), int(groups['hour']),
            int(groups['minute']), tzinfo=tz)
    except:
        raise Invalid(_(''))


def to_timezone(value):
    try:
        return timezone(value)
    except UnknownTimeZoneError:
        raise Invalid(_(''))


def clamp_length(min=None, max=None):
    """"""
    clamp a value between minimum and maximum lengths (either
    of which are optional).
    """"""
    def bind(value):
        value_length = len(value)
        if bind.min is not None and value_length < bind.min:
            raise Invalid(_(''))
        if bind.max is not None and value_length > bind.max:
            raise Invalid(_(''))
        return value
    bind.min = min
    bind.max = max
    return bind

def clamp(min=None, max=None):
    """"""
    clamp a value between minimum and maximum lengths (either
    of which are optional).
    """"""
    def bind(value):
        if bind.min is not None and value < bind.min:
            raise Invalid(_(''))
        if bind.max is not None and value > bind.max:
            raise Invalid(_(''))
        return value
    bind.min = min
    bind.max = max
    return bind


def not_duplicate(value):
    if len(set(value)) != len(value):
        raise Invalid(_(''))
    return value/n/n/n",0
87,87,2b70b391b0792c90ed71fd23ab36a6b7c60fb1e5,"/src/veil/development/browser/browser.py/n/nfrom __future__ import unicode_literals, print_function, division
import logging
import threading
import time
import traceback
import lxml.html
import os.path
import spynner
import selenium.webdriver
import os
from veil.utility.path import *
from veil.development.test import *
from veil.profile.web import *
from veil.frontend.web.static_file import *

LOGGER = logging.getLogger(__name__)

def start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):
    @route('POST', '/-test/stop', website=website)
    def stop_test():
        stop_browser()

    @route('POST', '/-test/fail', website=website)
    def fail_test():
        message = get_http_argument('message')
        LOGGER.error(message)
        get_executing_test().error = message

    @route('POST', '/-test/log', website=website)
    def log_from_test():
        LOGGER.info(get_http_argument('message'))

    @route('GET', '/-test/veil-test.js', website=website)
    def veil_test_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil-test.js').text()

    @route('GET', '/-test/jquery.js', website=website)
    def jquery_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery.js').text()

    @route('GET', '/-test/jquery-cookie.js', website=website)
    def jquery_cookie_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()

    @route('GET', '/-test/veil.js', website=website)
    def veil_js():
        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')
        return (as_path(__file__).dirname() / 'veil.js').text()

    page_interactions = list(reversed(page_interactions))
    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))
    http_server = start_test_website(website)
    domain = get_website_option(website, 'domain')
    if domain:
        url = 'http://{}{}'.format(domain, path)
    else:
        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)
    threading.Thread(target=lambda: execute_io_loop(timeout)).start()
    start_browser(url, browser)


def execute_io_loop(timeout):
    get_executing_test().addCleanup(require_io_loop_executor().stop)
    try:
        require_io_loop_executor().execute(timeout=timeout)
    except:
        get_executing_test().error = traceback.format_exc()
        raise


def start_browser(url, browser_type):
    if os.getenv('VEIL_REMOTE_BROWSER'):
        browser_type = 'remote'
    get_executing_test().browser_type = browser_type
    test = get_executing_test()
    test.addCleanup(stop_browser)
    if 'spynner' == browser_type:
        start_spynner_browser(url)
    elif 'chrome' == browser_type:
        start_chrome_browser(url)
    elif 'remote' == browser_type:
        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))
        start_remote_browser(url, command_executor)
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def start_spynner_browser(url, visible=False):
    test = get_executing_test()
    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)
    if visible:
        test.spynner_browser.show(maximized=False)
    try:
        test.spynner_browser.load(url)
    except:
        pass
    while test.spynner_browser:
        try:
            test.spynner_browser._events_loop()
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_chrome_browser(url):
    test = get_executing_test()
    old_cwd = os.getcwd()
    os.chdir('/tmp')
    test.webdriver = selenium.webdriver.Chrome()
    os.chdir(old_cwd)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def start_remote_browser(url, command_executor):
    test = get_executing_test()
    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER
    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)
    test.webdriver.get(url)
    while test.webdriver:
        try:
            time.sleep(0.1)
        except KeyboardInterrupt:
            test.error = 'keyboard interrupt'
        check_is_test_failed(test)


def check_is_test_failed(test):
    message = getattr(test, 'error', None)
    if message is not None:
        stop_browser()
        test.fail(message)


def stop_browser():
    test = get_executing_test()
    if 'spynner' == test.browser_type:
        stop_spynner_browser()
    elif test.browser_type in ['chrome', 'remote']:
        stop_webdriver()
    else:
        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))


def stop_spynner_browser():
    test = get_executing_test()
    browser = test.spynner_browser
    if browser:
        test.spynner_browser = None
        browser.close()


def stop_webdriver():
    test = get_executing_test()
    webdriver = getattr(test, 'webdriver', None)
    if webdriver:
        test.webdriver = None
        webdriver.close()


def inject_page_interaction(html, page_interactions):
    request = get_current_http_request()
    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):
        return html
    if request.path.startswith('/-test/'):
        return html
    if not page_interactions:
        return html
    fragment = lxml.html.document_fromstring(html)
    script = fragment.makeelement(
        'script', attrib={
            'type': 'text/javascript',
            'src': '/-test/veil-test.js'
        })
    fragment.find('body').append(script)
    script = fragment.makeelement(
        'script', attrib={'type': 'text/javascript'})
    script.text =\
    """"""
    $(document).ready(function() {
        %s
    });
    """""" % page_interactions.pop()
    fragment.find('body').append(script)
    return open_closed_tags(lxml.html.tostring(fragment, method='xml'))/n/n/n",1
50,50,85094ff8caac585cbff260fe89a6f21df241fd47,"service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = xsrf_token or request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",0
51,51,85094ff8caac585cbff260fe89a6f21df241fd47,"/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.sandbox_resource import SandboxResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

from pixelated.resources.users import UsersResource

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            if self._mode == MODE_RUNNING:
                return self._child_resources.get(path)
            else:
                return UnavailableResource()
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self._child_resources.add('sandbox', SandboxResource(self._static_folder))
        self._child_resources.add('assets', File(self._static_folder))
        self._child_resources.add('keys', KeysResource(self._services_factory))
        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self._child_resources.add('contacts', ContactsResource(self._services_factory))
        self._child_resources.add('features', FeaturesResource(portal))
        self._child_resources.add('tags', TagsResource(self._services_factory))
        self._child_resources.add('mails', MailsResource(self._services_factory))
        self._child_resources.add('mail', MailResource(self._services_factory))
        self._child_resources.add('feedback', FeedbackResource(self._services_factory))
        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self._child_resources.add('users', UsersResource(self._services_factory))
        self._child_resources.add(LoginResource.BASE_URL,
                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/n",1
66,66,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
67,67,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
0,0,59fdbf02dac752fd22cb87eb4bea59d599b333dd,"grab-monorail.py/n/n#!/usr/bin/env python3
import argparse
import glob
import logging
import os
import re
import requests
import subprocess
import sys

OSS_FUZZ_BUGURL = ""https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=""
DOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='

testcase_pattern = re.compile(r'https://oss-fuzz\.com/testcase\?key=(\d+)')
proto_pattern = r'\\nFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\\n'

parser = argparse.ArgumentParser()
parser.add_argument(""--debug"", action=""store_true"", help=""Enable verbose logging"")
parser.add_argument(""--cookie-file"", ""-c"", help=""File containing cookie value"")

# Pass through options
reporter_params = [
    (""report"", None),
    (""timeout"", int),
    (""memlimit"", int),
    (""memleaks"", None),
]
for name, arg_type in reporter_params:
    args = [""--"" + name]
    kwargs = {}
    if arg_type:
        kwargs[""type""] = arg_type
    else:
        kwargs[""action""] = ""store_true""
    kwargs[""default""] = None
    kwargs[""help""] = ""Option is passed to the reporter""
    parser.add_argument(*args, **kwargs)
parser.add_argument(""--reporter-args"", ""-r"", help=""Options to pass through"")


parser.add_argument(""issue_id"", type=int)
args = parser.parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG)

def fatal(*args):
    logging.error(*args)
    sys.exit(1)

def parse_cookies(text):
    cookies = {}
    for m in re.finditer(r'(SACSID)\s+(~[0-9a-zA-Z_-]+)\s+([a-z.-]+)(?:\s|$)', text):
        key, value, domain = m.groups()
        cookies[domain] = (key, value)
    # compatibility with Netscape cookie jar
    garbage = r'(?:TRUE|FALSE)\s+/\s+(?:TRUE|FALSE)\s+\d+\s+'
    cj_pattern = r'([a-z.-]+)\s+' + garbage + r'(SACSID)\s+(~[0-9a-zA-Z_-]+)(?:\s+|$)'
    for m in re.finditer(cj_pattern, text):
        domain, key, value = m.groups()
        cookies[domain] = (key, value)
    if any(not d in cookies for d in [""bugs.chromium.org"", ""oss-fuzz.com""]):
        fatal(""Missing domains, got: %s"", "" "".join(cookies.keys()))
    return cookies

cookie_file = args.cookie_file
if not cookie_file:
    # TODO maybe fallback to a default location?
    parser.error(""Missing cookie file"")
sid_cookies = parse_cookies(open(cookie_file).read().strip())

session = requests.Session()
for domain, (key, value) in sid_cookies.items():
    session.cookies.set(key, value, domain=domain)

# Fetch bug contents
issue_id = str(args.issue_id)
bugurl = OSS_FUZZ_BUGURL + issue_id
r = session.get(bugurl)
r.raise_for_status()

# Look for ID
pat = re.search(testcase_pattern, r.text)
if not pat:
    fatal('Cannot find testcase ID')
testcase_id = pat.group(1)

# Look for type (IP, etc.)
pat = re.search(proto_pattern, r.text)
if not pat:
    # XXX maybe assume IP?
    fatal('Protocol not found')
protocol = pat.group(1)

attachment_name = None
# Try to locate existing file
for prefix in [""clusterfuzz-testcase-minimized-"", ""clusterfuzz-testcase-""]:
    for suffix in ['', '.pcap']:
        name = prefix + testcase_id + suffix
        if os.path.exists(name):
            attachment_name = name
            break

# Download the attachment if missing
if attachment_name is None:
    att_url = DOWNLOAD_URL + testcase_id
    r = session.get(att_url, stream=True)
    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])
    if not pat:
        fatal('Cannot parse header: %s', r.headers['content-disposition'])
    attachment_name = pat.group(1)
    try:
        # Open without overwriting existing contents.
        with open(attachment_name, 'xb') as f:
            for chunk in r.iter_content(chunk_size=4096):
                f.write(chunk)
        logging.info(""Downloaded: %s"", attachment_name)
    except FileExistsError:
        # Ignore existing file.
        pass

cmd = [
    ""oss-fuzz-report.py"",
    ""--proto"", protocol,
    attachment_name,
    issue_id
]
if args.reporter_args:
    cmd += args.reporter_args.split()
for name, arg_type in reporter_params:
    value = getattr(args, name)
    if value is not None:
        cmd.append(""--"" + name)
        if arg_type:
            cmd.append(str(value))
print(' '.join(cmd))

os.execvp(cmd[0], cmd)
/n/n/n",0
1,1,59fdbf02dac752fd22cb87eb4bea59d599b333dd,"/grab-monorail.py/n/n#!/usr/bin/env python3
import argparse
import glob
import logging
import os
import re
import requests
import subprocess
import sys

OSS_FUZZ_BUGURL = ""https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=""
DOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='

testcase_pattern = re.compile(r'https://oss-fuzz\.com/testcase\?key=(\d+)')
proto_pattern = r'\bFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\b'

parser = argparse.ArgumentParser()
parser.add_argument(""--debug"", action=""store_true"", help=""Enable verbose logging"")
parser.add_argument(""--cookie-file"", ""-c"", help=""File containing cookie value"")

# Pass through options
reporter_params = [
    (""report"", None),
    (""timeout"", int),
    (""memlimit"", int),
    (""memleaks"", None),
]
for name, arg_type in reporter_params:
    args = [""--"" + name]
    kwargs = {}
    if arg_type:
        kwargs[""type""] = arg_type
    else:
        kwargs[""action""] = ""store_true""
    kwargs[""default""] = None
    kwargs[""help""] = ""Option is passed to the reporter""
    parser.add_argument(*args, **kwargs)
parser.add_argument(""--reporter-args"", ""-r"", help=""Options to pass through"")


parser.add_argument(""issue_id"", type=int)
args = parser.parse_args()

if args.debug:
    logging.basicConfig(level=logging.DEBUG)

def fatal(*args):
    logging.error(*args)
    sys.exit(1)

def parse_cookies(text):
    cookies = {}
    for m in re.finditer(r'(SACSID)\s+(~[0-9a-zA-Z_-]+)\s+([a-z.-]+)(?:\s|$)', text):
        key, value, domain = m.groups()
        cookies[domain] = (key, value)
    # compatibility with Netscape cookie jar
    garbage = r'(?:TRUE|FALSE)\s+/\s+(?:TRUE|FALSE)\s+\d+\s+'
    cj_pattern = r'([a-z.-]+)\s+' + garbage + r'(SACSID)\s+(~[0-9a-zA-Z_-]+)(?:\s+|$)'
    for m in re.finditer(cj_pattern, text):
        domain, key, value = m.groups()
        cookies[domain] = (key, value)
    if any(not d in cookies for d in [""bugs.chromium.org"", ""oss-fuzz.com""]):
        fatal(""Missing domains, got: %s"", "" "".join(cookies.keys()))
    return cookies

cookie_file = args.cookie_file
if not cookie_file:
    # TODO maybe fallback to a default location?
    parser.error(""Missing cookie file"")
sid_cookies = parse_cookies(open(cookie_file).read().strip())

session = requests.Session()
for domain, (key, value) in sid_cookies.items():
    session.cookies.set(key, value, domain=domain)

# Fetch bug contents
issue_id = str(args.issue_id)
bugurl = OSS_FUZZ_BUGURL + issue_id
r = session.get(bugurl)
r.raise_for_status()

# Look for ID
pat = re.search(testcase_pattern, r.text)
if not pat:
    fatal('Cannot find testcase ID')
testcase_id = pat.group(1)

# Look for type (IP, etc.)
pat = re.search(proto_pattern, r.text)
if not pat:
    # XXX maybe assume IP?
    fatal('Protocol not found')
protocol = pat.group(1)

attachment_name = None
# Try to locate existing file
for prefix in [""clusterfuzz-testcase-minimized-"", ""clusterfuzz-testcase-""]:
    for suffix in ['', '.pcap']:
        name = prefix + testcase_id + suffix
        if os.path.exists(name):
            attachment_name = name
            break

# Download the attachment if missing
if attachment_name is None:
    att_url = DOWNLOAD_URL + testcase_id
    r = session.get(att_url, stream=True)
    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])
    if not pat:
        fatal('Cannot parse header: %s', r.headers['content-disposition'])
    attachment_name = pat.group(1)
    try:
        # Open without overwriting existing contents.
        with open(attachment_name, 'xb') as f:
            for chunk in r.iter_content(chunk_size=4096):
                f.write(chunk)
        logging.info(""Downloaded: %s"", attachment_name)
    except FileExistsError:
        # Ignore existing file.
        pass

cmd = [
    ""oss-fuzz-report.py"",
    ""--proto"", protocol,
    attachment_name,
    issue_id
]
if args.reporter_args:
    cmd += args.reporter_args.split()
for name, arg_type in reporter_params:
    value = getattr(args, name)
    if value is not None:
        cmd.append(""--"" + name)
        if arg_type:
            cmd.append(str(value))
print(' '.join(cmd))

os.execvp(cmd[0], cmd)
/n/n/n",1
24,24,fa58bf0d37503c857be1a8cf533e8400d5cdbb6f,"app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

AUTHORIZATION_PARAMS_LIST = [
    'contact_name',
    'contact_email',
    'organization_name',
    'domain_write_permission',
    'read_permission',
    'full_read_permission',
    'search_permission',
    'subscribe_permission',
    'mark_notes_reviewed',
    'believed_dead_permission',
    'stats_permission',
    'is_valid',
]

def to_authorization_params(param):
    ret = {}
    for param_name in AUTHORIZATION_PARAMS_LIST:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags,
                           xsrf_token=xsrf_tool.generate_token(
                               user.user_id(), 'admin_api_keys'))


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/napp/model.py/n/n#!/usr/bin/python2.7
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""The Person Finder data model, based on PFIF (http://zesty.ca/pfif).""""""

__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'

from datetime import timedelta

from google.appengine.api import datastore_errors
from google.appengine.api import memcache
from google.appengine.ext import db

import config
import full_text_search
import indexing
import pfif
import prefix
from const import HOME_DOMAIN, NOTE_STATUS_TEXT

# default # of days for a record to expire.
DEFAULT_EXPIRATION_DAYS = 40

# ==== PFIF record IDs =====================================================

def is_original(repo, record_id):
    """"""Returns True if this is a record_id for a record originally created in
    the specified repository.""""""
    try:
        repo_id, local_id = record_id.split('/', 1)
        return repo_id == repo + '.' + HOME_DOMAIN
    except ValueError:
        raise ValueError('%r is not a valid record_id' % record_id)

def is_clone(repo, record_id):
    """"""Returns True if this is a record_id for a clone record (a record created
    in another repository and copied into the specified one).""""""
    return not is_original(repo, record_id)

def filter_by_prefix(query, key_name_prefix):
    """"""Filters a query for key_names that have the given prefix.  If root_kind
    is specified, filters the query for children of any entities that are of
    that kind with the given prefix; otherwise, the results are assumed to be
    top-level entities of the kind being queried.""""""
    root_kind = query._model_class.__name__
    min_key = db.Key.from_path(root_kind, key_name_prefix)
    max_key = db.Key.from_path(root_kind, key_name_prefix + u'\uffff')
    return query.filter('__key__ >=', min_key).filter('__key__ <=', max_key)

def get_properties_as_dict(db_obj):
    """"""Returns a dictionary containing all (dynamic)* properties of db_obj.""""""
    properties = dict((k, v.__get__(db_obj, db_obj.__class__)) for
                      k, v in db_obj.properties().iteritems() if
                      v.__get__(db_obj, db_obj.__class__))
    dynamic_properties = dict((prop, getattr(db_obj, prop)) for
                              prop in db_obj.dynamic_properties())
    properties.update(dynamic_properties)
    return properties

def clone_to_new_type(origin, dest_class, **kwargs):
    """"""Clones the given entity to a new entity of the type ""dest_class"".
    Optionally, pass in values to kwargs to update values during cloning.""""""
    vals = get_properties_as_dict(origin)
    vals.update(**kwargs)
    if hasattr(origin, 'record_id'):
        vals.update(record_id=origin.record_id)
    return dest_class(key_name=origin.key().name(), **vals)

# ==== Model classes =======================================================

# Every Person or Note entity belongs to a specific repository.  To partition
# the datastore, key names consist of the repo name, a colon, and then the
# record ID.  Each repository appears to be a separate instance of the app.

# Note that the repository name doesn't necessarily have to match the original
# repository domain in the record ID!  For example, a person record created at
# foo.person-finder.appspot.com would have a key name such as:
#
#     foo:foo.person-finder.appspot.com/person.234
#
# This record would be searchable only at foo.person-finder.appspot.com --
# each repository is independent.  Copying it to bar.person-finder.appspot.com
# would produce a clone record with the key name:
#
#     bar:foo.person-finder.appspot.com/person.234
#
# That is, the clone has the same record ID but a different repository name.

class Repo(db.Model):
    """"""Identifier for a repository of Person and Note records.  This is a
    top-level entity, with no parent, whose existence just indicates the
    existence of a repository.  Key name: unique repository name.  In the UI,
    each repository behaves like an independent instance of the application.""""""

    class ActivationStatus(object):
        """"""An enum for the launch/activation status of the repo.""""""
        # For use with repositories that have not yet been publicly launched.
        # Staging repos aren't listed on the homepage or in the repository feed,
        # but are otherwise totally usable repos for anyone who knows the URL.
        STAGING = 0
        # For repositories in active use. These repos are listed on the homepage
        # and in the repository feed.
        ACTIVE = 1
        # For repositories that have been turned down. The repository is
        # unavailable, through either the web interface or the API, and users
        # will instead see a deactivation message. These repos aren't listed on
        # the homepage or in the repository feed.
        DEACTIVATED = 2

    # TODO(nworden): actually use this field
    activation_status = db.IntegerProperty(
        required=False, default=ActivationStatus.STAGING)

    # Whether the repository is in test mode; meant for use with evergreen
    # repositories when they're not needed. Records for repos in test mode are
    # automatically deleted after 24 hours.
    test_mode = db.BooleanProperty(default=False)

    # Few properties for now; the repository title and other settings are all in
    # ConfigEntry entities (see config.py).

    @classmethod
    def list(cls):
        """"""Returns a list of all repository names.""""""
        return [repo.key().name() for repo in cls.all()]

    @classmethod
    def list_active(cls):
        """"""Returns a list of the active (non-deactivated) repository names.""""""
        return [name for name in Repo.list()
                if not config.get_for_repo(name, 'deactivated')]

    @classmethod
    def list_launched(cls):
        """"""Returns a list of the launched (listed in menu) repository names.""""""
        return [name for name in Repo.list()
                if config.get_for_repo(name, 'launched') and
                        not config.get_for_repo(name, 'deactivated')]


class Base(db.Model):
    """"""Base class providing methods common to both Person and Note entities,
    whose key names are partitioned using the repo name as a prefix.""""""

    # max records to fetch in one go.
    FETCH_LIMIT = 200

    # Even though the repo is part of the key_name, it is also stored
    # redundantly as a separate property so it can be indexed and queried upon.
    repo = db.StringProperty(required=True)

    # We can't use an inequality filter on expiry_date (together with other
    # inequality filters), so we use a periodic task to set the is_expired flag
    # on expired records, and filter using the flag.  A record's life cycle is:
    #
    # 1. Record is created with some expiry_date.
    # 2. expiry_date passes.
    # 3. tasks.DeleteExpired sets is_expired to True; record vanishes from UI.
    # 4. delete.EXPIRED_TTL_DAYS days pass.
    # 5. tasks.DeleteExpired wipes the record.

    # We set default=False to ensure all entities are indexed by is_expired.
    # NOTE: is_expired should ONLY be modified in Person.put_expiry_flags().
    is_expired = db.BooleanProperty(required=False, default=False)

    @classmethod
    def all(cls, keys_only=False, filter_expired=True):
        """"""Returns a query for all records of this kind; by default this
        filters out the records marked as expired.

        Args:
          keys_only - If true, return only the keys.
          filter_expired - If true, omit records with is_expired == True.
        Returns:
          query - A Query object for the results.
        """"""
        query = super(Base, cls).all(keys_only=keys_only)
        if filter_expired:
            query.filter('is_expired =', False)
        return query

    @classmethod
    def all_in_repo(cls, repo, filter_expired=True):
        """"""Gets a query for all entities in a given repository.""""""
        return cls.all(filter_expired=filter_expired).filter('repo =', repo)

    def get_record_id(self):
        """"""Returns the record ID of this record.""""""
        repo, record_id = self.key().name().split(':', 1)
        return record_id
    record_id = property(get_record_id)

    def get_original_domain(self):
        """"""Returns the domain name of this record's original repository.""""""
        return self.record_id.split('/', 1)[0]
    original_domain = property(get_original_domain)

    def is_original(self):
        """"""Returns True if this record was created in this repository.""""""
        return is_original(self.repo, self.record_id)

    def is_clone(self):
        """"""Returns True if this record was copied from another repository.""""""
        return not self.is_original()

    @classmethod
    def get_key(cls, repo, record_id):
        """"""Get entity key from its record id""""""
        return db.Key.from_path(cls.kind(), repo + ':' + record_id)

    @classmethod
    def get_all(cls, repo, record_ids, limit=200):
        """"""Gets the entities with the given record_ids in a given repository.""""""
        keys = [cls.get_key(repo, id) for id in record_ids]
        return [record for record in db.get(keys) if record is not None]

    @classmethod
    def get(cls, repo, record_id, filter_expired=True):
        """"""Gets the entity with the given record_id in a given repository.""""""
        record = cls.get_by_key_name(repo + ':' + record_id)
        if record:
            if not (filter_expired and record.is_expired):
                return record

    @classmethod
    def create_original(cls, repo, **kwargs):
        """"""Creates a new original entity with the given field values.""""""
        # TODO(ryok): Consider switching to URL-like record id format,
        # which is more consitent with repo id format.
        record_id = '%s.%s/%s.%d' % (
            repo, HOME_DOMAIN, cls.__name__.lower(), UniqueId.create_id())
        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)

    @classmethod
    def create_clone(cls, repo, record_id, **kwargs):
        """"""Creates a new clone entity with the given field values.""""""
        assert is_clone(repo, record_id)
        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)

    # TODO(kpy): Rename this function (maybe to create_with_record_id?).
    @classmethod
    def create_original_with_record_id(cls, repo, record_id, **kwargs):
        """"""Creates an original entity with the given record_id and field
        values, overwriting any existing entity with the same record_id.
        This should be rarely used in practice (e.g. for an administrative
        import into a home repository), hence the long method name.""""""
        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)


# All fields are either required, or have a default value.  For property
# types that have a false value, the default is the false value.  For types
# with no false value, the default is None.

class Person(Base):
    """"""The datastore entity kind for storing a PFIF person record.  Never call
    Person() directly; use Person.create_clone() or Person.create_original().

    Methods that start with ""get_"" return actual values or lists of values;
    other methods return queries or generators for values.
    """"""
    # If you add any new fields, be sure they are handled in wipe_contents().

    # entry_date should update every time a record is created or re-imported.
    entry_date = db.DateTimeProperty(required=True)
    expiry_date = db.DateTimeProperty(required=False)

    author_name = db.StringProperty(default='', multiline=True)
    author_email = db.StringProperty(default='')
    author_phone = db.StringProperty(default='')

    # the original date we saw this record; it should not change.
    original_creation_date = db.DateTimeProperty(auto_now_add=True)

    # source_date is the date that the original repository last changed
    # any of the fields in the pfif record.
    source_date = db.DateTimeProperty()

    source_name = db.StringProperty(default='')
    source_url = db.StringProperty(default='')

    # TODO(ryok): consider marking this required.
    full_name = db.StringProperty(multiline=True)
    given_name = db.StringProperty()
    family_name = db.StringProperty()
    alternate_names = db.StringProperty(default='', multiline=True)
    description = db.TextProperty(default='')
    sex = db.StringProperty(default='', choices=pfif.PERSON_SEX_VALUES)
    date_of_birth = db.StringProperty(default='')  # YYYY, YYYY-MM, YYYY-MM-DD
    age = db.StringProperty(default='')  # NN or NN-MM
    home_street = db.StringProperty(default='')
    home_neighborhood = db.StringProperty(default='')
    home_city = db.StringProperty(default='')
    home_state = db.StringProperty(default='')
    home_postal_code = db.StringProperty(default='')
    home_country = db.StringProperty(default='')
    photo_url = db.TextProperty(default='')
    profile_urls = db.TextProperty(default='')

    # This reference points to a locally stored Photo entity.  ONLY set this
    # property when storing a new Photo object that is owned by this Person
    # record and can be safely deleted when the Person is deleted.
    photo = db.ReferenceProperty(default=None)

    # The following properties are not part of the PFIF data model; they are
    # cached on the Person for efficiency.

    # Value of the 'status' and 'source_date' properties on the Note
    # with the latest source_date with the 'status' field present.
    latest_status = db.StringProperty(default='')
    latest_status_source_date = db.DateTimeProperty()
    # Value of the 'author_made_contact' and 'source_date' properties on the
    # Note with the latest source_date with the 'author_made_contact' field
    # present.
    latest_found = db.BooleanProperty()
    latest_found_source_date = db.DateTimeProperty()

    # Last write time of this Person or any Notes on this Person.
    # This reflects any change to the Person page.
    last_modified = db.DateTimeProperty(auto_now=True)

    # This flag is set to true only when the record author disabled
    # adding new notes to a record.
    notes_disabled = db.BooleanProperty(default=False)

    # attributes used by indexing.py
    names_prefixes = db.StringListProperty()
    # TODO(ryok): index address components.
    _fields_to_index_properties = ['given_name', 'family_name', 'full_name']
    _fields_to_index_by_prefix_properties = ['given_name', 'family_name',
        'full_name']

    @staticmethod
    def past_due_records(repo):
        """"""Returns a query for all Person records with expiry_date in the past,
        or None, regardless of their is_expired flags.""""""
        import utils
        return Person.all(filter_expired=False).filter(
            'expiry_date <=', utils.get_utcnow()).filter(
            'repo =', repo)

    @staticmethod
    def potentially_expired_records(repo,
                                    days_to_expire=DEFAULT_EXPIRATION_DAYS):
        """"""Returns a query for all Person records with source date
        older than days_to_expire (or empty source_date), regardless of
        is_expired flags value.""""""
        import utils
        cutoff_date = utils.get_utcnow() - timedelta(days_to_expire)
        return Person.all(filter_expired=False).filter(
            'source_date <=',cutoff_date).filter(
            'repo =', repo)

    @property
    def person_record_id(self):
        return self.record_id

    @property
    def primary_full_name(self):
        return self.full_name.splitlines()[0] if self.full_name else ''

    @property
    def full_name_list(self):
        return self.full_name.splitlines() if self.full_name else []

    @property
    def alternate_names_list(self):
        return self.alternate_names.splitlines() if self.alternate_names else []

    @property
    def fuzzified_age(self):
        import utils
        return utils.fuzzify_age(self.age) if self.age else None

    @property
    def profile_urls_list(self):
        return self.profile_urls.splitlines() if self.profile_urls else []

    @property
    def photo_url_no_scheme(self):
        import utils
        return utils.strip_url_scheme(self.photo_url)

    def get_notes(self, filter_expired=True):
        """"""Returns a list of all the Notes on this Person, omitting expired
        Notes by default.""""""
        return Note.get_by_person_record_id(
            self.repo, self.record_id, filter_expired=filter_expired)

    def get_subscriptions(self, subscription_limit=200):
        """"""Retrieves a list of all the Subscriptions for this Person.""""""
        return Subscription.get_by_person_record_id(
            self.repo, self.record_id, limit=subscription_limit)

    def get_linked_person_ids(self, note_limit=200):
        """"""Retrieves IDs of Persons marked as duplicates of this Person.""""""
        return [note.linked_person_record_id
                for note in self.get_notes(note_limit)
                if note.linked_person_record_id]

    def get_linked_persons(self, note_limit=200):
        """"""Retrieves Persons marked as duplicates of this Person.""""""
        return Person.get_all(self.repo,
                              self.get_linked_person_ids(note_limit))

    def get_all_linked_persons(self):
        """"""Retrieves all Persons transitively linked to this Person.""""""
        linked_person_ids = set([self.record_id])
        linked_persons = []
        # Maintain a list of ids of duplicate persons that have not
        # yet been processed.
        new_person_ids = set(self.get_linked_person_ids())
        # Iteratively process all new_person_ids by retrieving linked
        # duplicates and storing those not yet processed.
        # Processed ids are stored in the linked_person_ids set, and
        # their corresponding records are in the linked_persons list.
        while new_person_ids:
            linked_person_ids.update(new_person_ids)
            new_persons = Person.get_all(self.repo, list(new_person_ids))
            for person in new_persons:
                new_person_ids.update(person.get_linked_person_ids())
            linked_persons += new_persons
            new_person_ids -= linked_person_ids
        return linked_persons

    def get_associated_emails(self):
        """"""Gets a set of all the e-mail addresses to notify when this record
        is changed.""""""
        email_addresses = set([note.author_email for note in self.get_notes()
                               if note.author_email])
        if self.author_email:
            email_addresses.add(self.author_email)
        return email_addresses

    def get_effective_expiry_date(self):
        """"""Gets the expiry_date, or if no expiry_date is present, returns the
        source_date plus the configurable default_expiration_days interval.

        If there's no source_date, we use original_creation_date.
        Returns:
          A datetime date (not None).
        """"""
        if self.expiry_date:
            return self.expiry_date
        else:
            expiration_days = config.get_for_repo(
                self.repo, 'default_expiration_days') or (
                DEFAULT_EXPIRATION_DAYS)
            # in theory, we should always have original_creation_date, but since
            # it was only added recently, we might have legacy
            # records without it.
            start_date = self.original_creation_date or utils.get_utcnow()
            return start_date + timedelta(expiration_days)

    def put_expiry_flags(self):
        """"""Updates the is_expired flags on this Person and related Notes to
        make them consistent with the effective_expiry_date() on this Person,
        and commits the changes to the datastore.""""""
        import utils
        now = utils.get_utcnow()
        expired = self.get_effective_expiry_date() <= now

        if self.is_expired != expired:
            # NOTE: This should be the ONLY code that modifies is_expired.
            self.is_expired = expired

            # if we neglected to capture the original_creation_date,
            # make a best effort to grab it now, for posterity.
            if not self.original_creation_date:
                self.original_creation_date = self.source_date

            # If the record is expiring (being replaced with a placeholder,
            # see http://zesty.ca/pfif/1.3/#data-expiry) or un-expiring (being
            # restored from deletion), we want the source_date and entry_date
            # updated so downstream clients will see this as the newest state.
            self.source_date = now
            self.entry_date = now

            # All the Notes on the Person also expire or unexpire, to match.
            notes = self.get_notes(filter_expired=False)
            for note in notes:
                note.is_expired = expired

            # Store these changes in the datastore.
            db.put(notes + [self])
            # TODO(lschumacher): photos don't have expiration currently.

    def wipe_contents(self):
        """"""Sets all the content fields to None (leaving timestamps and the
        expiry flag untouched), stores the empty record, and permanently
        deletes any related Notes and Photos.  Call this method ONLY on records
        that have already expired.""""""
        # We rely on put_expiry_flags to have properly set the source_date,
        # entry_date, and is_expired flags on Notes, as necessary.
        assert self.is_expired

        # Permanently delete all related Photos and Notes, but not self.
        self.delete_related_entities()

        was_changed = False
        # TODO(nworden): consider adding a is_tombstone property or something
        # like that, so we could just check that instead of checking each
        # property individually every time.
        for name, property in self.properties().items():
            # Leave the repo, is_expired flag, and timestamps untouched.
            if name not in ['repo', 'is_expired', 'original_creation_date',
                            'source_date', 'entry_date', 'expiry_date']:
                if name == 'photo':
                    # If we attempt to access this directly, Datastore will try
                    # to fetch the actual photo, which won't go well, because we
                    # just deleted the photo.
                    cur_value = Person.photo.get_value_for_datastore(self)
                else:
                    cur_value = getattr(self, name)
                if cur_value != property.default:
                    setattr(self, name, property.default)
                    was_changed = True
        if was_changed:
            self.put()  # Store the empty placeholder record.

    def delete_related_entities(self, delete_self=False):
        """"""Permanently delete all related Photos and Notes, and also self if
        delete_self is True.""""""
        # Delete all related Notes.
        notes = self.get_notes(filter_expired=False)
        # Delete the locally stored Photos.  We use get_value_for_datastore to
        # get just the keys and prevent auto-fetching the Photo data.
        photo = Person.photo.get_value_for_datastore(self)
        note_photos = [Note.photo.get_value_for_datastore(n) for n in notes]

        entities_to_delete = filter(None, notes + [photo] + note_photos)
        if delete_self:
            entities_to_delete.append(self)
            if config.get('enable_fulltext_search'):
                full_text_search.delete_record_from_index(self)
        db.delete(entities_to_delete)

    def update_from_note(self, note):
        """"""Updates any necessary fields on the Person to reflect a new Note.""""""
        # We want to transfer only the *non-empty, newer* values to the Person.
        if note.author_made_contact is not None:  # for boolean, None means
                                                  # unspecified
            # datetime stupidly refuses to compare to None, so check for None.
            if (self.latest_found_source_date is None or
                note.source_date >= self.latest_found_source_date):
                self.latest_found = note.author_made_contact
                self.latest_found_source_date = note.source_date
        if note.status:  # for string, '' means unspecified
            if (self.latest_status_source_date is None or
                note.source_date >= self.latest_status_source_date):
                self.latest_status = note.status
                self.latest_status_source_date = note.source_date

    def update_index(self, which_indexing):
        #setup new indexing
        if 'new' in which_indexing:
            indexing.update_index_properties(self)
            if config.get('enable_fulltext_search'):
                full_text_search.add_record_to_index(self)
        # setup old indexing
        if 'old' in which_indexing:
            prefix.update_prefix_properties(self)

    def update_latest_status(self, modified_note=None):
        """"""Scans all notes on this Person and fixes latest_status if needed.""""""
        status = None
        status_source_date = None
        for note in self.get_notes():
            if modified_note and modified_note.note_record_id == note.record_id:
                note = modified_note
            if note.status and not note.hidden:
                status = note.status
                status_source_date = note.source_date
        if status != self.latest_status:
            self.latest_status = status
            self.latest_status_source_date = status_source_date
            self.put()

    def put_new(self):
        """"""Write the new person record to datastore. Increments person_counter
        because a new record is created. Logs user actions is updated too.
        We should never call this method against an existing record.""""""
        db.put(self)
        UsageCounter.increment_counter(self.repo, ['person'])
        UserActionLog.put_new('add', self, copy_properties=False)

# Old indexing
# TODO(ryok): This is obsolete. Remove it.
prefix.add_prefix_properties(
    Person, 'given_name', 'family_name', 'home_street', 'home_neighborhood',
    'home_city', 'home_state', 'home_postal_code')


class Note(Base):
    """"""The datastore entity kind for storing a PFIF note record.  Never call
    Note() directly; use Note.create_clone() or Note.create_original().""""""

    # The entry_date should update every time a record is re-imported.
    entry_date = db.DateTimeProperty(required=True)

    person_record_id = db.StringProperty(required=True)

    # Use this field to store the person_record_id of a duplicate Person entry.
    linked_person_record_id = db.StringProperty(default='')

    author_name = db.StringProperty(default='', multiline=True)
    author_email = db.StringProperty(default='')
    author_phone = db.StringProperty(default='')

    # the original date we saw this record; it should not change.
    original_creation_date = db.DateTimeProperty(auto_now_add=True)

    # source_date is the date that the original repository last changed
    # any of the fields in the pfif record.
    source_date = db.DateTimeProperty()

    status = db.StringProperty(default='', choices=pfif.NOTE_STATUS_VALUES)
    author_made_contact = db.BooleanProperty()
    email_of_found_person = db.StringProperty(default='')
    phone_of_found_person = db.StringProperty(default='')
    last_known_location = db.StringProperty(default='', multiline=True)
    text = db.TextProperty(default='')
    photo_url = db.TextProperty(default='')

    # This reference points to a locally stored Photo entity.  ONLY set this
    # property when storing a new Photo object that is owned by this Note
    # record and can be safely deleted when the Note is deleted.
    photo = db.ReferenceProperty(default=None)

    # True if the note has been marked as spam. Will cause the note to be
    # initially hidden from display upon loading a record page.
    hidden = db.BooleanProperty(default=False)

    # True if the note has been reviewed for spam content at /admin/review.
    reviewed = db.BooleanProperty(default=False)

    def get_note_record_id(self):
        return self.record_id
    note_record_id = property(get_note_record_id)

    @property
    def photo_url_no_scheme(self):
        import utils
        return utils.strip_url_scheme(self.photo_url)

    @staticmethod
    def get_by_person_record_id(
        repo, person_record_id, filter_expired=True):
        """"""Gets a list of all the Notes on a Person, ordered by source_date.""""""
        return list(Note.generate_by_person_record_id(
            repo, person_record_id, filter_expired))

    @staticmethod
    def generate_by_person_record_id(
        repo, person_record_id, filter_expired=True):
        """"""Generates all the Notes on a Person record ordered by source_date.""""""
        query = Note.all_in_repo(repo, filter_expired=filter_expired
            ).filter('person_record_id =', person_record_id
            ).order('source_date')
        notes = query.fetch(Note.FETCH_LIMIT)
        while notes:
            for note in notes:
                yield note
            query.with_cursor(query.cursor())  # Continue where fetch left off.
            notes = query.fetch(Note.FETCH_LIMIT)

    @staticmethod
    def get_unreviewed_notes_count(repo, filter_expired=True):
        """"""Gets the number of unreviewed notes.""""""
        query = Note.all_in_repo(repo, filter_expired=filter_expired
            ).filter('reviewed =', False).filter('hidden =', False)
        return query.count()

    def put_new(self):
        """"""Write the new note to datastore. Increments note_counter because
        a new note is created. Also, logs user actions is updated. We should
        never call this method against an existing record.""""""
        db.put(self)
        UserActionLog.put_new('add', self, copy_properties=False)
        note_status = self.status if self.status else 'unspecified'
        UsageCounter.increment_counter(self.repo, ['note', note_status])

class NoteWithBadWords(Note):
    # Spam score given by SpamDetector
    spam_score = db.FloatProperty(default=0)
    # True is the note is confirmed by its author through email
    confirmed = db.BooleanProperty(default=False)
    # Once the note is confirmed, this field stores the copy of
    # this note in Note table. It will be useful if we want to
    # delete the notes with bad words, even when they are confirmed.
    confirmed_copy_id = db.StringProperty(default='')

class Photo(db.Model):
    """"""An uploaded image file.  Key name: repo + ':' + photo_id.""""""

    # Even though the repo is part of the key_name, it is also stored
    # redundantly as a separate property so it can be indexed and queried upon.
    repo = db.StringProperty(required=True)
    image_data = db.BlobProperty()  # sanitized, resized image in PNG format
    upload_date = db.DateTimeProperty(auto_now_add=True)
    # thumbnail image in PNG format
    thumbnail_data = db.BlobProperty(default=None)

    @staticmethod
    def create(repo, **kwargs):
        """"""Creates a Photo entity with the given field values.""""""
        id = UniqueId.create_id()
        return Photo(key_name='%s:%s' % (repo, id), repo=repo, **kwargs)

    @staticmethod
    def get(repo, id):
        return Photo.get_by_key_name('%s:%s' % (repo, id))


class Authorization(db.Model):
    """"""Authorization keys.  Key name: repo + ':' + auth_key.""""""

    DEFAULT_SETTINGS = dict(contact_name='', contact_email='',
                            organization_name='', domain_write_permission='',
                            read_permission=False, full_read_permission=False,
                            search_permission=True, subscribe_permission=False,
                            mark_notes_reviewed=False, is_valid=True, key='')

    # Even though the repo is part of the key_name, it is also stored
    # redundantly as a separate property so it can be indexed and queried upon.
    repo = db.StringProperty(required=True)

    def summary_str(self):
        """"""Generates a summary of the key's current state.

        Meant for logging.
        """"""
        permissions_list = []
        for permission_field in ['read_permission',
                                 'full_read_permission',
                                 'search_permission',
                                 'subscribe_permission',
                                 'mark_notes_reviewed',
                                 'believed_dead_permission',
                                 'stats_permission']:
            if getattr(self, permission_field):
                permissions_list.append(permission_field)
        permissions = '; '.join(permissions_list)
        return ('repo: %(repo)s\n'
                'write domain: %(write_domain)s\n'
                'permissions: %(permissions)s\n'
                'valid: %(valid)s\n'
                'contact name: %(contact_name)s\n'
                'contact email: %(contact_email)s\n'
                'organization name: %(org_name)s') % {
                    'repo': self.repo,
                    'write_domain': self.domain_write_permission or 'None',
                    'permissions': permissions,
                    'valid': self.is_valid,
                    'contact_name': self.contact_name,
                    'contact_email': self.contact_email,
                    'org_name': self.organization_name,
                }

    # If this field is non-empty, this authorization token allows the client
    # to write records with this original domain.
    domain_write_permission = db.StringProperty()

    # If this flag is true, this authorization token allows the client to read
    # non-sensitive fields (i.e. filtered by utils.filter_sensitive_fields).
    read_permission = db.BooleanProperty()

    # If this flag is true, this authorization token allows the client to read
    # all fields (i.e. not filtered by utils.filter_sensitive_fields).
    full_read_permission = db.BooleanProperty()

    # If this flag is true, this authorization token allows the client to use
    # the search API and return non-sensitive fields (i.e. filtered
    # by utils.filter_sensitive_fields).
    search_permission = db.BooleanProperty()

    # If this flag is true, this authorization token allows the client to use
    # the API to subscribe any e-mail address to updates on any person.
    subscribe_permission = db.BooleanProperty()

    # If this flag is true, notes written with this authorization token are
    # marked as ""reviewed"" and won't show up in admin's review list.
    mark_notes_reviewed = db.BooleanProperty()

    # If this flag is true, notes written with this authorization token are
    # allowed to have status == 'believed_dead'.
    believed_dead_permission = db.BooleanProperty()

    # If this flag is true, this key can be used to get overall statistics.
    stats_permission = db.BooleanProperty()

    # If this flag is False, the API access with this key won't be
    # allowed.
    is_valid = db.BooleanProperty(default=True)

    # Bookkeeping information for humans, not used programmatically.
    contact_name = db.StringProperty()
    contact_email = db.StringProperty()
    organization_name = db.StringProperty()

    @property
    def api_key(self):
        """"""Gets a key value excluding the repo part. """"""
        if self.has_key():
            return self.key().name().split(':')[1]
        return None

    @classmethod
    def get(cls, repo, key):
        """"""Gets the Authorization entity for a given repository and key.""""""
        return cls.get_by_key_name(repo + ':' + key)

    @classmethod
    def create(cls, repo, key, **kwargs):
        """"""Creates an Authorization entity for a given repository and key.""""""
        return cls(key_name=repo + ':' + key, repo=repo, **kwargs)


class ApiKeyManagementLog(db.Model):
    """"""Log management history for API keys.""""""
    CREATE = 'create'
    UPDATE = 'update'
    DELETE = 'delete'
    ACTIONS = [CREATE, UPDATE, DELETE]

    user = db.UserProperty(auto_current_user_add=True)
    timestamp = db.DateTimeProperty(auto_now_add=True)
    repo = db.StringProperty(required=True)
    api_key = db.StringProperty(required=True)
    action = db.StringProperty(required=True, choices=ACTIONS)
    # The IP address of the admin making the change.
    ip_address = db.StringProperty()
    # A string representation of the state of the key after this action.
    key_state = db.TextProperty()

    @property
    def authorization(self):
        return Authorization.get(self.repo, self.api_key)

def encode_count_name(count_name):
    """"""Encode a name to printable ASCII characters so it can be safely
    used as an attribute name for the datastore.""""""
    encoded = []
    append = encoded.append
    for ch in map(ord, count_name):
        if ch == 92:
            append('\\\\')
        elif 33 <= ch <= 126:
            append(chr(ch))
        else:
            append('\\u%04x' % ch)
    return ''.join(encoded)

class ApiActionLog(db.Model):
    """"""Log of api key usage.""""""
    # actions
    REPO = 'repo'
    DELETE = 'delete'
    READ = 'read'
    SEARCH = 'search'
    WRITE = 'write'
    SUBSCRIBE = 'subscribe'
    UNSUBSCRIBE = 'unsubscribe'
    ACTIONS = [REPO, DELETE, READ, SEARCH, WRITE, SUBSCRIBE, UNSUBSCRIBE]

    repo = db.StringProperty()
    api_key = db.StringProperty()
    action = db.StringProperty(required=True, choices=ACTIONS)
    person_records = db.IntegerProperty()
    note_records = db.IntegerProperty()
    people_skipped = db.IntegerProperty() # write only
    notes_skipped = db.IntegerProperty() # write only
    user_agent = db.StringProperty()
    ip_address = db.StringProperty() # client ip
    request_url = db.StringProperty()
    version = db.StringProperty() # pfif version.
    timestamp = db.DateTimeProperty(auto_now=True)

    @staticmethod
    def record_action(repo, api_key, version, action, person_records,
                      note_records, people_skipped, notes_skipped, user_agent,
                      ip_address, request_url,
                      timestamp=None):
        import utils
        try:
            ApiActionLog(repo=repo,
                         api_key=api_key,
                         action=action,
                         person_records=person_records,
                         note_records=note_records,
                         people_skipped=people_skipped,
                         notes_skipped=notes_skipped,
                         user_agent=user_agent,
                         ip_address=ip_address,
                         request_url=request_url,
                         version=version,
                         timestamp=timestamp or utils.get_utcnow()).put()
        except Exception:
            # swallow anything to prevent the main action from failing.
            pass

class Counter(db.Expando):
    """"""Counters hold partial and completed results for ongoing counting tasks.
    To see how this is used, check out tasks.py.  A single Counter object can
    contain several named accumulators.  Typical usage is to scan for entities
    in order by __key__, update the accumulators for each entity, and save the
    partial counts when the time limit for a request is reached.  The last
    scanned key is saved in last_key so the next request can pick up the scan
    where the last one left off.  A non-empty last_key means a scan is not
    finished; when a scan is done, last_key should be set to ''.""""""
    timestamp = db.DateTimeProperty(auto_now=True)
    scan_name = db.StringProperty()
    repo = db.StringProperty()
    last_key = db.StringProperty(default='')  # if non-empty, count is partial

    # Each Counter also has a dynamic property for each accumulator; all such
    # properties are named ""count_"" followed by a count_name.  The count_name
    # is encoded to ensure all its characters are printable ASCII.
    def get(self, count_name):
        """"""Gets the specified accumulator from this counter object.""""""
        return getattr(self, 'count_' + encode_count_name(count_name), 0)

    def increment(self, count_name):
        """"""Increments the given accumulator on this Counter object.""""""
        prop_name = 'count_' + encode_count_name(count_name)
        setattr(self, prop_name, getattr(self, prop_name, 0) + 1)

    @classmethod
    def get_count(cls, repo, name):
        """"""Gets the latest finished count for the given repository and name.
        'name' should be in the format scan_name + '.' + count_name.""""""
        scan_name, count_name = name.split('.')
        count_name = encode_count_name(count_name)
        return cls.get_all_counts(repo, scan_name).get(count_name, 0)

    @classmethod
    def get_all_counts(cls, repo, scan_name):
        """"""Gets a dictionary of all the counts for the last completed scan
        for the given repository and scan name.""""""
        counter_key = repo + ':' + scan_name

        # Get the counts from memcache, loading from datastore if necessary.
        counter_dict = memcache.get(counter_key)
        if not counter_dict:
            try:
                # Get the latest completed counter with this scan_name.
                counter = cls.all().filter('repo =', repo
                                  ).filter('scan_name =', scan_name
                                  ).filter('last_key =', ''
                                  ).order('-timestamp').get()
            except datastore_errors.NeedIndexError:
                # Absurdly, it can take App Engine up to an hour to build an
                # index for a kind that has zero entities, and during that time
                # all queries fail.  Catch this error so we don't get screwed.
                counter = None

            counter_dict = {}
            if counter:
                # Cache the counter's contents in memcache for one minute.
                counter_dict = dict((name[6:], getattr(counter, name))
                                    for name in counter.dynamic_properties()
                                    if name.startswith('count_'))
                memcache.set(counter_key, counter_dict, 60)

        # Return the dictionary of counts for this scan.
        return counter_dict

    @classmethod
    def all_finished_counters(cls, repo, scan_name):
        """"""Gets a query for all finished counters for the specified scan.""""""
        return cls.all().filter('repo =', repo
                       ).filter('scan_name =', scan_name
                       ).filter('last_key =', '')

    @classmethod
    def get_unfinished_or_create(cls, repo, scan_name):
        """"""Gets the latest unfinished Counter entity for the given repository
        and scan_name.  If there is no unfinished Counter, create a new one.""""""
        counter = cls.all().filter('repo =', repo
                          ).filter('scan_name =', scan_name
                          ).order('-timestamp').get()
        if not counter or not counter.last_key:
            counter = Counter(repo=repo, scan_name=scan_name)
        return counter


class Subscription(db.Model):
    """"""Subscription to notifications when a note is added to a person record""""""
    repo = db.StringProperty(required=True)
    person_record_id = db.StringProperty(required=True)
    email = db.StringProperty(required=True)
    language = db.StringProperty(required=True)
    timestamp = db.DateTimeProperty(auto_now_add=True)

    @staticmethod
    def create(repo, record_id, email, language):
        """"""Creates a new Subscription""""""
        key_name = '%s:%s:%s' % (repo, record_id, email)
        return Subscription(key_name=key_name, repo=repo,
                            person_record_id=record_id,
                            email=email, language=language)

    @staticmethod
    def get(repo, record_id, email):
        """"""Gets the entity with the given record_id in a given repository.""""""
        key_name = '%s:%s:%s' % (repo, record_id, email)
        return Subscription.get_by_key_name(key_name)

    @staticmethod
    def get_by_person_record_id(repo, person_record_id, limit=200):
        """"""Retrieve subscriptions for a person record.""""""
        query = Subscription.all().filter('repo =', repo)
        query = query.filter('person_record_id =', person_record_id)
        return query.fetch(limit)


class UserActionLog(db.Expando):
    """"""Logs user actions.""""""
    time = db.DateTimeProperty(required=True)
    repo = db.StringProperty(required=True)
    action = db.StringProperty(required=True, choices=[
        'add', 'delete', 'extend', 'hide', 'mark_dead', 'mark_alive',
        'restore', 'unhide', 'disable_notes', 'enable_notes'])
    entity_kind = db.StringProperty(required=True)
    entity_key_name = db.StringProperty(required=True)
    detail = db.TextProperty()
    ip_address = db.StringProperty()

    @classmethod
    def put_new(cls, action, entity, detail='', ip_address='',
                copy_properties=True):
        """"""Adds an entry to the UserActionLog.  'action' is the action that
        the user performed, 'entity' is the entity that was operated on, and
        'detail' is a string containing any other details.""""""
        import utils
        kind = entity.kind()
        entry = cls(
            time=utils.get_utcnow(), repo=entity.repo, action=action,
            entity_kind=kind, entity_key_name=entity.key().name(),
            detail=detail, ip_address=ip_address)
        # copy the properties of the entity
        if copy_properties:
            for name in entity.properties():
                value = getattr(entity, name)
                if isinstance(value, db.Model):
                    value = value.key()
                setattr(entry, kind + '_' + name, value)
        entry.put()


class StaticSiteMapInfo(db.Model):
    """"""Holds static sitemaps file info.""""""
    static_sitemaps = db.StringListProperty()
    static_sitemaps_generation_time = db.DateTimeProperty(required=True)
    shard_size_seconds = db.IntegerProperty(default=90)


class SiteMapPingStatus(db.Model):
    """"""Tracks the last shard index that was pinged to the search engine.""""""
    search_engine = db.StringProperty(required=True)
    shard_index = db.IntegerProperty(default=-1)


class UniqueId(db.Model):
    """"""This entity is used just to generate unique numeric IDs.""""""
    @staticmethod
    def create_id():
        """"""Gets an integer ID that is guaranteed to be different from any ID
        previously returned by this static method.""""""
        unique_id = UniqueId()
        unique_id.put()
        return unique_id.key().id()

class UsageCounter(db.Expando):
    """"""Counters which count the historical statistics for each repository.
    To see how this is used, check out admin_statistics.py.
    Unlike the Counter class, UsageCounter object increments when
    a new record or a new note is created, which means, the UsageCounter
    will not decrement when a record/note is expired/deleted.""""""

    # repo stored as a seperate property so it can be indexed and queried.
    repo = db.StringProperty(required=True)

    @classmethod
    def create(cls, repo):
        """"""Create a new counter""""""
        return UsageCounter(key_name=repo, repo=repo)

    @classmethod
    def get(cls, repo):
        """"""Gets the entity with a given repository.""""""
        return UsageCounter.get_by_key_name(repo)

    @classmethod
    @db.transactional
    def increment_counter(cls, repo, counter_list, amount=1):
        """"""Increase the counter for the counter value
        based on the given amount. Each Counter has a dynamic property
        and is named based on a given counter_name.""""""
        counter = cls.get(repo)
        if not counter:
            counter = cls.create(repo)
        for counter_name in counter_list:
            counter_value = getattr(counter, counter_name, 0)
            setattr(counter, counter_name, counter_value + amount)
        counter.put()
/n/n/napp/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""URL routing module.""""""

from django.conf import urls

import site_settings
import tasksmodule.deletion
import tasksmodule.sitemap_ping
import views.admin.api_keys
import views.admin.create_repo
import views.admin.statistics
import views.meta.sitemap

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [
    ('admin_apikeys-list', r'(?P<repo>[^\/]+)/admin/api_keys/list/?',
     views.admin.api_keys.ApiKeyListView.as_view),
    ('admin_apikeys-manage', r'(?P<repo>[^\/]+)/admin/api_keys/?',
     views.admin.api_keys.ApiKeyManagementView.as_view),
    ('admin_create-repo', r'global/admin/create_repo/?',
     views.admin.create_repo.AdminCreateRepoView.as_view),
    ('admin_statistics', r'global/admin/statistics/?',
     views.admin.statistics.AdminStatisticsView.as_view),
    ('meta_sitemap', r'global/sitemap/?',
     views.meta.sitemap.SitemapView.as_view),
    ('tasks_process-expirations',
     r'(?P<repo>[^\/]+)/tasks/process_expirations/?',
     tasksmodule.deletion.ProcessExpirationsTask.as_view),
    ('tasks_cleanup-stray-notes',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_notes/?',
     tasksmodule.deletion.CleanupStrayNotesTask.as_view),
    ('tasks_cleanup-stray-subscriptions',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_subscriptions/?',
     tasksmodule.deletion.CleanupStraySubscriptionsTask.as_view),
    ('tasks_sitemap-ping', r'global/tasks/sitemap_ping/?',
     tasksmodule.sitemap_ping.SitemapPingTaskView.as_view),
]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^%s$' % path_exp, view_func(), name=name)
    for (name, path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^%(prefix)s/%(path)s$' % {
                'prefix': site_settings.OPTIONAL_PATH_PREFIX,
                'path': path_exp
            },
            view_func(),
            name='prefixed__%s' % name)
        for (name, path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/napp/views/admin/api_keys.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""The admin API key pages.

The way navigation is handled for these pages is a little unintuitive so let me
explain:
 - The main entry point to these pages is the list view, which accepts GET
   requests and returns a view with a) a link to create a new API key (which
   makes a GET request to the management page) and b) a list of existing pages,
   each with an ""edit"" button.
 - The list view's ""edit"" buttons make a _POST_ request to send the user to the
   management page for that key, with the key in a CGI parameter. I'm not
   exactly sure why that's a POST instead of a GET request, but I would guess
   it's to keep API keys out of URLs (which would end up in browser histories).
 - When a key is created or edited through the management page, it makes a POST
   request to itself, which returns a redirect to itself (which becomes a GET
   request). Consequently, the POST/GET handlers are the opposite of what you
   might expect: the POST handler handles the initial display of the form, while
   the GET handler handles what you see afterwards. The GET handler takes the
   Datastore key for a log entry (via a CGI param), which it uses to get the API
   key itself by way of the log entry.
""""""

import django.core.exceptions
import django.shortcuts
import django.utils.translation as t
from google.appengine.ext import db

import model
import utils
import views.admin.base


_API_KEY_LENGTH = 16


class ApiKeyListView(views.admin.base.AdminBaseView):
    """"""The admin API key list view.""""""

    ACTION_ID = 'admin/api_keys/list'

    def get(self, request, *args, **kwargs):
        """"""Serves a view with a list of API keys.""""""
        del request, args, kwargs  # unused
        auths = model.Authorization.all().filter(
            'repo = ', self.env.repo or '*')
        return self.render(
            'admin_api_keys_list.html',
            admin_api_keys_url=self.build_absolute_path(
                '/admin/api_keys', self.env.repo or 'global'),
            user=self.env.user,
            user_email=self.env.user.email(),
            authorizations=auths,
            xsrf_token=self.xsrf_tool.generate_token(
               self.env.user.user_id(), 'admin_api_keys'))


class ApiKeyManagementView(views.admin.base.AdminBaseView):
    """"""The API key management view, for creating or editing keys.""""""

    ACTION_ID = 'admin/api_keys'

    def get_params(self):
        return views.base.read_params(
            super(ApiKeyManagementView, self).get_params(),
            self.request,
            get_params={
                'log_key': utils.strip,
            },
            post_params={
                'authorization_key': utils.strip,
                'believed_dead_permission': utils.validate_checkbox_as_bool,
                'contact_name': utils.strip,
                'contact_email': utils.strip,
                'domain_write_permission': utils.strip,
                'edit_form': utils.strip,
                'full_read_permission': utils.validate_checkbox_as_bool,
                'is_valid': utils.validate_checkbox_as_bool,
                'key': utils.strip,
                'mark_notes_reviewed': utils.validate_checkbox_as_bool,
                'organization_name': utils.strip,
                'read_permission': utils.validate_checkbox_as_bool,
                'search_permission': utils.validate_checkbox_as_bool,
                'stats_permission': utils.validate_checkbox_as_bool,
                'subscribe_permission': utils.validate_checkbox_as_bool,
            })

    def get(self, request, *args, **kwargs):
        if self.params.get('log_key'):
            management_log_key = self.params.log_key
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == model.ApiKeyManagementLog.CREATE:
                message = t.ugettext(
                    'A new API key has been created successfully.')
            elif management_log.action == model.ApiKeyManagementLog.UPDATE:
                message = t.ugettext(
                    'The API key has been updated successfully.')
            return self._render_form(management_log.authorization, message)
        else:
            return self._render_form()

    def _make_authorization(self, repo, key_str):
        """"""Creates and stores an Authorization entity with the request's params.

        Args:
            repo (str): The ID of a repository, or '*' for a global key.
            key_str (str): The key itself.

        Returns:
            Authorization: An Authorization entity, already put in Datastore.
        """"""
        authorization = model.Authorization.create(
            repo,
            key_str,
            contact_name=self.params.contact_name,
            contact_email=self.params.contact_email,
            organization_name=self.params.organization_name,
            domain_write_permission=self.params.get('domain_write_permission'),
            read_permission=self.params.get('read_permission'),
            full_read_permission=self.params.get('full_read_permission'),
            search_permission=self.params.get('search_permission'),
            subscribe_permission=self.params.get('subscribe_permission'),
            mark_notes_reviewed=self.params.get('mark_notes_reviewed'),
            believed_dead_permission=self.params.get(
                'believed_dead_permission'),
            stats_permission=self.params.get('stats_permission'),
            is_valid=self.params.get('is_valid'))
        authorization.put()
        return authorization

    def post(self, request, *args, **kwargs):
        self.enforce_xsrf('admin_api_keys')

        # Navigation to an individual key's management page is handled by making
        # a POST request to this view. When it's such a request, the edit_form
        # param will be set.
        if self.params.get('edit_form'):
            authorization = db.get(self.params.get('authorization_key'))
            if not authorization:
                return self.error(404, t.ugettext(
                    'No such Authorization entity.'))
            return self._render_form(authorization)

        if not (self.params.get('contact_name') and
                self.params.get('contact_email') and
                self.params.get('organization_name')):
            return self.error(400, t.ugettext(
                'Please fill in all the required fields.'))

        repo = self.env.repo or '*'
        if self.params.get('key'):
            # Just override the existing one.
            existing_authorization = db.get(self.params.get('key'))
            if not existing_authorization:
                return self.error(404, t.ugettext(
                    'No such Authorization entity.'))
            # This shouldn't happen unless an admin does something funny with
            # URLs, but check just to be safe.
            if existing_authorization.repo != repo:
                return self.error(400, t.ugettext(
                    'Authorization already exists for another repo! '
                    'That\'s not expected.'))
            key_str = existing_authorization.api_key
            action = model.ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(_API_KEY_LENGTH)
            action = model.ApiKeyManagementLog.CREATE

        authorization = self._make_authorization(repo, key_str)

        management_log = model.ApiKeyManagementLog(
            repo=repo,
            api_key=authorization.api_key,
            action=action,
            ip_address=request.META.get('REMOTE_ADDR'),
            key_state=authorization.summary_str())
        management_log.put()

        return django.shortcuts.redirect(
            self.build_absolute_uri(
                '/%s/admin/api_keys?repo=%s&log_key=%s' % (
                    self.env.repo or 'global',
                    self.env.repo or 'global',
                    management_log.key())))

    def _render_form(self, authorization=None, message=None):
        """"""Produces a response with the API key management form.

        Args:
            authorization (Authorization, optional): An Authorization object. If
                present, an edit form will be produced; if None, a create form
                will be produced.
            message (str, optional): A message to display along with the form.

        Returns:
            HttpResponse: An HTTP response with the form.
        """"""
        if authorization:
            operation_type = 'update'
        else:
            authorization = model.Authorization.DEFAULT_SETTINGS
            operation_type = 'create'
        list_url = self.build_absolute_path(
            '/%s/admin/api_keys/list' % (self.env.repo or 'global'))
        return self.render(
            'admin_api_keys.html',
            user=self.env.user,
            target_key=authorization,
            user_email=self.env.user.email(),
            operation_type=operation_type,
            message=message,
            list_url=list_url,
            xsrf_token=self.xsrf_tool.generate_token(
                self.env.user.user_id(), 'admin_api_keys'),
        )
/n/n/napp/views/admin/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Code shared by admin view modules.""""""

import django.shortcuts
from google.appengine.api import users

import model
import utils
import views.base


class AdminBaseView(views.base.BaseView):
    """"""Base view for admin views.""""""

    class Env(views.base.BaseView.Env):
        """"""Class to store environment information used by views and templates.
        """"""
        # pylint: disable=attribute-defined-outside-init

        @property
        def all_repo_options(self):
            """"""Gets a list of Structs with repo IDs and URLs.

            Each Struct is expected to have two values:
            - repo: the repo ID
            - url: the URL to the repo's admin page
            """"""
            return self._all_repo_options

        @all_repo_options.setter
        def all_repo_options(self, value):
            self._all_repo_options = value

        @property
        def logout_url(self):
            """"""Gets a logout URL for the user.""""""
            return self._logout_url

        @logout_url.setter
        def logout_url(self, value):
            self._logout_url = value

        @property
        def user(self):
            """"""Gets a users.User object for the current user, if any.""""""
            return self._user

        @user.setter
        def user(self, value):
            self._user = value

    def setup(self, request, *args, **kwargs):
        """"""See docs on BaseView.setup.""""""
        # pylint: disable=attribute-defined-outside-init
        super(AdminBaseView, self).setup(request, *args, **kwargs)
        self.env.show_logo = True
        self.env.enable_javascript = True
        self.env.user = users.get_current_user()
        self.env.logout_url = users.create_logout_url(self.build_absolute_uri())
        self.env.all_repo_options = [
            utils.Struct(
                repo=repo, url=self.build_absolute_path('/%s/admin' % repo))
            for repo in sorted(model.Repo.list())
        ]
        self.xsrf_tool = utils.XsrfTool()

    def get_params(self):
        return views.base.read_params(
            super(AdminBaseView, self).get_params(),
            self.request,
            post_params={'xsrf_token': utils.strip})

    def enforce_xsrf(self, action_id):
        """"""Verifies the request's XSRF token.

        Checks the request's XSRF token and raises Django's PermissionDenied
        exception if the request didn't have a token or the token is invalid.
        As long as it's not caught, this will cause Django to return a 403.

        Args:
            action_id (str): The action ID used for creating the page's tokens.

        Raises:
            PermissionDenied: If the request's token is missing or invalid.
        """"""
        if not (self.params.get('xsrf_token') and
                self.xsrf_tool.verify_token(
                    self.params.get('xsrf_token'),
                    self.env.user.user_id(),
                    action_id)):
            raise django.core.exceptions.PermissionDenied

    def dispatch(self, request, *args, **kwargs):
        """"""See docs on django.views.View.dispatch.""""""
        # All the admin pages, and only the admin pages, require the user to be
        # logged in as an admin.
        # If we start requiring login for other pages, we should consider
        # refactoring this into a decorator or something like that.
        if not self.env.user:
            return django.shortcuts.redirect(
                users.create_login_url(self.build_absolute_uri()))
        if not users.is_current_user_admin():
            logout_url = users.create_logout_url(self.build_absolute_uri())
            return self.render(
                'not_admin_error.html',
                status_code=403,
                logout_url=logout_url,
                user=self.env.user)
        return super(AdminBaseView, self).dispatch(request, args, kwargs)
/n/n/napp/views/admin/create_repo.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""The admin create-repo page.""""""

import django.shortcuts

import config
import const
import model
import utils
import views.admin.base


class AdminCreateRepoView(views.admin.base.AdminBaseView):
    """"""The admin create-repo view.""""""

    ACTION_ID = 'admin/create_repo'

    def setup(self, request, *args, **kwargs):
        super(AdminCreateRepoView, self).setup(request, *args, **kwargs)

    def get_params(self):
        return views.base.read_params(
            super(AdminCreateRepoView, self).get_params(),
            self.request,
            post_params={'new_repo': utils.strip})

    def get(self, request, *args, **kwargs):
        """"""Serves GET requests.

        Args:
            request: Unused.
            *args: Unused.
            **kwargs: Unused.

        Returns:
            HttpResponse: A HTTP response with the admin create-repo page.
        """"""
        del request, args, kwargs  # unused
        return self.render(
            'admin_create_repo.html',
            xsrf_token=self.xsrf_tool.generate_token(self.env.user.user_id(),
                                                     self.ACTION_ID))

    def post(self, request, *args, **kwargs):
        """"""Serves POST requests, creating a new repo.

        Creates a new repository and sets some default values (assuming the user
        has permission and a valid XSRF token).

        Args:
            request: Unused.
            *args: Unused.
            **kwargs: Unused.

        Returns:
            HttpResponse: A redirect to the new repo's admin page.
        """"""
        del request, args, kwargs  # unused
        self.enforce_xsrf(self.ACTION_ID)
        new_repo = self.params.new_repo
        model.Repo(
            key_name=new_repo,
            activation_status=model.Repo.ActivationStatus.STAGING,
            test_mode=False).put()
        # Provide some defaults.
        config.set_for_repo(
            new_repo,
            language_menu_options=['en', 'fr'],
            repo_titles={
                'en': 'Earthquake',
                'fr': u'S\xe9isme'
            },
            keywords='person finder, people finder, person, people, ' +
            'crisis, survivor, family',
            use_family_name=True,
            use_alternate_names=True,
            use_postal_code=True,
            allow_believed_dead_via_ui=False,
            min_query_word_length=2,
            show_profile_entry=False,
            profile_websites=const.DEFAULT_PROFILE_WEBSITES,
            map_default_zoom=6,
            map_default_center=[0, 0],
            map_size_pixels=[400, 280],
            read_auth_key_required=True,
            search_auth_key_required=True,
            deactivated=False,
            launched=False,
            deactivation_message_html='',
            start_page_custom_htmls={
                'en': '',
                'fr': ''
            },
            results_page_custom_htmls={
                'en': '',
                'fr': ''
            },
            view_page_custom_htmls={
                'en': '',
                'fr': ''
            },
            seek_query_form_custom_htmls={
                'en': '',
                'fr': ''
            },
            footer_custom_htmls={
                'en': '',
                'fr': ''
            },
            bad_words='',
            published_date=utils.get_utcnow_timestamp(),
            updated_date=utils.get_utcnow_timestamp(),
            test_mode=False,
            force_https=True,
            zero_rating_mode=False,
            time_zone_offset=0,
            time_zone_abbreviation='UTC',
        )
        return django.shortcuts.redirect(
            self.build_absolute_path('/%s/admin' % new_repo))
/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    class Env(object):
        """"""Class to store environment information used by views and templates.

        Subclasses of BaseView may define their own Env class (which must be
        subclasses of BaseView.Env); that Env class (as long as it's called
        ""Env"") will be used automatically when the env is set up.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # pylint: disable=too-many-instance-attributes

        @property
        def action(self):
            """"""Gets the action ID, an identifier for the page being served.""""""
            return self._action

        @action.setter
        def action(self, value):
            self._action = value

        @property
        def charset(self):
            """"""Gets the character encoding being used to serve the page.""""""
            return self._charset

        @charset.setter
        def charset(self, value):
            self._charset = value

        @property
        def config(self):
            """"""Gets the config, a config.Config object for the repository.""""""
            return self._config

        @config.setter
        def config(self, value):
            self._config = value

        @property
        def enable_javascript(self):
            ""Gets whether or not to enable JavaScript."" """"
            return self._enable_javascript

        @enable_javascript.setter
        def enable_javascript(self, value):
            self._enable_javascript = value

        @property
        def global_url(self):
            """"""Gets the URL for the global root.""""""
            return self._global_url

        @global_url.setter
        def global_url(self, value):
            self._global_url = value

        @property
        def lang(self):
            """"""Gets the code for the language being used (see const.py).""""""
            return self._lang

        @lang.setter
        def lang(self, value):
            self._lang = value

        @property
        def repo(self):
            """"""Gets the repository ID, or None if it's a global page.""""""
            return self._repo

        @repo.setter
        def repo(self, value):
            self._repo = value

        @property
        def rtl(self):
            """"""Gets whether the language is a right-to-left language.""""""
            return self._rtl

        @rtl.setter
        def rtl(self, value):
            self._rtl = value

        @property
        def show_logo(self):
            """"""Gets whether or not to show the logo in the header.""""""
            return self._show_logo

        @show_logo.setter
        def show_logo(self, value):
            self._show_logo = value

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = self.get_params()

        # Set up env variable with data needed by the whole app.
        self.env = self.Env()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def get_params(self):
        """"""Gets parameter values out of the request.

        Subclasses that need additional values should override this function,
        with an implementation like this:
        return views.base.read_params(
            super(<Subclass>, self).get_params(),
            self.request,
            get_params={'x': validate_x, 'y': validate_y,},
            post_params={'z': validate_z})

        Returns:
            utils.Struct: A container with the values of CGI parameters used by
            this view.
        """"""
        return read_params(
            utils.Struct(), self.request, get_params={'lang': utils.strip})

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None, repo=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.
            repo (str, optional): A repo ID. If specified, the path will be
                considered relative to the repo's route. If this is specified,
                path must also be specified.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            assert not repo
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if repo:
            path = '/%s%s' % (repo, path)
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(self.build_absolute_path(path))

    def render(self, template_name, status_code=200, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            template_vars['csp_nonce'] = self.request.csp_nonce
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0),
            status=status_code)

    def error(self, status_code, message=''):
        """"""Returns an error response.

        Args:
            status_code (int): The HTTP status code to use.
            message (str, optional): A message to display. Defaults to the empty
                string.

        Returns:
            HttpResponse: An HTTP response with the given status code and
            message.
        """"""
        # pylint: disable=no-self-use
        # Making this a method of BaseView keeps it consistent with render(),
        # and probably other similar functions in the future.
        return django.http.HttpResponse(
            content=message, content_type='text/plain', status=status_code)

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view


def read_params(container,
                request,
                get_params=None,
                post_params=None,
                file_params=None):
    """"""Reads CGI parameter values from the request to the container.

    Args:
        container (utils.Struct): The container to put parameter values in.
        request (HttpRequest): The request to read from.
        get_params (dict): A dictionary from GET parameter keys to validator
            functions.
        post_params (dict): A dictionary from POST parameter keys to validator
            functions.
        file_params (dict): A dictionary from POST parameter keys for uploaded
            files to validator functions.

    Returns:
        utils.Struct: The container, for convenience.
    """"""
    if request.method == 'GET':
        if get_params:
            for key, validator in get_params.items():
                if key in request.GET:
                    setattr(container, key, validator(request.GET[key]))
    elif request.method == 'POST':
        if post_params:
            for key, validator in post_params.items():
                if key in request.POST:
                    setattr(container, key, validator(request.POST[key]))
        if file_params:
            for key, validator in file_params.items():
                if key in request.FILES:
                    setattr(container, key, validator(request.FILES[key]))
    return container
/n/n/ntests/server_test_cases/api_key_management_tests.py/n/n#!/usr/bin/python2.7
# encoding: utf-8
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Test cases for end-to-end testing.  Run with the server_tests script.""""""

import calendar
import datetime
import email
import email.header
import optparse
import os
import pytest
import re
import simplejson
import sys
import tempfile
import time
import unittest
import urlparse

from google.appengine.api import images

import config
from const import ROOT_URL, PERSON_STATUS_TEXT, NOTE_STATUS_TEXT
import download_feed
from model import *
from photo import MAX_IMAGE_DIMENSION
import remote_api
from resources import Resource, ResourceBundle
import reveal
import scrape
import setup_pf as setup
from test_pfif import text_diff
from text_query import TextQuery
import utils
from server_tests_base import ServerTestsBase


# TODO(ryok): fix go_as_operator() and re-enable the tests.
#class ApiKeyManagementTests(ServerTestsBase):
#    """"""Tests for API key management capabilities.""""""
#
#    key_management_operator = ""op@example.com""
#    
#    def go_as_operator(self, path, **kwargs):
#        """"""Navigates to the given path with an operator login.""""""
#        if not self.logged_in_as_operator:
#            scrape.setcookies(self.s.cookiejar, self.hostport,
#                              ['dev_appserver_login=%s:True:1' %
#                                  self.key_management_operator])
#            self.logged_in_as_operator = True
#        return self.go(path, **kwargs)
#
#    def go_as_admin(self, path, **kwargs):
#        """"""Setting logged_in_as_operator to False.""""""
#        ret = ServerTestsBase.go_as_admin(self, path, **kwargs)
#        self.logged_in_as_operator = False
#        return ret
#
#    def setUp(self):
#        ServerTestsBase.setUp(self)
#        self.logged_in_as_operator = False
#        config.set_for_repo(
#            'japan',
#            key_management_operators=[self.key_management_operator])
#
#    def test_toppage(self):
#        """"""Check the main page of API kay management.""""""
#        url = 'http://%s/personfinder/japan/admin/api_keys' % self.hostport
#        doc = self.go(url, redirects=0)
#        # check if 302
#        assert self.s.status == 302
#        doc = self.go_as_operator(url, redirects=0)
#        assert self.s.status == 200
#        assert 'API Key Management' in doc.text
#        doc = self.go_as_admin(url, redirects=0)
#        assert self.s.status == 200
#        assert 'API Key Management' in doc.text
#
#    def test_manage_key(self):
#        """"""Check if a new API key is created/updated correctly.""""""
#        url = 'http://%s/personfinder/japan/admin/api_keys' % self.hostport
#        doc = self.go_as_operator(url)
#        assert self.s.status == 200
#        assert 'API Key Management' in doc.text
#        form = doc.cssselect_one('form#create-or-update-api-key')
#        contact_name = 'Test User'
#        contact_email = 'user@example.com'
#        organization_name = 'Example, Inc.'
#        domain_write_permission = 'example.com'
#        doc = self.s.submit(
#            form,
#            contact_name=contact_name,
#            contact_email=contact_email,
#            organization_name=organization_name,
#            domain_write_permission=domain_write_permission,
#            read_permission='on',
#            full_read_permission='on',
#            search_permission='on',
#            subscribe_permission='on',
#            mark_notes_reviewed='on',
#            is_valid='on',
#        )
#        assert 'A new API key has been created successfully.' in doc.text
#        q = Authorization.all().filter('repo =', 'japan')
#        authorizations = q.fetch(10)
#        assert len(authorizations) == 1
#        authorization = authorizations[0]
#        # Check if the new key is correct.
#        assert authorization.contact_name == contact_name
#        assert authorization.contact_email == contact_email
#        assert authorization.organization_name == organization_name
#        assert authorization.domain_write_permission == domain_write_permission
#        assert authorization.read_permission is True
#        assert authorization.full_read_permission is True
#        assert authorization.search_permission is True
#        assert authorization.subscribe_permission is True
#        assert authorization.mark_notes_reviewed is True
#        assert authorization.is_valid is True
#        # Check if the management self.log is created correctly.
#        q = ApiKeyManagementLog.all().filter('repo =', 'japan')
#        logs = q.fetch(10)
#        assert len(logs) == 1
#        self.log = logs[0]
#        assert self.log.user.email() == self.key_management_operator
#        assert self.log.authorization.key() == authorization.key()
#        assert self.log.action == ApiKeyManagementLog.CREATE
#
#        # List the key and click the edit form on the list
#        url = 'http://%s/personfinder/japan/admin/api_keys/list' % self.hostport
#        doc = self.go_as_admin(url)
#        assert self.s.status == 200
#        assert 'Listing API keys for japan' in doc.text
#        form = doc.cssselect_one('form')
#        doc = self.s.submit(form)
#        assert self.s.status == 200
#        assert 'Detailed information of an API key for japan' in doc.text
#
#        # Update the key
#        contact_name = 'Japanese User'
#        contact_email = 'user@example.jp'
#        organization_name = 'Example, Corp.'
#
#        form = doc.cssselect_one('form')
#        doc = self.s.submit(
#            form,
#            contact_name=contact_name,
#            contact_email=contact_email,
#            organization_name=organization_name,
#            domain_write_permission='',
#            read_permission='',
#            full_read_permission='',
#            search_permission='',
#            subscribe_permission='',
#            mark_notes_reviewed='',
#            is_valid='',
#            key=str(authorization.key()),
#        )
#        assert 'The API key has been updated successfully.' in doc.text
#        q = Authorization.all().filter('repo =', 'japan')
#        authorizations = q.fetch(10)
#        assert len(authorizations) == 1
#        authorization = authorizations[0]
#        # Check if the new key is correct.
#        assert authorization.contact_name == contact_name
#        assert authorization.contact_email == contact_email
#        assert authorization.organization_name == organization_name
#        assert authorization.domain_write_permission == ''
#        assert authorization.read_permission is False
#        assert authorization.full_read_permission is False
#        assert authorization.search_permission is False
#        assert authorization.subscribe_permission is False
#        assert authorization.mark_notes_reviewed is False
#        assert authorization.is_valid is False
#        # Check if the management self.log is created correctly.
#        q = ApiKeyManagementLog.all().filter('repo =', 'japan')
#        logs = q.fetch(10)
#        assert len(logs) == 2
#        for self.log in logs:
#            assert self.log.user.email() == self.key_management_operator
#            assert self.log.authorization.key() == authorization.key()
#            if self.log.action != ApiKeyManagementLog.CREATE:
#                assert self.log.action == ApiKeyManagementLog.UPDATE
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/ntests/views/test_admin_api_keys.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Tests for the admin API keys pages.""""""

import django.http

import model

import view_tests_base


def add_test_authorization():
    authorization = model.Authorization.create(
        'haiti',
        'secret_key',
        contact_name='Bob Vance',
        contact_email='bob@fridge.com',
        organization_name='Vance Refrigeration',
        domain_write_permission='fridge.com',
        read_permission=True,
        full_read_permission=True,
        search_permission=True,
        subscribe_permission=False,
        mark_notes_reviewed=False,
        believed_dead_permission=False,
        stats_permission=False,
        is_valid=True)
    authorization.put()
    return authorization


class ApiKeyListViewTests(view_tests_base.ViewTestsBase):
    """"""Tests the admin API keys list view.""""""

    def setUp(self):
        super(ApiKeyListViewTests, self).setUp()
        model.Repo(key_name='haiti').put()
        add_test_authorization()
        self.login(is_admin=True)

    def test_get(self):
        """"""Tests GET requests.""""""
        doc = self.to_doc(self.client.get(
            '/haiti/admin/api_keys/list/', secure=True))
        self.assertTrue('Bob Vance' in doc.text)
        self.assertTrue('bob@fridge.com' in doc.text)
        self.assertTrue('Vance Refrigeration' in doc.text)
        # The first 10 elements with the ""permissions"" class are the
        # ""Permissions"" header and the individual permissions column headers.
        permissions_row = [el.text for el in doc.cssselect('.permission')[10:]]
        expected_permissions = [
            'fridge.com', 'x', 'x', 'x', None, None, None, None, 'x']
        self.assertEqual(permissions_row, expected_permissions)


class ApiKeyManagementViewTests(view_tests_base.ViewTestsBase):
    """"""Tests the API key management view.""""""

    def init_testbed_stubs(self):
        self.testbed.init_user_stub()
        self.testbed.init_datastore_v3_stub()

    def setUp(self):
        super(ApiKeyManagementViewTests, self).setUp()
        self.login(is_admin=True)

    def test_get_create_form(self):
        """"""Tests GET requests with no log key (i.e., the creation form).""""""
        self.authorization = add_test_authorization()
        res = self.client.get('/haiti/admin/api_keys/', secure=True)
        self.assertEqual(res.context['target_key'],
                         model.Authorization.DEFAULT_SETTINGS)
        self.assertEqual(res.context['operation_type'], 'create')

    def test_get_update_form(self):
        """"""Tests GET requests with a log key specified (i.e., an update form).
        """"""
        self.authorization = add_test_authorization()
        management_log = model.ApiKeyManagementLog(
            repo='haiti',
            api_key=self.authorization.api_key,
            action=model.ApiKeyManagementLog.CREATE,
            ip_address='123.45.67.89',
            key_state=self.authorization.summary_str())
        management_log.put()
        res = self.client.get(
            '/haiti/admin/api_keys/',
            data={'log_key': management_log.key()},
            secure=True)
        self.assertEqual(res.context['target_key'].key(),
                         self.authorization.key())
        self.assertEqual(res.context['operation_type'], 'update')

    def test_post_render_update_form(self):
        """"""Tests POST requests to show the update form.""""""
        self.authorization = add_test_authorization()
        params = {
            'edit_form': '1',
            'authorization_key': self.authorization.key(),
            'xsrf_token': self.xsrf_token('admin_api_keys'),
        }
        res = self.client.post(
            '/haiti/admin/api_keys/', data=params, secure=True)
        self.assertEqual(res.context['target_key'].key(),
                         self.authorization.key())
        self.assertEqual(res.context['operation_type'], 'update')

    def test_create_key(self):
        """"""Tests POST requests to create a new key.""""""
        params = {
            'contact_name': 'Creed Bratton',
            'contact_email': 'creed@aol.com',
            'organization_name': 'Creed Inc.',
            'read_permission': 'true',
            'search_permission': 'true',
            'is_valid': 'true',
            'xsrf_token': self.xsrf_token('admin_api_keys'),
        }
        res = self.client.post(
            '/haiti/admin/api_keys/', data=params, secure=True,
            REMOTE_ADDR='11.22.33.44')
        # Check that the Authorization entity was generated correctly.
        auths = model.Authorization.all().filter('repo =', 'haiti')
        self.assertEqual(auths.count(), 1)
        auth = auths[0]
        self.assertEqual(auth.contact_name, 'Creed Bratton')
        self.assertEqual(auth.contact_email, 'creed@aol.com')
        self.assertEqual(auth.organization_name, 'Creed Inc.')
        self.assertTrue(auth.read_permission)
        self.assertTrue(auth.search_permission)
        self.assertTrue(auth.is_valid)
        self.assertIsNone(auth.domain_write_permission)
        self.assertFalse(auth.full_read_permission)
        self.assertFalse(auth.subscribe_permission)
        self.assertFalse(auth.mark_notes_reviewed)
        self.assertFalse(auth.believed_dead_permission)
        self.assertFalse(auth.stats_permission)
        self.assertIsInstance(res, django.http.HttpResponseRedirect)
        # A management log entry should have been created.
        management_logs = model.ApiKeyManagementLog.all()
        self.assertEqual(1, management_logs.count())
        management_log = management_logs[0]
        self.assertEqual(management_log.repo, 'haiti')
        self.assertEqual(management_log.api_key, auth.api_key)
        self.assertEqual(
            management_log.action, model.ApiKeyManagementLog.CREATE)
        self.assertEqual(management_log.ip_address, '11.22.33.44')
        self.assertTrue('Creed' in management_log.key_state)
        # The user should be redirected to the form with the log key in a GET
        # parameter.
        self.assertEqual(
            res.url,
            'https://testserver/haiti/admin/api_keys?repo=haiti&log_key=%s' %
            management_log.key())

    def test_update_key(self):
        """"""Tests POST request to update an existing key.""""""
        self.authorization = add_test_authorization()
        params = {
            'key': self.authorization.key(),
            'contact_name': 'Phyllis Vance',
            'contact_email': 'phyllis@fridge.com',
            'organization_name': 'Vance Refrigeration',
            'domain_write_permission': 'fridge.com',
            'read_permission': 'true',
            'full_read_permission': 'true',
            'search_permission': 'true',
            'subscribe_permission': 'true',
            'is_valid': 'true',
            'xsrf_token': self.xsrf_token('admin_api_keys'),
        }
        res = self.client.post(
            '/haiti/admin/api_keys/', data=params, secure=True,
            REMOTE_ADDR='11.22.33.44')
        # Check that the Authorization entity was updated correctly.
        auths = model.Authorization.all().filter('repo =', 'haiti')
        self.assertEqual(auths.count(), 1)
        auth = auths[0]
        self.assertEqual(auth.key(), self.authorization.key())
        # Check that changes were made.
        self.assertEqual(auth.contact_name, 'Phyllis Vance')
        self.assertEqual(auth.contact_email, 'phyllis@fridge.com')
        self.assertTrue(auth.subscribe_permission)
        # A management log entry should have been created.
        management_logs = model.ApiKeyManagementLog.all()
        self.assertEqual(1, management_logs.count())
        management_log = management_logs[0]
        self.assertEqual(management_log.repo, 'haiti')
        self.assertEqual(management_log.api_key, auth.api_key)
        self.assertEqual(
            management_log.action, model.ApiKeyManagementLog.UPDATE)
        self.assertEqual(management_log.ip_address, '11.22.33.44')
        self.assertTrue('Phyllis' in management_log.key_state)
        # The user should be redirected to the form with the log key in a GET
        # parameter.
        self.assertEqual(
            res.url,
            'https://testserver/haiti/admin/api_keys?repo=haiti&log_key=%s' %
            management_log.key())
/n/n/ntests/views/view_tests_base.py/n/n""""""Tools to help run tests against the Django app.""""""

import os
import unittest

import django
import django.test
from google.appengine.ext import testbed

import const
import utils

import scrape


class ViewTestsBase(unittest.TestCase):
    """"""A base class for tests for the Django app.""""""

    _USER_ID = 'k'

    def init_testbed_stubs(self):
        self.testbed.init_user_stub()

    def setUp(self):
        self.testbed = testbed.Testbed()
        self.testbed.activate()
        self.init_testbed_stubs()
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
        django.setup()
        django.test.utils.setup_test_environment()
        self.client = django.test.Client()
        self._xsrf_tool = utils.XsrfTool()

    def tearDown(self):
        self.testbed.deactivate()
        django.test.utils.teardown_test_environment()

    def login(self, is_admin=False):
        """"""Logs in the ""user"" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """"""
        self.testbed.setup_env(
            user_email='kay@mib.gov',
            user_id=ViewTestsBase._USER_ID,
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)

    def to_doc(self, response):
        """"""Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """"""
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)
/n/n/n",0
25,25,fa58bf0d37503c857be1a8cf533e8400d5cdbb6f,"/app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

AUTHORIZATION_PARAMS_LIST = [
    'contact_name',
    'contact_email',
    'organization_name',
    'domain_write_permission',
    'read_permission',
    'full_read_permission',
    'search_permission',
    'subscribe_permission',
    'mark_notes_reviewed',
    'believed_dead_permission',
    'stats_permission',
    'is_valid',
]

def to_authorization_params(param):
    ret = {}
    for param_name in AUTHORIZATION_PARAMS_LIST:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags,
                           xsrf_token=xsrf_tool.generate_token(
                               user.user_id(), 'admin_api_keys'))


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/n",1
76,76,95d81b6b99a2718be934743e7ba59a1842b273c3,"acl.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import app_identity
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """"""Secret.""""""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """"""Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """"""
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """"""Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """"""Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """"""Wraps text in minimal HTML tags.""""""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """"""Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """"""
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """"""Returns all the IP addressed comprised in a range.""""""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """"""Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """"""
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  app_id = app_identity.get_application_id()
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(app_id),
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """"""Returns True if the provided token is valid.""""""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """"""Adds ACL to the request handler to ensure only valid users can use
  the handlers.""""""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """"""Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message.""""""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """"""Verifies if the IP is whitelisted.""""""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """"""Verifies if the user is whitelisted.""""""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """"""Ensures the token is valid.""""""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """"""Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """"""Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name=""whitelist"" method=""post"">'
      'Domain: <input type=""text"" name=""domain"" /><br />'
      '<input type=""hidden"" name=""token"" value=""%s"" />'
      '<input type=""submit"" value=""SUBMIT"" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """"""Returns the token.""""""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """"""Adds example.com as a valid domain when testing.""""""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')
/n/n/n",0
77,77,95d81b6b99a2718be934743e7ba59a1842b273c3,"/acl.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.
# Use of this source code is governed by the Apache v2.0 license that can be
# found in the LICENSE file.

import base64
import datetime
import hashlib
import logging
import os
import re
import time

# The app engine headers are located locally, so don't worry about not finding
# them.
# pylint: disable=E0611,F0401
import webapp2
from google.appengine.api import users
from google.appengine.ext import ndb
# pylint: enable=E0611,F0401

import template


### Models


class GlobalSecret(ndb.Model):
  """"""Secret.""""""
  secret = ndb.BlobProperty()

  def _pre_put_hook(self):
    """"""Generates random data only when necessary.

    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of
    random data on every process startup, which is unnecessary.
    """"""
    self.secret = self.secret or os.urandom(16)


class WhitelistedIP(ndb.Model):
  """"""Items where the IP address is allowed.

  The key is the ip as returned by ip_to_str(*parse_ip(ip)).
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)

  # This is used for sharing token. Use case: a slave are multiple HTTP proxies
  # which different public IP used in a round-robin fashion, so the slave looks
  # like a different IP at each request, but reuses the original token.
  group = ndb.StringProperty(indexed=False)

  # The textual representation of the IP of the machine to whitelist. Not used
  # in practice, just there since the canonical representation is hard to make
  # sense of.
  ip = ndb.StringProperty(indexed=False)

  # Is only for maintenance purpose.
  comment = ndb.StringProperty(indexed=False)


class WhitelistedDomain(ndb.Model):
  """"""Domain from which users can use the isolate server.

  The key is the domain name, like 'example.com'.
  """"""
  # Logs who made the change.
  timestamp = ndb.DateTimeProperty(auto_now=True)
  who = ndb.UserProperty(auto_current_user=True)


### Utility


_GLOBAL_KEY = 'global'


def htmlwrap(text):
  """"""Wraps text in minimal HTML tags.""""""
  return '<html><body>%s</body></html>' % text


def parse_ip(ipstr):
  """"""Returns a long number representing the IP and its type, 'v4' or 'v6'.

  This works around potentially different representations of the same value,
  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.
  """"""
  if '.' in ipstr:
    # IPv4.
    try:
      values = [int(i) for i in ipstr.split('.')]
    except ValueError:
      return None, None
    if len(values) != 4 or not all(0 <= i <= 255 for i in values):
      return None, None
    factor = 256
    iptype = 'v4'
  else:
    # IPv6.
    try:
      values = [int(i, 16) for i in ipstr.split(':')]
    except ValueError:
      return None, None
    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):
      return None, None
    factor = 65536
    iptype = 'v6'
  value = 0L
  for i in values:
    value = value * factor + i
  return iptype, value


def ip_to_str(iptype, ipvalue):
  if not iptype:
    return None
  return '%s-%d' % (iptype, ipvalue)


def ipv4_to_int(ip):
  values = [int(i) for i in ip.split('.')]
  factor = 256
  value = 0L
  for i in values:
    value = value * factor + i
  return value


def int_to_ipv4(integer):
  values = []
  factor = 256
  for _ in range(4):
    values.append(integer % factor)
    integer = integer / factor
  return '.'.join(str(i) for i in reversed(values))


def expand_subnet(ip, mask):
  """"""Returns all the IP addressed comprised in a range.""""""
  if mask == 32:
    return [ip]
  bit = 1 << (32 - mask)
  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]


def gen_token(access_id, offset, now):
  """"""Returns a valid token for the access_id.

  |offset| is the offset versus current time of day, in hours. It should be 0
  or -1.
  """"""
  assert offset <= 0
  # Rotate every hour.
  this_hour = int(now / 3600.)
  timestamp = str(this_hour + offset)
  version = os.environ['CURRENT_VERSION_ID']
  secrets = (
      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,
      str(access_id),
      str(version),
      timestamp)
  hashed = hashlib.sha1('\0'.join(secrets)).digest()
  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp


def is_valid_token(provided_token, access_id, now):
  """"""Returns True if the provided token is valid.""""""
  token_0 = gen_token(access_id, 0, now)
  if provided_token != token_0:
    token_1 = gen_token(access_id, -1, now)
    if provided_token != token_1:
      logging.info(
          'Token was invalid:\nGot %s\nExpected %s or %s\nAccessId: %s',
          provided_token, token_0, token_1, access_id)
      return False
  return True


### Handlers


class ACLRequestHandler(webapp2.RequestHandler):
  """"""Adds ACL to the request handler to ensure only valid users can use
  the handlers.""""""
  # Set to the uniquely identifiable token, either the userid or the IP address.
  access_id = None
  # Set to False if custom processing is required. In that case, a call to
  # self.enforce_valid_token() is required inside the post() handler.
  enforce_token_on_post = True

  def dispatch(self):
    """"""Ensures that only users from valid domains can continue, and that users
    from invalid domains receive an error message.""""""
    current_user = users.get_current_user()
    if current_user:
      self.check_user(current_user)
    else:
      self.check_ip(self.request.remote_addr)
    if self.request.method == 'POST' and self.enforce_token_on_post:
      self.enforce_valid_token()
    return webapp2.RequestHandler.dispatch(self)

  def check_ip(self, ip):
    """"""Verifies if the IP is whitelisted.""""""
    self.access_id = ip
    iptype, ipvalue = parse_ip(ip)
    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))
    if not whitelisted:
      logging.warning('Blocking IP %s', ip)
      self.abort(401, detail='Please login first.')
    if whitelisted.group:
      # Any member of of the group can impersonate others. This is to enable
      # support for slaves behind proxies with multiple IPs.
      self.access_id = whitelisted.group

  def check_user(self, user):
    """"""Verifies if the user is whitelisted.""""""
    domain = user.email().partition('@')[2]
    if (not WhitelistedDomain.get_by_id(domain) and
        not users.is_current_user_admin()):
      logging.warning('Disallowing %s, invalid domain' % user.email())
      self.abort(403, detail='Invalid domain, %s' % domain)
    # user_id() is only set with Google accounts, fallback to the email address
    # otherwise.
    self.access_id = user.user_id() or user.email()

  def get_token(self, offset, now):
    return gen_token(self.access_id, offset, now)

  def enforce_valid_token(self):
    """"""Ensures the token is valid.""""""
    token = self.request.get('token')
    if not token:
      logging.info('Token was not provided')
      self.abort(403)
    if not is_valid_token(token, self.access_id, time.time()):
      self.abort(403, detail='Invalid token.')


class RestrictedWhitelistIPHandler(ACLRequestHandler):
  """"""Whitelists the current IP.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    data = {
      'default_comment': '',
      'default_group': '',
      'default_ip': self.request.remote_addr,
      'note': '',
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    comment = self.request.get('comment')
    group = self.request.get('group')
    ip = self.request.get('ip')
    if not comment:
      self.abort(403, 'Comment is required.')
    mask = 32
    if '/' in ip:
      ip, mask = ip.split('/', 1)
      mask = int(mask)

    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):
      self.abort(403, 'IP is invalid')

    note = []
    for i in expand_subnet(ip, mask):
      key = ip_to_str(*parse_ip(i))
      item = WhitelistedIP.get_by_id(key)
      item_comment = comment
      if mask != 32:
        item_comment += ' ' + self.request.get('ip')
      if item:
        item.comment = item_comment
        item.group = group
        item.ip = i
        item.put()
        note.append('Already present: %s' % i)
      else:
        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()
        note.append('Success: %s' % i)

    data = {
      'default_comment': self.request.get('comment'),
      'default_group': self.request.get('group'),
      'default_ip': self.request.get('ip'),
      'note': '<br>'.join(note),
      'now': datetime.datetime.utcnow(),
      'token': self.get_token(0, time.time()),
      'whitelistips': WhitelistedIP.query(),
    }
    self.response.out.write(template.get('whitelistip.html').render(data))
    self.response.headers['Content-Type'] = 'text/html'


class RestrictedWhitelistDomainHandler(ACLRequestHandler):
  """"""Whitelists a domain.

  This handler must have login:admin in app.yaml.
  """"""
  def get(self):
    # The user must authenticate with a user credential before being able to
    # whitelist the IP. This is done with login:admin.
    self.response.out.write(htmlwrap(
      '<form name=""whitelist"" method=""post"">'
      'Domain: <input type=""text"" name=""domain"" /><br />'
      '<input type=""hidden"" name=""token"" value=""%s"" />'
      '<input type=""submit"" value=""SUBMIT"" />' %
        self.get_token(0, time.time())))
    self.response.headers['Content-Type'] = 'text/html'

  def post(self):
    domain = self.request.get('domain')
    if not re.match(r'^[a-z\.\-]+$', domain):
      self.abort(403, 'Invalid domain format')
    # Do not use get_or_insert() right away so we know if the entity existed
    # before.
    if not WhitelistedDomain.get_by_id(domain):
      WhitelistedDomain.get_or_insert(domain)
      self.response.out.write(htmlwrap('Success: %s' % domain))
    else:
      self.response.out.write(htmlwrap('Already present: %s' % domain))
    self.response.headers['Content-Type'] = 'text/html'


class GetTokenHandler(ACLRequestHandler):
  """"""Returns the token.""""""
  def get(self):
    self.response.headers['Content-Type'] = 'text/plain'
    token = self.get_token(0, time.time())
    self.response.out.write(token)
    logging.info('Generated %s\nAccessId: %s', token, self.access_id)


def bootstrap():
  """"""Adds example.com as a valid domain when testing.""""""
  if os.environ['SERVER_SOFTWARE'].startswith('Development'):
    WhitelistedDomain.get_or_insert('example.com')
    WhitelistedIP.get_or_insert(
        ip_to_str('v4', 2130706433),
        ip='127.0.0.1',
        comment='automatic because of running on dev server')
/n/n/n",1
70,70,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
71,71,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
52,52,a1548fa1586bce586c9cf06bf8dd7bf26cc6c212,"cornice/tests/test_validation.py/n/n# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the ""License""); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an ""AS IS"" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Cornice (Sagrada)
#
# The Initial Developer of the Original Code is the Mozilla Foundation.
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Tarek Ziade (tarek@mozilla.com)
#   Alexis Metaireau (alexis@mozilla.com)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the ""GPL""), or
# the GNU Lesser General Public License Version 2.1 or later (the ""LGPL""),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
import unittest
import simplejson as json

from webtest import TestApp
from pyramid.response import Response

from cornice.tests.validationapp import main, _json
from cornice.tests.support import LoggingCatcher
from cornice.schemas import Errors
from cornice.validators import filter_json_xsrf


class TestServiceDefinition(LoggingCatcher, unittest.TestCase):

    def test_validation(self):
        app = TestApp(main({}))
        app.get('/service', status=400)

        res = app.post('/service', params='buh', status=400)
        self.assertTrue('Not a json body' in res.body)

        res = app.post('/service', params=json.dumps('buh'))

        self.assertEqual(res.body, json.dumps({'body': '""buh""'}))

        app.get('/service?paid=yup')

        # valid = foo is one
        res = app.get('/service?foo=1&paid=yup')
        self.assertEqual(res.json['foo'], 1)

        # invalid value for foo
        res = app.get('/service?foo=buh&paid=yup', status=400)

        # check that json is returned
        errors = Errors.from_json(res.body)
        self.assertEqual(len(errors), 1)

        # the ""apidocs"" registry entry contains all the needed information
        # to build up documentation
        # in this case, this means the function is registered and the argument
        # of the service are defined (e.g ""validator"" is set)
        apidocs = app.app.registry.settings['apidocs']

        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])

    def test_accept(self):
        # tests that the accept headers are handled the proper way
        app = TestApp(main({}))

        # requesting the wrong accept header should return a 406 ...
        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)

        # ... with the list of accepted content-types
        self.assertTrue('application/json' in res.json)
        self.assertTrue('text/json' in res.json)

        app.get('/service2', headers={'Accept': 'application/*'}, status=200)

        # it should also work with multiple Accept headers
        app.get('/service2', headers={'Accept': 'audio/*, application/*'},
                status=200)

        # test that using a callable to define what's accepted works as well
        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)
        self.assertTrue('text/json' in res.json)

        app.get('/service3', headers={'Accept': 'text/*'}, status=200)

        # if we are not asking for a particular content-type, everything
        # should work just fine
        app.get('/service2', status=200)

    def test_filters(self):
        app = TestApp(main({}))

        # filters can be applied to all the methods of a service
        self.assertTrue(""filtered response"" in app.get('/filtered').body)
        self.assertTrue(""unfiltered"" in app.post('/filtered').body)

    def test_json_xsrf(self):
        # a view returning a json list should issue a warning
        resp = Response(json.dumps(('value1', 'value2')))
        resp.status = 200
        resp.content_type = 'application/json'
        filter_json_xsrf(resp)
        self.assertEquals(len(self.get_logs()), 1)
/n/n/ncornice/validators.py/n/nimport logging
import re

log = logging.getLogger('cornice')


def filter_json_xsrf(response):
    """"""drops a warning if a service is returning a json array.

    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info
    on this
    """"""
    if response.content_type in ('application/json', 'text/json'):
        if re.match(r'[\(\[).*[\)\]]', response.body):
            log.warn(""returning a json array is a potential security whole, ""
                     ""please ensure you really want to do this. See ""
                     ""http://wiki.pylonshq.com/display/pylonsfaq/Warnings ""
                     ""for more info"")
    return response


DEFAULT_VALIDATORS = []
DEFAULT_FILTERS = [filter_json_xsrf, ]
/n/n/n",0
53,53,a1548fa1586bce586c9cf06bf8dd7bf26cc6c212,"/cornice/tests/test_validation.py/n/n# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the ""License""); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an ""AS IS"" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Cornice (Sagrada)
#
# The Initial Developer of the Original Code is the Mozilla Foundation.
# Portions created by the Initial Developer are Copyright (C) 2011
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Tarek Ziade (tarek@mozilla.com)
#   Alexis Metaireau (alexis@mozilla.com)
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the ""GPL""), or
# the GNU Lesser General Public License Version 2.1 or later (the ""LGPL""),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
import unittest
import simplejson as json

from webtest import TestApp
from cornice.tests.validationapp import main, _json
from cornice.schemas import Errors


class TestServiceDefinition(unittest.TestCase):

    def test_validation(self):
        app = TestApp(main({}))
        app.get('/service', status=400)

        res = app.post('/service', params='buh', status=400)
        self.assertTrue('Not a json body' in res.body)

        res = app.post('/service', params=json.dumps('buh'))

        self.assertEqual(res.body, json.dumps({'body': '""buh""'}))

        app.get('/service?paid=yup')

        # valid = foo is one
        res = app.get('/service?foo=1&paid=yup')
        self.assertEqual(res.json['foo'], 1)

        # invalid value for foo
        res = app.get('/service?foo=buh&paid=yup', status=400)

        # check that json is returned
        errors = Errors.from_json(res.body)
        self.assertEqual(len(errors), 1)

        # the ""apidocs"" registry entry contains all the needed information
        # to build up documentation
        # in this case, this means the function is registered and the argument
        # of the service are defined (e.g ""validator"" is set)
        apidocs = app.app.registry.settings['apidocs']

        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])

    def test_accept(self):
        # tests that the accept headers are handled the proper way
        app = TestApp(main({}))

        # requesting the wrong accept header should return a 406 ...
        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)

        # ... with the list of accepted content-types
        self.assertTrue('application/json' in res.json)
        self.assertTrue('text/json' in res.json)

        app.get('/service2', headers={'Accept': 'application/*'}, status=200)

        # it should also work with multiple Accept headers
        app.get('/service2', headers={'Accept': 'audio/*, application/*'},
                status=200)

        # test that using a callable to define what's accepted works as well
        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)
        self.assertTrue('text/json' in res.json)

        app.get('/service3', headers={'Accept': 'text/*'}, status=200)

        # if we are not asking for a particular content-type, everything
        # should work just fine
        app.get('/service2', status=200)

    def test_filters(self):
        app = TestApp(main({}))

        # filters can be applied to all the methods of a service
        self.assertTrue(""filtered response"" in app.get('/filtered').body)
        self.assertTrue(""unfiltered"" in app.post('/filtered').body)
/n/n/n/cornice/validators.py/n/nimport json
import logging

log = logging.getLogger(__name__)


def filter_json_xsrf(response):
    """"""drops a warning if a service is returning a json array.

    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info
    on this
    """"""
    if response.content_type in ('application/json', 'text/json'):
        try:
            content = json.loads(response.body)
            if isinstance(content, (list, tuple)):
                log.warn(""returning a json array is a potential security whole, ""
                         ""please ensure you really want to do this. See ""
                         ""http://wiki.pylonshq.com/display/pylonsfaq/Warnings ""
                         ""for more info"")
        except:
            pass
    return response


DEFAULT_VALIDATORS = []
DEFAULT_FILTERS = [filter_json_xsrf, ]
/n/n/n",1
30,30,75cf3c0885faa5fa19819b7d83d5bbe120a47fe3,"LikedSavedDownloaderServer.py/n/n#!/usr/bin/env python

import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.httpclient
import tornado.gen

import os
import random
import shutil
import json
import multiprocessing

from utilities import sort_naturally
import settings
import redditUserImageScraper

# Require a username and password in order to use the web interface. See ReadMe.org for details.
enable_authentication = False
#enable_authentication = True

if enable_authentication:
    import PasswordManager

# List of valid user ids (used to compare user cookie)
authenticated_users = []

videoExtensions = ('.mp4', '.webm')
supportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')

savedImagesCache = []
def generateSavedImagesCache(outputDir):
    global savedImagesCache
    # Clear cache in case already created
    savedImagesCache = []

    print('Creating Liked Saved cache...')
    
    for root, dirs, files in os.walk(outputDir):
        for file in files:
            if file.endswith(supportedExtensions):
                savedImagesCache.append(os.path.join(root, file))

    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))

def outputPathToServerPath(path):
    # This is a little weird
    return 'output' + path.split(settings.settings['Output_dir'])[1]

def getRandomImage(filteredImagesCache=None, randomImageFilter=''):
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])

    if filteredImagesCache:
        randomImage = random.choice(filteredImagesCache)
    else:
        randomImage = random.choice(savedImagesCache)

    print('\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))

    serverPath = outputPathToServerPath(randomImage)

    return randomImage, serverPath

#
# Tornado handlers
#

# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py
# https://www.tornadoweb.org/en/stable/guide/security.html

def login_get_current_user(handler):
    if enable_authentication:
        cookie = handler.get_secure_cookie(""user"")
        if cookie in authenticated_users:
            return cookie
        else:
            print(""Bad/expired cookie received"")
            return None
    else:
        return ""authentication_disabled""

class AuthHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
class LoginHandler(AuthHandler):
    def get(self):
        if not enable_authentication:
            self.redirect(""/"")
        else:
            self.write('<html>'
                       '<head>'
	               '<title>Liked Saved Downloader</title>'
	               '<link rel=""stylesheet"" type=""text/css"" href=""webInterfaceNoAuth/index.css"">'
                       '</head>'
                       '<body><h1>Login Required</h1>'
                       '<form action=""/login"" method=""post"">'
                       'Name: <input type=""text"" name=""name""><br />'
                       'Password: <input type=""password"" name=""password"">'
                       '{}'
                       '<br /><input type=""submit"" value=""Sign in"">'
                       '</form></body></html>'.format(self.xsrf_form_html()))

    def post(self):
        global authenticated_users
        # Test password
        if enable_authentication and PasswordManager.verify(self.get_argument(""password"")):
            # Generate new authenticated user session
            randomGenerator = random.SystemRandom()
            cookieSecret = str(randomGenerator.getrandbits(128))
            authenticated_user = self.get_argument(""name"") + ""_"" + cookieSecret
            authenticated_user = authenticated_user.encode()
            authenticated_users.append(authenticated_user)
            
            # Set the cookie on the user's side
            self.set_secure_cookie(""user"", authenticated_user)
            
            print(""Authenticated user {}"".format(self.get_argument(""name"")))
            
            # Let them in
            self.redirect(""/"")
        else:
            print(""Refused user {} (password doesn't match any in database)"".format(self.get_argument(""name"")))
            self.redirect(""/login"")
            
class LogoutHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        global authenticated_users
        
        if enable_authentication:
            print(""User {} logging out"".format(self.current_user))
            if self.current_user in authenticated_users:
                authenticated_users.remove(self.current_user)
            self.redirect(""/login"")
        else:
            self.redirect(""/"")

class AuthedStaticHandler(tornado.web.StaticFileHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
    @tornado.web.authenticated
    def prepare(self):
        pass

class HomeHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        self.render('webInterface/index.html')

def settingsToHtmlForm():
    settingsInputs = []

    for sectionSettingsPair in settings.settingsStructure:
        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))

        for sectionOption in sectionSettingsPair[1]:
            option = None
            optionComment = ''
            if type(sectionOption) == tuple:
                option = sectionOption[0]
                optionComment = '<p class=""optionComment"">{}</p>'.format(sectionOption[1])
            else:
                option = sectionOption
                
            if type(settings.settings[option]) == bool:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""checkbox"" id=""{option}"" name=""{option}"" value=""{optionValue}"" {checkedState} />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment,
                                              checkedState=('checked' if settings.settings[option] else ''),
                                              optionValue=('1' if settings.settings[option] else '0')))
                
            elif type(settings.settings[option]) == int:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""number"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,
                                              optionValue=settings.settings[option]))
                
            elif type(settings.settings[option]) == str:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""{type}"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment, optionValue=settings.settings[option],
                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))

    return ''.join(settingsInputs)

class SettingsHandler(AuthHandler):
    def doSettings(self, afterSubmit):
        htmlSettingsForm = settingsToHtmlForm()
        settingsFilename = settings.getSettingsFilename()
        
        self.write('''<html>
                            <head>
                                  <link rel=""stylesheet"" type=""text/css"" href=""webInterface/settings.css"">
                                  <script type=""text/javascript"" src=""webInterface/settings.js""></script>
                            </head>
                            <body>
                                  <h1>Liked Saved Downloader Settings</h1>
                                  <a href=""/"">Back to Homepage</a><br /><br />
                                  {}
                                  <p>Settings being read from {}</p>
                                  <form action=""/settings"" method=""post"">
                                       <input type=""submit"" value=""Submit"">
                                       {}
                                       <input type=""submit"" value=""Submit"">
                                       {}
                                  </form>
                            </body>
                      </html>'''
                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),
                           settingsFilename, htmlSettingsForm, self.xsrf_form_html()))

    @tornado.web.authenticated
    def get(self):
        self.doSettings(False)

    @tornado.web.authenticated
    def post(self):
        currentOutputDir = settings.settings['Output_dir']
        
        print('Received new settings')
        
        for option in settings.settings:
            newValue = self.get_argument(option, None)
            if not newValue:
                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes
                # This means the user set the value to false
                if type(settings.settings[option]) == bool:
                    settings.settings[option] = False
                else:
                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'
                          '\n\tIgnore this if the field is intentionally empty'.format(option))
            else:
                # All false bools are handed in the above if block, so we know they're true here
                if type(settings.settings[option]) == bool:
                    newValue = True
                elif type(settings.settings[option]) == int:
                    newValue = int(newValue)
                
                settings.settings[option] = newValue
                # print('\tSet {} = {}'.format(option, newValue))

        # Write out the new settings
        settings.writeServerSettings()
        
        # Respond with a settings page saying we've updated the settings
        self.doSettings(True)

        # Refresh the cache in case the output directory changed
        if currentOutputDir != settings.settings['Output_dir']:
            generateSavedImagesCache(settings.settings['Output_dir'])
            

class RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):
    connections = set()

    def cacheFilteredImages(self):
        # Clear the cache
        self.filteredImagesCache = []

        if not self.randomImageFilter:
            return

        randomImageFilterLower = self.randomImageFilter.lower()
    
        for imagePath in savedImagesCache:
            if randomImageFilterLower in imagePath.lower():
                self.filteredImagesCache.append(imagePath)

        print('\tFiltered images with ""{}""; {} images matching filter'
              .format(self.randomImageFilter, len(self.filteredImagesCache)))

    def changeCurrentDirectory(self, newDirectory):
        self.currentDirectoryPath = newDirectory
        dirList = os.listdir(self.currentDirectoryPath)
        
        filteredDirList = []
        for fileOrDir in dirList:
            # The script spits out a lot of .json files the user probably doesn't want to see
            if (not fileOrDir.endswith('.json')
                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):
                filteredDirList.append(fileOrDir)
                
        self.currentDirectoryCache = sorted(filteredDirList)

    def open(self):
        if not login_get_current_user(self):
            return None
        
        self.connections.add(self)
        self.randomHistory = []
        self.randomHistoryIndex = -1
        self.favorites = []
        self.favoritesIndex = 0
        self.currentImage = None
        self.randomImageFilter = ''
        self.filteredImagesCache = []
        
        self.currentDirectoryPath = ''
        self.currentDirectoryCache = []
        self.directoryFilter = ''
        # Set up the directory cache with the top-level output
        self.changeCurrentDirectory(settings.settings['Output_dir'])

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RandomImageBrowserWebSocket: Received message ', message)
        parsedMessage = json.loads(message)
        command = parsedMessage['command']
        print('RandomImageBrowserWebSocket: Command ', command)
        action = ''

        """"""
         Random Image Browser
        """"""

        if command == 'imageAddToFavorites':
            if self.currentImage:
                self.favorites.append(self.currentImage)
                self.favoritesIndex = len(self.favorites) - 1

        if command == 'nextFavorite':
            self.favoritesIndex += 1
            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):
                action = 'setImage'
                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]
            else:
                self.favoritesIndex = len(self.favorites) - 1
                if len(self.favorites):
                    action = 'setImage'
                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'previousFavorite' and len(self.favorites):
            action = 'setImage'

            if self.favoritesIndex > 0:
                self.favoritesIndex -= 1
                
            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'nextImage':
            action = 'setImage'

            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:
                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)
                self.randomHistory.append((fullImagePath, serverImagePath))
                self.randomHistoryIndex = len(self.randomHistory) - 1
            else:
                self.randomHistoryIndex += 1
                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command == 'previousImage':
            action = 'setImage'

            if self.randomHistoryIndex > 0:
                self.randomHistoryIndex -= 1
                
            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):
            fullImagePath, serverImagePath = self.currentImage
                
            folder = fullImagePath[:fullImagePath.rfind('/')]
            imagesInFolder = []
            for root, dirs, files in os.walk(folder):
                for file in files:
                    if file.endswith(supportedExtensions):
                        imagesInFolder.append(os.path.join(root, file))
            sort_naturally(imagesInFolder)
            currentImageIndex = imagesInFolder.index(fullImagePath)
            if currentImageIndex >= 0:
                action = 'setImage'
                
                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)
                if nextImageIndex == len(imagesInFolder):
                    nextImageIndex = 0
                if nextImageIndex < 0:
                    nextImageIndex = len(imagesInFolder) - 1
                    
                fullImagePath = imagesInFolder[nextImageIndex]
                serverImagePath = outputPathToServerPath(fullImagePath)

        if command == 'setFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.randomImageFilter:
                self.randomImageFilter = newFilter
                self.cacheFilteredImages()

        """"""
         Directory browser
        """"""

        if command == 'setDirectoryFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.directoryFilter:
                self.directoryFilter = newFilter
                # Refresh cache with new filter
                self.changeCurrentDirectory(self.currentDirectoryPath)
                action = 'sendDirectory'

        if command == 'listCurrentDirectory':
            action = 'sendDirectory'

        if command == 'changeDirectory':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));
            action = 'sendDirectory'

        if command == 'directoryUp':
            # Don't allow going higher than output dir
            if self.currentDirectoryPath != settings.settings['Output_dir']:
                upDirectory = (settings.settings['Output_dir']  +
                               self.currentDirectoryPath[len(settings.settings['Output_dir'])
                                                         : self.currentDirectoryPath.rfind('/')])
                # Reset the filter (chances are the user only wanted to filter at one level
                self.directoryFilter = ''
                self.changeCurrentDirectory(upDirectory)
                action = 'sendDirectory'
            
        if command == 'directoryRoot':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory(settings.settings['Output_dir'])
            action = 'sendDirectory'

        """"""
         Actions
        """"""

        # Only send a response if needed
        if action == 'setImage':
            # Stupid hack
            if serverImagePath.endswith(videoExtensions):
                action = 'setVideo'
                
            self.currentImage = (fullImagePath, serverImagePath)
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""fullImagePath"":""{}"", ""serverImagePath"":""{}""}}'
                               .format(command, action, fullImagePath, serverImagePath))
            self.write_message(responseMessage)

        if action == 'sendDirectory':
            directoryList = ''
            for path in self.currentDirectoryCache:
                isSupportedFile = path.endswith(supportedExtensions)
                isFile = '.' in path
                if path.endswith(videoExtensions):
                    fileType = 'video'
                elif isSupportedFile:
                    fileType = 'image'
                elif isFile:
                    fileType = 'file'
                else:
                    fileType = 'dir'
                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path
                directoryList += '{{""path"":""{}"", ""type"":""{}"", ""serverPath"":""{}""}},'.format(path, fileType, serverPath)

            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""directoryList"":[{}]}}'
                               .format(command, action, directoryList[:-1]))
            self.write_message(responseMessage)
            

    def on_close(self):
        self.connections.remove(self)

scriptPipeConnection = None
scriptProcess = None

def startScript():
    global scriptPipeConnection, scriptProcess
    
    # Script already running
    if scriptProcess and scriptProcess.is_alive():
        return
    
    scriptPipeConnection, childConnection = multiprocessing.Pipe()
    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,
                                            args=(childConnection,))
    scriptProcess.start()

runScriptWebSocketConnections = set()
class RunScriptWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        if not login_get_current_user(self):
            return None
        
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.add(self)

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RunScriptWebSocket: Received message ', message)

        parsedMessage = json.loads(message)
        command = parsedMessage['command']

        print('RunScriptWebSocket: Command ', command)
        
        if command == 'runScript':
            if scriptProcess and scriptProcess.is_alive():
                print('RunScriptWebSocket: Script already running')
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Script already running\\n', 'printMessage'))
                self.write_message(responseMessage)
                
            else:
                print('RunScriptWebSocket: Starting script')

                startScript()
                
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Running script\\n', 'printMessage'))
                self.write_message(responseMessage)

    def on_close(self):
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.remove(self)

def updateScriptStatus():
    # If no pipe or no data to receive from pipe, we're done
    # Poll() is non-blocking whereas recv is blocking
    if (not runScriptWebSocketConnections
        or not scriptPipeConnection
        or not scriptPipeConnection.poll()):
        return

    pipeOutput = scriptPipeConnection.recv()
    if pipeOutput:
        responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                           .format(pipeOutput.replace('\n', '\\n').replace('\t', ''),
                                   'printMessage'))
        
        for client in runScriptWebSocketConnections:
            client.write_message(responseMessage)

        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:
            # Script finished; refresh image cache
            print('Refreshing cache due to script finishing')
            generateSavedImagesCache(settings.settings['Output_dir'])
            responseMessage = ('{{""action"":""{}""}}'
                               .format('scriptFinished'))
            
            for client in runScriptWebSocketConnections:
                client.write_message(responseMessage)

            scriptPipeConnection.close()

#
# Startup
#

def make_app():
    # Each time the server starts up, invalidate all cookies
    randomGenerator = random.SystemRandom()
    cookieSecret = str(randomGenerator.getrandbits(128))
    
    return tornado.web.Application([
        # Home page
        (r'/', HomeHandler),
        
        # Login
        (r'/login', LoginHandler),
        (r'/logout', LogoutHandler),

        # Configure the script
        (r'/settings', SettingsHandler),

        # Handles messages for run script
        (r'/runScriptWebSocket', RunScriptWebSocket),

        # Handles messages for randomImageBrowser
        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),

        # Static files
        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),
        # Don't change this ""output"" here without changing the other places as well
        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),

        # Files served regardless of whether the user is authenticated. Only login page resources
        # should be in this folder, because anyone can see them
        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),
    ],
                                   xsrf_cookies=True,
                                   cookie_secret=cookieSecret,
                                   login_url=""/login"")

if __name__ == '__main__':
    print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
    
    print('Loading settings...')
    settings.getSettings()

    print('Liked Saved output directory: ' + settings.settings['Output_dir'])
    if not settings.settings['Output_dir']:
        print('WARNING: No output directory specified! This will probably break things')
    
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])
    
    port = 8888
    print('\nStarting LikedSavedDownloader Server on port {}...'.format(port))
    app = make_app()

    # Generating a self-signing certificate:
    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem
    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)
    # I then had to tell Firefox to trust this certificate even though it is self-signing (because
    # I want a free certificate for this non-serious project)
    useSSL = True
    if useSSL:
        app.listen(port, ssl_options={""certfile"":""certificates/server_jupyter_based.crt.pem"",
                                      ""keyfile"":""certificates/server_jupyter_based.crt.key""})
    else:
        # Show the warning only if SSL is not enabled
        print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
        app.listen(port)
        
    ioLoop = tornado.ioloop.IOLoop.current()
    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)
    updateStatusCallback.start()
    ioLoop.start()
/n/n/n",0
31,31,75cf3c0885faa5fa19819b7d83d5bbe120a47fe3,"/LikedSavedDownloaderServer.py/n/n#!/usr/bin/env python

import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.httpclient
import tornado.gen

import os
import random
import shutil
import json
import multiprocessing

from utilities import sort_naturally
import settings
import redditUserImageScraper

# Require a username and password in order to use the web interface. See ReadMe.org for details.
enable_authentication = False
#enable_authentication = True

if enable_authentication:
    import PasswordManager

# List of valid user ids (used to compare user cookie)
authenticated_users = []

videoExtensions = ('.mp4', '.webm')
supportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')

savedImagesCache = []
def generateSavedImagesCache(outputDir):
    global savedImagesCache
    # Clear cache in case already created
    savedImagesCache = []

    print('Creating Liked Saved cache...')
    
    for root, dirs, files in os.walk(outputDir):
        for file in files:
            if file.endswith(supportedExtensions):
                savedImagesCache.append(os.path.join(root, file))

    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))

def outputPathToServerPath(path):
    # This is a little weird
    return 'output' + path.split(settings.settings['Output_dir'])[1]

def getRandomImage(filteredImagesCache=None, randomImageFilter=''):
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])

    if filteredImagesCache:
        randomImage = random.choice(filteredImagesCache)
    else:
        randomImage = random.choice(savedImagesCache)

    print('\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))

    serverPath = outputPathToServerPath(randomImage)

    return randomImage, serverPath

#
# Tornado handlers
#

# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py
# https://www.tornadoweb.org/en/stable/guide/security.html

def login_get_current_user(handler):
    if enable_authentication:
        cookie = handler.get_secure_cookie(""user"")
        if cookie in authenticated_users:
            return cookie
        else:
            print(""Bad/expired cookie received"")
            return None
    else:
        return ""authentication_disabled""

class AuthHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
class LoginHandler(AuthHandler):
    def get(self):
        if not enable_authentication:
            self.redirect(""/"")
        else:
            self.write('<html>'
                       '<head>'
	               '<title>Liked Saved Downloader</title>'
	               '<link rel=""stylesheet"" type=""text/css"" href=""webInterfaceNoAuth/index.css"">'
                       '</head>'
                       '<body><h1>Login Required</h1>'
                       '<form action=""/login"" method=""post"">'
                       'Name: <input type=""text"" name=""name""><br />'
                       'Password: <input type=""password"" name=""password"">'
                       '{}'
                       '<br /><input type=""submit"" value=""Sign in"">'
                       '</form></body></html>'.format(self.xsrf_form_html()))

    def post(self):
        global authenticated_users
        # Test password
        if enable_authentication and PasswordManager.verify(self.get_argument(""password"")):
            # Generate new authenticated user session
            randomGenerator = random.SystemRandom()
            cookieSecret = str(randomGenerator.getrandbits(128))
            authenticated_user = self.get_argument(""name"") + ""_"" + cookieSecret
            authenticated_user = authenticated_user.encode()
            authenticated_users.append(authenticated_user)
            
            # Set the cookie on the user's side
            self.set_secure_cookie(""user"", authenticated_user)
            
            print(""Authenticated user {}"".format(self.get_argument(""name"")))
            
            # Let them in
            self.redirect(""/"")
        else:
            print(""Refused user {} (password doesn't match any in database)"".format(self.get_argument(""name"")))
            self.redirect(""/login"")
            
class LogoutHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        global authenticated_users
        
        if enable_authentication:
            print(""User {} logging out"".format(self.current_user))
            if self.current_user in authenticated_users:
                authenticated_users.remove(self.current_user)
            self.redirect(""/login"")
        else:
            self.redirect(""/"")

class AuthedStaticHandler(tornado.web.StaticFileHandler):
    def get_current_user(self):
        return login_get_current_user(self)
    
    @tornado.web.authenticated
    def prepare(self):
        pass

class HomeHandler(AuthHandler):
    @tornado.web.authenticated
    def get(self):
        self.render('webInterface/index.html')

def settingsToHtmlForm():
    settingsInputs = []

    for sectionSettingsPair in settings.settingsStructure:
        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))

        for sectionOption in sectionSettingsPair[1]:
            option = None
            optionComment = ''
            if type(sectionOption) == tuple:
                option = sectionOption[0]
                optionComment = '<p class=""optionComment"">{}</p>'.format(sectionOption[1])
            else:
                option = sectionOption
                
            if type(settings.settings[option]) == bool:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""checkbox"" id=""{option}"" name=""{option}"" value=""{optionValue}"" {checkedState} />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment,
                                              checkedState=('checked' if settings.settings[option] else ''),
                                              optionValue=('1' if settings.settings[option] else '0')))
                
            elif type(settings.settings[option]) == int:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""number"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,
                                              optionValue=settings.settings[option]))
                
            elif type(settings.settings[option]) == str:
                settingsInputs.append('''<label for=""{option}"">{optionName}</label>
                                     <input type=""{type}"" id=""{option}"" name=""{option}"" value=""{optionValue}"" />{comment}
                                     <br />'''
                                      .format(option=option, optionName=option.replace('_', ' '),
                                              comment=optionComment, optionValue=settings.settings[option],
                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))

    return ''.join(settingsInputs)

class SettingsHandler(AuthHandler):
    def doSettings(self, afterSubmit):
        htmlSettingsForm = settingsToHtmlForm()
        settingsFilename = settings.getSettingsFilename()
        
        self.write('''<html>
                            <head>
                                  <link rel=""stylesheet"" type=""text/css"" href=""webInterface/settings.css"">
                                  <script type=""text/javascript"" src=""webInterface/settings.js""></script>
                            </head>
                            <body>
                                  <h1>Liked Saved Downloader Settings</h1>
                                  <a href=""/"">Back to Homepage</a><br /><br />
                                  {}
                                  <p>Settings being read from {}</p>
                                  <form action=""/settings"" method=""post"">
                                       <input type=""submit"" value=""Submit"">
                                       {}
                                       <input type=""submit"" value=""Submit"">
                                  </form>
                            </body>
                      </html>'''
                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),
                           settingsFilename, htmlSettingsForm))

    @tornado.web.authenticated
    def get(self):
        self.doSettings(False)

    @tornado.web.authenticated
    def post(self):
        currentOutputDir = settings.settings['Output_dir']
        
        print('Received new settings')
        
        for option in settings.settings:
            newValue = self.get_argument(option, None)
            if not newValue:
                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes
                # This means the user set the value to false
                if type(settings.settings[option]) == bool:
                    settings.settings[option] = False
                else:
                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'
                          '\n\tIgnore this if the field is intentionally empty'.format(option))
            else:
                # All false bools are handed in the above if block, so we know they're true here
                if type(settings.settings[option]) == bool:
                    newValue = True
                elif type(settings.settings[option]) == int:
                    newValue = int(newValue)
                
                settings.settings[option] = newValue
                # print('\tSet {} = {}'.format(option, newValue))

        # Write out the new settings
        settings.writeServerSettings()
        
        # Respond with a settings page saying we've updated the settings
        self.doSettings(True)

        # Refresh the cache in case the output directory changed
        if currentOutputDir != settings.settings['Output_dir']:
            generateSavedImagesCache(settings.settings['Output_dir'])
            

class RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):
    connections = set()

    def cacheFilteredImages(self):
        # Clear the cache
        self.filteredImagesCache = []

        if not self.randomImageFilter:
            return

        randomImageFilterLower = self.randomImageFilter.lower()
    
        for imagePath in savedImagesCache:
            if randomImageFilterLower in imagePath.lower():
                self.filteredImagesCache.append(imagePath)

        print('\tFiltered images with ""{}""; {} images matching filter'
              .format(self.randomImageFilter, len(self.filteredImagesCache)))

    def changeCurrentDirectory(self, newDirectory):
        self.currentDirectoryPath = newDirectory
        dirList = os.listdir(self.currentDirectoryPath)
        
        filteredDirList = []
        for fileOrDir in dirList:
            # The script spits out a lot of .json files the user probably doesn't want to see
            if (not fileOrDir.endswith('.json')
                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):
                filteredDirList.append(fileOrDir)
                
        self.currentDirectoryCache = sorted(filteredDirList)

    def open(self):
        if not login_get_current_user(self):
            return None
        
        self.connections.add(self)
        self.randomHistory = []
        self.randomHistoryIndex = -1
        self.favorites = []
        self.favoritesIndex = 0
        self.currentImage = None
        self.randomImageFilter = ''
        self.filteredImagesCache = []
        
        self.currentDirectoryPath = ''
        self.currentDirectoryCache = []
        self.directoryFilter = ''
        # Set up the directory cache with the top-level output
        self.changeCurrentDirectory(settings.settings['Output_dir'])

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RandomImageBrowserWebSocket: Received message ', message)
        parsedMessage = json.loads(message)
        command = parsedMessage['command']
        print('RandomImageBrowserWebSocket: Command ', command)
        action = ''

        """"""
         Random Image Browser
        """"""

        if command == 'imageAddToFavorites':
            if self.currentImage:
                self.favorites.append(self.currentImage)
                self.favoritesIndex = len(self.favorites) - 1

        if command == 'nextFavorite':
            self.favoritesIndex += 1
            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):
                action = 'setImage'
                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]
            else:
                self.favoritesIndex = len(self.favorites) - 1
                if len(self.favorites):
                    action = 'setImage'
                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'previousFavorite' and len(self.favorites):
            action = 'setImage'

            if self.favoritesIndex > 0:
                self.favoritesIndex -= 1
                
            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]

        if command == 'nextImage':
            action = 'setImage'

            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:
                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)
                self.randomHistory.append((fullImagePath, serverImagePath))
                self.randomHistoryIndex = len(self.randomHistory) - 1
            else:
                self.randomHistoryIndex += 1
                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command == 'previousImage':
            action = 'setImage'

            if self.randomHistoryIndex > 0:
                self.randomHistoryIndex -= 1
                
            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]

        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):
            fullImagePath, serverImagePath = self.currentImage
                
            folder = fullImagePath[:fullImagePath.rfind('/')]
            imagesInFolder = []
            for root, dirs, files in os.walk(folder):
                for file in files:
                    if file.endswith(supportedExtensions):
                        imagesInFolder.append(os.path.join(root, file))
            sort_naturally(imagesInFolder)
            currentImageIndex = imagesInFolder.index(fullImagePath)
            if currentImageIndex >= 0:
                action = 'setImage'
                
                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)
                if nextImageIndex == len(imagesInFolder):
                    nextImageIndex = 0
                if nextImageIndex < 0:
                    nextImageIndex = len(imagesInFolder) - 1
                    
                fullImagePath = imagesInFolder[nextImageIndex]
                serverImagePath = outputPathToServerPath(fullImagePath)

        if command == 'setFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.randomImageFilter:
                self.randomImageFilter = newFilter
                self.cacheFilteredImages()

        """"""
         Directory browser
        """"""

        if command == 'setDirectoryFilter':
            newFilter = parsedMessage['filter']
            if newFilter != self.directoryFilter:
                self.directoryFilter = newFilter
                # Refresh cache with new filter
                self.changeCurrentDirectory(self.currentDirectoryPath)
                action = 'sendDirectory'

        if command == 'listCurrentDirectory':
            action = 'sendDirectory'

        if command == 'changeDirectory':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));
            action = 'sendDirectory'

        if command == 'directoryUp':
            # Don't allow going higher than output dir
            if self.currentDirectoryPath != settings.settings['Output_dir']:
                upDirectory = (settings.settings['Output_dir']  +
                               self.currentDirectoryPath[len(settings.settings['Output_dir'])
                                                         : self.currentDirectoryPath.rfind('/')])
                # Reset the filter (chances are the user only wanted to filter at one level
                self.directoryFilter = ''
                self.changeCurrentDirectory(upDirectory)
                action = 'sendDirectory'
            
        if command == 'directoryRoot':
            # Reset the filter (chances are the user only wanted to filter at one level
            self.directoryFilter = ''
            self.changeCurrentDirectory(settings.settings['Output_dir'])
            action = 'sendDirectory'

        """"""
         Actions
        """"""

        # Only send a response if needed
        if action == 'setImage':
            # Stupid hack
            if serverImagePath.endswith(videoExtensions):
                action = 'setVideo'
                
            self.currentImage = (fullImagePath, serverImagePath)
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""fullImagePath"":""{}"", ""serverImagePath"":""{}""}}'
                               .format(command, action, fullImagePath, serverImagePath))
            self.write_message(responseMessage)

        if action == 'sendDirectory':
            directoryList = ''
            for path in self.currentDirectoryCache:
                isSupportedFile = path.endswith(supportedExtensions)
                isFile = '.' in path
                if path.endswith(videoExtensions):
                    fileType = 'video'
                elif isSupportedFile:
                    fileType = 'image'
                elif isFile:
                    fileType = 'file'
                else:
                    fileType = 'dir'
                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path
                directoryList += '{{""path"":""{}"", ""type"":""{}"", ""serverPath"":""{}""}},'.format(path, fileType, serverPath)

            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it
            responseMessage = ('{{""responseToCommand"":""{}"", ""action"":""{}"", ""directoryList"":[{}]}}'
                               .format(command, action, directoryList[:-1]))
            self.write_message(responseMessage)
            

    def on_close(self):
        self.connections.remove(self)

scriptPipeConnection = None
scriptProcess = None

def startScript():
    global scriptPipeConnection, scriptProcess
    
    # Script already running
    if scriptProcess and scriptProcess.is_alive():
        return
    
    scriptPipeConnection, childConnection = multiprocessing.Pipe()
    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,
                                            args=(childConnection,))
    scriptProcess.start()

runScriptWebSocketConnections = set()
class RunScriptWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        if not login_get_current_user(self):
            return None
        
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.add(self)

    def on_message(self, message):
        if not login_get_current_user(self):
            return None
        
        print('RunScriptWebSocket: Received message ', message)

        parsedMessage = json.loads(message)
        command = parsedMessage['command']

        print('RunScriptWebSocket: Command ', command)
        
        if command == 'runScript':
            if scriptProcess and scriptProcess.is_alive():
                print('RunScriptWebSocket: Script already running')
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Script already running\\n', 'printMessage'))
                self.write_message(responseMessage)
                
            else:
                print('RunScriptWebSocket: Starting script')

                startScript()
                
                responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                                   .format('Running script\\n', 'printMessage'))
                self.write_message(responseMessage)

    def on_close(self):
        global runScriptWebSocketConnections
        runScriptWebSocketConnections.remove(self)

def updateScriptStatus():
    # If no pipe or no data to receive from pipe, we're done
    # Poll() is non-blocking whereas recv is blocking
    if (not runScriptWebSocketConnections
        or not scriptPipeConnection
        or not scriptPipeConnection.poll()):
        return

    pipeOutput = scriptPipeConnection.recv()
    if pipeOutput:
        responseMessage = ('{{""message"":""{}"", ""action"":""{}""}}'
                           .format(pipeOutput.replace('\n', '\\n').replace('\t', ''),
                                   'printMessage'))
        
        for client in runScriptWebSocketConnections:
            client.write_message(responseMessage)

        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:
            # Script finished; refresh image cache
            print('Refreshing cache due to script finishing')
            generateSavedImagesCache(settings.settings['Output_dir'])
            responseMessage = ('{{""action"":""{}""}}'
                               .format('scriptFinished'))
            
            for client in runScriptWebSocketConnections:
                client.write_message(responseMessage)

            scriptPipeConnection.close()

#
# Startup
#

def make_app():
    # Each time the server starts up, invalidate all cookies
    randomGenerator = random.SystemRandom()
    cookieSecret = str(randomGenerator.getrandbits(128))
    
    return tornado.web.Application([
        # Home page
        (r'/', HomeHandler),
        
        # Login
        (r'/login', LoginHandler),
        (r'/logout', LogoutHandler),

        # Configure the script
        (r'/settings', SettingsHandler),

        # Handles messages for run script
        (r'/runScriptWebSocket', RunScriptWebSocket),

        # Handles messages for randomImageBrowser
        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),

        # Static files
        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),
        # Don't change this ""output"" here without changing the other places as well
        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),

        # Files served regardless of whether the user is authenticated. Only login page resources
        # should be in this folder, because anyone can see them
        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),
    ],
                                   xsrf_cookies=True,
                                   cookie_secret=cookieSecret,
                                   login_url=""/login"")

if __name__ == '__main__':
    print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
    
    print('Loading settings...')
    settings.getSettings()

    print('Liked Saved output directory: ' + settings.settings['Output_dir'])
    if not settings.settings['Output_dir']:
        print('WARNING: No output directory specified! This will probably break things')
    
    if not savedImagesCache:
        generateSavedImagesCache(settings.settings['Output_dir'])
    
    port = 8888
    print('\nStarting LikedSavedDownloader Server on port {}...'.format(port))
    app = make_app()

    # Generating a self-signing certificate:
    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem
    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)
    # I then had to tell Firefox to trust this certificate even though it is self-signing (because
    # I want a free certificate for this non-serious project)
    useSSL = True
    if useSSL:
        app.listen(port, ssl_options={""certfile"":""certificates/server_jupyter_based.crt.pem"",
                                      ""keyfile"":""certificates/server_jupyter_based.crt.key""})
    else:
        # Show the warning only if SSL is not enabled
        print('\n\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'
          ' nor when\n\t connected to an insecure LAN! It is not protected against malicious use.\n')
        app.listen(port)
        
    ioLoop = tornado.ioloop.IOLoop.current()
    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)
    updateStatusCallback.start()
    ioLoop.start()
/n/n/n",1
40,40,9573bdca55ddc5488066d3af525e41ed1d872ea6,"service/pixelated/resources/__init__.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import json

from twisted.web.http import UNAUTHORIZED
from twisted.web.resource import Resource

# from pixelated.resources.login_resource import LoginResource
from pixelated.resources.session import IPixelatedSession
from pixelated.support import log_time


class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return super(SetEncoder, self).default(obj)


def respond_json(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    return json_response


@log_time
def respond_json_deferred(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    request.write(json_response)
    request.finish()


class BaseResource(Resource):

    def __init__(self, services_factory):
        Resource.__init__(self)
        self._services_factory = services_factory

    def _get_user_id_from_request(self, request):
        if self._services_factory.mode.is_single_user:
            return None  # it doesn't matter
        session = self.get_session(request)
        if session.is_logged_in():
            return session.user_uuid
        raise ValueError('Not logged in')

    def is_logged_in(self, request):
        session = self.get_session(request)
        return session.is_logged_in() and self._services_factory.is_logged_in(session.user_uuid)

    def get_session(self, request):
        return IPixelatedSession(request.getSession())

    def _services(self, request):
        user_id = self._get_user_id_from_request(request)
        return self._services_factory.services(user_id)

    def _service(self, request, attribute):
        return getattr(self._services(request), attribute)

    def keymanager(self, request):
        return self._service(request, 'keymanager')

    def mail_service(self, request):
        return self._service(request, 'mail_service')

    def search_engine(self, request):
        return self._service(request, 'search_engine')

    def draft_service(self, request):
        return self._service(request, 'draft_service')

    def feedback_service(self, request):
        return self._service(request, 'feedback_service')


class UnAuthorizedResource(Resource):

    def __init__(self):
        Resource.__init__(self)

    def render_GET(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""

    def render_POST(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""
/n/n/nservice/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.python.filepath import FilePath
from twisted.web import util
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/nservice/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self.child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            return self.child_resources.get(path)
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self.child_resources.add('assets', File(self._static_folder))
        self.child_resources.add('keys', KeysResource(self._services_factory))
        self.child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.child_resources.add('contacts', ContactsResource(self._services_factory))
        self.child_resources.add('features', FeaturesResource(portal))
        self.child_resources.add('tags', TagsResource(self._services_factory))
        self.child_resources.add('mails', MailsResource(self._services_factory))
        self.child_resources.add('mail', MailResource(self._services_factory))
        self.child_resources.add('feedback', FeedbackResource(self._services_factory))
        self.child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self.child_resources.add(LoginResource.BASE_URL,
                                 LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/nservice/test/integration/test_retrieve_attachment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import base64
import json
from email import encoders
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from poster.encode import multipart_encode, MultipartParam
from twisted.internet import defer

from test.support.integration.soledad_test_base import SoledadTestBase


class RetrieveAttachmentTest(SoledadTestBase):
    @defer.inlineCallbacks
    def test_attachment_content_is_retrieved(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename, content_type=expected_content_type)

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    @defer.inlineCallbacks
    def test_should_retrieve_attachment_even_if_xsrf_token_not_passed(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename,
                                                    content_type=expected_content_type, ajax=False, csrf='mismatched token')

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    def _create_mail_with_attachment(self):
        input_mail = MIMEMultipart()
        input_mail.attach(MIMEText(u'a utf8 message', _charset='utf-8'))
        attachment = MIMEApplication('pretend to be binary attachment data')
        attachment.add_header('Content-Disposition', 'attachment', filename='file name.txt')
        attachment.add_header('Content-Type', 'text/plain')
        input_mail.attach(attachment)
        attachment_id = 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A'
        return attachment_id, input_mail

    @defer.inlineCallbacks
    def test_attachment_error_returned_if_id_not_found(self):
        attachment, req = yield self.get_attachment('invalid attachment id', 'base64')

        self.assertEqual(404, req.code)
        self.assertIsNone(attachment)

    @defer.inlineCallbacks
    def test_post_new_attachment(self):
        content_type = 'text/plain'
        filename = 'filename.txt'
        data = 'pretend to be binary attachment data'
        file = MultipartParam('attachment', value=data, filename=filename, filetype=content_type)
        datagen, headers = multipart_encode([file])
        post_data = """".join(datagen)

        _, req = yield self.post_attachment(post_data, headers)

        self.assertEqual(201, req.code)
        self.assertEqual('/attachment/B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A', req.headers['Location'])
        response_json = {'ident': 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A',
                         'content-type': content_type,
                         'name': filename,
                         'size': len(data),
                         'encoding': 'base64'}
        self.assertEqual(response_json, json.loads(req.written[0]))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/nservice/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None
        self.cookies = {}

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)

    def addCookie(self, key, value):
        self.cookies[key] = value

    def getCookie(self, key):
        return self.cookies.get(key)


def request_mock(path='', method='GET', body='', headers={}, ajax=True, csrf='token'):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)
    if ajax:
        dummy.headers['x-requested-with'] = 'XMLHttpRequest'
        dummy.headers['x-xsrf-token'] = csrf
        dummy.addCookie('XSRF-TOKEN', csrf)

    return dummy
/n/n/nservice/test/unit/resources/test_root_resource.py/n/nimport unittest
import re

from mock import MagicMock, patch
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource, MODE_STARTUP, MODE_RUNNING


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)
        self.root_resource = root_resource

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])
        request.addCookie = lambda key, value: 'stubbed'

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d

    def _test_should_renew_xsrf_cookie(self):
        request = DummyRequest([''])
        request.addCookie = MagicMock()
        generated_csrf_token = 'csrf_token'
        mock_sha = MagicMock()
        mock_sha.hexdigest = MagicMock(return_value=generated_csrf_token)

        with patch('hashlib.sha256', return_value=mock_sha):
            d = self.web.get(request)

        def assert_csrf_cookie(_):
            request.addCookie.assert_called_once_with('XSRF-TOKEN', generated_csrf_token)

        d.addCallback(assert_csrf_cookie)
        return d

    def test_should_renew_xsrf_cookie_on_startup_mode(self):
        self.root_resource._mode = MODE_STARTUP
        self._test_should_renew_xsrf_cookie()

    def test_should_renew_xsrf_cookie_on_running_mode(self):
        self.root_resource._mode = MODE_RUNNING
        self._test_should_renew_xsrf_cookie()

    def _mock_ajax_csrf(self, request, csrf_token):
        request.headers['x-requested-with'] = 'XMLHttpRequest'
        request.headers['x-xsrf-token'] = csrf_token

    def test_should_unauthorize_child_resource_ajax_requests_when_csrf_mismatch(self):
        request = DummyRequest(['/child'])
        self._mock_ajax_csrf(request, 'stubbed csrf token')

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d

    def test_should_authorize_child_resource_non_ajax_GET_requests(self):
        request = DummyRequest(['features'])

        request.getCookie = MagicMock(return_value='irrelevant -- stubbed')
        self.root_resource.initialize()

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(200, request.code)

        d.addCallback(assert_unauthorized)
        return d

    def test_should_unauthorize_child_resource_non_ajax_POST_requests_when_csrf_input_mismatch(self):
        request = DummyRequest(['mails'])
        request.method = 'POST'
        request.addArg('csrftoken', 'some csrf token')
        mock_content = MagicMock()
        mock_content.read = MagicMock(return_value={})
        request.content = mock_content

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d
/n/n/n",0
41,41,9573bdca55ddc5488066d3af525e41ed1d872ea6,"/service/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.web import util
from twisted.web.error import FlattenerError
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer
from twisted.python.filepath import FilePath

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/n/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import os
from string import Template

from pixelated.resources import BaseResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.resource import Resource
from twisted.web.static import File


MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):

    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        return Resource.getChild(self, path, request)

    def initialize(self, portal=None, disclaimer_banner=None):
        self.putChild('assets', File(self._static_folder))
        self.putChild('keys', KeysResource(self._services_factory))
        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.putChild('contacts', ContactsResource(self._services_factory))
        self.putChild('features', FeaturesResource(portal))
        self.putChild('tags', TagsResource(self._services_factory))
        self.putChild('mails', MailsResource(self._services_factory))
        self.putChild('mail', MailResource(self._services_factory))
        self.putChild('feedback', FeedbackResource(self._services_factory))
        self.putChild('user-settings', UserSettingsResource(self._services_factory))
        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def render_GET(self, request):
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)
/n/n/n/service/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True):
        request = request_mock(path)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers)
        return self._render(request)

    def put(self, path, body):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']})
        return self._render(request)

    def delete(self, path, body=""""):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"")
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n/service/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)


def request_mock(path='', method='GET', body='', headers={}):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)

    return dummy
/n/n/n/service/test/unit/resources/test_root_resource.py/n/nimport unittest
import re
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d
/n/n/n",1
20,20,d81fc3b81a2255ae128c54bf50a83bebc2118439,"app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

def to_authorization_params(param):
    param_list = [
        'contact_name',
        'contact_email',
        'organization_name',
        'domain_write_permission',
        'read_permission',
        'full_read_permission',
        'search_permission',
        'subscribe_permission',
        'mark_notes_reviewed',
        'believed_dead_permission',
        'stats_permission',
        'is_valid',
    ]
    ret = {}
    for param_name in param_list:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags,
                           xsrf_token=xsrf_tool.generate_token(
                               user.user_id(), 'admin_api_keys'))


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/napp/utils.py/n/n#!/usr/bin/python2.7
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'

from django_setup import ugettext as _  # always keep this first

import calendar
import cgi
from datetime import datetime, timedelta
import hmac
import httplib
import logging
import os
import random
import re
import string
import sys
import time
import traceback
import unicodedata
import urllib
import urlparse
import base64

import django.utils.html
from django.template.defaulttags import register
from google.appengine.api import images
from google.appengine.api import taskqueue
from google.appengine.api import users
from google.appengine.ext import webapp
import google.appengine.ext.webapp.template
import google.appengine.ext.webapp.util
from recaptcha.client import captcha
from babel.dates import format_date
from babel.dates import format_datetime
from babel.dates import format_time
import babel

import const
import config
import model
import pfif
import resources

# The domain name from which to send e-mail.
EMAIL_DOMAIN = 'appspotmail.com'  # All apps on appspot.com use this for mail.

# Query parameters which are automatically preserved on page transition
# if you use utils.BaseHandler.get_url() or
# env.hidden_input_tags_for_preserved_query_params.
PRESERVED_QUERY_PARAM_NAMES = ['ui', 'charsets', 'referrer']

@register.filter
def get_value(dictionary, key):
    """"""Django Template filter to get dictionary value based on the given key""""""
    return dictionary.get(key)

# ==== Field value text ========================================================


def get_person_sex_text(person):
    """"""Returns the UI text for a person's sex field.""""""
    return const.PERSON_SEX_TEXT.get(person.sex or '')


def get_note_status_text(note):
    """"""Returns the UI text for a note's status field.""""""
    return const.NOTE_STATUS_TEXT.get(note.status or '')


def get_person_status_text(person):
    """"""Returns the UI text for a person's latest_status.""""""
    return const.PERSON_STATUS_TEXT.get(person.latest_status or '')


# Things that occur as prefixes of global paths (i.e. no repository name).
GLOBAL_PATH_RE = re.compile(r'^/(global|personfinder)(/?|/.*)$')


# ==== String formatting =======================================================


def format_boolean(value):
    return value and 'true' or 'false'


def format_utc_datetime(dt):
    if not dt:
        return ''
    return dt.replace(microsecond=0).isoformat() + 'Z'


def format_utc_timestamp(timestamp):
    if not isinstance(timestamp, (int, float)):
        return ''
    return format_utc_datetime(datetime.utcfromtimestamp(timestamp))


def format_sitemaps_datetime(dt):
    integer_dt = datetime(
        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
    return integer_dt.isoformat() + '+00:00'


def encode(string, encoding='utf-8'):
    """"""If unicode, encode to encoding; if 8-bit string, leave unchanged.""""""
    if isinstance(string, unicode):
        string = string.encode(encoding)
    return string


def urlencode(params, encoding='utf-8'):
    """"""Encode the key-value pairs in 'params' into a query string, applying
    the specified encoding to any Unicode strings and ignoring any keys that
    have value == None.  (urllib.urlencode doesn't support Unicode).""""""
    keys = params.keys()
    keys.sort()  # Sort the keys to get canonical ordering
    return urllib.urlencode([
        (encode(key, encoding), encode(params[key], encoding))
        for key in keys if isinstance(params[key], basestring)])


def set_param(params, param, value):
    """"""Take the params from a urlparse and override one of the values.""""""
    # This will strip out None-valued params and collapse repeated params.
    params = dict(cgi.parse_qsl(params))
    if value is None:
        if param in params:
            del(params[param])
    else:
        params[param] = value
    return urlencode(params)


def set_url_param(url, param, value):
    """"""This modifies a URL setting the given param to the specified value.  This
    may add the param or override an existing value, or, if the value is None,
    it will remove the param.  Note that value must be a basestring and can't be
    an int, for example.""""""
    url_parts = list(urlparse.urlparse(url))
    url_parts[4] = set_param(url_parts[4], param, value)
    return urlparse.urlunparse(url_parts)


def anchor_start(href):
    """"""Returns the HREF escaped and embedded in an anchor tag.""""""
    return '<a href=""%s"">' % django.utils.html.escape(href)


def anchor(href, body):
    """"""Returns a string anchor HTML element with the given href and body.""""""
    return anchor_start(href) + django.utils.html.escape(body) + '</a>'


# ==== Validators ==============================================================

# These validator functions are used to check and parse query parameters.
# Each validator should return a parsed, sanitized value, or return a default
# value, or raise ValueError to display an error message to the user.


def strip(string):
    # Trailing nulls appear in some strange character encodings like Shift-JIS.
    return string.strip().rstrip('\0')


def strip_and_lower(string):
    return strip(string).lower()


def validate_yes(string):
    return (strip(string).lower() == 'yes') and 'yes' or ''


def validate_checkbox(string):
    return (strip(string).lower() == 'on') and 'yes' or ''


def validate_checkbox_as_bool(val):
    if val.lower() in ['on', 'yes', 'true']:
        return True
    return False


def validate_role(string):
    return (strip(string).lower() == 'provide') and 'provide' or 'seek'


def validate_int(string):
    return string and int(strip(string))


def validate_sex(string):
    """"""Validates the 'sex' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.PERSON_SEX_VALUES and string or ''


def validate_expiry(value):
    """"""Validates that the 'expiry_option' parameter is a positive integer.

    Returns:
      the int() value if it's present and parses, or the default_expiry_days
      for the repository, if it's set, otherwise -1 which represents the
      'unspecified' status.
    """"""
    try:
        value = int(value)
    except Exception, e:
        return None
    return value > 0 and value or None


APPROXIMATE_DATE_RE = re.compile(r'^\d{4}(-\d\d)?(-\d\d)?$')


def validate_approximate_date(string):
    if string:
        string = strip(string)
        if APPROXIMATE_DATE_RE.match(string):
            return string
    return ''


AGE_RE = re.compile(r'^\d+(-\d+)?$')
# Hyphen with possibly surrounding whitespaces.
HYPHEN_RE = re.compile(
    ur'\s*[-\u2010-\u2015\u2212\u301c\u30fc\ufe58\ufe63\uff0d]\s*',
    re.UNICODE)


def validate_age(string):
    """"""Validates the 'age' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string)
        string = unicodedata.normalize('NFKC', unicode(string))
        string = HYPHEN_RE.sub('-', string)
        if AGE_RE.match(string):
            return string
    return ''


def validate_status(string):
    """"""Validates an incoming status parameter, returning one of the canonical
    status strings or ''.  Note that '' is always used as the Python value
    to represent the 'unspecified' status.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.NOTE_STATUS_VALUES and string or ''


DATETIME_RE = re.compile(r'^(2\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z$')


def validate_datetime(string):
    if not string:
        return None  # A missing value is okay.
    match = DATETIME_RE.match(string)
    if match:
        return datetime(*map(int, match.groups()))
    raise ValueError('Bad datetime: %r' % string)


def validate_timestamp(string):
    try:
        return string and datetime.utcfromtimestamp(float(strip(string)))
    except:
        raise ValueError('Bad timestamp: %s' % string)


def validate_image(bytestring):
    try:
        image = None
        if bytestring:
            image = images.Image(bytestring)
            image.width
        return image
    except:
        return False


def validate_version(string):
    """"""Version, if present, should be in pfif versions.""""""
    if string and strip(string) not in pfif.PFIF_VERSIONS:
        raise ValueError('Bad pfif version: %s' % string)
    return pfif.PFIF_VERSIONS[strip(string) or pfif.PFIF_DEFAULT_VERSION]


REPO_RE = re.compile('^[a-z0-9-]+$')


def validate_repo(string):
    string = (string or '').strip()
    if not string:
        return None
    if string == 'global':
        raise ValueError('""global"" is an illegal repository name.')
    if REPO_RE.match(string):
        return string
    raise ValueError('Repository names can only contain '
                     'lowercase letters, digits, and hyphens.')


RESOURCE_NAME_RE = re.compile('^[a-z0-9._-]+$')


def validate_resource_name(string):
    """"""A resource name or bundle label.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if RESOURCE_NAME_RE.match(string):
        return string
    raise ValueError('Invalid resource name or bundle name: %r' % string)


LANG_RE = re.compile('^[A-Za-z0-9-]+$')


def validate_lang(string):
    """"""A BCP 47 language tag.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if LANG_RE.match(string):
        return string
    raise ValueError('Invalid language tag: %r' % string)


def validate_cache_seconds(string):
    """"""A number of seconds to cache a Resource in RAM.""""""
    string = (string or '').strip()
    if string:
        return float(string)
    return 1.0


# ==== Other utilities =========================================================


def url_is_safe(url):
    current_scheme, _, _, _, _ = urlparse.urlsplit(url)
    return current_scheme in ['http', 'https']


def get_app_name():
    """"""Canonical name of the app, without HR s~ nonsense.  This only works in
    the context of the appserver (eg remote_api can't use it).""""""
    from google.appengine.api import app_identity
    return app_identity.get_application_id()


def sanitize_urls(record):
    """"""Clean up URLs to protect against XSS.""""""
    # Single-line URLs.
    for field in ['photo_url', 'source_url']:
        url = getattr(record, field, None)
        if url and not url_is_safe(url):
            setattr(record, field, None)
    # Multi-line URLs.
    for field in ['profile_urls']:
        urls = (getattr(record, field, None) or '').splitlines()
        sanitized_urls = [url for url in urls if url and url_is_safe(url)]
        if len(urls) != len(sanitized_urls):
            setattr(record, field, '\n'.join(sanitized_urls))


def get_host(host=None):
    host = host or os.environ['HTTP_HOST']
    """"""Return the host name, without version specific details.""""""
    parts = host.split('.')
    if len(parts) > 3:
        return '.'.join(parts[-3:])
    else:
        return host


# List of sensitive field names in person and note records.
SENSITIVE_FIELDS = [
  'date_of_birth',
  'author_email',
  'author_phone',
  'email_of_found_person',
  'phone_of_found_person',
]


def optionally_filter_sensitive_fields(records, auth=None):
    """"""Removes sensitive fields from a list of dictionaries, unless the client
    has full read authorization.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    if not (auth and auth.full_read_permission):
        filter_sensitive_fields(records)


def filter_sensitive_fields(records):
    """"""Removes sensitive fields from a list of dictionaries.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    for record in records:
        for prefix in ['', 'person_', 'note_']:
            for field in SENSITIVE_FIELDS:
                prefixed_field = prefix + field
                if prefixed_field in record:
                    record[prefixed_field] = ''


def join_person_and_note_record(person_record, note_record):
    """"""Join a person record and a note record into a single dictionary.

    The field names are prefixed with 'person_' or 'note_' to avoid name
    collision. note_record can be None. In that case, person record field
    names are still prefixed.

    Args:
        person_record (dict): A dictionary representation of a person record.
            Cannot be None.
        note_record (dict): A dictionary representation of a note record for
            the person. Can be None.
    """"""
    joined_record = {}
    for name, value in person_record.iteritems():
        new_name = get_field_name_for_joined_record(name, 'person')
        joined_record[new_name] = value
    if note_record:
        assert (note_record['person_record_id'] ==
                person_record['person_record_id'])
        for name, value in note_record.iteritems():
            new_name = get_field_name_for_joined_record(name, 'note')
            joined_record[new_name] = value
    return joined_record


def get_field_name_for_joined_record(original_field_name, record_type):
    """"""Converts a field name in a person/note record into a field name used in
    a joined record of a person and a note.

    See also join_person_and_note_record().

    Args:
        original_field_name (str): A field name in a person/note record.
        record_type (str): 'person' or 'note'.
    """"""
    if original_field_name in ('person_record_id', 'note_record_id'):
        return original_field_name
    else:
        return '%s_%s' % (record_type, original_field_name)


# The current time for testing as a datetime object, or None if using real time.
_utcnow_for_test = None


def set_utcnow_for_test(now):
    """"""Sets the current time for testing purposes.  Pass in a datetime object
    or a timestamp in epoch seconds; or pass None to revert to real time.""""""
    global _utcnow_for_test
    if isinstance(now, (int, float)):
        now = datetime.utcfromtimestamp(float(now))
    _utcnow_for_test = now


def get_utcnow():
    """"""Returns the current UTC datetime (settable with set_utcnow_for_test).""""""
    global _utcnow_for_test
    return (_utcnow_for_test is None) and datetime.utcnow() or _utcnow_for_test


def get_timestamp(dt):
    """"""Converts datetime object to a float value in epoch seconds.""""""
    return calendar.timegm(dt.utctimetuple()) + dt.microsecond * 1e-6


def get_utcnow_timestamp():
    """"""Returns the current time in epoch seconds (settable with
    set_utcnow_for_test).""""""
    return get_timestamp(get_utcnow())


def log_api_action(handler, action, num_person_records=0, num_note_records=0,
                   people_skipped=0, notes_skipped=0):
    """"""Log an API action.""""""
    if handler.config and handler.config.api_action_logging:
        model.ApiActionLog.record_action(
            handler.repo, handler.params.key,
            handler.params.version.version, action,
            num_person_records, num_note_records,
            people_skipped, notes_skipped,
            handler.request.headers.get('User-Agent'),
            handler.request.remote_addr, handler.request.url)


def get_full_name(given_name, family_name, config):
    """"""Return full name string obtained by concatenating given_name and
    family_name in the order specified by config.family_name_first, or just
    given_name if config.use_family_name is False.""""""
    if config.use_family_name:
        separator = (given_name and family_name) and u' ' or u''
        if config.family_name_first:
            return separator.join([family_name, given_name])
        else:
            return separator.join([given_name, family_name])
    else:
        return given_name


def send_confirmation_email_to_record_author(
    handler, person, action, confirm_url, record_id):
    """"""Send the author an email to confirm enabling/disabling notes
    of a record.""""""
    if not person.author_email:
        return handler.error(
            400, _('No author email for record %(id)s.') % {'id' : record_id})

    # i18n: Subject line of an e-mail message confirming the author
    # wants to disable notes for this record
    if action == 'enable':
        subject = _('[Person Finder] Enable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    elif action == 'disable':
        subject = _('[Person Finder] Disable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    else:
        raise ValueError('Unknown action: %s' % action)

    # send e-mail to record author confirming the lock of this record.
    template_name = '%s_notes_email.txt' % action
    handler.send_mail(
        subject=subject,
        to=person.author_email,
        body=handler.render_to_string(
            template_name,
            author_name=person.author_name,
            full_name=person.primary_full_name,
            site_url=handler.get_url('/'),
            confirm_url=confirm_url
        )
    )


def get_repo_url(request, repo, scheme=None):
    """"""Constructs the absolute root URL for a given repository.""""""
    req_scheme, req_netloc, req_path, _, _ = urlparse.urlsplit(request.url)
    prefix = req_path.startswith('/personfinder') and '/personfinder' or ''
    if is_dev_app_server():
        scheme = 'http'  # HTTPS is not available when using dev_appserver
    return (scheme or req_scheme) + '://' + req_netloc + prefix + '/' + repo


def get_url(request, repo, action, charset='utf-8', scheme=None, **params):
    """"""Constructs the absolute URL for a given action and query parameters,
    preserving the current repo and the parameters listed in
    PRESERVED_QUERY_PARAM_NAMES.""""""
    repo_url = get_repo_url(request, repo or 'global', scheme)
    for name in PRESERVED_QUERY_PARAM_NAMES:
        params[name] = params.get(name, request.get(name, None))
    query = urlencode(params, charset)
    return repo_url + '/' + action.lstrip('/') + (query and '?' + query or '')


def add_profile_icon_url(website, handler):
    website['icon_url'] = \
        handler.env.global_url + '/' + website['icon_filename']
    return website


def strip_url_scheme(url):
    if not url:
        return url
    _, netloc, path, query, segment = urlparse.urlsplit(url)
    return urlparse.urlunsplit(('', netloc, path, query, segment))


def is_dev_app_server():
    return os.environ['APPLICATION_ID'].startswith('dev~')

# ==== Struct ==================================================================

class Struct:
    """"""A simple bag of attributes.""""""
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def get(self, name, default=None):
        return self.__dict__.get(name, default)


# ==== Key management ======================================================

def generate_random_key(length):
    """"""Generates a random key with given length.""""""
    source = ('abcdefghijklmnopqrstuvwxyz'
              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
              '1234567890'
              '-_')
    rng = random.SystemRandom()
    return ''.join(rng.choice(source) for i in range(length))


# ==== Decorators  ============================================================

def require_api_key_management_permission(handler_method):
    """"""
    This is a decorator for API Key management feature. The limitation
    is that the decorator can not preserve payloads within a POST/PUT
    request.

    Usage:
    class SomeHandler(utils.BaseHandler):
        @utils.require_api_key_management_permission
        def get(self):
            # ....
            # ....
    """"""
    def inner(*args, **kwargs):
        handler = args[0]
        user = users.get_current_user()
        if (users.is_current_user_admin() or
            (user and handler.config.key_management_operators and
             user.email() in handler.config.key_management_operators)):
            return handler_method(*args, **kwargs)
        else:
            return handler.redirect(
                users.create_login_url(handler.request.url))
    return inner


# ==== Base Handler ============================================================

class BaseHandler(webapp.RequestHandler):
    # Handlers that don't need a repository name can set this to False.
    repo_required = True

    # Handlers that require HTTPS can set this to True.
    https_required = False

    # Set this to True to enable a handler even for deactivated repositories.
    ignore_deactivation = False

    # Handlers that require an admin permission must set this to True.
    admin_required = False

    # List all accepted query parameters here with their associated validators.
    auto_params = {
        'action': strip,
        'add_note': validate_yes,
        'age': validate_age,
        'alternate_family_names': strip,
        'alternate_given_names': strip,
        'author_email': strip,
        'author_made_contact': validate_yes,
        'author_name': strip,
        'author_phone': strip,
        'your_own_email': strip,
        'your_own_phone': strip,
        'believed_dead_permission': validate_checkbox_as_bool,
        'cache_seconds': validate_cache_seconds,
        'clone': validate_yes,
        'confirm': validate_yes,
        'contact_email': strip,
        'contact_name': strip,
        'content_id': strip,
        'context': strip,
        'cursor': strip,
        'date_of_birth': validate_approximate_date,
        'description': strip,
        'domain_write_permission': strip,
        'dupe_notes': validate_yes,
        'email_of_found_person': strip,
        'error': strip,
        'expiry_option': validate_expiry,
        'family_name': strip,
        'full_read_permission': validate_checkbox_as_bool,
        'given_name': strip,
        'home_city': strip,
        'home_country': strip,
        'home_neighborhood': strip,
        'home_postal_code': strip,
        'home_state': strip,
        'home_street': strip,
        'id': strip,
        'id1': strip,
        'id2': strip,
        'id3': strip,
        'is_valid': validate_checkbox_as_bool,
        'key': strip,
        'lang': validate_lang,
        'last_known_location': strip,
        'mark_notes_reviewed': validate_checkbox_as_bool,
        'max_results': validate_int,
        'min_entry_date': validate_datetime,
        'new_repo': validate_repo,
        'note_photo': validate_image,
        'note_photo_url': strip,
        'omit_notes': validate_yes,
        'operation': strip,
        'organization_name': strip,
        'person_record_id': strip,
        'phone_of_found_person': strip,
        'photo': validate_image,
        'photo_url': strip,
        'profile_url1': strip,
        'profile_url2': strip,
        'profile_url3': strip,
        'query': strip,
        'query_name': strip,
        'query_location': strip,
        'query_type': strip,
        'read_permission': validate_checkbox_as_bool,
        'referrer': strip,
        'resource_bundle': validate_resource_name,
        'resource_bundle_default': validate_resource_name,
        'resource_bundle_original': validate_resource_name,
        'resource_lang': validate_lang,
        'resource_name': validate_resource_name,
        'role': validate_role,
        'search_engine_id': validate_int,
        'search_permission': validate_checkbox_as_bool,
        'sex': validate_sex,
        'signature': strip,
        'skip': validate_int,
        'small': validate_yes,
        'source': strip,
        'source_date': strip,
        'source_name': strip,
        'source_url': strip,
        'stats_permission': validate_checkbox_as_bool,
        'status': validate_status,
        'style': strip,
        'subscribe': validate_checkbox,
        'subscribe_own_info': validate_checkbox,
        'subscribe_email': strip,
        'subscribe_permission': validate_checkbox_as_bool,
        'suppress_redirect': validate_yes,
        'target': strip,
        'text': strip,
        'thumb': validate_checkbox_as_bool,
        'timestamp': validate_timestamp,
        'ui': strip_and_lower,
        'utcnow': validate_timestamp,
        'version': validate_version,
        'own_info': validate_yes,
        'xsrf_token': strip,
    }

    def redirect(self, path, repo=None, permanent=False, **params):
        # This will prepend the repo to the path to create a working URL,
        # unless the path has a global prefix or is an absolute URL.
        if re.match('^[a-z]+:', path) or GLOBAL_PATH_RE.match(path):
            if params:
              path += '?' + urlencode(params, self.charset)
        else:
            path = self.get_url(path, repo, **params)
        return webapp.RequestHandler.redirect(self, path, permanent=permanent)

    def render(self, name, language_override=None, cache_seconds=0,
               get_vars=lambda: {}, **vars):
        """"""Renders a template to the output stream, passing in the variables
        specified in **vars as well as any additional variables returned by
        get_vars().  Since this is intended for use by a dynamic page handler,
        caching is off by default; if cache_seconds is positive, then
        get_vars() will be called only when cached content is unavailable.""""""
        self.write(self.render_to_string(
            name, language_override, cache_seconds, get_vars, **vars))

    def render_to_string(self, name, language_override=None, cache_seconds=0,
                         get_vars=lambda: {}, **vars):
        """"""Renders a template to a string, passing in the variables specified
        in **vars as well as any additional variables returned by get_vars().
        Since this is intended for use by a dynamic page handler, caching is
        off by default; if cache_seconds is positive, then get_vars() will be
        called only when cached content is unavailable.""""""
        # TODO(kpy): Make the contents of extra_key overridable by callers?
        lang = language_override or self.env.lang
        extra_key = (self.env.repo, self.env.charset, self.request.query_string)
        def get_all_vars():
            vars.update(get_vars())
            for key in ('env', 'config', 'params'):
                if key in vars:
                    raise Exception(
                        'Cannot use ""%s"" as a key in vars. It is reserved.'
                        % key)
            vars['env'] = self.env  # pass along application-wide context
            vars['config'] = self.config  # pass along the configuration
            vars['params'] = self.params  # pass along the query parameters
            return vars
        return resources.get_rendered(
            name, lang, extra_key, get_all_vars, cache_seconds)

    def error(self, code, message='', message_html=''):
        self.info(code, message, message_html, style='error')

    def info(self, code, message='', message_html='', style='info'):
        """"""Renders a simple page with a message.

        Args:
          code: HTTP status code.
          message: A message in plain text.
          message_html: A message in HTML.
          style: 'info', 'error' or 'plain'. 'info' and 'error' differs in
              appearance. 'plain' just renders the message without extra
              HTML tags. Good for API response.
        """"""
        is_error = 400 <= code < 600
        if is_error:
            webapp.RequestHandler.error(self, code)
        else:
            self.response.set_status(code)
        if not message and not message_html:
            message = '%d: %s' % (code, httplib.responses.get(code))
        if style == 'plain':
            self.__render_plain_message(message, message_html)
        else:
            try:
                self.render('message.html', cls=style,
                            message=message, message_html=message_html)
            except:
                self.__render_plain_message(message, message_html)
        self.terminate_response()

    def __render_plain_message(self, message, message_html):
        self.response.out.write(
            django.utils.html.escape(message) +
            ('<p>' if message and message_html else '') +
            message_html)

    def terminate_response(self):
        """"""Prevents any further output from being written.""""""
        self.response.out.write = lambda *args: None
        self.get = lambda *args: None
        self.post = lambda *args: None

    def write(self, text):
        """"""Sends text to the client using the charset from select_charset().""""""
        self.response.out.write(text.encode(self.env.charset, 'replace'))

    def get_url(self, action, repo=None, scheme=None, **params):
        """"""Constructs the absolute URL for a given action and query parameters,
        preserving the current repo and the parameters listed in
        PRESERVED_QUERY_PARAM_NAMES.""""""
        return get_url(self.request, repo or self.env.repo, action,
                       charset=self.env.charset, scheme=scheme, **params)

    @staticmethod
    def add_task_for_repo(repo, name, action, **kwargs):
        """"""Queues up a task for an individual repository.""""""
        task_name = '%s-%s-%s' % (repo, name, int(time.time()*1000))
        path = '/%s/%s' % (repo, action)
        taskqueue.add(name=task_name, method='GET', url=path, params=kwargs)

    def send_mail(self, to, subject, body):
        """"""Sends e-mail using a sender address that's allowed for this app.""""""
        app_id = get_app_name()
        sender = 'Do not reply <do-not-reply@%s.%s>' % (app_id, EMAIL_DOMAIN)
        logging.info('Add mail task: recipient %r, subject %r' % (to, subject))
        taskqueue.add(queue_name='send-mail', url='/global/admin/send_mail',
                      params={'sender': sender,
                              'to': to,
                              'subject': subject,
                              'body': body})

    def get_captcha_html(self, error_code=None, use_ssl=False):
        """"""Generates the necessary HTML to display a CAPTCHA validation box.""""""

        # We use the 'custom_translations' parameter for UI messages, whereas
        # the 'lang' parameter controls the language of the challenge itself.
        # reCAPTCHA falls back to 'en' if this parameter isn't recognized.
        lang = self.env.lang.split('-')[0]

        return captcha.get_display_html(
            site_key=config.get('captcha_site_key'),
            use_ssl=use_ssl, error=error_code, lang=lang
        )

    def get_captcha_response(self):
        """"""Returns an object containing the CAPTCHA response information for the
        given request's CAPTCHA field information.""""""
        # Allows faking the CAPTCHA response by an HTTP request parameter, but
        # only locally, for testing purpose.
        faked_captcha_response = self.request.get('faked_captcha_response')
        if faked_captcha_response and self.request.remote_addr == '127.0.0.1':
            return captcha.RecaptchaResponse(
                is_valid=faked_captcha_response == 'success')

        captcha_response = self.request.get('g-recaptcha-response')
        return captcha.submit(captcha_response)

    def handle_exception(self, exception, debug_mode):
        logging.error(traceback.format_exc())
        self.error(500, _(
            'There was an error processing your request.  Sorry for the '
            'inconvenience.  Our administrators will investigate the source '
            'of the problem, but please check that the format of your '
            'request is correct.'))

    def __get_env_language_for_babel(self):
        language_code = self.env.lang
        try:
            return babel.Locale.parse(language_code, sep='-')
        except babel.UnknownLocaleError as e:
            # fallback language
            return babel.Locale('en')

    def to_local_time(self, date):
        """"""Converts a datetime object to the local time configured for the
        current repository.  For convenience, returns None if date is None.""""""
        # TODO(kpy): This only works for repositories that have a single fixed
        # time zone offset and never use Daylight Saving Time.
        if date:
            if self.config.time_zone_offset:
                return date + timedelta(0, 3600*self.config.time_zone_offset)
            return date

    def format_datetime_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale.""""""
        return format_datetime(dt, locale=self.__get_env_language_for_babel());

    def format_date_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the date.""""""
        return format_date(dt, locale=self.__get_env_language_for_babel());

    def format_time_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the time.""""""
        return format_time(dt, locale=self.__get_env_language_for_babel());

    def to_formatted_local_datetime(self, dt):
        """"""Converts a datetime object to the local datetime configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_datetime_localized(dt)

    def to_formatted_local_date(self, dt):
        """"""Converts a datetime object to the local date configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_date_localized(dt)

    def to_formatted_local_time(self, dt):
        """"""Converts a datetime object to the local time configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_time_localized(dt)

    def maybe_redirect_for_repo_alias(self, request):
        """"""If the specified repository name is an alias, redirects to the URL
        with the canonical repository name and returns True. Otherwise returns
        False.
        """"""
        # Config repo_alias is a dictionary from a repository name alias to
        # its canonical.
        # e.g., {'yol': '2013-yolanda', 'jam': '2014-jammu-kashmir-floods'}
        #
        # A repository name alias can be used instead of the canonical
        # repository name in URLs. This is especially useful combined with
        # the short URL. e.g., You can access
        # https://www.google.org/personfinder/2014-jammu-kashmir-floods
        # by http://g.co/pf/jam .
        if not self.repo:
            return False
        repo_aliases = config.get('repo_aliases', default={})
        if self.repo in repo_aliases:
            canonical_repo = repo_aliases[self.repo]
            params = {}
            for name in request.arguments():
                params[name] = request.get(name)
            # Redirects to the same URL including the query parameters, except
            # for the repository name.
            self.redirect('/' + self.env.action, repo=canonical_repo, **params)
            self.terminate_response()
            return True
        else:
            return False

    def should_show_inline_photo(self, photo_url):
        """"""Returns True if we should show the photo in our site directly with
        <img> tag. In zero-rating mode, it returns True only if the photo is
        served by our domain, to avoid loading resources in other domains in
        Person Finder.

        See ""Zero-rating"" section of the admin page
        (app/resources/admin.html.template) for details of zero-rating mode.
        """"""
        if not photo_url:
            return False
        elif self.env.config.zero_rating_mode:
            _, our_netloc, _, _, _ = urlparse.urlsplit(self.request.url)
            _, photo_netloc, _, _, _ = urlparse.urlsplit(photo_url)
            return photo_netloc == our_netloc
        else:
            return True

    URL_PARSE_QUERY_INDEX = 4

    def get_thumbnail_url(self, photo_url):
        """"""Get a thumbnail URL for an uploaded photo's URL.

        Args:
            photo_url: a photo URL for an uploaded photo
        """"""
        if not photo_url:
            return None
        parsed_url = list(urlparse.urlparse(photo_url))
        params_dict = dict(urlparse.parse_qsl(
            parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX]))
        params_dict['thumb'] = 'true'
        parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX] = urllib.urlencode(
            params_dict)
        return urlparse.urlunparse(parsed_url)

    def __return_unimplemented_method_error(self):
        return self.error(
            405,
            'HTTP method %s is not allowed for this URL.'
                % self.request.method)

    def __init__(self, request, response, env):
        webapp.RequestHandler.__init__(self, request, response)
        self.params = Struct()
        self.env = env
        self.repo = env.repo
        self.config = env.config
        self.charset = env.charset

        # Set default Content-Type header.
        self.response.headers['Content-Type'] = (
            'text/html; charset=%s' % self.charset)

        # Validate query parameters.
        for name, validator in self.auto_params.items():
            try:
                value = self.request.get(name, '')
                setattr(self.params, name, validator(value))
            except Exception, e:
                setattr(self.params, name, validator(None))
                return self.error(400, 'Invalid parameter %s: %s' % (name, e))

        # Ensure referrer is in whitelist, if it exists
        if self.params.referrer and (not self.params.referrer in
                                     self.config.referrer_whitelist):
            setattr(self.params, 'referrer', '')

        # Log the User-Agent header.
        sample_rate = float(
            self.config and self.config.user_agent_sample_rate or 0)
        if random.random() < sample_rate:
            model.UserAgentLog(
                repo=self.repo, sample_rate=sample_rate,
                user_agent=self.request.headers.get('User-Agent'), lang=lang,
                accept_charset=self.request.headers.get('Accept-Charset', ''),
                ip_address=self.request.remote_addr).put()

        # Check for SSL (unless running local dev app server).
        if self.https_required and not is_dev_app_server():
            if self.env.scheme != 'https':
                return self.error(403, 'HTTPS is required.')

        # Handles repository alias.
        if self.maybe_redirect_for_repo_alias(request):
            return

        # Check for an authorization key.
        self.auth = None
        if self.params.key:
            if self.repo:
                # check for domain specific one.
                self.auth = model.Authorization.get(self.repo, self.params.key)
            if not self.auth:
                # perhaps this is a global key ('*' for consistency with config).
                self.auth = model.Authorization.get('*', self.params.key)
        if self.auth and not self.auth.is_valid:
            self.auth = None

        # Shows a custom error page here when the user is not an admin
        # instead of ""login: admin"" in app.yaml
        # If we use it, user can't sign out
        # because the error page of ""login: admin"" doesn't have sign-out link.
        if self.admin_required:
            user = users.get_current_user()
            if not user:
                login_url = users.create_login_url(self.request.url)
                webapp.RequestHandler.redirect(self, login_url)
                self.terminate_response()
                return
            if not users.is_current_user_admin():
                logout_url = users.create_logout_url(self.request.url)
                self.render('not_admin_error.html', logout_url=logout_url, user=user)
                self.terminate_response()
                return

        # Handlers that don't need a repository configuration can skip it.
        if not self.repo:
            if self.repo_required:
                return self.error(400, 'No repository specified.')
            return
        # Everything after this requires a repo.

        # Reject requests for repositories that don't exist.
        if not model.Repo.get_by_key_name(self.repo):
            html = 'No such repository. '
            if self.env.repo_options:
                html += 'Select:<p>' + self.render_to_string('repo-menu.html')
            return self.error(404, message_html=html)

        # If this repository has been deactivated, terminate with a message.
        # The ignore_deactivation flag is for admin pages that bypass this.
        if self.config.deactivated and not self.ignore_deactivation:
            self.env.language_menu = []
            self.env.robots_ok = True
            self.render('message.html', cls='deactivation',
                        message_html=self.config.deactivation_message_html)
            self.terminate_response()

    def get(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def post(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def put(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def head(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def options(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def delete(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def trace(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()


# ==== XSRF protection =========================================================

class XsrfTool(object):

    # XSRF tokens expire after 4 hours.
    TOKEN_EXPIRATION_TIME = 60 * 60 * 4

    # Characters with which to choose a key if it's not set yet.
    TOKEN_CHARACTER_SET = string.letters + string.digits

    def __init__(self):
        configured_key = config.get('xsrf_token_key')
        if configured_key:
            # config.get returns unicode, but hmac is going to want a str
            self._key = configured_key.encode('utf-8')
        else:
            configured_key = ''.join([
                XsrfTool.TOKEN_CHARACTER_SET for _ in range(20)])
            config.set(xsrf_token_key=configured_key)
            self._key = configured_key

    def generate_token(self, user_id, action_id):
        action_time = get_utcnow_timestamp()
        return '%s/%f' % (
            self._generate_hmac_digest(user_id, action_id, action_time),
            action_time)

    def verify_token(self, token, user_id, action_id):
        [hmac_digest, action_time_str] = token.split('/')
        action_time = float(action_time_str)
        if (action_time + XsrfTool.TOKEN_EXPIRATION_TIME <
            get_utcnow_timestamp()):
          return False
        expected_hmac_digest = self._generate_hmac_digest(
            user_id, action_id, action_time)
        return hmac.compare_digest(
            hmac_digest.encode('utf-8'), expected_hmac_digest)

    def _generate_hmac_digest(self, user_id, action_id, action_time):
        hmac_obj = hmac.new(
            self._key, '%s/%s/%f' % (user_id, action_id, action_time))
        return hmac_obj.hexdigest()
/n/n/ntests/server_test_cases/xsrftool_tests.py/n/nimport datetime

import config
from server_tests_base import ServerTestsBase


class XsrfToolTests(ServerTestsBase):

    def setUp(self):
        ServerTestsBase.setUp(self)
        config.set(xsrf_token_key='abcdef')

    def testRejectGlobalEdit(self):
        self._checkPostIsRejected(
            '/global/admin',
            {'operation': 'save_global',
             'tos_url': 'www.evil.com',
             'sms_number_to_repo': '{}',
             'repo_aliases': '{}',
             'unreviewed_notes_threshold': '{}',})

    def testRejectApiKeyEdit(self):
        self._checkPostIsRejected(
            '/global/admin/api_keys',
            {'contact_name': 'Fred',
             'contact_email': 'fred@example.com',
             'organization_name': 'Fred Inc.',})

    def testRejectCreateRepo(self):
        self._checkPostIsRejected(
            '/global/admin/create_repo',
            {'new_repo': 'buffalo'})

    def testRejectDeleteRecord(self):
        self._checkPostIsRejected(
            '/haiti/admin/delete_record',
            {'operation': 'delete',
             'id': 'localhost.person/123'})

    def testRejectSetDefaultResourceBundle(self):
        self._checkPostIsRejected(
            '/global/admin/resources',
            {'operation': 'set_default',
             'resource_bundle_default': 'newbundle'})

    def _checkPostIsRejected(self, path, data):
        data['xsrf_token'] = 'NotTheRightDigest/123'
        doc = self.go_as_admin(path, data=data)
        self.assertEqual(doc.status, 403)
/n/n/ntests/test_xsrftool.py/n/nimport datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def testGenerateAndVerifyGoodToken(self):
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def testRejectsInvalidToken(self):
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(tool.verify_token(
            'NotTheRightDigest/%f' % timestamp, 12345, 'test_action'))

    def testRejectsExpiredToken(self):
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(
            XsrfToolTests.TEST_NOW + datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def testGoodTokenWithNoPriorTokenKey(self):
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def testBadTokenWithNoPriorTokenKey(self):
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(tool.verify_token(
            'NotTheRightDigest/%f' % timestamp, 12345, 'test_action'))
/n/n/n",0
21,21,d81fc3b81a2255ae128c54bf50a83bebc2118439,"/app/admin_api_keys.py/n/n#!/usr/bin/python2.7
# Copyright 2013 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import urllib

from google.appengine.ext import db
from google.appengine.api import users

from model import Authorization, ApiKeyManagementLog
import utils

from django.utils.html import escape
from django.utils.translation import ugettext as _


API_KEY_LENGTH = 16
KEYS_PER_PAGE = 50

def to_authorization_params(param):
    param_list = [
        'contact_name',
        'contact_email',
        'organization_name',
        'domain_write_permission',
        'read_permission',
        'full_read_permission',
        'search_permission',
        'subscribe_permission',
        'mark_notes_reviewed',
        'believed_dead_permission',
        'stats_permission',
        'is_valid',
    ]
    ret = {}
    for param_name in param_list:
        ret[param_name] = getattr(param, param_name)
    return ret


class ListApiKeys(utils.BaseHandler):
    """"""
    A handler for listing API keys for a particular domain.
    TODO(ryok): implement a search/filter and pagination feature.
    """"""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    @utils.require_api_key_management_permission
    def get(self):
        user = users.get_current_user()
        q = Authorization.all().filter('repo =', self.repo or '*')
        authorizations = q.fetch(KEYS_PER_PAGE)
        nav_html = ('<a href=""%s"">%s</a> '
                    % (self.get_url('admin/api_keys'),
                       escape(_('Create a new API key'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        return self.render('admin_api_keys_list.html',
                           nav_html=nav_html,
                           admin_api_keys_url=self.get_url('/admin/api_keys'),
                           user=user, authorizations=authorizations,
                           user_email_with_tags=user_email_with_tags)


class CreateOrUpdateApiKey(utils.BaseHandler):
    """"""A handler for create/update API keys.""""""

    https_required = True
    ignore_deactivation = True
    repo_required = False
    admin_required = True

    def render_form(self, authorization=None, message=''):
        """"""Display a form for create/update Authorization""""""
        user = users.get_current_user()
        if authorization:
            operation_name = _('Update an existing key')
            nav_html = ('<a href=""%s"">%s</a> '
                        % (self.get_url('admin/api_keys'),
                           escape(_('Create a new API key'))))
        else:
            authorization = Authorization.DEFAULT_SETTINGS
            operation_name = _('Create a new API key')
            nav_html = ''

        nav_html += ('<a href=""%s"">%s</a>'
                     % (self.get_url('admin/api_keys/list'),
                        escape(_('List API keys'))))
        user_email_with_tags = ('<span class=""email"">%s</span>'
                % escape(user.email()))
        xsrf_tool = utils.XsrfTool()
        return self.render(
            'admin_api_keys.html',
            user=user, target_key=authorization,
            user_email_with_tags=user_email_with_tags,
            login_url=users.create_login_url(self.request.url),
            logout_url=users.create_logout_url(self.request.url),
            operation_name=operation_name, message=message,
            nav_html=nav_html,
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_api_keys'),
        )

    @utils.require_api_key_management_permission
    def get(self):
        """"""
        It can be called with a key of ApiKeyManagementLog entity. In
        such a case, it will show a detailed information of the key in
        a form for updating the key, otherwise, it will show a form
        for creating a new API key.
        """"""
        management_log_key = self.request.get('log_key')
        if management_log_key:
            management_log = db.get(management_log_key)
            message = ''
            if management_log.action == ApiKeyManagementLog.CREATE:
                message = _('A new API key has been created successfully.')
            elif management_log.action == ApiKeyManagementLog.UPDATE:
                message = _('The API key has been updated successfully.')
            return self.render_form(management_log.authorization, message)
        else:
            # display a creation form
            return self.render_form()

    @utils.require_api_key_management_permission
    def post(self):
        """"""Handle a post request from the create/update/edit form""""""

        user = users.get_current_user()
        xsrf_tool = utils.XsrfTool()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):
            return self.error(403)

        # Handle a form submission from list page
        if self.request.get('edit_form'):
            authorization = db.get(self.request.get('authorization_key'))
            if not authorization:
                return self.error(404, _('No such Authorization entity.'))
            return self.render_form(authorization)

        # Handle authorization form submission
        if not (self.params.contact_name and 
                self.params.contact_email and
                self.params.organization_name):
            return self.error(400, _('Please fill in all the required fields.'))

        original_key = self.request.get('key')
        if original_key:
            # just override the existing one
            existing_authorization = db.get(original_key)
            if not existing_authorization:
                return self.error(404, _('No such Authorization entity.'))
            key_str = existing_authorization.api_key
            action = ApiKeyManagementLog.UPDATE
        else:
            key_str = utils.generate_random_key(API_KEY_LENGTH)
            action = ApiKeyManagementLog.CREATE
        repo = self.repo or '*'

        authorization = Authorization.create(
            repo, key_str,
            **to_authorization_params(self.params))
        authorization.put()

        management_log = ApiKeyManagementLog(repo=repo,
                                             api_key=authorization.api_key,
                                             action=action)
        management_log.put()

        self.redirect('/admin/api_keys?repo=%s&log_key=%s'
                      % (self.repo, management_log.key()))
/n/n/n",1
10,10,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
11,11,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
28,28,89bf68c6f62362e29467a2ed22eb2b477268eef8,"app/utils.py/n/n#!/usr/bin/python2.7
# Copyright 2017 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'

import calendar
import copy
from datetime import datetime, timedelta
import hmac
import httplib
import logging
import os
import random
import re
import string
import sys
import time
import traceback
import unicodedata
import urllib
import urlparse
import base64

from django.core.validators import EmailValidator, URLValidator, ValidationError
import django.utils.html
from django.utils.translation import ugettext as _
from django.template.defaulttags import register
from google.appengine.api import images
from google.appengine.api import taskqueue
from google.appengine.api import users
from google.appengine.ext import webapp
import google.appengine.ext.webapp.template
import google.appengine.ext.webapp.util
import recaptcha.client.captcha
from babel.dates import format_date
from babel.dates import format_datetime
from babel.dates import format_time
import babel

import const
import config
import model
import pfif
import resources

# The domain name from which to send e-mail.
EMAIL_DOMAIN = 'appspotmail.com'  # All apps on appspot.com use this for mail.

# Query parameters which are automatically preserved on page transition
# if you use utils.BaseHandler.get_url() or
# env.hidden_input_tags_for_preserved_query_params.
PRESERVED_QUERY_PARAM_NAMES = ['ui', 'charsets', 'referrer']

@register.filter
def get_value(dictionary, key):
    """"""Django Template filter to get dictionary value based on the given key""""""
    return dictionary.get(key)

# ==== Field value text ========================================================


def get_person_sex_text(person):
    """"""Returns the UI text for a person's sex field.""""""
    return const.PERSON_SEX_TEXT.get(person.sex or '')


def get_note_status_text(note):
    """"""Returns the UI text for a note's status field.""""""
    return const.NOTE_STATUS_TEXT.get(note.status or '')


def get_person_status_text(person):
    """"""Returns the UI text for a person's latest_status.""""""
    return const.PERSON_STATUS_TEXT.get(person.latest_status or '')


# Things that occur as prefixes of global paths (i.e. no repository name).
GLOBAL_PATH_RE = re.compile(r'^/(global|personfinder)(/?|/.*)$')


# ==== String formatting =======================================================


def format_boolean(value):
    return value and 'true' or 'false'


def format_utc_datetime(dt):
    if not dt:
        return ''
    return dt.replace(microsecond=0).isoformat() + 'Z'


def format_utc_timestamp(timestamp):
    if not isinstance(timestamp, (int, float)):
        return ''
    return format_utc_datetime(datetime.utcfromtimestamp(timestamp))


def format_sitemaps_datetime(dt):
    integer_dt = datetime(
        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
    return integer_dt.isoformat() + '+00:00'


def encode(string, encoding='utf-8'):
    """"""If unicode, encode to encoding; if 8-bit string, leave unchanged.""""""
    if isinstance(string, unicode):
        string = string.encode(encoding)
    return string


def urlencode(params, encoding='utf-8'):
    """"""Encode the key-value pairs in 'params' into a query string, applying
    the specified encoding to any Unicode strings and ignoring any keys that
    have value == None.  (urllib.urlencode doesn't support Unicode).""""""
    keys = params.keys()
    keys.sort()  # Sort the keys to get canonical ordering
    return urllib.urlencode([
        (encode(key, encoding), encode(params[key], encoding))
        for key in keys if isinstance(params[key], basestring)])


def set_param(params, param, value):
    """"""Take the params from a urlparse and override one of the values.""""""
    # This will strip out None-valued params and collapse repeated params.
    params = dict(urlparse.parse_qsl(params))
    if value is None:
        if param in params:
            del(params[param])
    else:
        params[param] = value
    return urlencode(params)


def set_url_param(url, param, value):
    """"""This modifies a URL setting the given param to the specified value.  This
    may add the param or override an existing value, or, if the value is None,
    it will remove the param.  Note that value must be a basestring and can't be
    an int, for example.""""""
    url_parts = list(urlparse.urlparse(url))
    url_parts[4] = set_param(url_parts[4], param, value)
    return urlparse.urlunparse(url_parts)


def anchor_start(href):
    """"""Returns the HREF escaped and embedded in an anchor tag.""""""
    return '<a href=""%s"">' % django.utils.html.escape(href)


def anchor(href, body):
    """"""Returns a string anchor HTML element with the given href and body.""""""
    return anchor_start(href) + django.utils.html.escape(body) + '</a>'


# ==== Validators ==============================================================

# These validator functions are used to check and parse query parameters.
# Each validator should return a parsed, sanitized value, or return a default
# value, or raise ValueError to display an error message to the user.


def strip(string):
    # Trailing nulls appear in some strange character encodings like Shift-JIS.
    return string.strip().rstrip('\0')


def strip_and_lower(string):
    return strip(string).lower()


def validate_yes(string):
    return (strip(string).lower() == 'yes') and 'yes' or ''


def validate_checkbox(string):
    return (strip(string).lower() == 'on') and 'yes' or ''


def validate_checkbox_as_bool(val):
    if val.lower() in ['on', 'yes', 'true']:
        return True
    return False


def validate_role(string):
    return (strip(string).lower() == 'provide') and 'provide' or 'seek'


def validate_int(string):
    return string and int(strip(string))


def validate_sex(string):
    """"""Validates the 'sex' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.PERSON_SEX_VALUES and string or ''


def validate_expiry(value):
    """"""Validates that the 'expiry_option' parameter is a positive integer.

    Returns:
      the int() value if it's present and parses, or the default_expiry_days
      for the repository, if it's set, otherwise -1 which represents the
      'unspecified' status.
    """"""
    try:
        value = int(value)
    except Exception, e:
        return None
    return value > 0 and value or None


APPROXIMATE_DATE_RE = re.compile(r'^\d{4}(-\d\d)?(-\d\d)?$')


def validate_approximate_date(string):
    if string:
        string = strip(string)
        if APPROXIMATE_DATE_RE.match(string):
            return string
    return ''


AGE_RE = re.compile(r'^(\d+)(-(\d+))?$')
# Hyphen with possibly surrounding whitespaces.
HYPHEN_RE = re.compile(
    ur'\s*[-\u2010-\u2015\u2212\u301c\u30fc\ufe58\ufe63\uff0d]\s*',
    re.UNICODE)


def validate_age(string):
    """"""Validates the 'age' parameter, returning a canonical value or ''.""""""
    if string:
        string = strip(string)
        string = unicodedata.normalize('NFKC', unicode(string))
        string = HYPHEN_RE.sub('-', string)
        if AGE_RE.match(string):
            return string
    return ''


def validate_status(string):
    """"""Validates an incoming status parameter, returning one of the canonical
    status strings or ''.  Note that '' is always used as the Python value
    to represent the 'unspecified' status.""""""
    if string:
        string = strip(string).lower()
    return string in pfif.NOTE_STATUS_VALUES and string or ''


DATETIME_RE = re.compile(r'^(2\d\d\d)-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z$')


def validate_datetime(string):
    if not string:
        return None  # A missing value is okay.
    match = DATETIME_RE.match(string)
    if match:
        return datetime(*map(int, match.groups()))
    raise ValueError('Bad datetime: %r' % string)


def validate_timestamp(string):
    try:
        return string and datetime.utcfromtimestamp(float(strip(string)))
    except:
        raise ValueError('Bad timestamp: %s' % string)


def validate_image(bytestring):
    try:
        image = None
        if bytestring:
            image = images.Image(bytestring)
            image.width
        return image
    except:
        return False


EMAIL_VALIDATOR = EmailValidator()


def validate_email(email):
    """"""Validates an email address, returning True on correct,
    False on incorrect, None on empty string.""""""
    # Note that google.appengine.api.mail.is_email_valid() is unhelpful;
    # it checks only for the empty string
    if not email:
        return None
    try:
        EMAIL_VALIDATOR(email)
        return True
    except ValidationError:
        return False


def validate_version(string):
    """"""Version, if present, should be in pfif versions.""""""
    if string and strip(string) not in pfif.PFIF_VERSIONS:
        raise ValueError('Bad pfif version: %s' % string)
    return pfif.PFIF_VERSIONS[strip(string) or pfif.PFIF_DEFAULT_VERSION]


REPO_RE = re.compile('^[a-z0-9-]+$')


def validate_repo(string):
    string = (string or '').strip()
    if not string:
        return None
    if string == 'global':
        raise ValueError('""global"" is an illegal repository name.')
    if REPO_RE.match(string):
        return string
    raise ValueError('Repository names can only contain '
                     'lowercase letters, digits, and hyphens.')


RESOURCE_NAME_RE = re.compile('^[a-z0-9._-]+$')


def validate_resource_name(string):
    """"""A resource name or bundle label.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if RESOURCE_NAME_RE.match(string):
        return string
    raise ValueError('Invalid resource name or bundle name: %r' % string)


LANG_RE = re.compile('^[A-Za-z0-9-]+$')


def validate_lang(string):
    """"""A BCP 47 language tag.""""""
    string = (string or '').strip().lower()
    if not string:
        return None
    if LANG_RE.match(string):
        return string
    raise ValueError('Invalid language tag: %r' % string)


def validate_cache_seconds(string):
    """"""A number of seconds to cache a Resource in RAM.""""""
    string = (string or '').strip()
    if string:
        return float(string)
    return 1.0


# ==== Fuzzification functions =================================================

# The range should be no more specific than a five year period.
MIN_AGE_RANGE = 5

def fuzzify_age(value):
    """"""Fuzzifies the age value for privacy.

    Args:
        value: a PFIF-compliant age value (a number or range, e.g., 45-49).

    Returns:
        A range of at least five years that includes the given value, or None if
        the input value is None or invalid.
    """"""
    if not value:
        return None
    parse = AGE_RE.match(value)
    if not parse:
        return None
    range_start = int(parse.group(1))
    range_end = int(parse.group(3)) if parse.group(3) else None
    if not range_end:
        # If no range was given, use a round five years around the given age.
        range_start -= range_start % MIN_AGE_RANGE
        return '%d-%d' % (range_start, range_start + MIN_AGE_RANGE)
    if (range_end - range_start) >= MIN_AGE_RANGE:
        # If the range we were given is already acceptably wide, leave it as-is.
        return value
    # If we were given too specific a range, pad it out to a round five year
    # range.
    range_start -= range_start % MIN_AGE_RANGE
    range_end += MIN_AGE_RANGE - ((range_end) % MIN_AGE_RANGE)
    return '%d-%d' % (range_start, range_end)


# ==== Other utilities =========================================================


def get_app_name():
    """"""Canonical name of the app, without HR s~ nonsense.  This only works in
    the context of the appserver (eg remote_api can't use it).""""""
    from google.appengine.api import app_identity
    return app_identity.get_application_id()


def sanitize_urls(record):
    """"""Clean up URLs to protect against XSS.

    We check URLs submitted through Person Finder, but bad data might come in
    through the API.
    """"""
    url_validator = URLValidator(schemes=['http', 'https'])
    # Single-line URLs.
    for field in ['photo_url', 'source_url']:
        url = getattr(record, field, None)
        if not url:
            continue
        try:
            url_validator(url)
        except ValidationError:
            setattr(record, field, None)
    # Multi-line URLs.
    for field in ['profile_urls']:
        urls = (getattr(record, field, None) or '').splitlines()
        sanitized_urls = []
        for url in urls:
            if url:
                try:
                    url_validator(url)
                    sanitized_urls.append(url)
                except ValidationError:
                    logging.warning(
                        'Unsanitary URL in database on %s' % record.record_id)
        if len(urls) != len(sanitized_urls):
            setattr(record, field, '\n'.join(sanitized_urls))


def get_host(host=None):
    host = host or os.environ['HTTP_HOST']
    """"""Return the host name, without version specific details.""""""
    parts = host.split('.')
    if len(parts) > 3:
        return '.'.join(parts[-3:])
    else:
        return host


# List of sensitive field names in person and note records.
SENSITIVE_FIELDS = [
  'date_of_birth',
  'author_email',
  'author_phone',
  'email_of_found_person',
  'phone_of_found_person',
]


def optionally_filter_sensitive_fields(records, auth=None):
    """"""Removes sensitive fields from a list of dictionaries, unless the client
    has full read authorization.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    if not (auth and auth.full_read_permission):
        filter_sensitive_fields(records)


def filter_sensitive_fields(records):
    """"""Removes sensitive fields from a list of dictionaries.

    Args:
        records (list of dict): A list of dictionaries which represent either of:
            - a person record
            - a note record
            - a joined record of a person and a note
    """"""
    for record in records:
        for prefix in ['', 'person_', 'note_']:
            for field in SENSITIVE_FIELDS:
                prefixed_field = prefix + field
                if prefixed_field in record:
                    record[prefixed_field] = ''


def join_person_and_note_record(person_record, note_record):
    """"""Join a person record and a note record into a single dictionary.

    The field names are prefixed with 'person_' or 'note_' to avoid name
    collision. note_record can be None. In that case, person record field
    names are still prefixed.

    Args:
        person_record (dict): A dictionary representation of a person record.
            Cannot be None.
        note_record (dict): A dictionary representation of a note record for
            the person. Can be None.
    """"""
    joined_record = {}
    for name, value in person_record.iteritems():
        new_name = get_field_name_for_joined_record(name, 'person')
        joined_record[new_name] = value
    if note_record:
        assert (note_record['person_record_id'] ==
                person_record['person_record_id'])
        for name, value in note_record.iteritems():
            new_name = get_field_name_for_joined_record(name, 'note')
            joined_record[new_name] = value
    return joined_record


def get_field_name_for_joined_record(original_field_name, record_type):
    """"""Converts a field name in a person/note record into a field name used in
    a joined record of a person and a note.

    See also join_person_and_note_record().

    Args:
        original_field_name (str): A field name in a person/note record.
        record_type (str): 'person' or 'note'.
    """"""
    if original_field_name in ('person_record_id', 'note_record_id'):
        return original_field_name
    else:
        return '%s_%s' % (record_type, original_field_name)


# The current time for testing as a datetime object, or None if using real time.
_utcnow_for_test = None


def set_utcnow_for_test(now):
    """"""Sets the current time for testing purposes.  Pass in a datetime object
    or a timestamp in epoch seconds; or pass None to revert to real time.""""""
    global _utcnow_for_test
    if isinstance(now, (int, float)):
        now = datetime.utcfromtimestamp(float(now))
    _utcnow_for_test = now


def get_utcnow():
    """"""Returns the current UTC datetime (settable with set_utcnow_for_test).""""""
    global _utcnow_for_test
    return (_utcnow_for_test is None) and datetime.utcnow() or _utcnow_for_test


def get_timestamp(dt):
    """"""Converts datetime object to a float value in epoch seconds.""""""
    return calendar.timegm(dt.utctimetuple()) + dt.microsecond * 1e-6


def get_utcnow_timestamp():
    """"""Returns the current time in epoch seconds (settable with
    set_utcnow_for_test).""""""
    return get_timestamp(get_utcnow())


def log_api_action(handler, action, num_person_records=0, num_note_records=0,
                   people_skipped=0, notes_skipped=0):
    """"""Log an API action.""""""
    if handler.config and handler.config.api_action_logging:
        model.ApiActionLog.record_action(
            handler.repo, handler.params.key,
            handler.params.version.version, action,
            num_person_records, num_note_records,
            people_skipped, notes_skipped,
            handler.request.headers.get('User-Agent'),
            handler.request.remote_addr, handler.request.url)


def get_full_name(given_name, family_name, config):
    """"""Return full name string obtained by concatenating given_name and
    family_name in the order specified by config.family_name_first, or just
    given_name if config.use_family_name is False.""""""
    if config.use_family_name:
        separator = (given_name and family_name) and u' ' or u''
        if config.family_name_first:
            return separator.join([family_name, given_name])
        else:
            return separator.join([given_name, family_name])
    else:
        return given_name


def send_confirmation_email_to_record_author(
    handler, person, action, confirm_url, record_id):
    """"""Send the author an email to confirm enabling/disabling notes
    of a record.""""""
    if not person.author_email:
        return handler.error(
            400, _('No author email for record %(id)s.') % {'id' : record_id})

    # i18n: Subject line of an e-mail message confirming the author
    # wants to disable notes for this record
    if action == 'enable':
        subject = _('[Person Finder] Enable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    elif action == 'disable':
        subject = _('[Person Finder] Disable notes on ""%(full_name)s""?'
                ) % {'full_name': person.primary_full_name}
    else:
        raise ValueError('Unknown action: %s' % action)

    # send e-mail to record author confirming the lock of this record.
    template_name = '%s_notes_email.txt' % action
    handler.send_mail(
        subject=subject,
        to=person.author_email,
        body=handler.render_to_string(
            template_name,
            author_name=person.author_name,
            full_name=person.primary_full_name,
            site_url=handler.get_url('/'),
            confirm_url=confirm_url
        )
    )


def get_repo_url(request, repo, scheme=None):
    """"""Constructs the absolute root URL for a given repository.""""""
    req_scheme, req_netloc, req_path, _, _ = urlparse.urlsplit(request.url)
    prefix = req_path.startswith('/personfinder') and '/personfinder' or ''
    if is_dev_app_server():
        scheme = 'http'  # HTTPS is not available when using dev_appserver
    return (scheme or req_scheme) + '://' + req_netloc + prefix + '/' + repo


def get_url(request, repo, action, charset='utf-8', scheme=None, **params):
    """"""Constructs the absolute URL for a given action and query parameters,
    preserving the current repo and the parameters listed in
    PRESERVED_QUERY_PARAM_NAMES.""""""
    repo_url = get_repo_url(request, repo or 'global', scheme)
    for name in PRESERVED_QUERY_PARAM_NAMES:
        params[name] = params.get(name, request.get(name, None))
    query = urlencode(params, charset)
    return repo_url + '/' + action.lstrip('/') + (query and '?' + query or '')


def add_profile_icon_url(website, handler):
    website = copy.deepcopy(website)  # avoid modifying the original
    website['icon_url'] = \
        handler.env.global_url + '/' + website['icon_filename']
    return website


def strip_url_scheme(url):
    if not url:
        return url
    _, netloc, path, query, segment = urlparse.urlsplit(url)
    return urlparse.urlunsplit(('', netloc, path, query, segment))


def is_dev_app_server():
    return os.environ['APPLICATION_ID'].startswith('dev~')

# ==== Struct ==================================================================

class Struct:
    """"""A simple bag of attributes.""""""
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def get(self, name, default=None):
        return self.__dict__.get(name, default)


# ==== Key management ======================================================

def generate_random_key(length):
    """"""Generates a random key with given length.""""""
    source = ('abcdefghijklmnopqrstuvwxyz'
              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
              '1234567890'
              '-_')
    rng = random.SystemRandom()
    return ''.join(rng.choice(source) for i in range(length))


# ==== Decorators  ============================================================

def require_api_key_management_permission(handler_method):
    """"""
    This is a decorator for API Key management feature. The limitation
    is that the decorator can not preserve payloads within a POST/PUT
    request.

    Usage:
    class SomeHandler(utils.BaseHandler):
        @utils.require_api_key_management_permission
        def get(self):
            # ....
            # ....
    """"""
    def inner(*args, **kwargs):
        handler = args[0]
        user = users.get_current_user()
        if (users.is_current_user_admin() or
            (user and handler.config.key_management_operators and
             user.email() in handler.config.key_management_operators)):
            return handler_method(*args, **kwargs)
        else:
            return handler.redirect(
                users.create_login_url(handler.request.url))
    return inner


# ==== Base Handler ============================================================

class BaseHandler(webapp.RequestHandler):
    # Handlers that don't need a repository name can set this to False.
    repo_required = True

    # Handlers that require HTTPS can set this to True.
    https_required = True

    # Set this to True to enable a handler even for deactivated repositories.
    ignore_deactivation = False

    # Handlers that require an admin permission must set this to True.
    admin_required = False

    # List all accepted query parameters here with their associated validators.
    auto_params = {
        'action': strip,
        'add_note': validate_yes,
        'age': validate_age,
        'alternate_family_names': strip,
        'alternate_given_names': strip,
        'author_email': strip,
        'author_made_contact': validate_yes,
        'author_name': strip,
        'author_phone': strip,
        'your_own_email': strip,
        'your_own_phone': strip,
        'believed_dead_permission': validate_checkbox_as_bool,
        'cache_seconds': validate_cache_seconds,
        'clone': validate_yes,
        'confirm': validate_yes,
        'contact_email': strip,
        'contact_name': strip,
        'content_id': strip,
        'context': strip,
        'cursor': strip,
        'date_of_birth': validate_approximate_date,
        'description': strip,
        'domain_write_permission': strip,
        'dupe_notes': validate_yes,
        'email_of_found_person': strip,
        'error': strip,
        'expiry_option': validate_expiry,
        'family_name': strip,
        'full_read_permission': validate_checkbox_as_bool,
        'given_name': strip,
        'home_city': strip,
        'home_country': strip,
        'home_neighborhood': strip,
        'home_postal_code': strip,
        'home_state': strip,
        'id': strip,
        'id1': strip,
        'id2': strip,
        'id3': strip,
        'is_valid': validate_checkbox_as_bool,
        'key': strip,
        'lang': validate_lang,
        'last_known_location': strip,
        'mark_notes_reviewed': validate_checkbox_as_bool,
        'max_results': validate_int,
        'min_entry_date': validate_datetime,
        'new_repo': validate_repo,
        'note_photo': validate_image,
        'note_photo_url': strip,
        'omit_notes': validate_yes,
        'operation': strip,
        'organization_name': strip,
        'person_record_id': strip,
        'phone_of_found_person': strip,
        'photo': validate_image,
        'photo_url': strip,
        'profile_url1': strip,
        'profile_url2': strip,
        'profile_url3': strip,
        'query': strip,
        'query_name': strip,
        'query_location': strip,
        'query_type': strip,
        'read_permission': validate_checkbox_as_bool,
        'referrer': strip,
        'resource_bundle': validate_resource_name,
        'resource_bundle_default': validate_resource_name,
        'resource_bundle_original': validate_resource_name,
        'resource_lang': validate_lang,
        'resource_name': validate_resource_name,
        'role': validate_role,
        'search_engine_id': validate_int,
        'search_permission': validate_checkbox_as_bool,
        'sex': validate_sex,
        'signature': strip,
        'skip': validate_int,
        'small': validate_yes,
        'source': strip,
        'source_date': strip,
        'source_name': strip,
        'source_url': strip,
        'stats_permission': validate_checkbox_as_bool,
        'status': validate_status,
        'style': strip,
        'subscribe': validate_checkbox,
        'subscribe_own_info': validate_checkbox,
        'subscribe_email': strip,
        'subscribe_permission': validate_checkbox_as_bool,
        'suppress_redirect': validate_yes,
        'target': strip,
        'text': strip,
        'thumb': validate_checkbox_as_bool,
        'timestamp': validate_timestamp,
        'ui': strip_and_lower,
        'utcnow': validate_timestamp,
        'version': validate_version,
        'own_info': validate_yes,
        'xsrf_token': strip,
    }

    def redirect(self, path, repo=None, permanent=False, **params):
        # This will prepend the repo to the path to create a working URL,
        # unless the path has a global prefix or is an absolute URL.
        if re.match('^[a-z]+:', path) or GLOBAL_PATH_RE.match(path):
            if params:
              path += '?' + urlencode(params, self.charset)
        else:
            path = self.get_url(path, repo, **params)
        return webapp.RequestHandler.redirect(self, path, permanent=permanent)

    def render(self, name, language_override=None, cache_seconds=0,
               get_vars=lambda: {}, **vars):
        """"""Renders a template to the output stream, passing in the variables
        specified in **vars as well as any additional variables returned by
        get_vars().  Since this is intended for use by a dynamic page handler,
        caching is off by default; if cache_seconds is positive, then
        get_vars() will be called only when cached content is unavailable.""""""
        self.write(self.render_to_string(
            name, language_override, cache_seconds, get_vars, **vars))

    def render_to_string(self, name, language_override=None, cache_seconds=0,
                         get_vars=lambda: {}, **vars):
        """"""Renders a template to a string, passing in the variables specified
        in **vars as well as any additional variables returned by get_vars().
        Since this is intended for use by a dynamic page handler, caching is
        off by default; if cache_seconds is positive, then get_vars() will be
        called only when cached content is unavailable.""""""
        # TODO(kpy): Make the contents of extra_key overridable by callers?
        lang = language_override or self.env.lang
        extra_key = (self.env.repo, self.env.charset, self.request.query_string)
        def get_all_vars():
            vars.update(get_vars())
            for key in ('env', 'config', 'params'):
                if key in vars:
                    raise Exception(
                        'Cannot use ""%s"" as a key in vars. It is reserved.'
                        % key)
            vars['env'] = self.env  # pass along application-wide context
            vars['config'] = self.config  # pass along the configuration
            vars['params'] = self.params  # pass along the query parameters
            return vars
        return resources.get_rendered(
            name, lang, extra_key, get_all_vars, cache_seconds)

    def error(self, code, message='', message_html=''):
        self.info(code, message, message_html, style='error')

    def info(self, code, message='', message_html='', style='info'):
        """"""Renders a simple page with a message.

        Args:
          code: HTTP status code.
          message: A message in plain text.
          message_html: A message in HTML.
          style: 'info', 'error' or 'plain'. 'info' and 'error' differs in
              appearance. 'plain' just renders the message without extra
              HTML tags. Good for API response.
        """"""
        is_error = 400 <= code < 600
        if is_error:
            webapp.RequestHandler.error(self, code)
        else:
            self.response.set_status(code)
        if not message and not message_html:
            message = '%d: %s' % (code, httplib.responses.get(code))
        if style == 'plain':
            self.__render_plain_message(message, message_html)
        else:
            try:
                self.render('message.html', cls=style,
                            message=message, message_html=message_html)
            except:
                self.__render_plain_message(message, message_html)
        self.terminate_response()

    def __render_plain_message(self, message, message_html):
        self.response.out.write(
            django.utils.html.escape(message) +
            ('<p>' if message and message_html else '') +
            message_html)

    def terminate_response(self):
        """"""Prevents any further output from being written.""""""
        self.response.out.write = lambda *args: None
        self.get = lambda *args: None
        self.post = lambda *args: None

    def write(self, text):
        """"""Sends text to the client using the charset from select_charset().""""""
        self.response.out.write(text.encode(self.env.charset, 'replace'))

    def get_url(self, action, repo=None, scheme=None, **params):
        """"""Constructs the absolute URL for a given action and query parameters,
        preserving the current repo and the parameters listed in
        PRESERVED_QUERY_PARAM_NAMES.""""""
        return get_url(self.request, repo or self.env.repo, action,
                       charset=self.env.charset, scheme=scheme, **params)

    @staticmethod
    def add_task_for_repo(repo, name, action, **kwargs):
        """"""Queues up a task for an individual repository.""""""
        task_name = '%s-%s-%s' % (repo, name, int(time.time()*1000))
        path = '/%s/%s' % (repo, action)
        taskqueue.add(name=task_name, method='GET', url=path, params=kwargs)

    def send_mail(self, to, subject, body):
        """"""Sends e-mail using a sender address that's allowed for this app.""""""
        app_id = get_app_name()
        sender = 'Do not reply <do-not-reply@%s.%s>' % (app_id, EMAIL_DOMAIN)
        logging.info('Add mail task: recipient %r, subject %r' % (to, subject))
        taskqueue.add(queue_name='send-mail', url='/global/admin/send_mail',
                      params={'sender': sender,
                              'to': to,
                              'subject': subject,
                              'body': body})

    def get_captcha_html(self, error_code=None, use_ssl=False):
        """"""Generates the necessary HTML to display a CAPTCHA validation box.""""""

        # We use the 'custom_translations' parameter for UI messages, whereas
        # the 'lang' parameter controls the language of the challenge itself.
        # reCAPTCHA falls back to 'en' if this parameter isn't recognized.
        lang = self.env.lang.split('-')[0]

        return recaptcha.client.captcha.get_display_html(
            site_key=config.get('captcha_site_key'),
            use_ssl=use_ssl, error=error_code, lang=lang
        )

    def get_captcha_response(self):
        """"""Returns an object containing the CAPTCHA response information for the
        given request's CAPTCHA field information.""""""
        # Allows faking the CAPTCHA response by an HTTP request parameter, but
        # only locally, for testing purpose.
        faked_captcha_response = self.request.get('faked_captcha_response')
        if faked_captcha_response and self.request.remote_addr == '127.0.0.1':
            return recaptcha.client.captcha.RecaptchaResponse(
                is_valid=faked_captcha_response == 'success')

        captcha_response = self.request.get('g-recaptcha-response')
        return recaptcha.client.captcha.submit(captcha_response)

    def handle_exception(self, exception, debug_mode):
        logging.error(traceback.format_exc())
        self.error(500, _(
            'There was an error processing your request.  Sorry for the '
            'inconvenience.  Our administrators will investigate the source '
            'of the problem, but please check that the format of your '
            'request is correct.'))

    def __get_env_language_for_babel(self):
        language_code = self.env.lang
        try:
            return babel.Locale.parse(language_code, sep='-')
        except babel.UnknownLocaleError as e:
            # fallback language
            return babel.Locale('en')

    def to_local_time(self, date):
        """"""Converts a datetime object to the local time configured for the
        current repository.  For convenience, returns None if date is None.""""""
        # TODO(kpy): This only works for repositories that have a single fixed
        # time zone offset and never use Daylight Saving Time.
        if date:
            if self.config.time_zone_offset:
                return date + timedelta(0, 3600*self.config.time_zone_offset)
            return date

    def format_datetime_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale.""""""
        return format_datetime(dt, locale=self.__get_env_language_for_babel());

    def format_date_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the date.""""""
        return format_date(dt, locale=self.__get_env_language_for_babel());

    def format_time_localized(self, dt):
        """"""Formats a datetime object to a localized human-readable string based
        on the current locale containing only the time.""""""
        return format_time(dt, locale=self.__get_env_language_for_babel());

    def to_formatted_local_datetime(self, dt):
        """"""Converts a datetime object to the local datetime configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_datetime_localized(dt)

    def to_formatted_local_date(self, dt):
        """"""Converts a datetime object to the local date configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_date_localized(dt)

    def to_formatted_local_time(self, dt):
        """"""Converts a datetime object to the local time configured for the
        current repository and formats to a localized human-readable string
        based on the current locale.""""""
        dt = self.to_local_time(dt)
        return self.format_time_localized(dt)

    def maybe_redirect_for_repo_alias(self, request):
        """"""If the specified repository name is an alias, redirects to the URL
        with the canonical repository name and returns True. Otherwise returns
        False.
        """"""
        # Config repo_alias is a dictionary from a repository name alias to
        # its canonical.
        # e.g., {'yol': '2013-yolanda', 'jam': '2014-jammu-kashmir-floods'}
        #
        # A repository name alias can be used instead of the canonical
        # repository name in URLs. This is especially useful combined with
        # the short URL. e.g., You can access
        # https://www.google.org/personfinder/2014-jammu-kashmir-floods
        # by https://g.co/pf/jam .
        if not self.repo:
            return False
        repo_aliases = config.get('repo_aliases', default={})
        if self.repo in repo_aliases:
            canonical_repo = repo_aliases[self.repo]
            params = {}
            for name in request.arguments():
                params[name] = request.get(name)
            # Redirects to the same URL including the query parameters, except
            # for the repository name.
            self.redirect('/' + self.env.action, repo=canonical_repo, **params)
            self.terminate_response()
            return True
        else:
            return False

    def should_show_inline_photo(self, photo_url):
        """"""Returns True if we should show the photo in our site directly with
        <img> tag. Returns True only if the photo is served by our domain, to
        avoid loading resources in other domains in Person Finder.
        """"""
        if not photo_url:
            return False
        else:
            _, our_netloc, _, _, _ = urlparse.urlsplit(self.request.url)
            _, photo_netloc, _, _, _ = urlparse.urlsplit(photo_url)
            return photo_netloc == our_netloc

    URL_PARSE_QUERY_INDEX = 4

    def get_thumbnail_url(self, photo_url):
        """"""Get a thumbnail URL for an uploaded photo's URL.

        Args:
            photo_url: a photo URL for an uploaded photo
        """"""
        if not photo_url:
            return None
        parsed_url = list(urlparse.urlparse(photo_url))
        params_dict = dict(urlparse.parse_qsl(
            parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX]))
        params_dict['thumb'] = 'true'
        parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX] = urllib.urlencode(
            params_dict)
        return urlparse.urlunparse(parsed_url)

    def set_auth(self):
        self.auth = None
        if self.params.key:
            if self.repo:
                # check for domain specific one.
                self.auth = model.Authorization.get(self.repo, self.params.key)
            if not self.auth:
                # perhaps this is a global key ('*' for consistency with config).
                self.auth = model.Authorization.get('*', self.params.key)
        if self.auth and not self.auth.is_valid:
            self.auth = None

    def __return_unimplemented_method_error(self):
        return self.error(
            405,
            'HTTP method %s is not allowed for this URL.'
                % self.request.method)

    def __init__(self, request, response, env):
        webapp.RequestHandler.__init__(self, request, response)
        self.params = Struct()
        self.env = env
        self.repo = env.repo
        self.config = env.config
        self.charset = env.charset

        # Set default Content-Type header.
        self.response.headers['Content-Type'] = (
            'text/html; charset=%s' % self.charset)
        if self.admin_required:
            self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'

        # Validate query parameters.
        for name, validator in self.auto_params.items():
            try:
                value = self.request.get(name, '')
                setattr(self.params, name, validator(value))
            except Exception, e:
                setattr(self.params, name, validator(None))
                return self.error(400, 'Invalid parameter %s: %s' % (name, e))

        # Ensure referrer is in whitelist, if it exists
        if self.params.referrer and (not self.params.referrer in
                                     self.config.referrer_whitelist):
            setattr(self.params, 'referrer', '')

        # Check for SSL (unless running local dev app server).
        if self.https_required and not is_dev_app_server():
            if self.env.scheme != 'https':
                url_parts = list(urlparse.urlparse(self.request.url))
                url_parts[0] = 'https'  # The 0th part is the scheme.
                webapp.RequestHandler.redirect(
                    self, urlparse.urlunparse(url_parts))
                self.terminate_response()
                return

        # Handles repository alias.
        if self.maybe_redirect_for_repo_alias(request):
            return

        # Shows a custom error page here when the user is not an admin
        # instead of ""login: admin"" in app.yaml
        # If we use it, user can't sign out
        # because the error page of ""login: admin"" doesn't have sign-out link.
        if self.admin_required:
            self.env.user = users.get_current_user()
            if not self.env.user:
                login_url = users.create_login_url(self.request.url)
                webapp.RequestHandler.redirect(self, login_url)
                self.terminate_response()
                return
            if not users.is_current_user_admin():
                logout_url = users.create_logout_url(self.request.url)
                self.render('not_admin_error.html', logout_url=logout_url, user=user)
                self.terminate_response()
                return
            self.env.logout_url = users.create_logout_url(self.request.url)
            # This is different from env.repo_options because this contains all
            # repositories including deactivated ones.
            self.env.all_repo_options = [
                Struct(
                    repo=repo,
                    url=get_repo_url(self.request, repo) + '/admin')
                for repo in sorted(model.Repo.list())]

        # Handlers that don't need a repository configuration can skip it.
        if not self.repo:
            if self.repo_required:
                return self.error(400, 'No repository specified.')
            return
        # Everything after this requires a repo.

        # Reject requests for repositories that don't exist.
        if not model.Repo.get_by_key_name(self.repo):
            html = 'No such repository. '
            if self.env.repo_options:
                html += 'Select:<p>' + self.render_to_string('repo-menu.html')
            return self.error(404, message_html=html)

        # If this repository has been deactivated, terminate with a message.
        # The ignore_deactivation flag is for admin pages that bypass this.
        if self.config.deactivated and not self.ignore_deactivation:
            self.env.language_menu = []
            self.env.robots_ok = True
            self.render('message.html', cls='deactivation',
                        message_html=self.config.deactivation_message_html)
            self.terminate_response()

    def get(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def post(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def put(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def head(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def options(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def delete(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()

    def trace(self, *args):
        """"""Default handler implementation which returns HTTP status 405.""""""
        return self.__return_unimplemented_method_error()


# ==== XSRF protection =========================================================

class XsrfTool(object):

    # XSRF tokens expire after 4 hours.
    TOKEN_EXPIRATION_TIME = 60 * 60 * 4

    def __init__(self):
        configured_key = config.get('xsrf_token_key')
        if configured_key:
            # config.get returns unicode, but hmac is going to want a str
            self._key = configured_key.encode('utf-8')
        else:
            configured_key = generate_random_key(20)
            config.set(xsrf_token_key=configured_key)
            self._key = configured_key

    def generate_token(self, user_id, action_id):
        action_time = get_utcnow_timestamp()
        return '%s/%f' % (
            self._generate_hmac_digest(user_id, action_id, action_time),
            action_time)

    def verify_token(self, token, user_id, action_id):
        token_spl = token.split('/')
        if len(token_spl) != 2:
            return False
        [hmac_digest, action_time_str] = token_spl
        action_time = float(action_time_str)
        if (action_time + XsrfTool.TOKEN_EXPIRATION_TIME <
            get_utcnow_timestamp()):
            return False
        expected_hmac_digest = self._generate_hmac_digest(
            user_id, action_id, action_time)
        return hmac.compare_digest(
            hmac_digest.encode('utf-8'), expected_hmac_digest)

    def _generate_hmac_digest(self, user_id, action_id, action_time):
        hmac_obj = hmac.new(
            self._key, '%s/%s/%f' % (user_id, action_id, action_time))
        return hmac_obj.hexdigest()
/n/n/ntests/test_xsrftool.py/n/n""""""Tests for the XSRF tool.""""""

import datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):
    """"""Test cases for utils.XsrfTool.""""""

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def test_gen_and_verify_good_token(self):
        """"""Tests generating and verifying a good token.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_rejects_invalid_tokens(self):
        """"""Tests that an invalid token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        self.assertFalse(tool.verify_token(
            'ThisTokenDoesNotEvenHaveASlash', 12345, 'test_action'))
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))

    def test_rejects_expired_token(self):
        """"""Tests that an expired token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +
                                  datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def test_good_with_no_prior_key(self):
        """"""Tests a good token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_bad_with_no_prior_key(self):
        """"""Tests a bad token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_delete-record': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/ntests/views/test_auto_security.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""Automatic security tests.

This file isn't meant for tests specific to a particular page; they're designed
as general-purpose tests for common security requirements. All paths must be
included in the AutoSecurityTests.PATH_TEST_INFO list (this is tested to ensure
we can't forget these tests for a new view).
""""""

import collections
import copy
import os

import django.urls

import urls

import view_tests_base


# A tuple containing configuration for automatic security tests for a path.
PathTestInfo = collections.namedtuple(
    'PathTestInfo',
    [
        # Whether the path is expected to accept GET requests.
        'accepts_get',
        # Whether the past is expected to accept POST requests.
        'accepts_post',
        # Whether the page is restricted to admins.
        'restricted_to_admins',
        # Whether POST requests should require an XSRF token.
        'requires_xsrf',
        # A dict with valid POST data, excluding an XSRF token (the tests will
        # add, or omit, the XSRF tokens). Should be None if XSRF isn't used for
        # the page.
        'sample_post_data',
        # The action ID used for XSRF tokens. Should be None if XSRF isn't used
        # for the page.
        'xsrf_action_id',
    ])


class AutoSecurityTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""
    # pylint: disable=no-self-use

    # A map from path names (defined in urls.py) to PathTestInfo tuples.
    PATH_TEST_INFO = {
        'admin_apikeys-list':
        PathTestInfo(
            accepts_get=True,
            accepts_post=False,
            restricted_to_admins=True,
            requires_xsrf=False,
            sample_post_data=None,
            xsrf_action_id=None),
        'admin_apikeys-manage':
        PathTestInfo(
            accepts_get=True,
            accepts_post=True,
            restricted_to_admins=True,
            requires_xsrf=True,
            sample_post_data={
                'contact_name': 'Bob',
                'contact_email': 'bob@fridge.com',
                'organization_name': 'Vance Refrigeration',
            },
            xsrf_action_id='admin_api_keys'),
        'admin_create-repo':
        PathTestInfo(
            accepts_get=True,
            accepts_post=True,
            restricted_to_admins=True,
            requires_xsrf=True,
            sample_post_data={
                'new_repo': 'new-hampshire',
            },
            xsrf_action_id='admin/create_repo'),
        'admin_delete-record':
        PathTestInfo(
            accepts_get=True,
            accepts_post=True,
            restricted_to_admins=True,
            requires_xsrf=True,
            sample_post_data={
                'id': 'abc123',
            },
            xsrf_action_id='admin/delete_record'),
        'admin_statistics':
        PathTestInfo(
            accepts_get=True,
            accepts_post=False,
            restricted_to_admins=True,
            requires_xsrf=False,
            sample_post_data=None,
            xsrf_action_id=None),
        'meta_sitemap':
        PathTestInfo(
            accepts_get=True,
            accepts_post=False,
            restricted_to_admins=False,
            requires_xsrf=False,
            sample_post_data=None,
            xsrf_action_id=None),
    }

    def get_path(self, path_name):
        """"""Gets a path to use for the given path name.

        Args:
            path_name (str): The path name defined in urls.py.

        This will first try to reverse the URL with no arguments, and then fall
        back to reversing it with a ""repo"" argument. If we ever have URLs with
        more interesting things in the path besides repo, we'll have to rethink
        this.
        """"""
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def get_valid_post_data(self, path_info):
        """"""Gets data for a valid POST requests.

        Generates and includes a valid XSRF token when needed.
        """"""
        if path_info.requires_xsrf:
            # Copy the data dict to avoid mutating the original.
            data = copy.deepcopy(path_info.sample_post_data)
            data['xsrf_token'] = self._xsrf_tool.generate_token(
                view_tests_base.ViewTestsBase.TEST_USER_ID,
                path_info.xsrf_action_id)
            return data
        return path_info.sample_post_data

    def get_paths_to_test(self, filter_func):
        """"""Gets paths to test based on a filter function.

        Args:
            filter_func (function): A function that accepts a PathTestInfo tuple
            and returns True or False to indicate if it should be included.

        Returns:
            list: A list of tuples with path names and PathTestInfo tuples.
        """"""
        return [(path_name, path_info)
                for (path_name,
                     path_info) in AutoSecurityTests.PATH_TEST_INFO.items()
                if filter_func(path_info)]

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.restricted_to_admins):
            path = self.get_path(path_name)
            if path_info.accepts_get:
                self.assertEqual(
                    self.client.get(path, secure=True).status_code, 403,
                    'Admin-only page available to non-admin: %s' % path_name)
            if path_info.accepts_post:
                self.assertEqual(
                    self.client.post(
                        path, self.get_valid_post_data(path_info),
                        secure=True).status_code, 403,
                    'Admin-only page available to non-admin: %s' % path_name)

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.restricted_to_admins):
            path = self.get_path(path_name)
            if path_info.accepts_get:
                self.assertEqual(
                    self.client.get(path, secure=True).status_code, 200,
                    'GET unavailable to admins for: %s' % path_name)
            # Some POST requests might return a redirect, so just ensure they
            # don't get a 403 like non-admins do.
            if path_info.accepts_post:
                self.assertNotEqual(
                    self.client.post(
                        path, self.get_valid_post_data(path_info),
                        secure=True).status_code, 403,
                    'POST unavailable to admins for: %s' % path_name)

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: not path_info.restricted_to_admins):
            path = self.get_path(path_name)
            if path_info.accepts_get:
                self.assertEqual(
                    self.client.get(path, secure=True).status_code, 200,
                    'Unrestricted page blocked to non-admin: %s' % path_name)
            if path_info.accepts_post:
                # Redirects are fine, just check that they don't get a 403.
                self.assertNotEqual(
                    self.client.post(
                        path, self.get_valid_post_data(path_info),
                        secure=True).status_code, 403,
                    'Unrestricted page blocked to non-admin: %s' % path_name)

    def test_missing_xsrf_token(self):
        """"""Tests that, if XSRF is required, POSTs without a token are rejected.
        """"""
        self.login(is_admin=True)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.requires_xsrf):
            # Just in case someone accidentally included an XSRF token in the
            # PathTestInfo tuple.
            assert 'xsrf_token' not in path_info.sample_post_data
            path = self.get_path(path_name)
            self.assertEqual(
                self.client.post(path, path_info.sample_post_data,
                                 secure=True).status_code, 403,
                'XSRF page accepts data missing XSRF token: %s' % path_name)
            post_data = copy.deepcopy(path_info.sample_post_data)
            post_data['xsrf_token'] = ''
            self.assertEqual(
                self.client.post(path, post_data, secure=True).status_code, 403,
                'XSRF page accepts data empty XSRF token: %s' % path_name)

    def test_invalid_xsrf_token(self):
        """"""Tests that XSRF tokens are checked for validity.""""""
        self.login(is_admin=True)
        for (path_name, path_info) in self.get_paths_to_test(
                lambda path_info: path_info.requires_xsrf):
            path = self.get_path(path_name)
            post_data = copy.deepcopy(path_info.sample_post_data)
            post_data['xsrf_token'] = 'NotAValidToken'
            self.assertEqual(
                self.client.post(path, post_data, secure=True).status_code, 403,
                'XSRF page accepts data invalid XSRF token: %s' % path_name)

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip tasks; they'll be tested separately.
                continue
            assert pattern.name in AutoSecurityTests.PATH_TEST_INFO

    def test_gae_task_header_required(self):
        """"""Tests that tasks can only be called by App Engine.

        App Engine sets a special header (and strips it out of external
        requests); we use that to reject external requests to task handlers.
        """"""
        # Set this to a non-dev ID, because we permit non-GAE requests in dev.
        os.environ['APPLICATION_ID'] = 'prod-app'
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if not pattern.name.startswith('tasks_'):
                # Skip views that aren't task handlers; they're tested
                # elsewhere.
                continue
            path = self.get_path(pattern.name)
            assert self.client.get(path, secure=True).status_code == 403
/n/n/ntests/views/view_tests_base.py/n/n""""""Tools to help run tests against the Django app.""""""

import const
import utils

import scrape
import testutils.base


class ViewTestsBase(testutils.base.ServerTestsBase):
    """"""A base class for tests for the Django app.""""""

    TEST_USER_EMAIL = 'kay@mib.gov'
    TEST_USER_ID = 'k'

    def setUp(self):
        super(ViewTestsBase, self).setUp()
        self._xsrf_tool = utils.XsrfTool()

    def login(self, is_admin=False):
        """"""Logs in the ""user"" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """"""
        self.testbed.setup_env(
            user_email=ViewTestsBase.TEST_USER_EMAIL,
            user_id=ViewTestsBase.TEST_USER_ID,
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(
            ViewTestsBase.TEST_USER_ID, action_id)

    def to_doc(self, response):
        """"""Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """"""
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)
/n/n/n",0
29,29,89bf68c6f62362e29467a2ed22eb2b477268eef8,"/tests/test_xsrftool.py/n/n""""""Tests for the XSRF tool.""""""

import datetime
import unittest

import config
import utils


class XsrfToolTests(unittest.TestCase):
    """"""Test cases for utils.XsrfTool.""""""

    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)

    def setUp(self):
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)

    def test_gen_and_verify_good_token(self):
        """"""Tests generating and verifying a good token.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_rejects_invalid_token(self):
        """"""Tests that an invalid token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))

    def test_rejects_expired_token(self):
        """"""Tests that an expired token is rejected.""""""
        config.set(xsrf_token_key='abcdef')
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +
                                  datetime.timedelta(hours=4, minutes=1))
        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))

    def test_good_with_no_prior_key(self):
        """"""Tests a good token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        token = tool.generate_token(12345, 'test_action')
        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))

    def test_bad_with_no_prior_key(self):
        """"""Tests a bad token when a token key has to be autogenerated.

        If the config doesn't already have an XSRF token key set, the XSRF tool
        will generate one automatically.
        """"""
        # config seems to be shared across tests, so we have to specifically set
        # it to None.
        config.set(xsrf_token_key=None)
        tool = utils.XsrfTool()
        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)
        self.assertFalse(
            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,
                              'test_action'))
/n/n/n/tests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_delete-record': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/n/tests/views/view_tests_base.py/n/n""""""Tools to help run tests against the Django app.""""""

import const
import utils

import scrape
import testutils.base


class ViewTestsBase(testutils.base.ServerTestsBase):
    """"""A base class for tests for the Django app.""""""

    _USER_ID = 'k'

    def setUp(self):
        super(ViewTestsBase, self).setUp()
        self._xsrf_tool = utils.XsrfTool()

    def login(self, is_admin=False):
        """"""Logs in the ""user"" for making requests.

        Args:
           is_admin (bool): Whether the user should be considered an admin.
        """"""
        self.testbed.setup_env(
            user_email='kay@mib.gov',
            user_id=ViewTestsBase._USER_ID,
            user_is_admin='1' if is_admin else '0',
            overwrite=True)

    def xsrf_token(self, action_id):
        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)

    def to_doc(self, response):
        """"""Produces a scrape.Document from the Django test response.

        Args:
            response (Response): A response from a Django test client.

        Returns:
            scrape.Document: A wrapper around the response's contents to help
                with examining it.
        """"""
        # TODO(nworden): when everything's on Django, make some changes to
        # scrape.py so it better fits Django's test framework.
        return scrape.Document(
            content_bytes=response.content,
            # The Django test Response objects don't include the URL, but that's
            # ok: the Document's url field is only used by scrape.Session, which
            # we're not using with the Django tests.
            url=None,
            status=response.status_code,
            # We aren't using this, at least not in the Django tests.
            message=None,
            # The response headers are accessed directly through the Response
            # object.
            headers=response,
            charset=const.CHARSET_UTF8)
/n/n/n",1
