,Unnamed: 0,id,code,label
64,64,1c2a256addf7a5273a40963f92a6351e5d053ae0,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers',
                        'accept, content-type, authorization, x-xsrftoken')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",0
65,65,1c2a256addf7a5273a40963f92a6351e5d053ae0,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",1
6,6,20edecca740c36a80b65678fce66c5d453281dd0,"invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token
                                 expires. Defaults to 300 seconds.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""

OAUTHCLIENT_STATE_EXPIRES = 300
""""""Number of seconds after which the state token expires.""""""
/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate',
                              'show_login': 'true'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def get_session_next_url(remote_app):
    return session.get(
        ""%s_%s"" % (token_session_key(remote_app), ""next_url"")
    )


def set_session_next_url(remote_app, url):
    session[""%s_%s"" % (token_session_key(remote_app), ""next_url"")] = \
        url


def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    next_url = get_session_next_url(remote.name)
    if next_url:
        return redirect(next_url)
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        next_url = get_session_next_url(remote.name)
        if next_url:
            return redirect(next_url)
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite
from mock import MagicMock, Mock, patch
from sqlalchemy.exc import SQLAlchemyError


class FormTestCase(InvenioTestCase):

    @patch('invenio.modules.oauthclient.forms.User')
    def test_validate_email(self, user):
        from invenio.modules.oauthclient.forms import EmailSignUpForm

        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())

        # Mock query
        obj = MagicMock()
        obj.one = MagicMock(side_effect=SQLAlchemyError())
        user.query.filter = Mock(return_value=obj)
        self.assertTrue(
            EmailSignUpForm(email='good@invenio-software.org').validate()
        )

        user.query.filter = MagicMock()
        self.assertFalse(
            EmailSignUpForm(email='bad@invenio-software.org').validate()
        )


TEST_SUITE = make_test_suite(FormTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

import time
from flask import url_for, session
from invenio.base.globals import cfg
from invenio.ext.sqlalchemy import db
from invenio.testsuite import make_test_suite, run_test_suite
from itsdangerous import TimedJSONWebSignatureSerializer
from mock import MagicMock, patch
from six.moves.urllib_parse import parse_qs, urlparse
from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_redirect_uri(self):
        from invenio.modules.oauthclient.views.client import serializer

        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test',
                    next='http://invenio-software.org')
        )
        self.assertStatus(resp, 302)

        # Verify parameters
        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Verify next parameter in state token does not allow blanco redirects
        state = serializer.loads(params['state'][0])
        self.assertIsNone(state['next'])

        # Assert redirect uri does not have any parameters.
        params = parse_qs(urlparse(params['redirect_uri'][0]).query)
        self.assertEqual(params, {})

        # Assert that local redirects are allowed
        test_urls = [
            '/search',
            url_for('oauthclient.disconnect', remote_app='test',
                    _external=True)
        ]
        for url in test_urls:
            resp = self.client.get(
                url_for(""oauthclient.login"", remote_app='test', next=url)
            )
            self.assertStatus(resp, 302)
            state = serializer.loads(
                parse_qs(urlparse(resp.location).query)['state'][0]
            )
            self.assertEqual(url, state['next'])

    def test_login(self):
        # Test redirect
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='test', next='/')
        )
        self.assertStatus(resp, 302)

        params = parse_qs(urlparse(resp.location).query)
        self.assertEqual(params['response_type'], ['code'])
        self.assertEqual(params['client_id'], ['testid'])
        assert params['redirect_uri']
        assert params['state']

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            from invenio.modules.oauthclient.views.client import serializer

            state = serializer.dumps({
                'app': 'test',
                'sid': session.sid,
                'next': None,
            })

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                    state=state
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            state = serializer.dumps({
                'app': 'test_invalid',
                'sid': session.sid,
                'next': None,
            })

            self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                    state=state,
                )
            )

    @patch('invenio.modules.oauthclient.views.client.session')
    def test_state_token(self, session):
        from invenio.modules.oauthclient.views.client import serializer

        # Mock session id
        session.sid = '1234'

        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')

            # Good state token
            state = serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            resp = c.get(
                url_for(""oauthclient.authorized"", remote_app='test',
                        code='test', state=state)
            )
            self.assert200(resp)

            outdated_serializer = TimedJSONWebSignatureSerializer(
                cfg['SECRET_KEY'],
                expires_in=0,
            )

            # Bad state - timeout
            state1 = outdated_serializer.dumps(
                {'app': 'test', 'sid': '1234',  'next': None, }
            )
            # Bad state - app
            state2 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test_invalid', 'sid': '1234',  'next': None, }
            )
            # Bad state - sid
            state3 = serializer.dumps(
                # State for another existing app (test_invalid exists)
                {'app': 'test', 'sid': 'bad',  'next': None, }
            )
            time.sleep(1)
            for s in [state1, state2, state3]:
                resp = c.get(
                    url_for(""oauthclient.authorized"", remote_app='test',
                            code='test', state=s)
                )
                self.assert403(resp)

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_token_getter_setter(self, session, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        # Mock user
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                state = parse_qs(urlparse(res.location).query)['state'][0]

                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state,
                ))

                # Assert if everything is as it should be.
                from flask import session as flask_session
                assert flask_session['oauth_token_full'] == \
                    ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                # Mock a new authorized request
                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    @patch('invenio.modules.oauthclient.views.client.session')
    def test_rejected(self, session, save_session):
        from invenio.modules.oauthclient.client import oauth

        # Mock user id
        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)

        # Mock session id
        session.sid = '1234'

        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                from invenio.modules.oauthclient.views.client import serializer
                state = serializer.dumps({
                    'app': 'full', 'sid': '1234',  'next': None,
                })

                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                    state=state
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Client blueprint used to handle OAuth callbacks.""""""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, request, session, url_for
from flask.ext.login import user_logged_out
from itsdangerous import TimedJSONWebSignatureSerializer, BadData
from werkzeug.local import LocalProxy

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required
from invenio.utils.url import get_safe_redirect_target

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler, \
    set_session_next_url


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


serializer = LocalProxy(
    lambda: TimedJSONWebSignatureSerializer(
        cfg['SECRET_KEY'],
        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],
    )
)


@blueprint.before_app_first_request
def setup_app():
    """"""Setup OAuth clients.""""""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """"""Send user to remote application for authentication.""""""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    # Get redirect target in safe manner.
    next_param = get_safe_redirect_target(arg='next')

    # Redirect URI - must be registered in the remote service.
    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        _external=True,
    )

    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES
    # seconds.
    state_token = serializer.dumps({
        'app': remote_app,
        'next': next_param,
        'sid': session.sid,
    })

    return oauth.remote_apps[remote_app].authorize(
        callback=callback_url,
        state=state_token,
    )


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """"""Authorized handler callback.""""""
    if remote_app not in handlers:
        return abort(404)

    state_token = request.args.get('state')

    # Verify state parameter
    try:
        assert state_token
        # Checks authenticity and integrity of state and decodes the value.
        state = serializer.loads(state_token)
        # Verify that state is for this session, app and that next parameter
        # have not been modified.
        assert state['sid'] == session.sid
        assert state['app'] == remote_app
        # Store next URL
        set_session_next_url(remote_app, state['next'])
    except (AssertionError, BadData):
        abort(403)

    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """"""Extra signup step.""""""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """"""Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""
urlutils.py -- helper functions for URL related problems such as
argument washing, redirection, etc.
""""""

__revision__ = ""$Id$""

import time
import base64
import hmac
import re
import sys
import os
import inspect
import urllib
import urllib2
from urllib import urlencode, quote_plus, quote, FancyURLopener
from six.moves.urllib.parse import urlparse, urlunparse
from cgi import parse_qs, parse_qsl, escape
from werkzeug import cached_property
from werkzeug.local import LocalProxy

try:
    import BeautifulSoup
    BEAUTIFUL_SOUP_IMPORTED = True
except ImportError:
    BEAUTIFUL_SOUP_IMPORTED = False

from invenio.base.globals import cfg
from invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED
from invenio.utils.text import wash_for_utf8
from invenio.utils import apache


def wash_url_argument(var, new_type):
    """"""
    Wash argument into 'new_type', that can be 'list', 'str',
                                               'int', 'tuple' or 'dict'.
    If needed, the check 'type(var) is not None' should be done before
    calling this function.
    @param var: variable value
    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'
    @return: as much as possible, value var as type new_type
            If var is a list, will change first element into new_type.
            If int check unsuccessful, returns 0
    """"""
    out = []
    if new_type == 'list':  # return lst
        if isinstance(var, list):
            out = var
        else:
            out = [var]
    elif new_type == 'str':  # return str
        if isinstance(var, list):
            try:
                out = ""%s"" % var[0]
            except:
                out = """"
        elif isinstance(var, str):
            out = var
        else:
            out = ""%s"" % var
    elif new_type == 'int': # return int
        if isinstance(var, list):
            try:
                out = int(var[0])
            except:
                out = 0
        elif isinstance(var, (int, long)):
            out = var
        elif isinstance(var, str):
            try:
                out = int(var)
            except:
                out = 0
        else:
            out = 0
    elif new_type == 'tuple': # return tuple
        if isinstance(var, tuple):
            out = var
        else:
            out = (var, )
    elif new_type == 'dict': # return dictionary
        if isinstance(var, dict):
            out = var
        else:
            out = {0: var}
    return out


from urlparse import urlparse, urljoin
from flask import request, url_for

def is_local_url(target):
    """"""Determine if URL is a local.""""""
    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))
    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc


def get_safe_redirect_target(arg='next'):
    """"""Get URL to redirect to and ensure that it is local.""""""
    for target in request.args.get(arg), request.referrer:
        if not target:
            continue
        if is_local_url(target):
            return target
    return None


def redirect_to_url(req, url, redirection_type=None, norobot=False):
    """"""
    Redirect current page to url.
    @param req: request as received from apache
    @param url: url to redirect to
    @param redirection_type: what kind of redirection is required:
    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300
          apache.HTTP_MOVED_PERMANENTLY            = 301
          apache.HTTP_MOVED_TEMPORARILY            = 302
          apache.HTTP_SEE_OTHER                    = 303
          apache.HTTP_NOT_MODIFIED                 = 304
          apache.HTTP_USE_PROXY                    = 305
          apache.HTTP_TEMPORARY_REDIRECT           = 307
    The default is apache.HTTP_MOVED_TEMPORARILY
    @param norobot: wether to instruct crawlers and robots such as GoogleBot
        not to index past this point.
    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
    """"""
    url = url.strip()
    if redirection_type is None:
        redirection_type = apache.HTTP_MOVED_TEMPORARILY

    from flask import redirect
    r = redirect(url, code=redirection_type)
    raise apache.SERVER_RETURN, r
    #FIXME enable code bellow

    del req.headers_out[""Cache-Control""]
    req.headers_out[""Cache-Control""] = ""no-cache, private, no-store, "" \
        ""must-revalidate, post-check=0, pre-check=0, max-age=0""
    req.headers_out[""Pragma""] = ""no-cache""

    if norobot:
        req.headers_out[""X-Robots-Tag""] = ""noarchive, nosnippet, noindex, nocache""

    user_agent = req.headers_in.get('User-Agent', '')
    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:
        ## HACK: this is to workaround Microsoft Office trying to be smart
        ## when users click on URLs in Office documents that require
        ## authentication. Office will check the validity of the URL
        ## but will pass the browser the redirected URL rather than
        ## the original one. This is incompatible with e.g. Shibboleth
        ## based SSO since the referer would be lost.
        ## See: http://support.microsoft.com/kb/899927
        req.status = 200
        req.content_type = 'text/html'
        if req.method != 'HEAD':
            req.write(""""""
<html>
    <head>
        <title>Intermediate page for URLs clicked on MS Office Documents</title>
        <meta http-equiv=""REFRESH"" content=""5;url=%(url)s""></meta>
    </head>
    <body>
        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=""%(url)s"">%(url_ok)s</a>.</p>
    </body>
</html>"""""" % {
                'url': escape(req.unparsed_uri, True),
                'url_ok': escape(req.unparsed_uri)
            })
        raise apache.SERVER_RETURN(apache.DONE)

    req.headers_out[""Location""] = url

    if req.response_sent_p:
        raise IOError(""Cannot redirect after headers have already been sent."")

    req.status = redirection_type
    req.write('<p>Please go to <a href=""%s"">here</a></p>\n' % url)

    raise apache.SERVER_RETURN, apache.DONE


def rewrite_to_secure_url(url, secure_base=None):
    """"""
    Rewrite URL to a Secure URL

    @param url URL to be rewritten to a secure URL.
    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).
    """"""
    if secure_base is None:
        secure_base = cfg.get('CFG_SITE_SECURE_URL')
    url_parts = list(urlparse(url))
    url_secure_parts = urlparse(secure_base)
    url_parts[0] = url_secure_parts[0]
    url_parts[1] = url_secure_parts[1]
    return urlunparse(url_parts)


def get_referer(req, replace_ampersands=False):
    """""" Return the referring page of a request.
    Referer (wikipedia): Referer is a common misspelling of the word
    ""referrer""; so common, in fact, that it made it into the official
    specification of HTTP. When visiting a webpage, the referer or
    referring page is the URL of the previous webpage from which a link was
    followed.
    @param req: request
    @param replace_ampersands: if 1, replace & by &amp; in url
                               (correct HTML cannot contain & characters alone)
    """"""
    try:
        referer = req.headers_in['Referer']
        if replace_ampersands == 1:
            return referer.replace('&', '&amp;')
        return referer
    except KeyError:
        return ''


def drop_default_urlargd(urlargd, default_urlargd):
    lndefault = {}
    lndefault.update(default_urlargd)

    ## Commented out. An Invenio URL now should always specify the desired
    ## language, in order not to raise the automatic language discovery
    ## (client browser language can be used now in place of CFG_SITE_LANG)
    # lndefault['ln'] = (str, CFG_SITE_LANG)

    canonical = {}
    canonical.update(urlargd)

    for k, v in urlargd.items():
        try:
            d = lndefault[k]

            if d[1] == v:
                del canonical[k]

        except KeyError:
            pass

    return canonical


def make_canonical_urlargd(urlargd, default_urlargd):
    """""" Build up the query part of an URL from the arguments passed in
    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which
    contains tuples of the form (type, default value) for the query
    arguments (this is the same dictionary as the one you can pass to
    webinterface_handler.wash_urlargd).

    When a query element has its default value, it is discarded, so
    that the simplest (canonical) url query is returned.

    The result contains the initial '?' if there are actual query
    items remaining.
    """"""

    canonical = drop_default_urlargd(urlargd, default_urlargd)

    if canonical:
        return '?' + urlencode(canonical, doseq=True)
        #FIXME double escaping of '&'? .replace('&', '&amp;')

    return ''


def create_html_link(urlbase, urlargd, link_label, linkattrd=None,
                     escape_urlargd=True, escape_linkattrd=True,
                     urlhash=None):
    """"""Creates a W3C compliant link.
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})
    @param link_label: text displayed in a browser (has to be already escaped)
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    attributes_separator = ' '
    output = '<a href=""' + \
             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '""'
    if linkattrd:
        output += ' '
        if escape_linkattrd:
            attributes = [escape(str(key), quote=True) + '=""' + \
                          escape(str(linkattrd[key]), quote=True) + '""'
                                for key in linkattrd.keys()]
        else:
            attributes = [str(key) + '=""' + str(linkattrd[key]) + '""'
                                for key in linkattrd.keys()]
        output += attributes_separator.join(attributes)
    output = wash_for_utf8(output)
    output += '>' + wash_for_utf8(link_label) + '</a>'
    return output


def create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,
        link_label=""%(email)s"", linkattrd=None, escape_urlargd=True,
        escape_linkattrd=True, email_obfuscation_mode=None):
    """"""Creates a W3C compliant 'mailto' link.

    Encode/encrypt given email to reduce undesired automated email
    harvesting when embedded in a web page.

    NOTE: there is no ultimate solution to protect against email
    harvesting. All have drawbacks and can more or less be
    circumvented. There are other techniques to protect email
    addresses. We implement the less annoying one for users.

    @param email: the recipient of the email
    @param subject: a default subject for the email (must not contain
                    line feeds)
    @param body: a default body for the email
    @param cc: the co-recipient(s) of the email
    @param bcc: the hidden co-recpient(s) of the email
    @param link_label: the label of this mailto link. String
                       replacement is performed on key %(email)s with
                       the email address if needed.
    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param escape_linkattrd: boolean indicating if the function should escape
                           attributes (e.g. < becomes &lt; or "" becomes &quot;)
    @param email_obfuscation_mode: the protection mode. See below:

    You can choose among several modes to protect emails. It is
    advised to keep the default
    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is
    possible for an admin to change the policy globally.

    Available modes ([t] means ""transparent"" for the user):

         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and
             CFG_SITE_SUPPORT_EMAIL.

      [t] 0 : no protection, email returned as is.
                foo@example.com => foo@example.com

          1 : basic email munging: replaces @ by [at] and . by [dot]
                foo@example.com => foo [at] example [dot] com

      [t] 2 : transparent name mangling: characters are replaced by
              equivalent HTML entities.
                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;

      [t] 3 : javascript insertion. Requires Javascript enabled on client side.

          4 : replaces @ and . characters by gif equivalents.
                foo@example.com => foo<img src=""at.gif"" alt="" [at] "">example<img src=""dot.gif"" alt="" [dot] "">com
    """"""
    # TODO: implement other protection modes to encode/encript email:
    #
    ## [t] 5 : form submission. User is redirected to a form that he can
    ##         fills in to send the email (??Use webmessage??).
    ##         Depending on WebAccess, ask to answer a question.
    ##
    ## [t] 6 : if user can see (controlled by WebAccess), display. Else
    ##         ask to login to see email. If user cannot see, display
    ##         form submission.

    if email_obfuscation_mode is None:
        email_obfuscation_mode = cfg.get(
            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')

    if linkattrd is None:
        linkattrd = {}

    parameters = {}
    if subject:
        parameters[""subject""] = subject
    if body:
        parameters[""body""] = body.replace('\r\n', '\n').replace('\n', '\r\n')
    if cc:
        parameters[""cc""] = cc
    if bcc:
        parameters[""bcc""] = bcc

    # Preprocessing values for some modes
    if email_obfuscation_mode == 1:
        # Basic Munging
        email = email.replace(""@"", "" [at] "").replace(""."", "" [dot] "")
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        email = string_to_numeric_char_reference(email)

    if '%(email)s' in link_label:
        link_label = link_label % {'email': email}

    mailto_link = create_html_link('mailto:' + email, parameters,
                                   link_label, linkattrd,
                                   escape_urlargd, escape_linkattrd)

    if email_obfuscation_mode == 0:
        # Return ""as is""
        return mailto_link
    elif email_obfuscation_mode == 1:
        # Basic Munging
        return mailto_link
    elif email_obfuscation_mode == 2:
        # Transparent name mangling
        return mailto_link
    elif email_obfuscation_mode == 3:
        # Javascript-based
        return '''<script language=""JavaScript"" ''' \
            '''type=""text/javascript"">''' \
            '''document.write('%s'.split("""").reverse().join(""""))''' \
            '''</script>''' % \
               mailto_link[::-1].replace(""'"", ""\\'"")
    elif email_obfuscation_mode == 4:
        # GIFs-based
        email = email.replace('.',
            '<img src=""%s/img/dot.gif"" alt="" [dot] "" '
            'style=""vertical-align:bottom""  />' % cfg.get('CFG_SITE_URL'))
        email = email.replace('@',
            '<img src=""%s/img/at.gif"" alt="" [at] "" '
            'style=""vertical-align:baseline"" />' % cfg.get('CFG_SITE_URL'))
        return email

    # All other cases, including mode -1:
    return """"


def string_to_numeric_char_reference(string):
    """"""
    Encode a string to HTML-compatible numeric character reference.
    Eg: encode_html_entities(""abc"") == '&#97;&#98;&#99;'
    """"""
    out = """"
    for char in string:
        out += ""&#"" + str(ord(char)) + "";""
    return out

def get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):
    """"""
    Given an Invenio URL returns a tuple with two elements. The first is the
    canonical URL, that is the original URL with CFG_SITE_URL prefix, and
    where the ln= argument stripped. The second element element is mapping,
    language code -> alternate URL

    @param quote_path: if True, the path section of the given C{url}
                       is quoted according to RFC 2396
    """"""
    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)
    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]
    parsed_query = washed_argd or parse_qsl(query)
    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']
    if drop_ln:
        canonical_parsed_query = no_ln_parsed_query
    else:
        canonical_parsed_query = parsed_query
    if quote_path:
        path = urllib.quote(path)
    canonical_query = urlencode(canonical_parsed_query)
    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))
    alternate_urls = {}
    for ln in cfg.get('CFG_SITE_LANGS'):
        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])
        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))
        alternate_urls[ln] = alternate_url
    return canonical_url, alternate_urls

def create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):
    """"""Creates a W3C compliant URL. Output will look like this:
    'urlbase?param1=value1&amp;param2=value2'
    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)
    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}
    @param escape_urlargd: boolean indicating if the function should escape
                           arguments (e.g. < becomes &lt; or "" becomes &quot;)
    @param urlhash: hash string to add at the end of the link
    """"""
    separator = '&amp;'
    output = urlbase
    if urlargd:
        output += '?'
        if escape_urlargd:
            arguments = [escape(quote(str(key)), quote=True) + '=' + \
                         escape(quote(str(urlargd[key])), quote=True)
                                for key in urlargd.keys()]
        else:
            arguments = [str(key) + '=' + str(urlargd[key])
                            for key in urlargd.keys()]
        output += separator.join(arguments)
    if urlhash:
        output += ""#"" + escape(quote(str(urlhash)))
    return output


def same_urls_p(a, b):
    """""" Compare two URLs, ignoring reorganizing of query arguments """"""

    ua = list(urlparse(a))
    ub = list(urlparse(b))

    ua[4] = parse_qs(ua[4])
    ub[4] = parse_qs(ub[4])

    return ua == ub


def urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):
    """"""Analyze `urlargs' (URL CGI GET query arguments in string form)
       and for each occurrence of argument matching `regexp_argname'
       replace every substring `text_old' by `text_new'.  Return the
       resulting new URL.

       Used to be used for search engine's create_nearest_terms_box,
       now it is not used there anymore.  It is left here in case it
       will become possibly useful later.
    """"""
    out = """"
    # parse URL arguments into a dictionary:
    urlargsdict = parse_qs(urlargs)
    ## construct new URL arguments:
    urlargsdictnew = {}
    for key in urlargsdict.keys():
        if re.match(regexp_argname, key): # replace `arg' by new values
            urlargsdictnew[key] = []
            for parg in urlargsdict[key]:
                urlargsdictnew[key].append(parg.replace(text_old, text_new))
        else: # keep old values
            urlargsdictnew[key] = urlargsdict[key]
    # build new URL for this word:
    for key in urlargsdictnew.keys():
        for val in urlargsdictnew[key]:
            out += ""&amp;"" + key + ""="" + quote_plus(val, '')
    if out.startswith(""&amp;""):
        out = out[5:]
    return out

def get_title_of_page(url):
    """"""
    @param url: page to get the title from
    @return: the page title in utf-8 or None in case
    that any kind of exception occured e.g. connection error,
    URL not known
    """"""
    if BEAUTIFUL_SOUP_IMPORTED:
        try:
            opener = make_invenio_opener('UrlUtils')
            soup = BeautifulSoup.BeautifulSoup(opener.open(url))
            return soup.title.string.encode(""utf-8"")
        except:
            return None
    else:
        return ""Title not available""


def make_user_agent_string(component=None):
    """"""
    Return a nice and uniform user-agent string to be used when Invenio
    act as a client in HTTP requests.
    """"""
    ret = ""Invenio-%s (+%s; \""%s\"")"" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))
    if component:
        ret += "" %s"" % component
    return ret


class InvenioFancyURLopener(FancyURLopener):
    """"""Provide default user agent string.""""""

    @cached_property
    def version(self):
        return make_user_agent_string()

    def prompt_user_passwd(self, host, realm):
        """"""Don't prompt""""""
        return None, None

## Let's override default useragent string
## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html
urllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())

def make_invenio_opener(component=None):
    """"""
    Return an urllib2 opener with the useragent already set in the appropriate
    way.
    """"""
    opener = urllib2.build_opener()
    opener.addheaders = [('User-agent', make_user_agent_string(component))]
    return opener

def create_AWS_request_url(base_url, argd, _amazon_secret_access_key,
                           _timestamp=None):
    """"""
    Create a signed AWS (Amazon Web Service) request URL corresponding
    to the given parameters.

    Example:
    >> create_AWS_request_url(""http://ecs.amazon.com/onca/xml"",
                             {'AWSAccessKeyID': '0000000000',
                              'Service': 'AWSECommerceService',
                              'Operation': 'ItemLookup',
                              'ItemID': '0679722769',
                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},
                             ""1234567890"")

    @param base_url: Service URL of the Amazon store to query
    @param argd: dictionary of arguments defining the query
    @param _amazon_secret_access_key: your Amazon secret key
    @param _timestamp: for testing purpose only (default: current timestamp)

    @type base_url: string
    @type argd: dict
    @type _amazon_secret_access_key: string
    @type _timestamp: string

    @return signed URL of the request (string)
    """"""

    ## First define a few util functions

    def get_AWS_signature(argd, _amazon_secret_access_key,
                          method=""GET"", request_host=""webservices.amazon.com"",
                          request_uri=""/onca/xml"",
                          _timestamp=None):
        """"""
        Returns the signature of an Amazon request, based on the
        arguments of the request.

        @param argd: dictionary of arguments defining the query
        @param _amazon_secret_access_key: your Amazon secret key
        @param method: method of the request POST or GET
        @param request_host: host contacted for the query. To embed in the signature.
        @param request_uri: uri contacted at 'request_host'. To embed in the signature.
        @param _timestamp: for testing purpose only (default: current timestamp)

        @type argd: dict
        @type _amazon_secret_access_key: string
        @type method: string
        @type host_header: string
        @type http_request_uri: string
        @type _timestamp: string

        @return signature of the request (string)
        """"""

        # Add timestamp
        if not _timestamp:
            argd[""Timestamp""] = time.strftime(""%Y-%m-%dT%H:%M:%SZ"",
                                              time.gmtime())
        else:
            argd[""Timestamp""] = _timestamp

        # Order parameter keys by byte value
        parameter_keys = argd.keys()
        parameter_keys.sort()

        # Encode arguments, according to RFC 3986. Make sure we
        # generate a list which is ordered by byte value of the keys
        arguments = [quote(str(key), safe=""~/"") + ""="" + \
                     quote(str(argd[key]), safe=""~/"") \
                     for key in parameter_keys]

        # Join
        parameters_string = ""&"".join(arguments)

        # Prefix
        parameters_string = method.upper() + ""\n"" + \
                            request_host.lower() + ""\n"" + \
                            (request_uri or ""/"") + ""\n"" + \
                            parameters_string

        # Sign and return
        return calculate_RFC2104_HMAC(parameters_string,
                                      _amazon_secret_access_key)

    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):
        """"""
        Computes a RFC 2104 compliant HMAC Signature and then Base64
        encodes it.

        Module hashlib must be installed if Python < 2.5
        <http://pypi.python.org/pypi/hashlib/20081119>

        @param data: data to sign
        @param _amazon_secret_access_key: your Amazon secret key

        @type data: string
        @type _amazon_secret_access_key: string. Empty if hashlib module not installed
        """"""
        if not HASHLIB_IMPORTED:
            try:
                raise Exception(""Module hashlib not installed. Please install it."")
            except:
                from invenio.ext.logging import register_exception
                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
                return """"
        else:
            if sys.version_info < (2, 5):
                # compatibility mode for Python < 2.5 and hashlib
                my_digest_algo = _MySHA256(sha256())
            else:
                my_digest_algo = sha256

        return base64.encodestring(hmac.new(_amazon_secret_access_key,
                                            data, my_digest_algo).digest()).strip()
     ## End util functions

    parsed_url = urlparse(base_url)
    signature = get_AWS_signature(argd, _amazon_secret_access_key,
                                  request_host=parsed_url[1],
                                  request_uri=parsed_url[2],
                                  _timestamp=_timestamp)
    if signature:
        argd[""Signature""] = signature
    return base_url + ""?"" + urlencode(argd)


def create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):
    """"""
    Create a signed Indico request URL to access Indico HTTP Export APIs.

    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more
    information.

    Example:
    >> create_Indico_request_url(""https://indico.cern.ch"",
                                 ""categ"",
                                 """",
                                 [1, 7],
                                 ""xml"",
                                 {'onlypublic': 'yes',
                                  'order': 'title',
                                  'from': 'today',
                                  'to': 'tomorrow'},
                                 '00000000-0000-0000-0000-000000000000',
                                 '00000000-0000-0000-0000-000000000000')

    @param base_url: Service base URL of the Indico instance to query
    @param indico_what: element to export
    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}
    @param indico_loc: location of the element(s) specified by ID (only used for some elements)
    @param indico_id: ID of the element to be exported
    @type indico_id: a string or a list/tuple of strings
    @param indico_type: output format
    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}
    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}
    @param indico_key: API key provided for the given Indico instance
    @param indico_sig: API secret key (signature) provided for the given Indico instance
    @param _timestamp: for testing purpose only (default: current timestamp)

    @return signed URL of the request (string)
    """"""

    url = '/export/' + indico_what + '/'
    if indico_loc:
        url += indico_loc + '/'
    if type(indico_id) in (list, tuple):
        # dash separated list of values
        indico_id = '-'.join([str(x) for x in indico_id])
    url += indico_id + '.' + str(indico_type)

    if hasattr(indico_params, 'items'):
        items = indico_params.items()
    else:
        items = list(indico_params)
    if indico_key:
        items.append(('apikey', indico_key))
    if indico_sig and HASHLIB_IMPORTED:
        if _timestamp:
            items.append(('timestamp', str(_timestamp)))
        else:
            items.append(('timestamp', str(int(time.time()))))
        items = sorted(items, key=lambda x: x[0].lower())
        url_to_sign = '%s?%s' % (url, urlencode(items))
        if sys.version_info < (2, 5):
            # compatibility mode for Python < 2.5 and hashlib
            my_digest_algo = _MySHA1(sha1())
        else:
            my_digest_algo = sha1
        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()
        items.append(('signature', signature))
    elif not HASHLIB_IMPORTED:
        try:
            raise Exception(""Module hashlib not installed. Please install it."")
        except:
            from invenio.ext.logging import register_exception
            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')
    if not items:
        return url

    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))
    return url

class _MyHashlibAlgo(object):
    '''
    Define a subclass of any hashlib algorithm class, with an additional ""new()""
    function, to work with the Python < 2.5 version of the hmac module.

    (This class is more complex than it should, but it is not
    possible to subclass haslib algorithm)
    '''

    def __init__(self, obj):
        """"""Set the wrapped object.""""""
        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)

        methods = []
        for name_value in inspect.getmembers(obj, inspect.ismethod):
            methods.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)

        def isnotmethod(object_):
            ""Opposite of ismethod(..)""
            return not inspect.ismethod(object_)
        members = []
        for name_value in inspect.getmembers(obj, isnotmethod):
            members.append(name_value[0])
        super(_MyHashlibAlgo, self).__setattr__('__members__', members)

    def __getattr__(self, name):
        """"""Redirect unhandled get attribute to self._obj.""""""
        if not hasattr(self._obj, name):
            raise AttributeError, (""'%s' has no attribute %s"" %
                                   (self.__class__.__name__, name))
        else:
            return getattr(self._obj, name)

    def __setattr__(self, name, value):
        """"""Redirect set attribute to self._obj if necessary.""""""
        self_has_attr = True
        try:
            super(_MyHashlibAlgo, self).__getattribute__(name)
        except AttributeError:
            self_has_attr = False

        if (name == ""_obj"" or not hasattr(self, ""_obj"") or
            not hasattr(self._obj, name) or self_has_attr):
            return super(_MyHashlibAlgo, self).__setattr__(name, value)
        else:
            return setattr(self._obj, name, value)

if HASHLIB_IMPORTED:
    from invenio.utils.hash import sha256


    class _MySHA256(_MyHashlibAlgo):
        ""A _MyHashlibAlgo subsclass for sha256""
        new = lambda d = '': sha256()


class _MySHA1(_MyHashlibAlgo):
    ""A _MyHashlibAlgo subsclass for sha1""
    new = lambda d = '': sha1()

def auto_version_url(file_path):
    """""" Appends modification time of the file to the request URL in order for the
        browser to refresh the cache when file changes

        @param file_path: path to the file, e.g js/foo.js
        @return: file_path with modification time appended to URL
    """"""
    file_md5 = """"
    try:
        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()
    except IOError:
        pass
    return file_path + ""?%s"" % file_md5

def get_relative_url(url):
    """"""
    Returns the relative URL from a URL. For example:

    'http://web.net' -> ''
    'http://web.net/' -> ''
    'http://web.net/1222' -> '/1222'
    'http://web.net/wsadas/asd' -> '/wsadas/asd'

    It will never return a trailing ""/"".

    @param url: A url to transform
    @type url: str

    @return: relative URL
    """"""
    # remove any protocol info before
    stripped_site_url = url.replace(""://"", """")
    baseurl = ""/"" + ""/"".join(stripped_site_url.split(""/"")[1:])

    # remove any trailing slash (""/"")
    if baseurl[-1] == ""/"":
        return baseurl[:-1]
    else:
        return baseurl
/n/n/n",0
7,7,20edecca740c36a80b65678fce66c5d453281dd0,"/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Configuration variables for defining remote applications.

================================ ==============================================
`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example
                                 below. **Default:** ``{}``.
`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the
                                 an access token. **Default:** ``oauth_token``.
================================ ==============================================

Each remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``
dictionary, where the keys are the application names and the values the
configuration parameters for the application.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # configuration values for myapp ...
        ),
    )

The application name is used in the login, authorized, sign-up and disconnect
endpoints:

- Login endpoint: ``/oauth/login/<REMOTE APP>/``.
- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.


Remote application
^^^^^^^^^^^^^^^^^^
Configuration of a single remote application is a dictionary with the following
keys:

- ``title`` - Title of remote application. Displayed to end-users under Account
  > Linked accounts.
- ``description`` - Short description of remote application. Displayed to
  end-users under Account > Linked accounts.
- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the
  Font-Awesome GitHub icon). Displayed to end-users.
- ``params`` - Flask-OAuthlib remote application parameters..
- ``authorized_handler`` - Import path to authorized callback handler.
- ``disconnect_handler`` - Import path to disconnect callback handler.
- ``signup_handler`` - A dictionary of import path to sign up callback handler.
- ``remember`` - Boolean indicating if the session should be permament.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            title='...',
            description='...',
            icon='...',
            authorized_handler=""..."",
            disconnect_handler=""..."",
            signup_handler=dict(
                info=""..."",
                setup=""..."",
                view=""..."",
            ),
            params=dict(...),
            remember=True
            )
        )
    )


Flask-OAuthlib parameters
^^^^^^^^^^^^^^^^^^^^^^^^^
The Flask-OAuthlib parameters defines the remote application OAuth endpoints as
well as the client id and secret. Full description of these parameters are
given in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.

Normally you will have to browse the remote application's API documentation to
find which URLs and scopes to use.

Below is an example for GitHub:

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        github=dict(
            # ...
            params=dict(
                request_token_params={'scope': 'user:email'},
                base_url='https://api.github.com/',
                request_token_url=None,
                access_token_url=""https://github.com/login/oauth/access_token"",
                access_token_method='POST',
                authorize_url=""https://github.com/login/oauth/authorize"",
                app_key=""GITHUB_APP_CREDENTIALS"",
            )
        )
    )

    GITHUB_APP_CREDENTIALS=dict(
        consumer_key=""changeme""
        consumer_secret=""changeme""
    )

The ``app_key`` parameter allows you to put your sensitive client id and secret
in your instance configuration (``var/invenio.base-instance/invenio.cfg``).

Handlers
^^^^^^^^
Handlers allow customizing oauthclient endpoints for each remote
application:

- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.
- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.
- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.

By default only authorized and disconnect handlers are required, and Invenio
provide default implementation that stores the access token in the user session
as well as to the database if the user is authenticated:


.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        myapp=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_default_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            # ...
        )
    )

If you want to provide sign in/up functionality using oauthclient, Invenio
comes with a default handler that will try to find a matching local user for
a given authorize request.

.. code-block:: python

    OAUTHCLIENT_REMOTE_APPS = dict(
        orcid=dict(
            # ...
            authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
            disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
            )
            signup_handler=dict(
                info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
                setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
                view=""invenio.modules.oauthclient.handlers:signup_handler"",
            ),
            # ...
        )
    )
""""""

OAUTHCLIENT_REMOTE_APPS = {}
""""""Configuration of remote applications.""""""

OAUTHCLIENT_SESSION_KEY_PREFIX = ""oauth_token""
""""""Session key prefix used when storing the access token for a remote app.""""""
/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Pre-configured remote application for enabling sign in/up with ORCID.

**Usage:**

1. Edit your configuration and add:

   .. code-block:: python

       from invenio.modules.oauthclient.contrib import orcid
       OAUTHCLIENT_REMOTE_APPS = dict(
           orcid=orcid.REMOTE_APP,
       )

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""changeme"",
           consumer_secret=""changeme"",
       )

  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``
  instead of ``orcid.REMOTE_APP``.

2. Register a new application with ORCID. When registering the
   application ensure that the *Redirect URI* points to:
   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not
   allow localhost to be used, thus testing on development machines is
   somewhat complicated by this).


3. Grab the *Client ID* and *Client Secret* after registering the application
   and add them to your instance configuration (``invenio.cfg``):

   .. code-block:: python

       ORCID_APP_CREDENTIALS = dict(
           consumer_key=""<CLIENT ID>"",
           consumer_secret=""<CLIENT SECRET>"",
       )

4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.
   http://localhost:4000/oauth/login/orcid/)

5. Also, you should see ORCID listed under Linked accounts:
   http://localhost:4000//account/settings/linkedaccounts/

By default the ORCID module will try first look if a link already exists
between a ORCID account and a user. If no link is found, the user is asked
to provide an email address to sign-up.

In templates you can add a sign in/up link:

.. code-block:: jinja

    <a href=""{{url_for('oauthclient.login', remote_app='orcid')}}"">Sign in with ORCID</a>

""""""

import copy

from flask import current_app, session
from flask.ext.login import current_user

from invenio.ext.sqlalchemy.utils import session_manager


REMOTE_APP = dict(
    title='ORCID',
    description='Connecting Research and Researchers.',
    icon='',
    authorized_handler=""invenio.modules.oauthclient.handlers""
                       "":authorized_signup_handler"",
    disconnect_handler=""invenio.modules.oauthclient.handlers""
                       "":disconnect_handler"",
    signup_handler=dict(
        info=""invenio.modules.oauthclient.contrib.orcid:account_info"",
        setup=""invenio.modules.oauthclient.contrib.orcid:account_setup"",
        view=""invenio.modules.oauthclient.handlers:signup_handler"",
    ),
    params=dict(
        request_token_params={'scope': '/authenticate'},
        base_url='https://pub.orcid.com/',
        request_token_url=None,
        access_token_url=""https://pub.orcid.org/oauth/token"",
        access_token_method='POST',
        authorize_url=""https://orcid.org/oauth/authorize#show_login"",
        app_key=""ORCID_APP_CREDENTIALS"",
        content_type=""application/json"",
    )
)
"""""" ORCID Remote Application. """"""

REMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)
""""""ORCID Sandbox Remote Application.""""""

REMOTE_SANDBOX_APP['params'].update(dict(
    base_url=""https://api.sandbox.orcid.org/"",
    access_token_url=""https://api.sandbox.orcid.org/oauth/token"",
    authorize_url=""https://sandbox.orcid.org/oauth/authorize#show_login"",
))


def account_info(remote, resp):
    """"""Retrieve remote account information used to find local user.""""""
    account_info = dict(external_id=resp.get(""orcid""), external_method=""orcid"")

    return account_info


@session_manager
def account_setup(remote, token):
    """"""Perform additional setup after user have been logged in.""""""
    from invenio.modules.accounts.models import User, UserEXT
    from invenio.ext.sqlalchemy import db
    from ..handlers import token_session_key

    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound

    import json
    import requests

    orcid = session.get(token_session_key(remote.name) +
                        ""_account_info"").get(""external_id"")

    extra_data = {
        ""orcid"": orcid
        }
    token.remote_account.extra_data = extra_data

    try:
        user = User.query.join(UserEXT).filter_by(id=orcid,
                                                  method=""orcid"").one()
    except (MultipleResultsFound, NoResultFound):
        current_app.logger.exception(""No user entry in userEXT."")

    # Fill user full name if not already set
    if user and not any([user.given_names, user.family_name]):
        # Query ORCID to get the real name
        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)

        headers = {'Accept': 'application/orcid+json'}
        response = requests.get(request_url, headers=headers)
        code = response.status_code

        if code == requests.codes.ok:
            try:
                orcid_bio = json.loads(response.content)
            except ValueError:
                current_app.logger.exception(""Not valid JSON response from "" +
                                             ""ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            try:
                name = orcid_bio[""orcid-profile""][""orcid-bio""][""personal-details""]
                user.given_names = name[""given-names""][""value""]
                user.family_name = name[""family-name""][""value""]
            except KeyError:
                current_app.logger.exception(""Unexpected return format "" +
                                             ""from ORCID:\n {0}"".format(repr(orcid_bio)))
                return
            db.session.add(user)
            # Refresh user cache
            current_user.reload()
/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014, 2015 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

""""""Handlers for customizing oauthclient endpoints.""""""

import six

from flask import current_app, flash, redirect, render_template, \
    request, session, url_for
from flask.ext.login import current_user
from functools import partial, wraps
from werkzeug.utils import import_string

from invenio.base.globals import cfg

from .client import oauth, signup_handlers
from .errors import OAuthClientError, OAuthError, \
    OAuthRejectedRequestError, OAuthResponseError
from .forms import EmailSignUpForm
from .models import RemoteAccount, RemoteToken
from .utils import oauth_authenticate, oauth_get_user, oauth_register


#
# Token handling
#
def token_session_key(remote_app):
    """"""Generate a session key used to store the token for a remote app.""""""
    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)


def response_token_setter(remote, resp):
    """"""Extract token from response and set it for the user.""""""
    if resp is None:
        raise OAuthRejectedRequestError(""User rejected request."", remote, resp)
    else:
        if 'access_token' in resp:
            return oauth2_token_setter(remote, resp)
        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:
            return oauth1_token_setter(remote, resp)
        elif 'error' in resp:
            # Only OAuth2 specifies how to send error messages
            raise OAuthClientError(
                'Authorization with remote service failed.', remote, resp,
            )
    raise OAuthResponseError(""Bad OAuth authorized request"", remote, resp)


def oauth1_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth1 token.""""""
    return token_setter(
        remote,
        resp['oauth_token'],
        secret=resp['oauth_token_secret'],
        extra_data=extra_data,
        token_type=token_type,
    )


def oauth2_token_setter(remote, resp, token_type='', extra_data=None):
    """"""Set an OAuth2 token.""""""
    return token_setter(
        remote,
        resp['access_token'],
        secret='',
        token_type=token_type,
        extra_data=extra_data,
    )


def token_setter(remote, token, secret='', token_type='', extra_data=None):
    """"""Set token for user.""""""
    session[token_session_key(remote.name)] = (token, secret)

    # Save token if used is authenticated
    if current_user.is_authenticated():
        uid = current_user.get_id()
        cid = remote.consumer_key

        # Check for already existing token
        t = RemoteToken.get(uid, cid, token_type=token_type)

        if t:
            t.update_token(token, secret)
        else:
            t = RemoteToken.create(
                uid, cid, token, secret,
                token_type=token_type, extra_data=extra_data
            )
        return t
    return None


def token_getter(remote, token=''):
    """"""Retrieve OAuth access token.

    Ued by flask-oauthlib to get the access token when making requests.

    :param token: Type of token to get. Data passed from ``oauth.request()`` to
         identify which token to retrieve.
    """"""
    session_key = token_session_key(remote.name)

    if session_key not in session and current_user.is_authenticated():
        # Fetch key from token store if user is authenticated, and the key
        # isn't already cached in the session.
        remote_token = RemoteToken.get(
            current_user.get_id(),
            remote.consumer_key,
            token_type=token,
        )

        if remote_token is None:
            return None

        # Store token and secret in session
        session[session_key] = remote_token.token()

    return session.get(session_key, None)


def token_delete(remote, token=''):
    """"""Remove OAuth access tokens from session.""""""
    session_key = token_session_key(remote.name)
    return session.pop(session_key, None)


#
# Error handling decorators
#
def oauth_error_handler(f):
    """"""Decorator to handle exceptions.""""""
    @wraps(f)
    def inner(*args, **kwargs):
        # OAuthErrors should not happen, so they are not caught here. Hence
        # they will result in a 500 Internal Server Error which is what we
        # are interested in.
        try:
            return f(*args, **kwargs)
        except OAuthClientError as e:
            current_app.logger.warning(e.message, exc_info=True)
            return oauth2_handle_error(
                e.remote, e.response, e.code, e.uri, e.description
            )
        except OAuthRejectedRequestError:
            flash(""You rejected the authentication request."")
            return redirect('/')
    return inner


#
# Handlers
#
@oauth_error_handler
def authorized_default_handler(resp, remote, *args, **kwargs):
    """"""Store access token in session.

    Default authorized handler.
    """"""
    response_token_setter(remote, resp)
    return redirect('/')


@oauth_error_handler
def authorized_signup_handler(resp, remote, *args, **kwargs):
    """"""Handle sign-in/up functionality.""""""
    # Remove any previously stored auto register session key
    session.pop(token_session_key(remote.name) + '_autoregister', None)

    # Store token in session
    # ----------------------
    # Set token in session - token object only returned if
    # current_user.is_autenticated().
    token = response_token_setter(remote, resp)
    handlers = signup_handlers[remote.name]

    # Sign-in/up user
    # ---------------
    if not current_user.is_authenticated():
        account_info = handlers['info'](resp)

        user = oauth_get_user(
            remote.consumer_key,
            account_info=account_info,
            access_token=token_getter(remote)[0],
        )

        if user is None:
            # Auto sign-up if user not found
            user = oauth_register(account_info)
            if user is None:
                # Auto sign-up requires extra information
                session[
                    token_session_key(remote.name) + '_autoregister'] = True
                session[token_session_key(remote.name) +
                        ""_account_info""] = account_info
                return redirect(url_for(
                    "".signup"",
                    remote_app=remote.name,
                    next=request.args.get('next', '/')
                ))

        # Authenticate user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account
        # ------------
        # Need to store token in database instead of only the session when
        # called first time.
        token = response_token_setter(remote, resp)

    # Setup account
    # -------------
    if not token.remote_account.extra_data and \
       remote.name in signup_handlers:
        handlers['setup'](token)

    # Redirect to next
    if request.args.get('next', None):
        return redirect(request.args.get('next'))
    else:
        return redirect('/')


@oauth_error_handler
def disconnect_handler(remote, *args, **kwargs):
    """"""Handle unlinking of remote account.

    This default handler will just delete the remote account link. You may
    wish to extend this module to perform clean-up in the remote service
    before removing the link (e.g. removing install webhooks).
    """"""
    if not current_user.is_authenticated():
        return current_app.login_manager.unauthorized()

    account = RemoteAccount.get(
        user_id=current_user.get_id(),
        client_id=remote.consumer_key
    )
    if account:
        account.delete()

    return redirect(url_for('oauthclient_settings.index'))


def signup_handler(remote, *args, **kwargs):
    """"""Handle extra signup information.""""""
    # User already authenticated so move on
    if current_user.is_authenticated():
        return redirect(""/"")

    # Retrieve token from session
    oauth_token = token_getter(remote)
    if not oauth_token:
        return redirect(""/"")

    # Test to see if this is coming from on authorized request
    if not session.get(token_session_key(remote.name) + '_autoregister',
                       False):
        return redirect(url_for("".login"", remote_app=remote.name))

    form = EmailSignUpForm(request.form)

    if form.validate_on_submit():
        account_info = session.get(token_session_key(remote.name) +
                                   ""_account_info"")
        # Register user
        user = oauth_register(account_info, form.data)

        if user is None:
            raise OAuthError(""Could not create user."", remote)

        # Remove session key
        session.pop(token_session_key(remote.name) + '_autoregister', None)

        # Authenticate the user
        if not oauth_authenticate(remote.consumer_key, user,
                                  require_existing_link=False,
                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']
                                  [remote.name].get('remember', False)):
            return current_app.login_manager.unauthorized()

        # Link account and set session data
        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])
        handlers = signup_handlers[remote.name]

        if token is None:
            raise OAuthError(""Could not create token for user."", remote)

        if not token.remote_account.extra_data:
            handlers['setup'](token)

        # Remove account info from session
        session.pop(token_session_key(remote.name) + '_account_info', None)

        # Redirect to next
        if request.args.get('next', None):
            return redirect(request.args.get('next'))
        else:
            return redirect('/')

    return render_template(
        ""oauthclient/signup.html"",
        form=form,
        remote=remote,
        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),
        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(
            'description', ''
        ),
        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),
    )


def oauth_logout_handler(sender_app, user=None):
    """"""Remove all access tokens from session on logout.""""""
    for remote in oauth.remote_apps.values():
        token_delete(remote)


#
# Helpers
#
def make_handler(f, remote, with_response=True):
    """"""Make a handler for authorized and disconnect callbacks.

    :param f: Callable or an import path to a callable
    """"""
    if isinstance(f, six.text_type):
        f = import_string(f)

    @wraps(f)
    def inner(*args, **kwargs):
        if with_response:
            return f(args[0], remote, *args[1:], **kwargs)
        else:
            return f(remote, *args, **kwargs)
    return inner


def make_token_getter(remote):
    """"""Make a token getter for a remote application.""""""
    return partial(token_getter, remote)


def oauth2_handle_error(remote, resp, error_code, error_uri,
                        error_description):
    """"""Handle errors during exchange of one-time code for an access tokens.""""""
    flash(""Authorization with remote service failed."")
    return redirect('/')
/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

from __future__ import absolute_import

from mock import MagicMock, patch
from six.moves.urllib_parse import quote_plus
from flask import url_for, session
from invenio.testsuite import make_test_suite, run_test_suite
from invenio.ext.sqlalchemy import db

from .helpers import OAuth2ClientTestCase


class RemoteAccountTestCase(OAuth2ClientTestCase):
    def setUp(self):
        params = lambda x: dict(
            request_token_params={'scope': ''},
            base_url='https://foo.bar/',
            request_token_url=None,
            access_token_url=""https://foo.bar/oauth/access_token"",
            authorize_url=""https://foo.bar/oauth/authorize"",
            consumer_key=x,
            consumer_secret='testsecret',
        )

        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(
            test=dict(
                authorized_handler=self.handler,
                params=params('testid'),
                title='MyLinkedTestAccount',
            ),
            test_invalid=dict(
                authorized_handler=self.handler_invalid,
                params=params('test_invalidid'),
                title='Test Invalid',
            ),
            full=dict(
                params=params(""fullid""),
                title='Full',
            ),
        )
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def tearDown(self):
        self.handled_resp = None
        self.handled_remote = None
        self.handled_args = None
        self.handled_kwargs = None

        from invenio.modules.oauthclient.models import RemoteToken, \
            RemoteAccount
        RemoteToken.query.delete()
        RemoteAccount.query.delete()
        db.session.commit()

    def handler(self, resp, remote, *args, **kwargs):
        self.handled_resp = resp
        self.handled_remote = remote
        self.handled_args = args
        self.handled_kwargs = kwargs
        return ""TEST""

    def handler_invalid(self):
        self.handled_resp = 1
        self.handled_remote = 1
        self.handled_args = 1
        self.handled_kwargs = 1

    def mock_response(self, app='test', data=None):
        """""" Mock the oauth response to use the remote """"""
        from invenio.modules.oauthclient.client import oauth

        # Mock oauth remote application
        oauth.remote_apps[app].handle_oauth2_response = MagicMock(
            return_value=data or {
                ""access_token"": ""test_access_token"",
                ""scope"": """",
                ""token_type"": ""bearer""
            }
        )

    def test_login(self):
        # Test redirect
        resp = self.client.get(url_for(""oauthclient.login"", remote_app='test'))
        self.assertStatus(resp, 302)
        self.assertEqual(
            resp.location,
            ""https://foo.bar/oauth/authorize?response_type=code&""
            ""client_id=testid&redirect_uri=%s"" % quote_plus(url_for(
                ""oauthclient.authorized"", remote_app='test', _external=True
            ))
        )

        # Invalid remote
        resp = self.client.get(
            url_for(""oauthclient.login"", remote_app='invalid')
        )
        self.assertStatus(resp, 404)

    def test_authorized(self):
        # Fake an authorized request
        with self.app.test_client() as c:
            # Ensure remote apps have been loaded (due to before first
            # request)
            c.get(url_for(""oauthclient.login"", remote_app='test'))
            self.mock_response(app='test')
            self.mock_response(app='test_invalid')

            resp = c.get(
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test',
                    code='test',
                )
            )
            assert resp.data == ""TEST""
            assert self.handled_remote.name == 'test'
            assert not self.handled_args
            assert not self.handled_kwargs
            assert self.handled_resp['access_token'] == 'test_access_token'

            resp = self.assertRaises(
                TypeError,
                c.get,
                url_for(
                    ""oauthclient.authorized"",
                    remote_app='test_invalid',
                    code='test',
                )
            )

    def test_no_remote_app(self):
        self.assert404(self.client.get(
            url_for(""oauthclient.authorized"", remote_app='invalid')
        ))

        self.assert404(self.client.get(
            url_for(""oauthclient.disconnect"", remote_app='invalid')
        ))

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_token_getter_setter(self, save_session):
        from invenio.modules.oauthclient.models import RemoteToken
        from invenio.modules.oauthclient.handlers import token_getter
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )
                # Mock resposen class
                self.mock_response(app='full')

                # Imitate that the user authorized our request in the remote
                # application.
                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                # Assert if every is as it should be.
                assert session['oauth_token_full'] == ('test_access_token', '')

                t = RemoteToken.get(1, ""fullid"")
                assert t.remote_account.client_id == 'fullid'
                assert t.access_token == 'test_access_token'
                assert RemoteToken.query.count() == 1

                self.mock_response(app='full', data={
                    ""access_token"": ""new_access_token"",
                    ""scope"": """",
                    ""token_type"": ""bearer""
                })

                c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))

                t = RemoteToken.get(1, ""fullid"")
                assert t.access_token == 'new_access_token'
                assert RemoteToken.query.count() == 1

                val = token_getter(oauth.remote_apps['full'])
                assert val == ('new_access_token', '')

                # Disconnect account
                res = c.get(url_for(
                    ""oauthclient.disconnect"", remote_app='full',
                ))
                assert res.status_code == 302
                assert res.location.endswith(
                    url_for('oauthclient_settings.index')
                )
                # Assert that remote account have been removed.
                t = RemoteToken.get(1, ""fullid"")
                assert t is None

    @patch('invenio.ext.session.interface.SessionInterface.save_session')
    def test_rejected(self, save_session):
        from invenio.modules.oauthclient.client import oauth

        user = MagicMock()
        user.get_id = MagicMock(return_value=1)
        user.is_authenticated = MagicMock(return_value=True)
        with patch('flask.ext.login._get_user', return_value=user):
            with self.app.test_client() as c:
                # First call login to be redirected
                res = c.get(url_for(""oauthclient.login"", remote_app='full'))
                assert res.status_code == 302
                assert res.location.startswith(
                    oauth.remote_apps['full'].authorize_url
                )

                # Mock response to imitate an invalid response. Here, an
                # example from GitHub when the code is expired.
                self.mock_response(app='full', data=dict(
                    error_uri='http://developer.github.com/v3/oauth/'
                              '#bad-verification-code',
                    error_description='The code passed is '
                                      'incorrect or expired.',
                    error='bad_verification_code',
                ))

                # Imitate that the user authorized our request in the remote
                # application (however, the remote app will son reply with an
                # error)
                res = c.get(url_for(
                    ""oauthclient.authorized"", remote_app='full', code='test',
                ))
                assert res.status_code == 302

    def test_settings_view(self):
        # Create a remove account (linked account)
        from invenio.modules.oauthclient.models import RemoteAccount
        RemoteAccount.create(1, 'testid', None)

        self.assert401(self.client.get(url_for('oauthclient_settings.index'),
                                       follow_redirects=True))
        self.login(""admin"", """")

        res = self.client.get(url_for('oauthclient_settings.index'))
        self.assert200(res)
        assert 'MyLinkedTestAccount' in res.data
        assert url_for('oauthclient.disconnect', remote_app='test') in res.data
        assert url_for('oauthclient.login', remote_app='full') in res.data
        assert url_for('oauthclient.login', remote_app='test_invalid') in \
            res.data


TEST_SUITE = make_test_suite(RemoteAccountTestCase)

if __name__ == ""__main__"":
    run_test_suite(TEST_SUITE)
/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-
##
## This file is part of Invenio.
## Copyright (C) 2014 CERN.
##
## Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""""" Client blueprint used to handle OAuth callbacks. """"""

from __future__ import absolute_import

from flask import Blueprint, abort, current_app, url_for, request

from flask.ext.login import user_logged_out

from invenio.base.globals import cfg
from invenio.ext.sslify import ssl_required

from ..client import oauth, handlers, disconnect_handlers, signup_handlers
from ..handlers import authorized_default_handler, make_token_getter, \
    make_handler, disconnect_handler, oauth_logout_handler


blueprint = Blueprint(
    'oauthclient',
    __name__,
    url_prefix=""/oauth"",
    static_folder=""../static"",
    template_folder=""../templates"",
)


@blueprint.before_app_first_request
def setup_app():
    """""" Setup OAuth clients. """"""
    # Connect signal to remove access tokens on logout
    user_logged_out.connect(oauth_logout_handler)

    # Add remote applications
    oauth.init_app(current_app)

    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():
        # Prevent double creation problems
        if remote_app not in oauth.remote_apps:
            remote = oauth.remote_app(
                remote_app,
                **conf['params']
            )

        remote = oauth.remote_apps[remote_app]

        # Set token getter for remote
        remote.tokengetter(make_token_getter(remote))

        # Register authorized handler
        handlers.register(
            remote_app,
            remote.authorized_handler(make_handler(
                conf.get('authorized_handler', authorized_default_handler),
                remote,
            ))
        )

        # Register disconnect handler
        disconnect_handlers.register(
            remote_app, make_handler(
                conf.get('disconnect_handler', disconnect_handler),
                remote,
                with_response=False,
            )
        )

        # Register sign-up handlers
        def dummy_handler(remote, *args, **kargs):
            pass

        signup_handler = conf.get('signup_handler', dict())
        account_info_handler = make_handler(
            signup_handler.get('info', dummy_handler),
            remote,
            with_response=False
        )
        account_setup_handler = make_handler(
            signup_handler.get('setup', dummy_handler),
            remote,
            with_response=False
        )
        account_view_handler = make_handler(
            signup_handler.get('view', dummy_handler),
            remote,
            with_response=False
        )

        signup_handlers.register(
            remote_app,
            dict(
                info=account_info_handler,
                setup=account_setup_handler,
                view=account_view_handler,
            )
        )


@blueprint.route('/login/<remote_app>/')
@ssl_required
def login(remote_app):
    """""" Send user to remote application for authentication. """"""
    if remote_app not in oauth.remote_apps:
        return abort(404)

    callback_url = url_for(
        '.authorized',
        remote_app=remote_app,
        next=request.args.get('next') or request.referrer or None,
        _external=True,
    )

    return oauth.remote_apps[remote_app].authorize(callback=callback_url)


@blueprint.route('/authorized/<remote_app>/')
@ssl_required
def authorized(remote_app=None):
    """""" Authorized handler callback. """"""
    if remote_app not in handlers:
        return abort(404)
    return handlers[remote_app]()


@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])
@ssl_required
def signup(remote_app):
    """""" Extra signup step. """"""
    if remote_app not in signup_handlers:
        return abort(404)
    res = signup_handlers[remote_app]['view']()
    return abort(404) if res is None else res


@blueprint.route('/disconnect/<remote_app>/')
@ssl_required
def disconnect(remote_app):
    """""" Disconnect user from remote application.

    Removes application as well as associated information.
    """"""
    if remote_app not in disconnect_handlers:
        return abort(404)

    return disconnect_handlers[remote_app]()
/n/n/n",1
14,14,ae7e50d52016e4c9471e39bb4ac03b4c7dfe33bb,"bzs/core.py/n/n
import socket
import threading
import tornado

import tornado.concurrent
import tornado.httputil
import tornado.httpserver
import tornado.gen
import tornado.ioloop
import tornado.process
import tornado.web

from bzs import const
from bzs import db
from bzs import files

from bzs import module_error404
from bzs import module_files
from bzs import module_home
from bzs import module_index
from bzs import module_static

WEB_PORT = 80

def main():
    # Creating web application
    web_app = tornado.web.Application([
            (r'^/$', module_index.MainframeHandler),
            (r'/static/(.*)$', module_static.StaticHandler),
            # (r'/static/(.*)', tornado.web.StaticFileHandler, {
            #     ""path"": ""./static/"" # Optimized static file handler with cache
            # }),
            (r'^/home', module_home.HomeHandler),
            (r'^/files/?()$', module_files.FilesListHandler),
            (r'^/files/list/(.*)', module_files.FilesListHandler),
            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),
            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),
            (r'^/files/operation/?', module_files.FilesOperationHandler),
            (r'.*', module_error404.Error404Handler)
        ],
        xsrf_cookies=False # True to prevent CSRF third party attacks
    )
    # Starting server
    web_sockets = tornado.netutil.bind_sockets(
        const.get_const('server-port'),
        family=socket.AF_INET)
    if const.get_const('server-threads') > 1:
        if hasattr(os, 'fork'):
            # os.fork() operation unavailable on Windows.
            tornado.process.fork_processes(const.get_const('server-threads') - 1)
    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)
    web_server.add_sockets(web_sockets)
    # Boot I/O thread for asynchronous purposes
    tornado.ioloop.IOLoop.instance().start()
    return
/n/n/nbzs/module_error404.py/n/n
import re
import tornado

from bzs import files
from bzs import const

class Error404Handler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        try:
            file_data = files.get_static_data('./static/404.html')
        except Exception:
            file_data = '404 Not Found'
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/nbzs/module_files.py/n/n
import base64
import binascii
import cgi
import io
import json
import re
import time
import tornado
import urllib

from bzs import const
from bzs import db
from bzs import files
from bzs import preproc
from bzs import users

def encode_str_to_hexed_b64(data):
    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')
def decode_hexed_b64_to_str(data):
    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')

################################################################################

class FilesListHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, target_path):
        """"""/files/list/HEXED_BASE64_STRING_OF_PATH/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async(target_path):
            # Getting file template.
            file_temp = files.get_static_data('./static/files.html')

            # Retrieving list operation target.
            try:
                target_path = decode_hexed_b64_to_str(target_path)
            except:
                target_path = '/'
            if not target_path:
                target_path = '/'

            # Getting hierarchical file path
            files_hierarchy = target_path.split('/')
            files_hierarchy_list = list()
            while '' in files_hierarchy:
                files_hierarchy.remove('')
            files_hierarchy = [''] + files_hierarchy
            files_hierarchy_cwd = ''
            for i in range(0, len(files_hierarchy)):
                files_hierarchy[i] += '/'
                files_hierarchy_cwd += files_hierarchy[i]
                files_hierarchy_list.append(dict(
                    folder_name=files_hierarchy[i],
                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),
                    disabled=(i == len(files_hierarchy) - 1)))
                continue

            # Getting current directory content
            files_attrib_list = list()
            for f_handle in db.Filesystem.listdir(target_path):
                # try:
                    file_name = f_handle['file-name']
                    actual_path = target_path + file_name
                    attrib = dict()
                    attrib['file-name'] = file_name
                    attrib['file-name-url'] = urllib.parse.quote(file_name)
                    attrib['file-name-escaped'] = cgi.escape(file_name)
                    attrib['size'] = f_handle['file-size']
                    attrib['size-str'] = files.format_file_size(attrib['size'])
                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!
                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))
                    # Encoding MIME types
                    if f_handle['is-dir']:
                        attrib['mime-type'] = 'directory/folder'
                    else:
                        attrib['mime-type'] = files.guess_mime_type(file_name)
                    # Encoding hyperlinks
                    if attrib['mime-type'] == 'directory/folder':
                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')
                    else:
                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])
                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)
                    files_attrib_list.append(attrib)
                # except Exception:
                #     pass
            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)

            # File actually exists, sending data
            working_user = users.get_user_by_cookie(
                self.get_cookie('user_active_login', default=''))
            file_temp = preproc.preprocess_webpage(file_temp, working_user,
                files_attrib_list=files_attrib_list,
                files_hierarchy_list=files_hierarchy_list,
                cwd_uuid=cwd_uuid)
            future.set_result(file_temp)
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,
            target_path)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_temp)
        self.flush()
        self.finish()
        return self

    head=get
    pass

################################################################################

class FilesDownloadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path, file_name):
        """"""/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME""""""
        # Something that I do not wish to write too many times..
        def invoke_404():
            self.set_status(404, ""Not Found"")
            self.add_header('Content-Length', '0')
            self.flush()
            return

        # Get file location (exactly...)
        try:
            file_path = decode_hexed_b64_to_str(file_path)
        except Exception:
            file_path = ''
        if not file_path:
            invoke_404()
            return

        # Asynchronous web request...
        file_block_size = 64 * 1024 # 64 KiB / Chunk
        file_block = bytes()
        file_data = None

        future = tornado.concurrent.Future()
        def inquire_data_async():
            _tf_data = db.Filesystem.get_content(file_path)
            future.set_result(_tf_data)
        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)
        file_data = yield future
        file_stream = io.BytesIO(file_data)

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'application/x-download')
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        while file_stream.tell() < len(file_data):
            byte_pos = file_stream.tell()
            # Entry to the concurrency worker
            future = tornado.concurrent.Future()
            # Concurrent worker
            def retrieve_data_async():
                block = file_stream.read(file_block_size)
                future.set_result(block)
            # Injection and pending
            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)
            # Reset or read
            file_block = yield future
            self.write(file_block)
            file_block = None
            self.flush()
        file_block = None
        self.finish()

        # Release memory...
        file_stream = None
        file_data = None
        return self

    head=get
    pass

################################################################################

class FilesOperationHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self):
        """"""/files/operation/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async():
            operation_content_raw = self.request.body
            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))
            action = operation_content['action']
            sources = operation_content['source']
            if type(sources) == list:
                for i in range(0, len(sources)):
                    try:
                        sources[i] = decode_hexed_b64_to_str(sources[i])
                    except:
                        pass
            else:
                sources = decode_hexed_b64_to_str(sources)
            if action in ['copy', 'move']:
                try:
                    target = decode_hexed_b64_to_str(operation_content['target'])
                except:
                    target = '/'
            elif action in ['rename', 'new-folder']:
                try:
                    target = operation_content['target']
                except:
                    target = sources # I am not handling more exceptions as this is brutal enough
            # Done assigning values, now attempting to perform operation
            if action == 'copy':
                for source in sources:
                    db.Filesystem.copy(source, target, new_owner='user-cp')
            elif action == 'move':
                for source in sources:
                    db.Filesystem.move(source, target)
            elif action == 'delete':
                for source in sources:
                    db.Filesystem.remove(source)
            elif action == 'rename':
                db.Filesystem.rename(sources, target)
            elif action == 'new-folder':
                db.Filesystem.mkdir(sources, target, 'user-nf')
            future.set_result('')
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_temp)
        self.flush()
        self.finish()
        return self
    pass

################################################################################

class FilesUploadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self, target_path, file_name):
        """"""/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()
        working_user = users.get_user_by_cookie(
            self.get_cookie('user_active_login', default=''))

        def save_file_async(alter_ego, target_path, file_name, working_user):
            upload_data = alter_ego.request.body
            # Crucial, to release data.
            alter_ego.request.body = None
            target_path = decode_hexed_b64_to_str(target_path)
            # Committing changes to database
            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)
            # Final return
            future.set_result('bzs_upload_success')
        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,
            self, target_path, file_name, working_user)

        response_temp = yield future
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(response_temp)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(response_temp)
        self.flush()
        self.finish()
        return self
    pass
/n/n/nbzs/module_home.py/n/n
import re
import tornado

from bzs import files
from bzs import const
from bzs import users
from bzs import preproc

class HomeHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_index_html_async():
                file_data = files.get_static_data('./static/home.html')
                working_user = users.get_user_by_cookie(
                    self.get_cookie('user_active_login', default=''))
                file_data = preproc.preprocess_webpage(file_data, working_user)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)
            file_data = yield future
        except Exception:
            self.set_status(404, ""Not Found"")
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/nbzs/module_index.py/n/n
import re
import tornado

from bzs import files
from bzs import const
from bzs import users
from bzs import preproc

class MainframeHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_index_html_async():
                file_data = files.get_static_data('./static/index.html')
                working_user = users.get_user_by_cookie(
                    self.get_cookie('user_active_login', default=''))
                file_data = preproc.preprocess_webpage(file_data, working_user)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)
            file_data = yield future
        except Exception:
            print(Exception)
            self.set_status(404, ""Not Found"")
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        # File actually exists, sending data
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/nbzs/module_static.py/n/n
import re
import tornado

from bzs import files
from bzs import const

class StaticHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path):
        """"""/static/PATH""""""
        file_path = './static/' + file_path
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_file_data_async():
                file_data = files.get_static_data(file_path)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_file_data_async)
            file_data = yield future
        except Exception:
            self.set_status(404, ""Not Found"")
            self._headers = tornado.httputil.HTTPHeaders()
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        # File actually exists, sending data
        self.set_status(200, ""OK"")
        self._headers = tornado.httputil.HTTPHeaders()
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', files.guess_mime_type(file_path))
        self.add_header('Content-Length', str(len(file_data)))
        self.xsrf_form_html() # Prefent CSRF attacks

        # Push result to client in one blob
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/n",0
15,15,ae7e50d52016e4c9471e39bb4ac03b4c7dfe33bb,"/bzs/core.py/n/n
import socket
import threading
import tornado

import tornado.concurrent
import tornado.httputil
import tornado.httpserver
import tornado.gen
import tornado.ioloop
import tornado.process
import tornado.web

from bzs import const
from bzs import db
from bzs import files

from bzs import module_error404
from bzs import module_files
from bzs import module_home
from bzs import module_index
from bzs import module_static

WEB_PORT = 80

def main():
    # Creating web application
    web_app = tornado.web.Application([
            (r'^/$', module_index.MainframeHandler),
            (r'/static/.*', module_static.StaticHandler),
            # (r'/static/(.*)', tornado.web.StaticFileHandler, {
            #     ""path"": ""./static/"" # Optimized static file handler with cache
            # }),
            (r'^/home', module_home.HomeHandler),
            (r'^/files/?()$', module_files.FilesListHandler),
            (r'^/files/list/(.*)', module_files.FilesListHandler),
            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),
            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),
            (r'^/files/operation/?', module_files.FilesOperationHandler),
            (r'.*', module_error404.Error404Handler)
        ],
        xsrf_cookies=False # True to prevent CSRF third party attacks
    )
    # Starting server
    web_sockets = tornado.netutil.bind_sockets(
        const.get_const('server-port'),
        family=socket.AF_INET)
    if const.get_const('server-threads') > 1:
        if hasattr(os, 'fork'):
            # os.fork() operation unavailable on Windows.
            tornado.process.fork_processes(const.get_const('server-threads') - 1)
    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)
    web_server.add_sockets(web_sockets)
    # Boot I/O thread for asynchronous purposes
    tornado.ioloop.IOLoop.instance().start()
    return
/n/n/n/bzs/module_error404.py/n/n
import re
import tornado

from bzs import files
from bzs import const

class Error404Handler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        try:
            file_data = files.get_static_data('./static/404.html')
        except Exception:
            file_data = '404 Not Found'
        self.set_status(200, ""OK"")
        self._headers = tornado.httputil.HTTPHeaders()
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/n/bzs/module_files.py/n/n
import base64
import binascii
import cgi
import io
import json
import re
import time
import tornado
import urllib

from bzs import const
from bzs import db
from bzs import files
from bzs import preproc
from bzs import users

def encode_str_to_hexed_b64(data):
    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')
def decode_hexed_b64_to_str(data):
    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')

################################################################################

class FilesListHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, target_path):
        """"""/files/list/HEXED_BASE64_STRING_OF_PATH/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async(target_path):
            # Getting file template.
            file_temp = files.get_static_data('./static/files.html')

            # Retrieving list operation target.
            try:
                target_path = decode_hexed_b64_to_str(target_path)
            except:
                target_path = '/'
            if not target_path:
                target_path = '/'

            # Getting hierarchical file path
            files_hierarchy = target_path.split('/')
            files_hierarchy_list = list()
            while '' in files_hierarchy:
                files_hierarchy.remove('')
            files_hierarchy = [''] + files_hierarchy
            files_hierarchy_cwd = ''
            for i in range(0, len(files_hierarchy)):
                files_hierarchy[i] += '/'
                files_hierarchy_cwd += files_hierarchy[i]
                files_hierarchy_list.append(dict(
                    folder_name=files_hierarchy[i],
                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),
                    disabled=(i == len(files_hierarchy) - 1)))
                continue

            # Getting current directory content
            files_attrib_list = list()
            for f_handle in db.Filesystem.listdir(target_path):
                # try:
                    file_name = f_handle['file-name']
                    actual_path = target_path + file_name
                    attrib = dict()
                    attrib['file-name'] = file_name
                    attrib['file-name-url'] = urllib.parse.quote(file_name)
                    attrib['file-name-escaped'] = cgi.escape(file_name)
                    attrib['size'] = f_handle['file-size']
                    attrib['size-str'] = files.format_file_size(attrib['size'])
                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!
                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))
                    # Encoding MIME types
                    if f_handle['is-dir']:
                        attrib['mime-type'] = 'directory/folder'
                    else:
                        attrib['mime-type'] = files.guess_mime_type(file_name)
                    # Encoding hyperlinks
                    if attrib['mime-type'] == 'directory/folder':
                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')
                    else:
                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])
                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)
                    files_attrib_list.append(attrib)
                # except Exception:
                #     pass
            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)

            # File actually exists, sending data
            working_user = users.get_user_by_cookie(
                self.get_cookie('user_active_login', default=''))
            file_temp = preproc.preprocess_webpage(file_temp, working_user,
                files_attrib_list=files_attrib_list,
                files_hierarchy_list=files_hierarchy_list,
                cwd_uuid=cwd_uuid)
            future.set_result(file_temp)
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,
            target_path)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.write(file_temp)
        self.flush()
        self.finish()
        return self

    head=get
    pass

################################################################################

class FilesDownloadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self, file_path, file_name):
        """"""/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME""""""
        # Something that I do not wish to write too many times..
        def invoke_404():
            self.set_status(404, ""Not Found"")
            self._headers = tornado.httputil.HTTPHeaders()
            self.add_header('Content-Length', '0')
            self.flush()
            return

        # Get file location (exactly...)
        try:
            file_path = decode_hexed_b64_to_str(file_path)
        except Exception:
            file_path = ''
        if not file_path:
            invoke_404()
            return

        # Asynchronous web request...
        file_block_size = 64 * 1024 # 64 KiB / Chunk
        file_block = bytes()
        file_data = None

        future = tornado.concurrent.Future()
        def inquire_data_async():
            _tf_data = db.Filesystem.get_content(file_path)
            future.set_result(_tf_data)
        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)
        file_data = yield future
        file_stream = io.BytesIO(file_data)

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'application/x-download')
        self.add_header('Content-Length', str(len(file_data)))

        while file_stream.tell() < len(file_data):
            byte_pos = file_stream.tell()
            # Entry to the concurrency worker
            future = tornado.concurrent.Future()
            # Concurrent worker
            def retrieve_data_async():
                block = file_stream.read(file_block_size)
                future.set_result(block)
            # Injection and pending
            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)
            # Reset or read
            file_block = yield future
            self.write(file_block)
            file_block = None
            self.flush()
        file_block = None
        self.finish()

        # Release memory...
        file_stream = None
        file_data = None
        return self

    head=get
    pass

################################################################################

class FilesOperationHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self):
        """"""/files/operation/""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()

        def get_final_html_async():
            operation_content_raw = self.request.body
            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))
            action = operation_content['action']
            sources = operation_content['source']
            if type(sources) == list:
                for i in range(0, len(sources)):
                    try:
                        sources[i] = decode_hexed_b64_to_str(sources[i])
                    except:
                        pass
            else:
                sources = decode_hexed_b64_to_str(sources)
            if action in ['copy', 'move']:
                try:
                    target = decode_hexed_b64_to_str(operation_content['target'])
                except:
                    target = '/'
            elif action in ['rename', 'new-folder']:
                try:
                    target = operation_content['target']
                except:
                    target = sources # I am not handling more exceptions as this is brutal enough
            # Done assigning values, now attempting to perform operation
            if action == 'copy':
                for source in sources:
                    db.Filesystem.copy(source, target, new_owner='user-cp')
            elif action == 'move':
                for source in sources:
                    db.Filesystem.move(source, target)
            elif action == 'delete':
                for source in sources:
                    db.Filesystem.remove(source)
            elif action == 'rename':
                db.Filesystem.rename(sources, target)
            elif action == 'new-folder':
                db.Filesystem.mkdir(sources, target, 'user-nf')
            future.set_result('')
        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)
        file_temp = yield future

        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_temp)))
        self.write(file_temp)
        self.flush()
        self.finish()
        return self
    pass

################################################################################

class FilesUploadHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['POST']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def post(self, target_path, file_name):
        """"""/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME""""""
        # Another concurrency blob...
        future = tornado.concurrent.Future()
        working_user = users.get_user_by_cookie(
            self.get_cookie('user_active_login', default=''))

        def save_file_async(alter_ego, target_path, file_name, working_user):
            upload_data = alter_ego.request.body
            # Crucial, to release data.
            alter_ego.request.body = None
            target_path = decode_hexed_b64_to_str(target_path)
            # Committing changes to database
            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)
            # Final return
            future.set_result('bzs_upload_success')
        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,
            self, target_path, file_name, working_user)

        response_temp = yield future
        self.set_status(200, ""OK"")
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(response_temp)))
        self.write(response_temp)
        self.flush()
        self.finish()
        return self
    pass
/n/n/n/bzs/module_home.py/n/n
import re
import tornado

from bzs import files
from bzs import const
from bzs import users
from bzs import preproc

class HomeHandler(tornado.web.RequestHandler):
    SUPPORTED_METHODS = ['GET', 'HEAD']

    @tornado.web.asynchronous
    @tornado.gen.coroutine
    def get(self):
        # In case it does not exist.
        try:
            future = tornado.concurrent.Future()
            def get_index_html_async():
                file_data = files.get_static_data('./static/home.html')
                working_user = users.get_user_by_cookie(
                    self.get_cookie('user_active_login', default=''))
                file_data = preproc.preprocess_webpage(file_data, working_user)
                future.set_result(file_data)
            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)
            file_data = yield future
        except Exception:
            self.set_status(404, ""Not Found"")
            self._headers = tornado.httputil.HTTPHeaders()
            self.add_header('Content-Length', '0')
            self.flush()
            return None

        self.set_status(200, ""OK"")
        self._headers = tornado.httputil.HTTPHeaders()
        self.add_header('Cache-Control', 'max-age=0')
        self.add_header('Connection', 'close')
        self.add_header('Content-Type', 'text/html')
        self.add_header('Content-Length', str(len(file_data)))
        self.write(file_data)
        self.flush()
        self.finish()
        return self

    head=get
    pass
/n/n/n",1
26,26,5bd28a262e274d24cf802ed6051e6880c7033452,"app/admin_delete_record.py/n/n#!/usr/bin/python2.7
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from const import *
from model import *
from utils import *
import reveal


class Handler(BaseHandler):
    """"""An admin page to delete person records.""""""

    # After a repository is deactivated, we still need the admin page to be
    # accessible so we can edit its settings.
    ignore_deactivation = True

    repo_required = False
    admin_required = True

    def get(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        self.render(
            'admin_delete_record.html',
            id=self.env.domain + '/person.',
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_delete_record'))

    def post(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                    self.params.xsrf_token, user.user_id(),
                    'admin_delete_record')):
            self.error(403)
            return False
        # Redirect to the deletion handler with a valid signature.
        action = ('delete', str(self.params.id))
        self.redirect('/delete', id=self.params.id,
                      signature=reveal.sign(action))
/n/n/napp/main.py/n/n#!/usr/bin/python2.7
# Copyright 2010 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""""""The main request handler. All dynamic requests except for remote_api are
handled by this handler, which dispatches to all other dynamic handlers.""""""

import django_setup  # always keep this first

import mimetypes
import re
import os

import urlparse

from google.appengine.api import memcache
from google.appengine.api import users
from google.appengine.ext import webapp

import config
import const
import django.utils.html
import logging
import model
import pfif
import resources
import utils
import user_agents
import setup_pf


# When no action or repo is specified, redirect to this action.
HOME_ACTION = 'home.html'

# Map of URL actions to Python module and class names.
# TODO(kpy): Remove the need for this configuration information, either by
# regularizing the module and class names or adding a URL attribute to handlers.
HANDLER_CLASSES = dict((x, x.replace('/', '_') + '.Handler') for x in [
  'start',
  'amp_start',
  'query',
  'results',
  'create',
  'view',
  'multiview',
  'reveal',
  'photo',
  'embed',
  'extend',
  'gadget',
  'delete',
  'flag_note',
  'restore',
  'subscribe',
  'unsubscribe',
  'disable_notes',
  'confirm_disable_notes',
  'enable_notes',
  'confirm_enable_notes',
  'post_flagged_note',
  'confirm_post_flagged_note',
  'third_party_search',
  'admin',
  'admin/create_repo',
  'admin/dashboard',
  'admin/resources',
  'admin/review',
  'css',
  'add_note',
  'tos',
])

# Exceptional cases where the module name doesn't match the URL.
HANDLER_CLASSES[''] = 'start.Handler'
HANDLER_CLASSES['admin/api_keys'] = 'admin_api_keys.CreateOrUpdateApiKey'
HANDLER_CLASSES['admin/api_keys/list'] = 'admin_api_keys.ListApiKeys'
HANDLER_CLASSES['api/import'] = 'api.Import'
HANDLER_CLASSES['api/import/notes'] = 'api.Import'
HANDLER_CLASSES['api/import/persons'] = 'api.Import'
HANDLER_CLASSES['api/read'] = 'api.Read'
HANDLER_CLASSES['api/write'] = 'api.Write'
HANDLER_CLASSES['api/search'] = 'api.Search'
HANDLER_CLASSES['api/subscribe'] = 'api.Subscribe'
HANDLER_CLASSES['api/unsubscribe'] = 'api.Unsubscribe'
HANDLER_CLASSES['api/stats'] = 'api.Stats'
HANDLER_CLASSES['api/handle_sms'] = 'api.HandleSMS'
HANDLER_CLASSES['api/photo_upload'] = 'api.PhotoUpload'
HANDLER_CLASSES['feeds/repo'] = 'feeds.Repo'
HANDLER_CLASSES['feeds/note'] = 'feeds.Note'
HANDLER_CLASSES['feeds/person'] = 'feeds.Person'
HANDLER_CLASSES['tasks/count/note'] = 'tasks.CountNote'
HANDLER_CLASSES['tasks/count/person'] = 'tasks.CountPerson'
HANDLER_CLASSES['tasks/count/reindex'] = 'tasks.Reindex'
HANDLER_CLASSES['tasks/count/update_dead_status'] = 'tasks.UpdateDeadStatus'
HANDLER_CLASSES['tasks/count/update_status'] = 'tasks.UpdateStatus'
HANDLER_CLASSES['tasks/delete_expired'] = 'tasks.DeleteExpired'
HANDLER_CLASSES['tasks/delete_old'] = 'tasks.DeleteOld'
HANDLER_CLASSES['tasks/dump_csv'] = 'tasks.DumpCSV'
HANDLER_CLASSES['tasks/clean_up_in_test_mode'] = 'tasks.CleanUpInTestMode'
HANDLER_CLASSES['tasks/notify_many_unreviewed_notes'] = 'tasks.NotifyManyUnreviewedNotes'
HANDLER_CLASSES['tasks/thumbnail_preparer'] = 'tasks.ThumbnailPreparer'
if config.get('enable_react_ui'):
    HANDLER_CLASSES['d/create'] = 'frontend_api.Create'
    HANDLER_CLASSES['d/person'] = 'frontend_api.Person'
    HANDLER_CLASSES['d/repo'] = 'frontend_api.Repo'
    HANDLER_CLASSES['d/results'] = 'frontend_api.Results'

NON_REACT_UI_PATHS = ['api/', 'admin/', 'feeds/', 'sitemap', 'tasks/', 'd/']

def is_development_server():
    """"""Returns True if the app is running in development.""""""
    server = os.environ.get('SERVER_SOFTWARE', '')
    return 'Development' in server

def is_cron_task(request):
    """"""Returns True if the request is from appengine cron.""""""
    return 'X-AppEngine-Cron' in request.headers

def is_task_queue_task(request):
    """"""Returns True if the request is from the appengine task queue.""""""
    return 'X-AppEngine-TaskName' in request.headers

def get_repo_and_action(request):
    """"""Determines the repo and action for a request.  The action is the part
    of the URL path after the repo, with no leading or trailing slashes.""""""
    scheme, netloc, path, _, _ = urlparse.urlsplit(request.url)
    parts = path.lstrip('/').split('/')

    # Depending on whether we're serving from appspot directly or
    # google.org/personfinder we could have /global or /personfinder/global
    # as the 'global' prefix.
    if parts[0] == 'personfinder':
        parts.pop(0)
    repo = parts and parts.pop(0) or None
    action = '/'.join(parts)
    if repo == 'global':
        repo = None
    return repo, action

def select_charset(request):
    """"""Given a request, chooses a charset for encoding the response.

    If the selected charset is UTF-8, it always returns
    'utf-8' (const.CHARSET_UTF8), not 'utf8', 'UTF-8', etc.

    For now, we always use UTF-8, because supporting anything else with WebOB
    1.2.3 and webapp2 is impractical. We might revisit this once we migrate to
    Django, with which it shouldn't be so difficult to support other character
    sets.
    """"""
    return const.CHARSET_UTF8

def select_lang(request, config=None):
    """"""Selects the best language to use for a given request.  The 'lang' query
    parameter has priority, then the django_language cookie, then
    'Accept-Language' HTTP header, then the first language in the language menu,
    then the default setting.""""""
    default_lang = (
        (config and
         config.language_menu_options and
         config.language_menu_options[0]) or
            const.DEFAULT_LANGUAGE_CODE)
    lang = (request.get('lang') or
            request.cookies.get('django_language', None) or
            select_lang_from_header(request, default_lang=default_lang))
    lang = re.sub('[^A-Za-z0-9-]', '', lang)
    lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
    if lang in const.LANGUAGE_ENDONYMS.keys():
        return lang
    else:
        return default_lang

def select_lang_from_header(request, default_lang):
    """"""Selects the best language matching 'Accept-Language' HTTP header.""""""
    # Either of the first item in the first argument or the default_match
    # argument is used as the default depending on the situation. So we need to
    # put the default language to both. See:
    #   https://docs.pylonsproject.org/projects/webob/en/stable/api/webob.html#webob.acceptparse.AcceptLanguageValidHeader.best_match
    #   https://docs.pylonsproject.org/projects/webob/en/stable/api/webob.html#webob.acceptparse.AcceptLanguageNoHeader.best_match
    return request.accept_language.best_match(
        [default_lang] + const.LANGUAGE_ENDONYMS.keys(),
        default_match=default_lang)

def get_repo_options(request, lang):
    """"""Returns a list of the names and titles of the launched repositories.""""""
    options = []
    for repo in model.Repo.list_launched():
        titles = config.get_for_repo(repo, 'repo_titles', {})
        default_title = (titles.values() or ['?'])[0]
        title = titles.get(lang, titles.get('en', default_title))
        url = utils.get_repo_url(request, repo)
        test_mode = config.get_for_repo(repo, 'test_mode')
        options.append(utils.Struct(repo=repo, title=title, url=url,
                                    test_mode=test_mode))
    return options

def get_language_options(request, config, current_lang):
    """"""Returns a list of information needed to generate the language menu.""""""
    primary_langs = (config and config.language_menu_options) or ['en']
    all_langs = sorted(
        const.LANGUAGE_ENDONYMS.keys(),
        key=lambda s: const.LANGUAGE_ENDONYMS[s])
    return {
        'primary':
            [get_language_option(request, lang, lang == current_lang)
             for lang in primary_langs],
        'all':
            # We put both 'primary' and 'all' languages into a single <select>
            # box (See app/resources/language-menu.html.template).
            # If current_lang is in the primary languages, we mark the
            # language as is_selected in 'primary', not in 'all', to make sure
            # a single option is selected in the <select> box.
            [get_language_option(
                request, lang,
                lang == current_lang and lang not in primary_langs)
             for lang in all_langs],
    }

def get_language_option(request, lang, is_selected):
    return {
        'lang': lang,
        'endonym': const.LANGUAGE_ENDONYMS.get(lang, '?'),
        'url': utils.set_url_param(request.url, 'lang', lang),
        'is_selected': is_selected,
    }

def get_localized_message(localized_messages, lang, default):
    """"""Gets the localized message for lang from a dictionary that maps language
    codes to localized messages.  Falls back to English if language 'lang' is
    not available, or to a default message if English is not available.""""""
    if not isinstance(localized_messages, dict):
        return default
    return localized_messages.get(lang, localized_messages.get('en', default))

def get_hidden_input_tags_for_preserved_query_params(request):
    """"""Gets HTML with <input type=""hidden""> tags to preserve query parameters
    listed in utils.PRESERVED_QUERY_PARAM_NAMES e.g. ""ui"".""""""
    tags_str = ''
    for name in utils.PRESERVED_QUERY_PARAM_NAMES:
        value = request.get(name)
        if value:
            tags_str += '<input type=""hidden"" name=""%s"" value=""%s"">\n' % (
                django.utils.html.escape(name),
                django.utils.html.escape(value))
    return tags_str

def setup_env(request):
    """"""Constructs the 'env' object, which contains various template variables
    that are commonly used by most handlers.""""""
    env = utils.Struct()
    env.repo, env.action = get_repo_and_action(request)
    env.config = config.Configuration(env.repo or '*')

    env.analytics_id = env.config.get('analytics_id')
    env.amp_gtm_id = env.config.get('amp_gtm_id')
    env.maps_api_key = env.config.get('maps_api_key')

    # Internationalization-related stuff.
    env.charset = select_charset(request)
    env.lang = select_lang(request, env.config)
    env.rtl = env.lang in const.LANGUAGES_BIDI

    # Determine the resource bundle to use.
    env.default_resource_bundle = env.config.get('default_resource_bundle', '1')
    env.resource_bundle = (request.cookies.get('resource_bundle', '') or
                           env.default_resource_bundle)

    # Information about the request.
    env.url = utils.set_url_param(request.url, 'lang', env.lang)
    env.scheme, env.netloc, env.path, _, _ = urlparse.urlsplit(request.url)
    env.force_https = True
    env.domain = env.netloc.split(':')[0]
    env.global_url = utils.get_repo_url(request, 'global')

    # Commonly used information that's rendered or localized for templates.
    env.language_options = get_language_options(request, env.config, env.lang)
    env.repo_options = get_repo_options(request, env.lang)
    env.expiry_options = [
        utils.Struct(value=value, text=const.PERSON_EXPIRY_TEXT[value])
        for value in sorted(const.PERSON_EXPIRY_TEXT.keys(), key=int)
    ]
    env.status_options = [
        utils.Struct(value=value, text=const.NOTE_STATUS_TEXT[value])
        for value in pfif.NOTE_STATUS_VALUES
        if (value != 'believed_dead' or
            not env.config or env.config.allow_believed_dead_via_ui)
    ]
    env.hidden_input_tags_for_preserved_query_params = (
        get_hidden_input_tags_for_preserved_query_params(request))

    ui_param = request.get('ui', '').strip().lower()

    # Interprets ""small"" and ""style"" parameters for backward compatibility.
    # TODO(ichikawa): Delete these in near future when we decide to drop
    # support of these parameters.
    small_param = request.get('small', '').strip().lower()
    style_param = request.get('style', '').strip().lower()
    if not ui_param and small_param == 'yes':
        ui_param = 'small'
    elif not ui_param and style_param:
        ui_param = style_param

    if ui_param:
        env.ui = ui_param
    elif user_agents.is_jp_tier2_mobile_phone(request):
        env.ui = 'light'
    else:
        env.ui = 'default'

    # UI configurations.
    #
    # Enables features which require JavaScript.
    env.enable_javascript = True
    # Enables operations which requires Captcha.
    env.enable_captcha = True
    # Enables photo upload.
    env.enable_photo_upload = True
    # Enables to flag/unflag notes as spam, and to reveal spam notes.
    env.enable_spam_ops = True
    # Enables duplicate marking mode.
    env.enable_dup_mode = True
    # Shows a logo on top of the page.
    env.show_logo = True
    # Shows language menu.
    env.show_language_menu = True
    # Uses short labels for buttons.
    env.use_short_buttons = False
    # Optional ""target"" attribute for links to non-small pages.
    env.target_attr = ''
    # Shows record IDs in the results page.
    env.show_record_ids_in_results = True
    # Shows non AMP HTML pages by default.
    env.amp = False

    if env.ui == 'small':
        env.show_logo = False
        env.target_attr = ' target=""_blank"" '

    elif env.ui == 'light':
        # Disables features which requires JavaScript. Some feature phones
        # doesn't support JavaScript.
        env.enable_javascript = False
        # Disables operations which requires Captcha because Captcha requires
        # JavaScript.
        env.enable_captcha = False
        # Uploading is often not supported in feature phones.
        env.enable_photo_upload = False
        # Disables spam operations because it requires JavaScript and
        # supporting more pages on ui=light.
        env.enable_spam_ops = False
        # Disables duplicate marking mode because it doesn't support
        # small screens and it requires JavaScript.
        env.enable_dup_mode = False
        # Hides the logo on the top to save the space. Also, the logo links
        # to the global page which doesn't support small screens.
        env.show_logo = False
        # Hides language menu because the menu in the current position is
        # annoying in feature phones.
        # TODO(ichikawa): Consider layout of the language menu.
        env.show_language_menu = False
        # Too long buttons are not fully shown in some feature phones.
        env.use_short_buttons = True
        # To make it simple.
        env.show_record_ids_in_results = False

    env.back_chevron = u'\xab'
    back_chevron_in_charset = True
    try:
        env.back_chevron.encode(env.charset)
    except UnicodeEncodeError:
        # u'\xab' is not in the charset (e.g. Shift_JIS).
        back_chevron_in_charset = False
    if not back_chevron_in_charset or env.ui == 'light':
        # Use ASCII characters on ui=light too because some feature phones
        # support UTF-8 but don't render UTF-8 symbols such as u'\xab'.
        env.back_chevron = u'<<'

    env.enable_maps = (
        env.enable_javascript
        and not env.config.zero_rating_mode
        and env.maps_api_key)
    env.enable_analytics = (
        env.enable_javascript
        and not env.config.zero_rating_mode
        and env.analytics_id)
    env.enable_translate = (
        env.enable_javascript
        and not env.config.zero_rating_mode
        and env.config.translate_api_key)

    # Repo-specific information.
    if env.repo:
        # repo_url is the root URL for the repository.
        env.repo_url = utils.get_repo_url(request, env.repo)
        # start_url is like repo_url but preserves parameters such as 'ui'.
        env.start_url = utils.get_url(request, env.repo, '')
        # URL of the link in the heading. The link on ui=small links to the
        # normal UI.
        env.repo_title_url = (
            env.repo_url if env.ui == 'small' else env.start_url)
        # URL to force default UI. Note that we show ui=light version in some
        # user agents when ui parameter is not specified.
        env.default_ui_url = utils.get_url(request, env.repo, '', ui='default')
        env.repo_path = urlparse.urlsplit(env.repo_url)[2]
        env.repo_title = get_localized_message(
            env.config.repo_titles, env.lang, '?')
        env.start_page_custom_html = get_localized_message(
            env.config.start_page_custom_htmls, env.lang, '')
        env.results_page_custom_html = get_localized_message(
            env.config.results_page_custom_htmls, env.lang, '')
        env.view_page_custom_html = get_localized_message(
            env.config.view_page_custom_htmls, env.lang, '')
        env.seek_query_form_custom_html = get_localized_message(
            env.config.seek_query_form_custom_htmls, env.lang, '')
        env.footer_custom_html = get_localized_message(
            env.config.footer_custom_htmls, env.lang, '')
        # If the repository is deactivated, we should not show test mode
        # notification.
        env.repo_test_mode = (
            env.config.test_mode and not env.config.deactivated)
        env.force_https = env.config.force_https

        env.params_full_name = request.get('full_name', '').strip()
        if not env.params_full_name:
            # Preformat the name from 'given_name' and 'family_name' parameters.
            given_name = request.get('given_name', '').strip()
            family_name = request.get('family_name', '').strip()
            env.params_full_name = utils.get_full_name(
                given_name, family_name, env.config)

    return env

def flush_caches(*keywords):
    """"""Flushes the specified set of caches.  Pass '*' to flush everything.""""""
    if '*' in keywords or 'resource' in keywords:
       resources.clear_caches()
    if '*' in keywords or 'memcache' in keywords:
       memcache.flush_all()
    if '*' in keywords or 'config' in keywords:
       config.cache.flush()
    for keyword in keywords:
        if keyword.startswith('config/'):
            config.cache.delete(keyword[7:])


class Main(webapp.RequestHandler):
    """"""The main request handler.  All dynamic requests except for remote_api are
    handled by this handler, which dispatches to all other dynamic handlers.""""""

    def initialize(self, request, response):
        webapp.RequestHandler.initialize(self, request, response)

        # If requested, set the clock before doing anything clock-related.
        # Only works on localhost for testing.  Specify ?utcnow=1293840000 to
        # set the clock to 2011-01-01, or ?utcnow=real to revert to real time.
        utcnow = request.get('utcnow')
        if request.remote_addr == '127.0.0.1' and utcnow:
            if utcnow == 'real':
                utils.set_utcnow_for_test(None)
            else:
                utils.set_utcnow_for_test(float(utcnow))

        # If requested, flush caches before we touch anything that uses them.
        # This is used for certain tests.
        if utils.is_dev_app_server():
            flush_caches(*request.get('flush', '').split(','))

        # Gather commonly used information into self.env.
        self.env = setup_env(request)

        # Force a redirect if requested, except where https is not supported:
        # - for cron jobs
        # - for task queue jobs
        # - in development
        if (self.env.force_https and self.env.scheme == 'http'
            and not is_cron_task(self.request)
            and not is_task_queue_task(self.request)
            and not is_development_server()):
            self.redirect(self.env.url.replace('http:', 'https:'))

        # Activate the selected language.
        response.headers['Content-Language'] = self.env.lang
        response.headers['Set-Cookie'] = \
            'django_language=%s; path=/' % self.env.lang
        django_setup.activate(self.env.lang)

        # Activate the appropriate resource bundle.
        resources.set_active_bundle_name(self.env.resource_bundle)

    def should_serve_react_ui(self):
        for path_prefix in NON_REACT_UI_PATHS:
            if self.env.action.startswith(path_prefix):
                return False
        return True

    def set_content_security_policy(self):
        """"""Sets the CSP in the headers. Returns the nonce to use for scripts.""""""
        csp_nonce = utils.generate_random_key(20)
        csp_value = (
            'object-src \'none\'; '
            'script-src \'nonce-%s\' \'unsafe-inline\' '
            '\'strict-dynamic\' https: http:; '
            'base-uri \'none\';'
        ) % csp_nonce
        self.response.headers['Content-Security-Policy'] = csp_value
        return csp_nonce

    def serve(self):
        request, response, env = self.request, self.response, self.env

        # If the Person Finder instance has not been initialized yet,
        # prepend to any served page a warning and a link to the admin
        # page where the datastore can be initialized.
        if not env.config.get('initialized'):
            if request.get('operation') == 'setup_datastore':
                setup_pf.setup_datastore()
                self.redirect(env.global_url + '/')
                return
            else:
                get_vars = lambda: {'env': env}
                content = resources.get_rendered('setup_datastore.html', env.lang,
                        (env.repo, env.charset), get_vars)
                response.out.write(content)

        if env.config.get('enable_react_ui'):
            # TODO(nworden): serve static files from /global/static
            if env.repo == 'static':
                self.serve_static_content(self.env.action)
            elif self.should_serve_react_ui():
                csp_nonce = self.set_content_security_policy()
                response.out.write(
                    resources.get_rendered(
                        'react_index.html', env.lang,
                        get_vars=lambda: {'env': env, 'csp_nonce': csp_nonce}))
                return

        if not env.action and not env.repo:
            # A request for the root path ('/'). Renders the home page.
            self.serve_static_content(HOME_ACTION)
        elif env.action in HANDLER_CLASSES:
            # Dispatch to the handler for the specified action.
            module_name, class_name = HANDLER_CLASSES[env.action].split('.')
            handler = getattr(__import__(module_name), class_name)(
                request, response, env)
            getattr(handler, request.method.lower())()  # get() or post()
        elif env.action.endswith('.template'):
            # Don't serve template source code.
            response.set_status(404)
            response.out.write('Not found')
        else:
            self.serve_static_content(self.env.action)

    def serve_static_content(self, resource_name):
        """"""Serve a static page or file in app/resources/static directory.""""""
        response, env = self.response, self.env
        env.robots_ok = True
        get_vars = lambda: {'env': env, 'config': env.config}
        content = resources.get_rendered(
            'static/%s' % resource_name,
            env.lang,
            (env.repo, env.charset),
            get_vars)
        if content is None:
            response.set_status(404)
            response.out.write('Not found')
        else:
            content_type, encoding = mimetypes.guess_type(resource_name)
            response.headers['Content-Type'] = (
                    (content_type or 'text/plain') +
                    ('; charset=%s' % encoding if encoding else ''))
            response.out.write(content)

    def get(self):
        self.serve()

    def post(self):
        self.serve()

    def head(self):
        self.request.method = 'GET'
        self.serve()
        self.response.clear()

if __name__ == '__main__':
    webapp.util.run_wsgi_app(webapp.WSGIApplication([('.*', Main)]))
/n/n/napp/urls.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""URL routing module.""""""

from django.conf import urls

import site_settings
import tasksmodule.deletion
import tasksmodule.sitemap_ping
import views.admin.api_keys
import views.admin.create_repo
import views.admin.delete_record
import views.admin.statistics
import views.meta.sitemap

# We include an optional trailing slash in all the patterns (Django has support
# for automatic redirection, but we don't want to send people redirect responses
# if it's not really needed).
_BASE_URL_PATTERNS = [
    ('admin_apikeys-list', r'(?P<repo>[^\/]+)/admin/api_keys/list/?',
     views.admin.api_keys.ApiKeyListView.as_view),
    ('admin_apikeys-manage', r'(?P<repo>[^\/]+)/admin/api_keys/?',
     views.admin.api_keys.ApiKeyManagementView.as_view),
    ('admin_create-repo', r'global/admin/create_repo/?',
     views.admin.create_repo.AdminCreateRepoView.as_view),
    ('admin_delete-record', r'(?P<repo>[^\/]+)/admin/delete_record/?',
     views.admin.delete_record.AdminDeleteRecordView.as_view),
    ('admin_statistics', r'global/admin/statistics/?',
     views.admin.statistics.AdminStatisticsView.as_view),
    ('meta_sitemap', r'global/sitemap/?',
     views.meta.sitemap.SitemapView.as_view),
    ('tasks_process-expirations',
     r'(?P<repo>[^\/]+)/tasks/process_expirations/?',
     tasksmodule.deletion.ProcessExpirationsTask.as_view),
    ('tasks_cleanup-stray-notes',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_notes/?',
     tasksmodule.deletion.CleanupStrayNotesTask.as_view),
    ('tasks_cleanup-stray-subscriptions',
     r'(?P<repo>[^\/]+)/tasks/cleanup_stray_subscriptions/?',
     tasksmodule.deletion.CleanupStraySubscriptionsTask.as_view),
    ('tasks_sitemap-ping', r'global/tasks/sitemap_ping/?',
     tasksmodule.sitemap_ping.SitemapPingTaskView.as_view),
]

# pylint: disable=invalid-name
# Pylint would prefer that this name be uppercased, but Django's going to look
# for this value in the urls module; it has to be called urlpatterns.
urlpatterns = [
    urls.url('^%s$' % path_exp, view_func(), name=name)
    for (name, path_exp, view_func) in _BASE_URL_PATTERNS
]

if site_settings.OPTIONAL_PATH_PREFIX:
    urlpatterns += [
        urls.url(
            '^%(prefix)s/%(path)s$' % {
                'prefix': site_settings.OPTIONAL_PATH_PREFIX,
                'path': path_exp
            },
            view_func(),
            name='prefixed__%s' % name)
        for (name, path_exp, view_func) in _BASE_URL_PATTERNS
    ]
/n/n/napp/views/admin/delete_record.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""The admin delete-record page.

No deleting is done from this page itself; it's just a way to skip the captcha
on the user-facing deletion page.
""""""

import django.shortcuts

import const
import reveal
import utils
import views.admin.base


class AdminDeleteRecordView(views.admin.base.AdminBaseView):
    """"""The admin delete-record view.""""""

    ACTION_ID = 'admin/delete_record'

    def setup(self, request, *args, **kwargs):
        super(AdminDeleteRecordView, self).setup(request, *args, **kwargs)

    def get_params(self):
        return views.base.read_params(
            super(AdminDeleteRecordView, self).get_params(),
            self.request,
            post_params={'id': utils.strip})

    def get(self, request, *args, **kwargs):
        """"""Serves GET requests with the deletion form.""""""
        del request, args, kwargs  # unused
        return self.render(
            'admin_delete_record.html',
            id='%s/person.' % const.HOME_DOMAIN,
            xsrf_token=self.xsrf_tool.generate_token(self.env.user.user_id(),
                                                     self.ACTION_ID))

    def post(self, request, *args, **kwargs):
        """"""Sends the user to the deletion page with a valid signature.""""""
        del request, args, kwargs  # unused
        self.enforce_xsrf(self.ACTION_ID)
        action = ('delete', self.params.id)
        path = '/delete?' + utils.urlencode(
            {'id': self.params.id,
             'signature': reveal.sign(action),})
        return django.shortcuts.redirect(
            self.build_absolute_uri(path, self.env.repo))
/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""View-related code common to the whole app.""""""

import functools
import re

import django.http
import django.utils.decorators
import django.views

import config
import const
import resources
import site_settings
import utils


class BaseView(django.views.View):
    """"""Base view class shared across the app.""""""

    # This should be overridden by subclasses.
    ACTION_ID = None

    class Env(object):
        """"""Class to store environment information used by views and templates.

        Subclasses of BaseView may define their own Env class (which must be
        subclasses of BaseView.Env); that Env class (as long as it's called
        ""Env"") will be used automatically when the env is set up.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # pylint: disable=too-many-instance-attributes

        @property
        def action(self):
            """"""Gets the action ID, an identifier for the page being served.""""""
            return self._action

        @action.setter
        def action(self, value):
            self._action = value

        @property
        def charset(self):
            """"""Gets the character encoding being used to serve the page.""""""
            return self._charset

        @charset.setter
        def charset(self, value):
            self._charset = value

        @property
        def config(self):
            """"""Gets the config, a config.Config object for the repository.""""""
            return self._config

        @config.setter
        def config(self, value):
            self._config = value

        @property
        def enable_javascript(self):
            ""Gets whether or not to enable JavaScript."" """"
            return self._enable_javascript

        @enable_javascript.setter
        def enable_javascript(self, value):
            self._enable_javascript = value

        @property
        def global_url(self):
            """"""Gets the URL for the global root.""""""
            return self._global_url

        @global_url.setter
        def global_url(self, value):
            self._global_url = value

        @property
        def lang(self):
            """"""Gets the code for the language being used (see const.py).""""""
            return self._lang

        @lang.setter
        def lang(self, value):
            self._lang = value

        @property
        def repo(self):
            """"""Gets the repository ID, or None if it's a global page.""""""
            return self._repo

        @repo.setter
        def repo(self, value):
            self._repo = value

        @property
        def rtl(self):
            """"""Gets whether the language is a right-to-left language.""""""
            return self._rtl

        @rtl.setter
        def rtl(self, value):
            self._rtl = value

        @property
        def show_logo(self):
            """"""Gets whether or not to show the logo in the header.""""""
            return self._show_logo

        @show_logo.setter
        def show_logo(self, value):
            self._show_logo = value

    def setup(self, request, *args, **kwargs):
        """"""Sets up the handler.

        Views aren't passed any request-specific information when they're
        initialized, so you can't really do much in __init__. However, having a
        function that gets called before dispatch is useful for all kinds of
        things (in particular, it's useful to have a top-down function, where
        the parent class functions run before those of subclasses). setup() is
        essentially a substitute for __init__().

        Args:
            request (HttpRequest): The request object.
            *args: Unused.
            **kwargs: Arbitrary keyword arguments. Should include repository ID
                (under the key 'repo') if applicable.
        """"""
        # pylint: disable=attribute-defined-outside-init
        # TODO(nworden): don't forget to call super.setup here once we upgrade
        # to Django 2.2.
        del request, args  # unused

        # Set up the parameters and read in the base set of parameters.
        self.params = self.get_params()

        # Set up env variable with data needed by the whole app.
        self.env = self.Env()
        self.env.repo = kwargs.get('repo', None)
        self.env.action = self.ACTION_ID
        self.env.config = config.Configuration(self.env.repo or '*')
        # Django will make a guess about what language to use, but Django's
        # guess should be overridden by the lang CGI param if it's set.
        # TODO(nworden): figure out how much of the logic below we still need
        # now that Django can do a lot of the work for us.
        lang = self.params.get('lang') or self.request.LANGUAGE_CODE
        lang = re.sub('[^A-Za-z0-9-]', '', lang)
        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)
        if lang in const.LANGUAGE_ENDONYMS.keys():
            self.env.lang = lang
        else:
            self.env.lang = (self.env.config.language_menu_options[0]
                             if self.env.config.language_menu_options else
                             const.DEFAULT_LANGUAGE_CODE)
        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI
        self.env.charset = const.CHARSET_UTF8
        # TODO(nworden): try to eliminate use of global_url. It doesn't seem
        # great that templates are building URLs by sticking things onto this.
        self.env.global_url = self.build_absolute_uri('/global')

    def get_params(self):
        """"""Gets parameter values out of the request.

        Subclasses that need additional values should override this function,
        with an implementation like this:
        return views.base.read_params(
            super(<Subclass>, self).get_params(),
            self.request,
            get_params={'x': validate_x, 'y': validate_y,},
            post_params={'z': validate_z})

        Returns:
            utils.Struct: A container with the values of CGI parameters used by
            this view.
        """"""
        return read_params(
            utils.Struct(), self.request, get_params={'lang': utils.strip})

    def _request_is_for_prefixed_path(self):
        """"""Checks if the request's path uses an optional path prefix.""""""
        if not site_settings.OPTIONAL_PATH_PREFIX:
            return False
        req_path = self.request.path[1:]  # drop the leading slash
        if req_path == site_settings.OPTIONAL_PATH_PREFIX:
            return True
        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)

    def build_absolute_path(self, path=None, repo=None):
        """"""Builds an absolute path, including the path prefix if required.

        Django's HttpRequest objects have a similar function, but we implement
        our own so that we can handle path prefixes correctly when they're in
        use.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.
            repo (str, optional): A repo ID. If specified, the path will be
                considered relative to the repo's route. If this is specified,
                path must also be specified.

        Returns:
            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX
            if it was used with the original request (e.g.,
            '/personfinder/abc?x=y'). Does not preserve query parameters from
            the original request.
        """"""
        if path is None:
            assert not repo
            # request.path will already include the path prefix if it's being
            # used.
            return self.request.path
        assert path[0] == '/'
        if repo:
            path = '/%s%s' % (repo, path)
        if self._request_is_for_prefixed_path():
            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)
        else:
            return path

    def build_absolute_uri(self, path=None, repo=None):
        """"""Builds an absolute URI given a path.

        See build_absolute_path (above) for an explanation of why we implement
        this function ourselves.

        Args:
            path (str, optional): A path beginning with a slash (may include a
                query string), e.g., '/abc?x=y'. If the path argument is not
                specified or is None, the current request's path will be used.
            repo (str, optional): A repo ID. If specified, the path will be
                considered relative to the repo's route. If this is specified,
                path must also be specified.

        Returns:
            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if
            it was used with the original request (e.g.,
            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve
            query parameters from the original request.
        """"""
        return self.request.build_absolute_uri(
            self.build_absolute_path(path, repo))

    def render(self, template_name, status_code=200, **template_vars):
        """"""Renders a template with the given variables.

        Args:
            template_name (str): The filename of the template in app/resources.
            **template_vars: Named variables to pass to the template.

        Returns:
            HttpResponse: An HttpResponse with the rendered template.
        """"""

        def get_vars():
            """"""A function returning vars, for use by the resources module.""""""
            template_vars['env'] = self.env
            # TODO(nworden): change templates to access config through env, which
            # already has the config anyway
            template_vars['config'] = self.env.config
            template_vars['params'] = self.params
            template_vars['csp_nonce'] = self.request.csp_nonce
            return template_vars

        query_str = self.request.META.get('QUERY_STRING', '')
        extra_key = (self.env.repo, self.env.charset, query_str)
        return django.http.HttpResponse(
            resources.get_rendered(template_name, self.env.lang, extra_key,
                                   get_vars, 0),
            status=status_code)

    def error(self, status_code, message=''):
        """"""Returns an error response.

        Args:
            status_code (int): The HTTP status code to use.
            message (str, optional): A message to display. Defaults to the empty
                string.

        Returns:
            HttpResponse: An HTTP response with the given status code and
            message.
        """"""
        # pylint: disable=no-self-use
        # Making this a method of BaseView keeps it consistent with render(),
        # and probably other similar functions in the future.
        return django.http.HttpResponse(
            content=message, content_type='text/plain', status=status_code)

    @django.utils.decorators.classonlymethod
    def as_view(cls, **initkwargs):
        # pylint: disable=E,W,R,C
        # We want to have a setup() function called before dispatch() (see
        # explanation in the comments on the setup() function), and Django 2.2
        # has support for it built in. However, we're not on Django 2.2 yet, so
        # we make the modification to View.as_view() ourselves to get this
        # feature ahead of time (the code below is just a copy of the original
        # Django 1.11 View.as_view function, with the setup() call stuck in). We
        # can clean this up when we upgrade to Django 2.2.
        """"""Main entry point for a request-response process.""""""
        for key in initkwargs:
            if key in cls.http_method_names:
                raise TypeError(""You tried to pass in the %s method name as a ""
                                ""keyword argument to %s(). Don't do that."" %
                                (key, cls.__name__))
            if not hasattr(cls, key):
                raise TypeError(
                    ""%s() received an invalid keyword %r. as_view ""
                    ""only accepts arguments that are already ""
                    ""attributes of the class."" % (cls.__name__, key))

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            self.setup(request, *args, **kwargs)
            return self.dispatch(request, *args, **kwargs)

        view.view_class = cls
        view.view_initkwargs = initkwargs

        # take name and docstring from class
        functools.update_wrapper(view, cls, updated=())

        # and possible attributes set by decorators
        # like csrf_exempt from dispatch
        functools.update_wrapper(view, cls.dispatch, assigned=())
        return view


def read_params(container,
                request,
                get_params=None,
                post_params=None,
                file_params=None):
    """"""Reads CGI parameter values from the request to the container.

    Args:
        container (utils.Struct): The container to put parameter values in.
        request (HttpRequest): The request to read from.
        get_params (dict): A dictionary from GET parameter keys to validator
            functions.
        post_params (dict): A dictionary from POST parameter keys to validator
            functions.
        file_params (dict): A dictionary from POST parameter keys for uploaded
            files to validator functions.

    Returns:
        utils.Struct: The container, for convenience.
    """"""
    if request.method == 'GET':
        if get_params:
            for key, validator in get_params.items():
                if key in request.GET:
                    setattr(container, key, validator(request.GET[key]))
    elif request.method == 'POST':
        if post_params:
            for key, validator in post_params.items():
                if key in request.POST:
                    setattr(container, key, validator(request.POST[key]))
        if file_params:
            for key, validator in file_params.items():
                if key in request.FILES:
                    setattr(container, key, validator(request.FILES[key]))
    return container
/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Access restriction tests.""""""

import os

import django.urls

import urls
import views

import view_tests_base


class AccessRestrictionTests(view_tests_base.ViewTestsBase):
    """"""Tests that access restrictions are enforced.""""""

    # Dictionary from path name to a boolean indicating whether the page should
    # be restricted to admins.
    IS_RESTRICTED_TO_ADMINS = {
        'admin_apikeys-manage': True,
        'admin_apikeys-list': True,
        'admin_create-repo': True,
        'admin_delete-record': True,
        'admin_statistics': True,
        'meta_sitemap': False,
    }

    def get_path(self, path_name):
        # If we ever have URLs with more interesting things in the path besides
        # repo, we'll have to rethink this.
        try:
            return django.urls.reverse(path_name)
        except django.urls.NoReverseMatch:
            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})

    def test_blocked_to_non_admins(self):
        """"""Tests that admin-only pages aren't available to non-admins.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 403
            assert self.client.post(path, secure=True).status_code == 403

    def test_available_to_admins(self):
        """"""Tests that admin-only pages are available to admins.

        This is a sort of meta-test: I'm not really concerned that we might
        accidentally lock admins out of the admin pages, but I do want to make
        sure that the test above actually depends on the user not being an admin
        (as opposed to access getting denied because the tests are set up wrong
        somehow).
        """"""
        self.login(is_admin=True)
        for (path_name, _
            ) in filter(lambda item: item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code == 200
            # Don't test POST requests here; they'll need an XSRF token and
            # that'll be covered in a separate test.

    def test_other_pages_unrestricted(self):
        """"""Tests that non-admins can access unrestricted pages.""""""
        self.login(is_admin=False)
        for (path_name, _
            ) in filter(lambda item: not item[1],
                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):
            path = self.get_path(path_name)
            assert self.client.get(path, secure=True).status_code != 403

    def test_all_paths_included(self):
        """"""Tests that all (Django-served) pages are listed.

        We want to make sure no one forgets to add these tests for admin pages,
        so we require that each URL path is included in the dictionary above.
        """"""
        for pattern in urls.urlpatterns:
            if pattern.name.startswith('prefixed__'):
                # Skip these; they're the same views as the non-prefixed
                # versions.
                continue
            if pattern.name.startswith('tasks_'):
                # Skip task handlers; they'll be tested separately.
                # TODO(nworden): test them
                continue
            assert (
                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)
/n/n/ntests/views/test_admin_delete_record.py/n/n# Copyright 2019 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""""""Tests for the admin delete-record page.""""""

import datetime

import django
import django.http
import django.test
import six.moves.urllib.parse as urlparse

# pylint: disable=wrong-import-order
# pylint sometimes thinks config is a standard import that belongs before the
# django import. It's mistaken; config is our own module (if you run
# python -c ""import config"", it produces an error saying config doesn't exist).
# Filed issue #626 to move us out of the global namespace someday, which would
# prevent stuff like this.
import config
import const
import model

import view_tests_base


class AdminDeleteRecordViewTests(view_tests_base.ViewTestsBase):
    """"""Tests the admin delete-record view.""""""

    def setUp(self):
        super(AdminDeleteRecordViewTests, self).setUp()
        self.login(is_admin=True)
        self.data_generator.repo()
        self.person = self.data_generator.person()

    def test_get(self):
        """"""Tests GET requests.""""""
        res = self.client.get('/global/admin/delete_record/', secure=True)
        self.assertEqual(res.context['id'], '%s/person.' % const.HOME_DOMAIN)

    def test_post(self):
        """"""Tests POST requests to delete a record.""""""
        get_doc = self.to_doc(self.client.get(
            '/global/admin/delete_record/', secure=True))
        xsrf_token = get_doc.cssselect_one('input[name=""xsrf_token""]').get(
            'value')
        post_resp = self.client.post('/haiti/admin/delete_record/', {
            'xsrf_token': xsrf_token,
            'id': self.person.record_id,
        }, secure=True)
        # Check that the user's redirected to the repo's main admin page.
        self.assertIsInstance(post_resp, django.http.HttpResponseRedirect)
        parse = urlparse.urlparse(post_resp.url)
        self.assertEqual('/haiti/delete', parse.path)
        query_params = dict(urlparse.parse_qsl(parse.query))
        self.assertEqual(query_params['id'], self.person.record_id)
        # Check that the signature param is present and not the empty string.
        self.assertTrue(len(query_params['signature']) > 1)
/n/n/n",0
27,27,5bd28a262e274d24cf802ed6051e6880c7033452,"/app/admin_delete_record.py/n/n#!/usr/bin/python2.7
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from const import *
from model import *
from utils import *
import reveal


class Handler(BaseHandler):
    """"""An admin page to delete person records.""""""

    # After a repository is deactivated, we still need the admin page to be
    # accessible so we can edit its settings.
    ignore_deactivation = True

    repo_required = False
    admin_required = True

    def get(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        self.render(
            'admin_delete_record.html',
            id=self.env.domain + '/person.',
            xsrf_token=xsrf_tool.generate_token(
                user.user_id(), 'admin_delete_record'))

    def post(self):
        xsrf_tool = XsrfTool()
        user = users.get_current_user()
        if not (self.params.xsrf_token and xsrf_tool.verify_token(
                    self.params.xsrf_token, user.user_id(),
                    'admin_delete_record')):
            self.error(403)
            return False
        # Redirect to the deletion handler with a valid signature.
        action = ('delete', str(self.params.id))
        self.redirect('/delete', id=self.params.id,
                      signature=reveal.sign(action))
/n/n/n",1
32,32,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"jupyter-5.0-default-jupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/njupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------

## This is an application.

## The date format used by logging formatters for %(asctime)s
#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#c.Application.log_level = 30

#------------------------------------------------------------------------------
# JupyterApp(Application) configuration
#------------------------------------------------------------------------------

## Base class for Jupyter applications

## Answer yes to any prompts.
#c.JupyterApp.answer_yes = False

## Full path of a config file.
#c.JupyterApp.config_file = ''

## Specify a config file to load.
#c.JupyterApp.config_file_name = ''

## Generate default config file.
#c.JupyterApp.generate_config = False

#------------------------------------------------------------------------------
# NotebookApp(JupyterApp) configuration
#------------------------------------------------------------------------------

## Set the Access-Control-Allow-Credentials: true header
#c.NotebookApp.allow_credentials = False

## Set the Access-Control-Allow-Origin header
#  
#  Use '*' to allow any origin to access your server.
#  
#  Takes precedence over allow_origin_pat.
#c.NotebookApp.allow_origin = ''

## Use a regular expression for the Access-Control-Allow-Origin header
#  
#  Requests from an origin matching the expression will get replies with:
#  
#      Access-Control-Allow-Origin: origin
#  
#  where `origin` is the origin of the request.
#  
#  Ignored if allow_origin is set.
#c.NotebookApp.allow_origin_pat = ''

## Whether to allow the user to run the notebook as root.
#c.NotebookApp.allow_root = False

## DEPRECATED use base_url
#c.NotebookApp.base_project_url = '/'

## The base URL for the notebook server.
#  
#  Leading and trailing slashes can be omitted, and will automatically be added.
#c.NotebookApp.base_url = '/'

## Specify what command to use to invoke a web browser when opening the notebook.
#  If not specified, the default browser will be determined by the `webbrowser`
#  standard library module, which allows setting of the BROWSER environment
#  variable to override it.
#c.NotebookApp.browser = ''

## The full path to an SSL/TLS certificate file.
#c.NotebookApp.certfile = ''

## The full path to a certificate authority certificate for SSL/TLS client
#  authentication.
#c.NotebookApp.client_ca = ''

## The config manager class to use
#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'

## The notebook manager class to use.
#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'

## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's
#  set_secure_cookie docs for details.
#c.NotebookApp.cookie_options = {}

## The random bytes used to secure cookies. By default this is a new random
#  number every time you start the Notebook. Set it to a value in a config file
#  to enable logins to persist across server sessions.
#  
#  Note: Cookie secrets should be kept private, do not share config files with
#  cookie_secret stored in plaintext (you can read the value from a file).
#c.NotebookApp.cookie_secret = b''

## The file where the cookie secret is stored.
#c.NotebookApp.cookie_secret_file = ''

## The default URL to redirect to from `/`
#c.NotebookApp.default_url = '/tree'

## Disable cross-site-request-forgery protection
#  
#  Jupyter notebook 4.3.1 introduces protection from cross-site request
#  forgeries, requiring API requests to either:
#  
#  - originate from pages served by this server (validated with XSRF cookie and
#  token), or - authenticate with a token
#  
#  Some anonymous compute resources still desire the ability to run code,
#  completely without authentication. These services can disable all
#  authentication and security checks, with the full knowledge of what that
#  implies.
#c.NotebookApp.disable_check_xsrf = False

## Whether to enable MathJax for typesetting math/TeX
#  
#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is
#  very large, so you may want to disable it if you have a slow internet
#  connection, or for offline use of the notebook.
#  
#  When disabled, equations etc. will appear as their untransformed TeX source.
#c.NotebookApp.enable_mathjax = True

## extra paths to look for Javascript notebook extensions
#c.NotebookApp.extra_nbextensions_path = []

## Extra paths to search for serving static files.
#  
#  This allows adding javascript/css to be available from the notebook server
#  machine, or overriding individual files in the IPython
#c.NotebookApp.extra_static_paths = []

## Extra paths to search for serving jinja templates.
#  
#  Can be used to override templates from notebook.templates.
#c.NotebookApp.extra_template_paths = []

## 
#c.NotebookApp.file_to_run = ''

## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS
#  recompilation
#c.NotebookApp.ignore_minified_js = False

## (bytes/sec) Maximum rate at which messages can be sent on iopub before they
#  are limited.
#c.NotebookApp.iopub_data_rate_limit = 1000000

## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are
#  limited.
#c.NotebookApp.iopub_msg_rate_limit = 1000

## The IP address the notebook server will listen on.
#c.NotebookApp.ip = 'localhost'

## Supply extra arguments that will be passed to Jinja environment.
#c.NotebookApp.jinja_environment_options = {}

## Extra variables to supply to jinja templates when rendering.
#c.NotebookApp.jinja_template_vars = {}

## The kernel manager class to use.
#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'

## The kernel spec manager class to use. Should be a subclass of
#  `jupyter_client.kernelspec.KernelSpecManager`.
#  
#  The Api of KernelSpecManager is provisional and might change without warning
#  between this version of Jupyter and the next stable one.
#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'

## The full path to a private key file for usage with SSL/TLS.
#c.NotebookApp.keyfile = ''

## The login handler class to use.
#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'

## The logout handler class to use.
#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'

## The MathJax.js configuration file that is to be used.
#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'

## A custom url for MathJax.js. Should be in the form of a case-sensitive url to
#  MathJax, for example:  /static/components/MathJax/MathJax.js
#c.NotebookApp.mathjax_url = ''

## Dict of Python modules to load as notebook server extensions.Entry values can
#  be used to enable and disable the loading ofthe extensions. The extensions
#  will be loaded in alphabetical order.
#c.NotebookApp.nbserver_extensions = {}

## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = ''

## Whether to open in a browser after starting. The specific browser used is
#  platform dependent and determined by the python standard library `webbrowser`
#  module, unless it is overridden using the --browser (NotebookApp.browser)
#  configuration option.
#c.NotebookApp.open_browser = True

## Hashed password to use for web authentication.
#  
#  To generate, type in a python/IPython shell:
#  
#    from notebook.auth import passwd; passwd()
#  
#  The string should be of the form type:salt:hashed-password.
#c.NotebookApp.password = ''

## Forces users to use a password for the Notebook server. This is useful in a
#  multi user environment, for instance when everybody in the LAN can access each
#  other's machine though ssh.
#  
#  In such a case, server the notebook server on localhost is not secure since
#  any user can connect to the notebook server via ssh.
#c.NotebookApp.password_required = False

## The port the notebook server will listen on.
#c.NotebookApp.port = 8888

## The number of additional ports to try if the specified port is not available.
#c.NotebookApp.port_retries = 50

## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.
#c.NotebookApp.pylab = 'disabled'

## (sec) Time window used to  check the message and data rate limits.
#c.NotebookApp.rate_limit_window = 3

## Reraise exceptions encountered loading server extensions?
#c.NotebookApp.reraise_server_extension_failures = False

## DEPRECATED use the nbserver_extensions dict instead
#c.NotebookApp.server_extensions = []

## The session manager class to use.
#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'

## Supply SSL options for the tornado HTTPServer. See the tornado docs for
#  details.
#c.NotebookApp.ssl_options = {}

## Supply overrides for terminado. Currently only supports ""shell_command"".
#c.NotebookApp.terminado_settings = {}

## Token used for authenticating first-time connections to the server.
#  
#  When no password is enabled, the default is to generate a new, random token.
#  
#  Setting to an empty string disables authentication altogether, which is NOT
#  RECOMMENDED.
#c.NotebookApp.token = '<generated>'

## Supply overrides for the tornado.web.Application that the Jupyter notebook
#  uses.
#c.NotebookApp.tornado_settings = {}

## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-
#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles
#  SSL
#c.NotebookApp.trust_xheaders = False

## DEPRECATED, use tornado_settings
#c.NotebookApp.webapp_settings = {}

## The base URL for websockets, if it differs from the HTTP server (hint: it
#  almost certainly doesn't).
#  
#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]
#c.NotebookApp.websocket_url = ''

#------------------------------------------------------------------------------
# ConnectionFileMixin(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Mixin for configurable classes that work with connection files

## JSON file in which to store connection info [default: kernel-<pid>.json]
#  
#  This file will contain the IP, ports, and authentication key needed to connect
#  clients to this kernel. By default, this file will be created in the security
#  dir of the current profile, but can be specified by absolute path.
#c.ConnectionFileMixin.connection_file = ''

## set the control (ROUTER) port [default: random]
#c.ConnectionFileMixin.control_port = 0

## set the heartbeat port [default: random]
#c.ConnectionFileMixin.hb_port = 0

## set the iopub (PUB) port [default: random]
#c.ConnectionFileMixin.iopub_port = 0

## Set the kernel's IP address [default localhost]. If the IP address is
#  something other than localhost, then Consoles on other machines will be able
#  to connect to the Kernel, so be careful!
#c.ConnectionFileMixin.ip = ''

## set the shell (ROUTER) port [default: random]
#c.ConnectionFileMixin.shell_port = 0

## set the stdin (ROUTER) port [default: random]
#c.ConnectionFileMixin.stdin_port = 0

## 
#c.ConnectionFileMixin.transport = 'tcp'

#------------------------------------------------------------------------------
# KernelManager(ConnectionFileMixin) configuration
#------------------------------------------------------------------------------

## Manages a single kernel in a subprocess on this host.
#  
#  This version starts kernels with Popen.

## Should we autorestart the kernel if it dies.
#c.KernelManager.autorestart = True

## DEPRECATED: Use kernel_name instead.
#  
#  The Popen Command to launch the kernel. Override this if you have a custom
#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not
#  pass any arguments to the kernel, because it cannot make any assumptions about
#  the arguments that the kernel understands. In particular, this means that the
#  kernel does not receive the option --debug if it given on the Jupyter command
#  line.
#c.KernelManager.kernel_cmd = []

## Time to wait for a kernel to terminate before killing it, in seconds.
#c.KernelManager.shutdown_wait_time = 5.0

#------------------------------------------------------------------------------
# Session(Configurable) configuration
#------------------------------------------------------------------------------

## Object for handling serialization and sending of messages.
#  
#  The Session object handles building messages and sending them with ZMQ sockets
#  or ZMQStream objects.  Objects can communicate with each other over the
#  network via Session objects, and only need to work with the dict-based IPython
#  message spec. The Session will handle serialization/deserialization, security,
#  and metadata.
#  
#  Sessions support configurable serialization via packer/unpacker traits, and
#  signing with HMAC digests via the key/keyfile traits.
#  
#  Parameters ----------
#  
#  debug : bool
#      whether to trigger extra debugging statements
#  packer/unpacker : str : 'json', 'pickle' or import_string
#      importstrings for methods to serialize message parts.  If just
#      'json' or 'pickle', predefined JSON and pickle packers will be used.
#      Otherwise, the entire importstring must be used.
#  
#      The functions must accept at least valid JSON input, and output *bytes*.
#  
#      For example, to use msgpack:
#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'
#  pack/unpack : callables
#      You can also set the pack/unpack callables for serialization directly.
#  session : bytes
#      the ID of this Session object.  The default is to generate a new UUID.
#  username : unicode
#      username added to message headers.  The default is to ask the OS.
#  key : bytes
#      The key used to initialize an HMAC signature.  If unset, messages
#      will not be signed or checked.
#  keyfile : filepath
#      The file containing a key.  If this is set, `key` will be initialized
#      to the contents of the file.

## Threshold (in bytes) beyond which an object's buffer should be extracted to
#  avoid pickling.
#c.Session.buffer_threshold = 1024

## Whether to check PID to protect against calls after fork.
#  
#  This check can be disabled if fork-safety is handled elsewhere.
#c.Session.check_pid = True

## Threshold (in bytes) beyond which a buffer should be sent without copying.
#c.Session.copy_threshold = 65536

## Debug output in the Session
#c.Session.debug = False

## The maximum number of digests to remember.
#  
#  The digest history will be culled when it exceeds this value.
#c.Session.digest_history_size = 65536

## The maximum number of items for a container to be introspected for custom
#  serialization. Containers larger than this are pickled outright.
#c.Session.item_threshold = 64

## execution key, for signing messages.
#c.Session.key = b''

## path to file containing execution key.
#c.Session.keyfile = ''

## Metadata dictionary, which serves as the default top-level metadata dict for
#  each message.
#c.Session.metadata = {}

## The name of the packer for serializing messages. Should be one of 'json',
#  'pickle', or an import name for a custom callable serializer.
#c.Session.packer = 'json'

## The UUID identifying this session.
#c.Session.session = ''

## The digest scheme used to construct the message signatures. Must have the form
#  'hmac-HASH'.
#c.Session.signature_scheme = 'hmac-sha256'

## The name of the unpacker for unserializing messages. Only used with custom
#  functions for `packer`.
#c.Session.unpacker = 'json'

## Username for the Session. Default is your system username.
#c.Session.username = 'username'

#------------------------------------------------------------------------------
# MultiKernelManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for managing multiple kernels.

## The name of the default kernel to start
#c.MultiKernelManager.default_kernel_name = 'python3'

## The kernel manager class.  This is configurable to allow subclassing of the
#  KernelManager for customized behavior.
#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'

#------------------------------------------------------------------------------
# MappingKernelManager(MultiKernelManager) configuration
#------------------------------------------------------------------------------

## A KernelManager that handles notebook mapping and HTTP error handling

## 
#c.MappingKernelManager.root_dir = ''

#------------------------------------------------------------------------------
# ContentsManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## Base class for serving files and directories.
#  
#  This serves any text or binary file, as well as directories, with special
#  handling for JSON notebook documents.
#  
#  Most APIs take a path argument, which is always an API-style unicode path, and
#  always refers to a directory.
#  
#  - unicode, not url-escaped
#  - '/'-separated
#  - leading and trailing '/' will be stripped
#  - if unspecified, path defaults to '',
#    indicating the root path.

## 
#c.ContentsManager.checkpoints = None

## 
#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'

## 
#c.ContentsManager.checkpoints_kwargs = {}

## Glob patterns to hide in file and directory listings.
#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']

## Python callable or importstring thereof
#  
#  To be called on a contents model prior to save.
#  
#  This can be used to process the structure, such as removing notebook outputs
#  or other side effects that should not be saved.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(path=path, model=model, contents_manager=self)
#  
#  - model: the model to be saved. Includes file contents.
#    Modifying this dict will affect the file that is stored.
#  - path: the API path of the save destination
#  - contents_manager: this ContentsManager instance
#c.ContentsManager.pre_save_hook = None

## 
#c.ContentsManager.root_dir = '/'

## The base name used when creating untitled directories.
#c.ContentsManager.untitled_directory = 'Untitled Folder'

## The base name used when creating untitled files.
#c.ContentsManager.untitled_file = 'untitled'

## The base name used when creating untitled notebooks.
#c.ContentsManager.untitled_notebook = 'Untitled'

#------------------------------------------------------------------------------
# FileManagerMixin(Configurable) configuration
#------------------------------------------------------------------------------

## Mixin for ContentsAPI classes that interact with the filesystem.
#  
#  Provides facilities for reading, writing, and copying both notebooks and
#  generic files.
#  
#  Shared by FileContentsManager and FileCheckpoints.
#  
#  Note ---- Classes using this mixin must provide the following attributes:
#  
#  root_dir : unicode
#      A directory against against which API-style paths are to be resolved.
#  
#  log : logging.Logger

## By default notebooks are saved on disk on a temporary file and then if
#  succefully written, it replaces the old ones. This procedure, namely
#  'atomic_writing', causes some bugs on file system whitout operation order
#  enforcement (like some networked fs). If set to False, the new notebook is
#  written directly on the old one which could fail (eg: full filesystem or quota
#  )
#c.FileManagerMixin.use_atomic_writing = True

#------------------------------------------------------------------------------
# FileContentsManager(FileManagerMixin,ContentsManager) configuration
#------------------------------------------------------------------------------

## Python callable or importstring thereof
#  
#  to be called on the path of a file just saved.
#  
#  This can be used to process the file on disk, such as converting the notebook
#  to a script or HTML via nbconvert.
#  
#  It will be called as (all arguments passed by keyword)::
#  
#      hook(os_path=os_path, model=model, contents_manager=instance)
#  
#  - path: the filesystem path to the file just written - model: the model
#  representing the file - contents_manager: this ContentsManager instance
#c.FileContentsManager.post_save_hook = None

## 
#c.FileContentsManager.root_dir = ''

## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0
#c.FileContentsManager.save_script = False

#------------------------------------------------------------------------------
# NotebookNotary(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## A class for computing and verifying notebook signatures.

## The hashing algorithm used to sign notebooks.
#c.NotebookNotary.algorithm = 'sha256'

## The sqlite file in which to store notebook signatures. By default, this will
#  be in your Jupyter data directory. You can set it to ':memory:' to disable
#  sqlite writing to the filesystem.
#c.NotebookNotary.db_file = ''

## The secret key with which notebooks are signed.
#c.NotebookNotary.secret = b''

## The file where the secret key is stored.
#c.NotebookNotary.secret_file = ''

## A callable returning the storage backend for notebook signatures. The default
#  uses an SQLite database.
#c.NotebookNotary.store_factory = traitlets.Undefined

#------------------------------------------------------------------------------
# KernelSpecManager(LoggingConfigurable) configuration
#------------------------------------------------------------------------------

## If there is no Python kernelspec registered and the IPython kernel is
#  available, ensure it is added to the spec list.
#c.KernelSpecManager.ensure_native_kernel = True

## The kernel spec class.  This is configurable to allow subclassing of the
#  KernelSpecManager for customized behavior.
#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'

## Whitelist of allowed kernel names.
#  
#  By default, all installed kernels are allowed.
#c.KernelSpecManager.whitelist = set()
/n/n/n",0
33,33,3fc5e147bdb8bfea24b62927f59fd09036346ef9,"/jupyter_notebook_config.py/n/n# Copyright (c) Jupyter Development Team.
from jupyter_core.paths import jupyter_data_dir
import subprocess
import os

PEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')

c = get_config()
c.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'
c.NotebookApp.port = int(os.getenv('PORT', '') or 8888)
c.NotebookApp.open_browser = False

# Set a certificate if USE_HTTPS is set to any value
if 'USE_HTTPS' in os.environ:
    if not os.path.isfile(PEM_FILE):
        # Generate a certificate if one doesn't exist on disk
        subprocess.check_call(['openssl', 'req', '-new', 
            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',
            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',
            '-keyout', PEM_FILE, '-out', PEM_FILE])
    c.NotebookApp.certfile = PEM_FILE

# Set a password if PASSWORD is set
if 'PASSWORD' in os.environ:
    from IPython.lib import passwd
    c.NotebookApp.password = passwd(os.environ['PASSWORD'])
    del os.environ['PASSWORD']
/n/n/n",1
46,46,9573bdca55ddc5488066d3af525e41ed1d872ea6,"service/pixelated/resources/__init__.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import json

from twisted.web.http import UNAUTHORIZED
from twisted.web.resource import Resource

# from pixelated.resources.login_resource import LoginResource
from pixelated.resources.session import IPixelatedSession
from pixelated.support import log_time


class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return super(SetEncoder, self).default(obj)


def respond_json(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    return json_response


@log_time
def respond_json_deferred(entity, request, status_code=200):
    json_response = json.dumps(entity, cls=SetEncoder)
    request.responseHeaders.addRawHeader(b""content-type"", b""application/json"")
    request.code = status_code
    request.write(json_response)
    request.finish()


class BaseResource(Resource):

    def __init__(self, services_factory):
        Resource.__init__(self)
        self._services_factory = services_factory

    def _get_user_id_from_request(self, request):
        if self._services_factory.mode.is_single_user:
            return None  # it doesn't matter
        session = self.get_session(request)
        if session.is_logged_in():
            return session.user_uuid
        raise ValueError('Not logged in')

    def is_logged_in(self, request):
        session = self.get_session(request)
        return session.is_logged_in() and self._services_factory.is_logged_in(session.user_uuid)

    def get_session(self, request):
        return IPixelatedSession(request.getSession())

    def _services(self, request):
        user_id = self._get_user_id_from_request(request)
        return self._services_factory.services(user_id)

    def _service(self, request, attribute):
        return getattr(self._services(request), attribute)

    def keymanager(self, request):
        return self._service(request, 'keymanager')

    def mail_service(self, request):
        return self._service(request, 'mail_service')

    def search_engine(self, request):
        return self._service(request, 'search_engine')

    def draft_service(self, request):
        return self._service(request, 'draft_service')

    def feedback_service(self, request):
        return self._service(request, 'feedback_service')


class UnAuthorizedResource(Resource):

    def __init__(self):
        Resource.__init__(self)

    def render_GET(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""

    def render_POST(self, request):
        request.setResponseCode(UNAUTHORIZED)
        return ""Unauthorized!""
/n/n/nservice/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.python.filepath import FilePath
from twisted.web import util
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/nservice/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import hashlib
import json
import os
from string import Template

from pixelated.resources import BaseResource, UnAuthorizedResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.static import File

CSRF_TOKEN_LENGTH = 32

MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):
    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self.child_resources = ChildResourcesMap()
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        if self._is_xsrf_valid(request):
            return self.child_resources.get(path)
        return UnAuthorizedResource()

    def _is_xsrf_valid(self, request):
        xsrf_token = request.getCookie('XSRF-TOKEN')

        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')
        if ajax_request:
            xsrf_header = request.getHeader('x-xsrf-token')
            return xsrf_header and xsrf_header == xsrf_token

        get_request = (request.method == 'GET')
        if get_request:
            return True

        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]
        return csrf_input and csrf_input == xsrf_token

    def initialize(self, portal=None, disclaimer_banner=None):
        self.child_resources.add('assets', File(self._static_folder))
        self.child_resources.add('keys', KeysResource(self._services_factory))
        self.child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.child_resources.add('contacts', ContactsResource(self._services_factory))
        self.child_resources.add('features', FeaturesResource(portal))
        self.child_resources.add('tags', TagsResource(self._services_factory))
        self.child_resources.add('mails', MailsResource(self._services_factory))
        self.child_resources.add('mail', MailResource(self._services_factory))
        self.child_resources.add('feedback', FeedbackResource(self._services_factory))
        self.child_resources.add('user-settings', UserSettingsResource(self._services_factory))
        self.child_resources.add(LoginResource.BASE_URL,
                                 LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def _add_csrf_cookie(self, request):
        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()
        request.addCookie('XSRF-TOKEN', csrf_token)

    def render_GET(self, request):
        self._add_csrf_cookie(request)
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)


class ChildResourcesMap(object):
    def __init__(self):
        self._registry = {}

    def add(self, path, resource):
        self._registry[path] = resource

    def get(self, path):
        return self._registry.get(path)
/n/n/nservice/test/integration/test_retrieve_attachment.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import base64
import json
from email import encoders
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from poster.encode import multipart_encode, MultipartParam
from twisted.internet import defer

from test.support.integration.soledad_test_base import SoledadTestBase


class RetrieveAttachmentTest(SoledadTestBase):
    @defer.inlineCallbacks
    def test_attachment_content_is_retrieved(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename, content_type=expected_content_type)

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    @defer.inlineCallbacks
    def test_should_retrieve_attachment_even_if_xsrf_token_not_passed(self):
        attachment_id, input_mail = self._create_mail_with_attachment()
        yield self.mail_store.add_mail('INBOX', input_mail.as_string())

        requested_filename = ""file name with space""
        expected_content_type = 'text/plain'
        expected_content_disposition = 'attachment; filename=""file name with space""'

        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename,
                                                    content_type=expected_content_type, ajax=False, csrf='mismatched token')

        self.assertEqual(200, req.code)
        self.assertEquals('pretend to be binary attachment data', attachment)
        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])
        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])

    def _create_mail_with_attachment(self):
        input_mail = MIMEMultipart()
        input_mail.attach(MIMEText(u'a utf8 message', _charset='utf-8'))
        attachment = MIMEApplication('pretend to be binary attachment data')
        attachment.add_header('Content-Disposition', 'attachment', filename='file name.txt')
        attachment.add_header('Content-Type', 'text/plain')
        input_mail.attach(attachment)
        attachment_id = 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A'
        return attachment_id, input_mail

    @defer.inlineCallbacks
    def test_attachment_error_returned_if_id_not_found(self):
        attachment, req = yield self.get_attachment('invalid attachment id', 'base64')

        self.assertEqual(404, req.code)
        self.assertIsNone(attachment)

    @defer.inlineCallbacks
    def test_post_new_attachment(self):
        content_type = 'text/plain'
        filename = 'filename.txt'
        data = 'pretend to be binary attachment data'
        file = MultipartParam('attachment', value=data, filename=filename, filetype=content_type)
        datagen, headers = multipart_encode([file])
        post_data = """".join(datagen)

        _, req = yield self.post_attachment(post_data, headers)

        self.assertEqual(201, req.code)
        self.assertEqual('/attachment/B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A', req.headers['Location'])
        response_json = {'ident': 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A',
                         'content-type': content_type,
                         'name': filename,
                         'size': len(data),
                         'encoding': 'base64'}
        self.assertEqual(response_json, json.loads(req.written[0]))
/n/n/nservice/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):
        request = request_mock(path, ajax=ajax, csrf=csrf)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None, ajax=True, csrf='token'):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers, ajax=ajax, csrf=csrf)
        return self._render(request)

    def put(self, path, body, ajax=True, csrf='token'):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)
        return self._render(request)

    def delete(self, path, body="""", ajax=True, csrf='token'):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"", ajax=ajax, csrf=csrf)
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False, ajax=ajax, csrf=csrf)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/nservice/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None
        self.cookies = {}

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)

    def addCookie(self, key, value):
        self.cookies[key] = value

    def getCookie(self, key):
        return self.cookies.get(key)


def request_mock(path='', method='GET', body='', headers={}, ajax=True, csrf='token'):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)
    if ajax:
        dummy.headers['x-requested-with'] = 'XMLHttpRequest'
        dummy.headers['x-xsrf-token'] = csrf
        dummy.addCookie('XSRF-TOKEN', csrf)

    return dummy
/n/n/nservice/test/unit/resources/test_root_resource.py/n/nimport unittest
import re

from mock import MagicMock, patch
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource, MODE_STARTUP, MODE_RUNNING


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)
        self.root_resource = root_resource

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])
        request.addCookie = lambda key, value: 'stubbed'

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d

    def _test_should_renew_xsrf_cookie(self):
        request = DummyRequest([''])
        request.addCookie = MagicMock()
        generated_csrf_token = 'csrf_token'
        mock_sha = MagicMock()
        mock_sha.hexdigest = MagicMock(return_value=generated_csrf_token)

        with patch('hashlib.sha256', return_value=mock_sha):
            d = self.web.get(request)

        def assert_csrf_cookie(_):
            request.addCookie.assert_called_once_with('XSRF-TOKEN', generated_csrf_token)

        d.addCallback(assert_csrf_cookie)
        return d

    def test_should_renew_xsrf_cookie_on_startup_mode(self):
        self.root_resource._mode = MODE_STARTUP
        self._test_should_renew_xsrf_cookie()

    def test_should_renew_xsrf_cookie_on_running_mode(self):
        self.root_resource._mode = MODE_RUNNING
        self._test_should_renew_xsrf_cookie()

    def _mock_ajax_csrf(self, request, csrf_token):
        request.headers['x-requested-with'] = 'XMLHttpRequest'
        request.headers['x-xsrf-token'] = csrf_token

    def test_should_unauthorize_child_resource_ajax_requests_when_csrf_mismatch(self):
        request = DummyRequest(['/child'])
        self._mock_ajax_csrf(request, 'stubbed csrf token')

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d

    def test_should_authorize_child_resource_non_ajax_GET_requests(self):
        request = DummyRequest(['features'])

        request.getCookie = MagicMock(return_value='irrelevant -- stubbed')
        self.root_resource.initialize()

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(200, request.code)

        d.addCallback(assert_unauthorized)
        return d

    def test_should_unauthorize_child_resource_non_ajax_POST_requests_when_csrf_input_mismatch(self):
        request = DummyRequest(['mails'])
        request.method = 'POST'
        request.addArg('csrftoken', 'some csrf token')
        mock_content = MagicMock()
        mock_content.read = MagicMock(return_value={})
        request.content = mock_content

        request.getCookie = MagicMock(return_value='mismatched csrf token')

        d = self.web.get(request)

        def assert_unauthorized(_):
            self.assertEqual(401, request.responseCode)
            self.assertEqual(""Unauthorized!"", request.written[0])

        d.addCallback(assert_unauthorized)
        return d
/n/n/n",0
47,47,9573bdca55ddc5488066d3af525e41ed1d872ea6,"/service/pixelated/resources/login_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import logging
import os
from xml.sax import SAXParseException

from twisted.cred import credentials
from twisted.internet import defer
from twisted.web import util
from twisted.web.error import FlattenerError
from twisted.web.http import UNAUTHORIZED, OK
from twisted.web.resource import IResource, NoResource
from twisted.web.server import NOT_DONE_YET
from twisted.web.static import File
from twisted.web.template import Element, XMLFile, renderElement, renderer
from twisted.python.filepath import FilePath

from pixelated.adapter.welcome_mail import add_welcome_mail
from pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession

log = logging.getLogger(__name__)


def _get_startup_folder():
    path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(path, '..', 'assets')


def _get_static_folder():
    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
    # this is a workaround for packaging
    if not os.path.exists(static_folder):
        static_folder = os.path.abspath(
            os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
    if not os.path.exists(static_folder):
        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
    return static_folder


class DisclaimerElement(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))

    def __init__(self, banner):
        super(DisclaimerElement, self).__init__()
        self._set_loader(banner)
        self._banner_filename = banner or ""_login_disclaimer_banner.html""

    def _set_loader(self, banner):
        if banner:
            current_path = os.path.dirname(os.path.abspath(__file__))
            banner_file_path = os.path.join(current_path, "".."", "".."", "".."", banner)
            self.loader = XMLFile(FilePath(banner_file_path))

    def render(self, request):
        try:
            return super(DisclaimerElement, self).render(request)
        except SAXParseException:
            return [""Invalid XML template format for %s."" % self._banner_filename]
        except IOError:
            return [""Disclaimer banner file %s could not be read or does not exit."" % self._banner_filename]


class LoginWebSite(Element):
    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))

    def __init__(self, error_msg=None, disclaimer_banner_file=None):
        super(LoginWebSite, self).__init__()
        self._error_msg = error_msg
        self.disclaimer_banner_file = disclaimer_banner_file

    @renderer
    def error_msg(self, request, tag):
        if self._error_msg is not None:
            return tag(self._error_msg)
        return tag('')

    @renderer
    def disclaimer(self, request, tag):
        return DisclaimerElement(self.disclaimer_banner_file).render(request)


class LoginResource(BaseResource):
    BASE_URL = 'login'

    def __init__(self, services_factory, portal=None, disclaimer_banner=None):
        BaseResource.__init__(self, services_factory)
        self._static_folder = _get_static_folder()
        self._startup_folder = _get_startup_folder()
        self._portal = portal
        self._disclaimer_banner = disclaimer_banner
        self.putChild('startup-assets', File(self._startup_folder))

    def set_portal(self, portal):
        self._portal = portal

    def getChild(self, path, request):
        if path == '':
            return self
        if path == 'login':
            return self
        if not self.is_logged_in(request):
            return UnAuthorizedResource()
        return NoResource()

    def render_GET(self, request):
        request.setResponseCode(OK)
        return self._render_template(request)

    def _render_template(self, request, error_msg=None):
        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)
        return renderElement(request, site)

    def render_POST(self, request):
        if self.is_logged_in(request):
            return util.redirectTo(""/"", request)

        def render_response(leap_session):
            request.setResponseCode(OK)
            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())
            request.finish()
            self._setup_user_services(leap_session, request)

        def render_error(error):
            log.info('Login Error for %s' % request.args['username'][0])
            log.info('%s' % error)
            request.setResponseCode(UNAUTHORIZED)
            return self._render_template(request, 'Invalid credentials')

        d = self._handle_login(request)
        d.addCallbacks(render_response, render_error)

        return NOT_DONE_YET

    @defer.inlineCallbacks
    def _handle_login(self, request):
        self.creds = self._get_creds_from(request)
        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)
        defer.returnValue(leap_session)

    def _get_creds_from(self, request):
        username = request.args['username'][0]
        password = request.args['password'][0]
        return credentials.UsernamePassword(username, password)

    @defer.inlineCallbacks
    def _setup_user_services(self, leap_session, request):
        user_id = leap_session.user_auth.uuid
        if not self._services_factory.is_logged_in(user_id):
            yield self._services_factory.create_services_from(leap_session)
        self._init_http_session(request, user_id)

    @defer.inlineCallbacks
    def _initialize_services(self, leap_session):
        yield self._services_factory.create_services_from(leap_session)

        if leap_session.fresh_account:
            yield add_welcome_mail(leap_session.mail_store)

    def _init_http_session(self, request, user_id):
        session = IPixelatedSession(request.getSession())
        session.user_uuid = user_id
/n/n/n/service/pixelated/resources/root_resource.py/n/n#
# Copyright (c) 2016 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.

import os
from string import Template

from pixelated.resources import BaseResource
from pixelated.resources.attachments_resource import AttachmentsResource
from pixelated.resources.contacts_resource import ContactsResource
from pixelated.resources.features_resource import FeaturesResource
from pixelated.resources.feedback_resource import FeedbackResource
from pixelated.resources.login_resource import LoginResource
from pixelated.resources.logout_resource import LogoutResource
from pixelated.resources.user_settings_resource import UserSettingsResource
from pixelated.resources.mail_resource import MailResource
from pixelated.resources.mails_resource import MailsResource
from pixelated.resources.tags_resource import TagsResource
from pixelated.resources.keys_resource import KeysResource
from twisted.web.resource import Resource
from twisted.web.static import File


MODE_STARTUP = 1
MODE_RUNNING = 2


class RootResource(BaseResource):

    def __init__(self, services_factory):
        BaseResource.__init__(self, services_factory)
        self._startup_assets_folder = self._get_startup_folder()
        self._static_folder = self._get_static_folder()
        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()
        self._services_factory = services_factory
        self._startup_mode()

    def _startup_mode(self):
        self.putChild('startup-assets', File(self._startup_assets_folder))
        self._mode = MODE_STARTUP

    def getChild(self, path, request):
        if path == '':
            return self
        return Resource.getChild(self, path, request)

    def initialize(self, portal=None, disclaimer_banner=None):
        self.putChild('assets', File(self._static_folder))
        self.putChild('keys', KeysResource(self._services_factory))
        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))
        self.putChild('contacts', ContactsResource(self._services_factory))
        self.putChild('features', FeaturesResource(portal))
        self.putChild('tags', TagsResource(self._services_factory))
        self.putChild('mails', MailsResource(self._services_factory))
        self.putChild('mail', MailResource(self._services_factory))
        self.putChild('feedback', FeedbackResource(self._services_factory))
        self.putChild('user-settings', UserSettingsResource(self._services_factory))
        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))
        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))

        self._mode = MODE_RUNNING

    def _get_startup_folder(self):
        path = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(path, '..', 'assets')

    def _get_static_folder(self):
        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", ""web-ui"", ""app""))
        # this is a workaround for packaging
        if not os.path.exists(static_folder):
            static_folder = os.path.abspath(
                os.path.join(os.path.abspath(__file__), "".."", "".."", "".."", "".."", ""web-ui"", ""app""))
        if not os.path.exists(static_folder):
            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')
        return static_folder

    def _is_starting(self):
        return self._mode == MODE_STARTUP

    def render_GET(self, request):
        if self._is_starting():
            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()
        else:
            account_email = self.mail_service(request).account_email
            response = Template(self._html_template).safe_substitute(account_email=account_email)
            return str(response)
/n/n/n/service/test/support/integration/app_test_client.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
import json
import multiprocessing
from leap.mail.adaptors.soledad import SoledadMailAdaptor
from leap.srp_session import SRPSession
from mockito import mock
import os
import shutil
import time
import uuid
import random


from leap.mail.imap.account import IMAPAccount
from leap.soledad.client import Soledad
from mock import Mock
from twisted.internet import reactor, defer
from twisted.internet.defer import succeed
from twisted.web.resource import getChildForRequest
# from twisted.web.server import Site as PixelatedSite
from zope.interface import implementer
from twisted.cred import checkers, credentials
from pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore
from pixelated.adapter.services.feedback_service import FeedbackService
from pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources
from pixelated.bitmask_libraries.config import LeapConfig
from pixelated.bitmask_libraries.session import LeapSession
from pixelated.config.services import Services
from pixelated.config.site import PixelatedSite

from pixelated.adapter.mailstore import LeapMailStore
from pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore

from pixelated.adapter.search import SearchEngine
from pixelated.adapter.services.draft_service import DraftService
from pixelated.adapter.services.mail_service import MailService
from pixelated.resources.root_resource import RootResource
from test.support.integration.model import MailBuilder
from test.support.test_helper import request_mock
from test.support.integration.model import ResponseMail
from tempdir import TempDir


class AppTestAccount(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'

    def __init__(self, user_id, leap_home):
        self._user_id = user_id
        self._leap_home = leap_home
        self._uuid = str(uuid.uuid4())
        self._mail_address = '%s@pixelated.org' % user_id
        self._soledad = None
        self._services = None

    @defer.inlineCallbacks
    def start(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)
        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)
        self.keymanager = mock()
        self.mail_sender = self._create_mail_sender()
        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)
        self.attachment_store = LeapAttachmentStore(self.soledad)

        yield self._initialize_imap_account()

        self.draft_service = DraftService(self.mail_store)
        self.leap_session = mock()
        self.feedback_service = FeedbackService(self.leap_session)

        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)

        mails = yield self.mail_service.all_mails()
        if len(mails) > 0:
            raise Exception('What? Where did these come from?')
        self.search_engine.index_mails(mails)

    @property
    def services(self):
        if self._services is None:
            services = mock(Services)
            services.keymanager = self.keymanager
            services.mail_service = self.mail_service
            services.draft_service = self.draft_service
            services.search_engine = self.search_engine
            services.feedback_service = self.feedback_service
            services._leap_session = self.leap_session

            self._services = services
            self.leap_session.close = lambda: 'mocked'

        return self._services

    def cleanup(self):
        soledad_test_folder = os.path.join(self._leap_home, self._uuid)
        shutil.rmtree(soledad_test_folder)

    def _initialize_imap_account(self):
        account_ready_cb = defer.Deferred()
        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)
        return account_ready_cb

    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):
        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender


@implementer(checkers.ICredentialsChecker)
class StubSRPChecker(object):
    credentialInterfaces = (
        credentials.IUsernamePassword,
    )

    def __init__(self, leap_provider, credentials={}):
        self._leap_provider = leap_provider
        self._credentials = credentials.copy()

    def add_user(self, username, password):
        self._credentials[username] = password

    def requestAvatarId(self, credentials):
        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())
        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))


class StubServicesFactory(ServicesFactory):

    def __init__(self, accounts, mode):
        super(StubServicesFactory, self).__init__(mode=mode)
        self._accounts = accounts

    @defer.inlineCallbacks
    def create_services_from(self, leap_session):
        account = self._accounts[leap_session.user_auth.username]
        self._services_by_user[leap_session.user_auth.uuid] = account.services
        yield defer.succeed(None)


class AppTestClient(object):
    INDEX_KEY = '\xde3?\x87\xff\xd9\xd3\x14\xf0\xa7>\x1f%C{\x16.\\\xae\x8c\x13\xa7\xfb\x04\xd4]+\x8d_\xed\xd1\x8d\x0bI' \
                '\x8a\x0e\xa4tm\xab\xbf\xb4\xa5\x99\x00d\xd5w\x9f\x18\xbc\x1d\xd4_W\xd2\xb6\xe8H\x83\x1b\xd8\x9d\xad'
    ACCOUNT = 'test'
    MAIL_ADDRESS = 'test@pixelated.org'

    def _initialize(self):
        self._tmp_dir = TempDir()
        self.accounts = {}

    @defer.inlineCallbacks
    def start_client(self, mode=UserAgentMode(is_single_user=True)):
        self._initialize()
        self._mode = mode
        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)

        yield self._test_account.start()

        self.cleanup = lambda: self._tmp_dir.dissolve()

        # copy fields for single user tests
        self.soledad = self._test_account.soledad
        self.search_engine = self._test_account.search_engine
        self.keymanager = self._test_account.keymanager
        self.mail_sender = self._test_account.mail_sender
        self.mail_store = self._test_account.mail_store
        self.attachment_store = self._test_account.attachment_store
        self.draft_service = self._test_account.draft_service
        self.leap_session = self._test_account.leap_session
        self.feedback_service = self._test_account.feedback_service
        self.mail_service = self._test_account.mail_service
        self.account = self._test_account.account

        if mode.is_single_user:
            self.service_factory = SingleUserServicesFactory(mode)
            services = self._test_account.services
            self.service_factory.add_session('someuserid', services)

            self.resource = RootResource(self.service_factory)
            self.resource.initialize()
        else:
            self.service_factory = StubServicesFactory(self.accounts, mode)
            provider = mock()
            provider.config = LeapConfig(self._tmp_dir.name)

            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))

    @defer.inlineCallbacks
    def create_user(self, account_name):
        if self._mode.is_single_user:
            raise Exception('Not supported in single user mode')

        account = AppTestAccount(account_name, self._tmp_dir.name)
        yield account.start()

        self.accounts[account_name] = account

    def _render(self, request, as_json=True):
        def get_str(_str):
            return json.loads(_str) if as_json else _str

        def get_request_written_data(_=None):
            written_data = request.getWrittenData()
            if written_data:
                return get_str(written_data)

        resource = getChildForRequest(self.resource, request)
        result = resource.render(request)

        if isinstance(result, basestring):
            return get_str(result), request

        # result is NOT_DONE_YET
        d = succeed(request) if request.finished else request.notifyFinish()
        d.addCallback(get_request_written_data)
        return d, request

    def listenTCP(self, port=4567, host='127.0.0.1'):
        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)

    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):
        def _start():
            self.listenTCP(port, host)
            reactor.run()
        process = multiprocessing.Process(target=_start)
        process.start()
        time.sleep(1)
        return lambda: process.terminate()

    def get(self, path, get_args='', as_json=True):
        request = request_mock(path)
        request.args = get_args
        return self._render(request, as_json)

    def post(self, path, body='', headers=None):
        headers = headers or {'Content-Type': 'application/json'}
        request = request_mock(path=path, method=""POST"", body=body, headers=headers)
        return self._render(request)

    def put(self, path, body):
        request = request_mock(path=path, method=""PUT"", body=body, headers={'Content-Type': ['application/json']})
        return self._render(request)

    def delete(self, path, body=""""):
        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=""DELETE"")
        return self._render(request)

    @defer.inlineCallbacks
    def add_mail_to_inbox(self, input_mail):
        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)
        defer.returnValue(mail)

    def account_for(self, username):
        return self.accounts[username]

    def add_mail_to_user_inbox(self, input_mail, username):
        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)

    @defer.inlineCallbacks
    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):
        mails = []
        yield self.mail_store.add_mailbox(mailbox)
        for _ in range(num):
            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)
            builder.with_body(str(random.random()))
            input_mail = builder.build_input_mail()
            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)
            if tags:
                mail.tags |= set(tags)
            if flags:
                for flag in flags:
                    mail.flags.add(flag)
            if tags or flags:
                yield self.mail_store.update_mail(mail)
            mails.append(mail)

        defer.returnValue(mails)

    def _create_mail_sender(self):
        mail_sender = Mock()
        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)
        return mail_sender

    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):
        return os.path.join(soledad_test_folder, str(uuid.uuid4()))

    def get_mails_by_tag(self, tag, page=1, window=100):
        tags = 'tag:%s' % tag
        return self.search(tags, page, window)

    @defer.inlineCallbacks
    def search(self, query, page=1, window=100):
        res, _ = self.get(""/mails"", {
            'q': [query],
            'w': [str(window)],
            'p': [str(page)]
        })
        res = yield res
        defer.returnValue([ResponseMail(m) for m in res['mails']])

    @defer.inlineCallbacks
    def get_mails_by_mailbox_name(self, mbox_name):
        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)
        mails = yield self.mail_store.get_mails(mail_ids)
        defer.returnValue(mails)

    @defer.inlineCallbacks
    def get_attachment(self, ident, encoding, filename=None, content_type=None):
        params = {'encoding': [encoding]}
        if filename:
            params['filename'] = [filename]
        if content_type:
            params['content_type'] = [content_type]
        deferred_result, req = self.get(""/attachment/%s"" % ident, params, as_json=False)
        res = yield deferred_result
        defer.returnValue((res, req))

    @defer.inlineCallbacks
    def post_attachment(self, data, headers):
        deferred_result, req = self.post('/attachment', body=data, headers=headers)
        res = yield deferred_result
        defer.returnValue((res, req))

    def put_mail(self, data):
        res, req = self.put('/mails', data)
        return res, req

    def post_tags(self, mail_ident, tags_json):
        res, req = self.post(""/mail/%s/tags"" % mail_ident, tags_json)
        return res

    def get_tags(self, **kwargs):
        res, req = self.get('/tags', kwargs)
        return res

    def get_mail(self, mail_ident):
        res, req = self.get('/mail/%s' % mail_ident)
        return res

    def delete_mail(self, mail_ident):
        res, req = self.delete(""/mail/%s"" % mail_ident)
        return res

    def delete_mails(self, idents):
        res, req = self.post(""/mails/delete"", json.dumps({'idents': idents}))
        return res

    def mark_many_as_unread(self, idents):
        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))
        return res

    def mark_many_as_read(self, idents):
        res, req = self.post('/mails/read', json.dumps({'idents': idents}))
        return res

    def get_contacts(self, query):
        res, req = self.get('/contacts', get_args={'q': query})
        return res


@defer.inlineCallbacks
def initialize_soledad(tempdir, uuid):
    if os.path.isdir(tempdir):
        shutil.rmtree(tempdir)

    passphrase = u""verysecretpassphrase""
    secret_path = os.path.join(tempdir, ""secret.gpg"")
    local_db_path = os.path.join(tempdir, ""soledad.u1db"")
    server_url = ""http://provider""
    cert_file = """"

    class MockSharedDB(object):
        get_doc = Mock(return_value=None)
        put_doc = Mock()
        lock = Mock(return_value=('atoken', 300))
        unlock = Mock(return_value=True)
        close = Mock()

        def __call__(self):
            return self

    Soledad._shared_db = MockSharedDB()

    _soledad = Soledad(
        uuid,
        passphrase,
        secret_path,
        local_db_path,
        server_url,
        cert_file,
        defer_encryption=False,
        syncable=False)

    yield SoledadMailAdaptor().initialize_store(_soledad)

    defer.returnValue(_soledad)
/n/n/n/service/test/support/test_helper.py/n/n#
# Copyright (c) 2014 ThoughtWorks, Inc.
#
# Pixelated is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Pixelated is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.
from datetime import datetime
import io
from twisted.web.test.test_web import DummyRequest

from pixelated.adapter.model.mail import InputMail


LEAP_FLAGS = ['\\Seen',
              '\\Answered',
              '\\Flagged',
              '\\Deleted',
              '\\Draft',
              '\\Recent',
              'List']

DEFAULT_HEADERS = {'date': str(datetime.now())}


def mail_dict():
    return {
        'header': {
            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],
            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],
            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],
            'subject': 'Subject'
        },
        'body': 'Body',
        'ident': '',
        'tags': []
    }


class TestDoc(object):
    def __init__(self, content):
        self.content = content

    def __getitem__(self, key):
        return self.content[key]


def leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',
              chash='chash'):
    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})

    if headers is None:
        headers = {}
    if not (headers.get('received') or headers.get('date')):
        headers.update(DEFAULT_HEADERS)
    headers['headers'] = extra_headers
    hdoc = TestDoc(headers)

    bdoc = TestDoc({'raw': body, 'type': 'cnt'})

    return (fdoc, hdoc, bdoc)


def input_mail():
    mail = InputMail()
    mail.fdoc = TestDoc({})
    mail._chash = ""123""
    mail.as_dict = lambda: None
    return mail


class TestRequest:

    def __init__(self, json):
        self.json = json


class PixRequestMock(DummyRequest):
    def __init__(self, path):
        DummyRequest.__init__(self, path)
        self.content = None
        self.code = None

    def getWrittenData(self):
        if len(self.written):
            return self.written[0]

    def redirect(self, url):
        self.setResponseCode(302)
        self.setHeader(b""location"", url)


def request_mock(path='', method='GET', body='', headers={}):
    dummy = PixRequestMock(path.split('/'))
    for name, val in headers.iteritems():
        dummy.headers[name.lower()] = val
    dummy.method = method
    if isinstance(body, str):
        dummy.content = io.BytesIO(body)
    else:
        for key, val in body.items():
            dummy.addArg(key, val)

    return dummy
/n/n/n/service/test/unit/resources/test_root_resource.py/n/nimport unittest
import re
from mockito import mock, when, any as ANY

from pixelated.application import UserAgentMode
from test.unit.resources import DummySite
from twisted.web.test.requesthelper import DummyRequest
from pixelated.resources.root_resource import RootResource


class TestRootResource(unittest.TestCase):
    MAIL_ADDRESS = 'test_user@pixelated-project.org'

    def setUp(self):
        self.mail_service = mock()
        self.services_factory = mock()
        self.services_factory.mode = UserAgentMode(is_single_user=True)
        self.services = mock()
        self.services.mail_service = self.mail_service
        self.services_factory._services_by_user = {'someuserid': self.mail_service}
        when(self.services_factory).services(ANY()).thenReturn(self.services)
        self.mail_service.account_email = self.MAIL_ADDRESS

        root_resource = RootResource(self.services_factory)
        root_resource._html_template = ""<html><head><title>$account_email</title></head></html>""
        root_resource._mode = root_resource
        self.web = DummySite(root_resource)

    def test_render_GET_should_template_account_email(self):
        request = DummyRequest([''])

        d = self.web.get(request)

        def assert_response(_):
            expected = ""<title>{0}</title>"".format(self.MAIL_ADDRESS)
            matches = re.findall(expected, request.written[0])
            self.assertEquals(len(matches), 1)

        d.addCallback(assert_response)
        return d
/n/n/n",1
58,58,1c2a256addf7a5273a40963f92a6351e5d053ae0,"notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers',
                        'accept, content-type, authorization, x-xsrftoken')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",0
59,59,1c2a256addf7a5273a40963f92a6351e5d053ae0,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import mimetypes
import os
import re
import sys
import traceback
import types
import warnings
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook._tz import utcnow
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

_sys_info_cache = None
def json_sys_info():
    global _sys_info_cache
    if _sys_info_cache is None:
        _sys_info_cache = json.dumps(get_sys_info())
    return _sys_info_cache

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        if 'Content-Security-Policy' in self.settings.get('headers', {}):
            # user-specified, don't override
            return self.settings['headers']['Content-Security-Policy']

        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),
        ])

    def set_default_headers(self):
        headers = {}
        headers.update(self.settings.get('headers', {}))

        headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name, value in headers.items():
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/contents'))
        return self.settings.get('contents_js_source', 'services/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def set_attachment_header(self, filename):
        """"""Set Content-Disposition: attachment header

        As a method to ensure handling of filename encoding
        """"""
        escaped_filename = url_escape(filename)
        self.set_header('Content-Disposition',
            'attachment;'
            "" filename*=utf-8''{utf8}""
            .format(
                utf8=escaped_filename,
            )
        )

    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, let the request through.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf cookie checks when token-authenticated""""""
        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=json_sys_info(),
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token.decode('utf8'),
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )

        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            html = self.render_template('error.html', **ns)

        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def write_error(self, status_code, **kwargs):
        """"""APIHandler errors are JSON, not human pages""""""
        self.set_header('Content-Type', 'application/json')
        message = responses.get(status_code, 'Unknown HTTP Error')
        reply = {
            'message': message,
        }
        exc_info = kwargs.get('exc_info')
        if exc_info:
            e = exc_info[1]
            if isinstance(e, HTTPError):
                reply['message'] = e.log_message or message
            else:
                reply['message'] = 'Unhandled error'
                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))
        self.log.warning(reply['message'])
        self.finish(json.dumps(reply))

    def get_current_user(self):
        """"""Raise 403 on API handlers instead of redirecting to human login page""""""
        # preserve _user_cache so we don't raise more than once
        if hasattr(self, '_user_cache'):
            return self._user_cache
        self._user_cache = user = super(APIHandler, self).get_current_user()
        if user is None:
            raise web.HTTPError(403)
        return user

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp

    # set _track_activity = False on API handlers that shouldn't track activity
    _track_activity = True

    def update_api_activity(self):
        """"""Update last_activity of API requests""""""
        # record activity of authenticated requests
        if self._track_activity and self.get_current_user():
            self.settings['api_last_activity'] = utcnow()

    def finish(self, *args, **kwargs):
        self.update_api_activity()
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(""download"", False):
            name = path.rsplit('/', 1)[-1]
            self.set_attachment_header(name)

        return web.StaticFileHandler.get(self, path)
    
    def get_content_type(self):
        path = self.absolute_path.strip('/')
        if '/' in path:
            _, name = path.rsplit('/', 1)
        else:
            name = path
        if name.endswith('.ipynb'):
            return 'application/x-ipynb+json'
        else:
            cur_mime = mimetypes.guess_type(name)[0]
            if cur_mime == 'text/plain':
                return 'text/plain; charset=UTF-8'
            else:
                return super(AuthenticatedFileHandler, self).get_content_type()

    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',
        DeprecationWarning,
        stacklevel=2,
    )
    @functools.wraps(method)
    def wrapper(self, *args, **kwargs):
        self.write_error = types.MethodType(APIHandler.write_error, self)
        return method(self, *args, **kwargs)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler),
    (r'/(robots\.txt|favicon\.ico)', web.StaticFileHandler),
]
/n/n/n",1
60,60,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"notebook/auth/login.py/n/n""""""Tornado handlers for logging into the notebook.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import re

try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2
import uuid

from tornado.escape import url_escape

from ..auth.security import passwd_check

from ..base.handlers import IPythonHandler


class LoginHandler(IPythonHandler):
    """"""The basic tornado login handler

    authenticates with a hashed password from the configuration.
    """"""
    def _render(self, message=None):
        self.write(self.render_template('login.html',
                next=url_escape(self.get_argument('next', default=self.base_url)),
                message=message,
        ))

    def _redirect_safe(self, url, default=None):
        """"""Redirect if url is on our PATH

        Full-domain redirects are allowed if they pass our CORS origin checks.

        Otherwise use default (self.base_url if unspecified).
        """"""
        if default is None:
            default = self.base_url
        if not url.startswith(self.base_url):
            # require that next_url be absolute path within our path
            allow = False
            # OR pass our cross-origin check
            if '://' in url:
                # if full URL, run our cross-origin check:
                parsed = urlparse(url.lower())
                origin = '%s://%s' % (parsed.scheme, parsed.netloc)
                if self.allow_origin:
                    allow = self.allow_origin == origin
                elif self.allow_origin_pat:
                    allow = bool(self.allow_origin_pat.match(origin))
            if not allow:
                # not allowed, use default
                self.log.warning(""Not allowing login redirect to %r"" % url)
                url = default
        self.redirect(url)

    def get(self):
        if self.current_user:
            next_url = self.get_argument('next', default=self.base_url)
            self._redirect_safe(next_url)
        else:
            self._render()

    @property
    def hashed_password(self):
        return self.password_from_settings(self.settings)

    def post(self):
        typed_password = self.get_argument('password', default=u'')
        if self.get_login_available(self.settings):
            if passwd_check(self.hashed_password, typed_password):
                self.set_login_cookie(self, uuid.uuid4().hex)
            elif self.token and self.token == typed_password:
                self.set_login_cookie(self, uuid.uuid4().hex)
            else:
                self.set_status(401)
                self._render(message={'error': 'Invalid password'})
                return

        next_url = self.get_argument('next', default=self.base_url)
        self._redirect_safe(next_url)

    @classmethod
    def set_login_cookie(cls, handler, user_id=None):
        """"""Call this on handlers to set the login cookie for success""""""
        cookie_options = handler.settings.get('cookie_options', {})
        cookie_options.setdefault('httponly', True)
        # tornado <4.2 has a bug that considers secure==True as soon as
        # 'secure' kwarg is passed to set_secure_cookie
        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):
            cookie_options.setdefault('secure', True)
        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)
        return user_id

    auth_header_pat = re.compile('token\s+(.+)', re.IGNORECASE)

    @classmethod
    def get_token(cls, handler):
        """"""Get the user token from a request

        Default:

        - in URL parameters: ?token=<token>
        - in header: Authorization: token <token>
        """"""

        user_token = handler.get_argument('token', '')
        if not user_token:
            # get it from Authorization header
            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))
            if m:
                user_token = m.group(1)
        return user_token

    @classmethod
    def should_check_origin(cls, handler):
        """"""Should the Handler check for CORS origin validation?
        
        Origin check should be skipped for token-authenticated requests.
        """"""
        return not cls.is_token_authenticated(handler)
    
    @classmethod
    def is_token_authenticated(cls, handler):
        """"""Check if the handler has been authenticated by a token.
        
        This is used to signal certain things, such as:
        
        - permit access to REST API
        - xsrf protection
        - skip origin-checks for scripts
        """"""
        if getattr(handler, '_user_id', None) is None:
            # ensure get_user has been called, so we know if we're token-authenticated
            handler.get_current_user()
        return getattr(handler, '_token_authenticated', False)

    @classmethod
    def get_user(cls, handler):
        """"""Called by handlers.get_current_user for identifying the current user.

        See tornado.web.RequestHandler.get_current_user for details.
        """"""
        # Can't call this get_current_user because it will collide when
        # called on LoginHandler itself.
        if getattr(handler, '_user_id', None):
            return handler._user_id
        user_id = cls.get_user_token(handler)
        if user_id is None:
            user_id = handler.get_secure_cookie(handler.cookie_name)
        else:
            cls.set_login_cookie(handler, user_id)
            # Record that we've been authenticated with a token.
            # Used in should_check_origin above.
            handler._token_authenticated = True
        if user_id is None:
            # prevent extra Invalid cookie sig warnings:
            handler.clear_login_cookie()
            if not handler.login_available:
                # Completely insecure! No authentication at all.
                # No need to warn here, though; validate_security will have already done that.
                user_id = 'anonymous'

        # cache value for future retrievals on the same request
        handler._user_id = user_id
        return user_id

    @classmethod
    def get_user_token(cls, handler):
        """"""Identify the user based on a token in the URL or Authorization header""""""
        token = handler.token
        if not token:
            return
        # check login token from URL argument or Authorization header
        user_token = cls.get_token(handler)
        one_time_token = handler.one_time_token
        authenticated = False
        if user_token == token:
            # token-authenticated, set the login cookie
            handler.log.debug(""Accepting token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True
        elif one_time_token and user_token == one_time_token:
            # one-time-token-authenticated, only allow this token once
            handler.settings.pop('one_time_token', None)
            handler.log.info(""Accepting one-time-token-authenticated connection from %s"", handler.request.remote_ip)
            authenticated = True

        if authenticated:
            return uuid.uuid4().hex
        else:
            return None


    @classmethod
    def validate_security(cls, app, ssl_options=None):
        """"""Check the notebook application's security.

        Show messages, or abort if necessary, based on the security configuration.
        """"""
        if not app.ip:
            warning = ""WARNING: The notebook server is listening on all IP addresses""
            if ssl_options is None:
                app.log.warning(warning + "" and not using encryption. This ""
                    ""is not recommended."")
            if not app.password and not app.token:
                app.log.warning(warning + "" and not using authentication. ""
                    ""This is highly insecure and not recommended."")
        else:
            if not app.password and not app.token:
                app.log.warning(
                    ""All authentication is disabled.""
                    ""  Anyone who can connect to this server will be able to run code."")

    @classmethod
    def password_from_settings(cls, settings):
        """"""Return the hashed password from the tornado settings.

        If there is no configured password, an empty string will be returned.
        """"""
        return settings.get('password', u'')

    @classmethod
    def get_login_available(cls, settings):
        """"""Whether this LoginHandler is needed - and therefore whether the login page should be displayed.""""""
        return bool(cls.password_from_settings(settings) or settings.get('token'))
/n/n/nnotebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""

    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def token_authenticated(self):
        """"""Have I been authenticated with a token?""""""
        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):
            return False
        return self.login_handler.is_token_authenticated(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow

    def check_xsrf_cookie(self):
        """"""Bypass xsrf checks when token-authenticated""""""
        if self.token_authenticated:
            # Token-authenticated requests do not need additional XSRF-check
            # Servers without authentication are vulnerable to XSRF
            return
        return super(IPythonHandler, self).check_xsrf_cookie()

    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            token=self.token,
            xsrf_token=self.xsrf_token,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",0
61,61,70e79a0ad69f02d46abed57e007ce5ef7f79319b,"/notebook/base/handlers.py/n/n""""""Base Tornado handlers for the notebook server.""""""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import functools
import json
import os
import re
import sys
import traceback
try:
    # py3
    from http.client import responses
except ImportError:
    from httplib import responses
try:
    from urllib.parse import urlparse # Py 3
except ImportError:
    from urlparse import urlparse # Py 2

from jinja2 import TemplateNotFound
from tornado import web, gen, escape
from tornado.log import app_log

from notebook._sysinfo import get_sys_info

from traitlets.config import Application
from ipython_genutils.path import filefind
from ipython_genutils.py3compat import string_types

import notebook
from notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape
from notebook.services.security import csp_report_uri

#-----------------------------------------------------------------------------
# Top-level handlers
#-----------------------------------------------------------------------------
non_alphanum = re.compile(r'[^A-Za-z0-9]')

sys_info = json.dumps(get_sys_info())

def log():
    if Application.initialized():
        return Application.instance().log
    else:
        return app_log

class AuthenticatedHandler(web.RequestHandler):
    """"""A RequestHandler with an authenticated user.""""""
    
    @property
    def content_security_policy(self):
        """"""The default Content-Security-Policy header
        
        Can be overridden by defining Content-Security-Policy in settings['headers']
        """"""
        return '; '.join([
            ""frame-ancestors 'self'"",
            # Make sure the report-uri is relative to the base_url
            ""report-uri "" + url_path_join(self.base_url, csp_report_uri),
        ])

    def set_default_headers(self):
        headers = self.settings.get('headers', {})

        if ""Content-Security-Policy"" not in headers:
            headers[""Content-Security-Policy""] = self.content_security_policy

        # Allow for overriding headers
        for header_name,value in headers.items() :
            try:
                self.set_header(header_name, value)
            except Exception as e:
                # tornado raise Exception (not a subclass)
                # if method is unsupported (websocket and Access-Control-Allow-Origin
                # for example, so just ignore)
                self.log.debug(e)
    
    def clear_login_cookie(self):
        self.clear_cookie(self.cookie_name)
    
    def get_current_user(self):
        if self.login_handler is None:
            return 'anonymous'
        return self.login_handler.get_user(self)

    def skip_check_origin(self):
        """"""Ask my login_handler if I should skip the origin_check
        
        For example: in the default LoginHandler, if a request is token-authenticated,
        origin checking should be skipped.
        """"""
        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):
            return False
        return not self.login_handler.should_check_origin(self)

    @property
    def cookie_name(self):
        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(
            self.request.host
        ))
        return self.settings.get('cookie_name', default_cookie_name)
    
    @property
    def logged_in(self):
        """"""Is a user currently logged in?""""""
        user = self.get_current_user()
        return (user and not user == 'anonymous')

    @property
    def login_handler(self):
        """"""Return the login handler for this application, if any.""""""
        return self.settings.get('login_handler_class', None)

    @property
    def token(self):
        """"""Return the login token for this application, if any.""""""
        return self.settings.get('token', None)

    @property
    def one_time_token(self):
        """"""Return the one-time-use token for this application, if any.""""""
        return self.settings.get('one_time_token', None)

    @property
    def login_available(self):
        """"""May a user proceed to log in?

        This returns True if login capability is available, irrespective of
        whether the user is already logged in or not.

        """"""
        if self.login_handler is None:
            return False
        return bool(self.login_handler.get_login_available(self.settings))


class IPythonHandler(AuthenticatedHandler):
    """"""IPython-specific extensions to authenticated handling
    
    Mostly property shortcuts to IPython-specific settings.
    """"""

    @property
    def ignore_minified_js(self):
        """"""Wether to user bundle in template. (*.min files)
        
        Mainly use for development and avoid file recompilation
        """"""
        return self.settings.get('ignore_minified_js', False)

    @property
    def config(self):
        return self.settings.get('config', None)
    
    @property
    def log(self):
        """"""use the IPython log by default, falling back on tornado's logger""""""
        return log()

    @property
    def jinja_template_vars(self):
        """"""User-supplied values to supply to jinja templates.""""""
        return self.settings.get('jinja_template_vars', {})
    
    #---------------------------------------------------------------
    # URLs
    #---------------------------------------------------------------
    
    @property
    def version_hash(self):
        """"""The version hash to use for cache hints for static files""""""
        return self.settings.get('version_hash', '')
    
    @property
    def mathjax_url(self):
        url = self.settings.get('mathjax_url', '')
        if not url or url_is_absolute(url):
            return url
        return url_path_join(self.base_url, url)
    
    @property
    def mathjax_config(self):
        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')

    @property
    def base_url(self):
        return self.settings.get('base_url', '/')

    @property
    def default_url(self):
        return self.settings.get('default_url', '')

    @property
    def ws_url(self):
        return self.settings.get('websocket_url', '')

    @property
    def contents_js_source(self):
        self.log.debug(""Using contents: %s"", self.settings.get('contents_js_source',
            'services/built/contents'))
        return self.settings.get('contents_js_source', 'services/built/contents')
    
    #---------------------------------------------------------------
    # Manager objects
    #---------------------------------------------------------------
    
    @property
    def kernel_manager(self):
        return self.settings['kernel_manager']

    @property
    def contents_manager(self):
        return self.settings['contents_manager']
    
    @property
    def session_manager(self):
        return self.settings['session_manager']
    
    @property
    def terminal_manager(self):
        return self.settings['terminal_manager']
    
    @property
    def kernel_spec_manager(self):
        return self.settings['kernel_spec_manager']

    @property
    def config_manager(self):
        return self.settings['config_manager']

    #---------------------------------------------------------------
    # CORS
    #---------------------------------------------------------------
    
    @property
    def allow_origin(self):
        """"""Normal Access-Control-Allow-Origin""""""
        return self.settings.get('allow_origin', '')
    
    @property
    def allow_origin_pat(self):
        """"""Regular expression version of allow_origin""""""
        return self.settings.get('allow_origin_pat', None)
    
    @property
    def allow_credentials(self):
        """"""Whether to set Access-Control-Allow-Credentials""""""
        return self.settings.get('allow_credentials', False)
    
    def set_default_headers(self):
        """"""Add CORS headers, if defined""""""
        super(IPythonHandler, self).set_default_headers()
        if self.allow_origin:
            self.set_header(""Access-Control-Allow-Origin"", self.allow_origin)
        elif self.allow_origin_pat:
            origin = self.get_origin()
            if origin and self.allow_origin_pat.match(origin):
                self.set_header(""Access-Control-Allow-Origin"", origin)
        if self.allow_credentials:
            self.set_header(""Access-Control-Allow-Credentials"", 'true')
    
    def get_origin(self):
        # Handle WebSocket Origin naming convention differences
        # The difference between version 8 and 13 is that in 8 the
        # client sends a ""Sec-Websocket-Origin"" header and in 13 it's
        # simply ""Origin"".
        if ""Origin"" in self.request.headers:
            origin = self.request.headers.get(""Origin"")
        else:
            origin = self.request.headers.get(""Sec-Websocket-Origin"", None)
        return origin

    # origin_to_satisfy_tornado is present because tornado requires
    # check_origin to take an origin argument, but we don't use it
    def check_origin(self, origin_to_satisfy_tornado=""""):
        """"""Check Origin for cross-site API requests, including websockets

        Copied from WebSocket with changes:

        - allow unspecified host/origin (e.g. scripts)
        - allow token-authenticated requests
        """"""
        if self.allow_origin == '*' or self.skip_check_origin():
            return True

        host = self.request.headers.get(""Host"")
        origin = self.request.headers.get(""Origin"")

        # If no header is provided, allow it.
        # Origin can be None for:
        # - same-origin (IE, Firefox)
        # - Cross-site POST form (IE, Firefox)
        # - Scripts
        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token
        if origin is None or host is None:
            return True

        origin = origin.lower()
        origin_host = urlparse(origin).netloc

        # OK if origin matches host
        if origin_host == host:
            return True

        # Check CORS headers
        if self.allow_origin:
            allow = self.allow_origin == origin
        elif self.allow_origin_pat:
            allow = bool(self.allow_origin_pat.match(origin))
        else:
            # No CORS headers deny the request
            allow = False
        if not allow:
            self.log.warning(""Blocking Cross Origin API request for %s.  Origin: %s, Host: %s"",
                self.request.path, origin, host,
            )
        return allow
    
    #---------------------------------------------------------------
    # template rendering
    #---------------------------------------------------------------
    
    def get_template(self, name):
        """"""Return the jinja template object for a given name""""""
        return self.settings['jinja2_env'].get_template(name)
    
    def render_template(self, name, **ns):
        ns.update(self.template_namespace)
        template = self.get_template(name)
        return template.render(**ns)
    
    @property
    def template_namespace(self):
        return dict(
            base_url=self.base_url,
            default_url=self.default_url,
            ws_url=self.ws_url,
            logged_in=self.logged_in,
            login_available=self.login_available,
            token_available=bool(self.token or self.one_time_token),
            static_url=self.static_url,
            sys_info=sys_info,
            contents_js_source=self.contents_js_source,
            version_hash=self.version_hash,
            ignore_minified_js=self.ignore_minified_js,
            xsrf_form_html=self.xsrf_form_html,
            **self.jinja_template_vars
        )
    
    def get_json_body(self):
        """"""Return the body of the request as JSON data.""""""
        if not self.request.body:
            return None
        # Do we need to call body.decode('utf-8') here?
        body = self.request.body.strip().decode(u'utf-8')
        try:
            model = json.loads(body)
        except Exception:
            self.log.debug(""Bad JSON: %r"", body)
            self.log.error(""Couldn't parse JSON"", exc_info=True)
            raise web.HTTPError(400, u'Invalid JSON in body of request')
        return model

    def write_error(self, status_code, **kwargs):
        """"""render custom error pages""""""
        exc_info = kwargs.get('exc_info')
        message = ''
        status_message = responses.get(status_code, 'Unknown HTTP Error')
        exception = '(unknown)'
        if exc_info:
            exception = exc_info[1]
            # get the custom message, if defined
            try:
                message = exception.log_message % exception.args
            except Exception:
                pass
            
            # construct the custom reason, if defined
            reason = getattr(exception, 'reason', '')
            if reason:
                status_message = reason
        
        # build template namespace
        ns = dict(
            status_code=status_code,
            status_message=status_message,
            message=message,
            exception=exception,
        )
        
        self.set_header('Content-Type', 'text/html')
        # render the template
        try:
            html = self.render_template('%s.html' % status_code, **ns)
        except TemplateNotFound:
            self.log.debug(""No template for %d"", status_code)
            html = self.render_template('error.html', **ns)
        
        self.write(html)


class APIHandler(IPythonHandler):
    """"""Base class for API handlers""""""

    def prepare(self):
        if not self.check_origin():
            raise web.HTTPError(404)
        return super(APIHandler, self).prepare()

    def check_xsrf_cookie(self):
        """"""Check non-empty body on POST for XSRF

        instead of checking the cookie for forms.
        """"""
        if self.request.method.upper() == 'POST' and not self.request.body:
            # Require non-empty POST body for XSRF
            raise web.HTTPError(400, ""POST requests must have a JSON body. If no content is needed, use '{}'."")

    @property
    def content_security_policy(self):
        csp = '; '.join([
                super(APIHandler, self).content_security_policy,
                ""default-src 'none'"",
            ])
        return csp
    
    def finish(self, *args, **kwargs):
        self.set_header('Content-Type', 'application/json')
        return super(APIHandler, self).finish(*args, **kwargs)

    def options(self, *args, **kwargs):
        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')
        self.set_header('Access-Control-Allow-Methods',
                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')
        self.finish()


class Template404(IPythonHandler):
    """"""Render our 404 template""""""
    def prepare(self):
        raise web.HTTPError(404)


class AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):
    """"""static files should only be accessible when logged in""""""

    @web.authenticated
    def get(self, path):
        if os.path.splitext(path)[1] == '.ipynb':
            name = path.rsplit('/', 1)[-1]
            self.set_header('Content-Type', 'application/json')
            self.set_header('Content-Disposition','attachment; filename=""%s""' % escape.url_escape(name))
        
        return web.StaticFileHandler.get(self, path)
    
    def set_headers(self):
        super(AuthenticatedFileHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments:
            self.add_header(""Cache-Control"", ""no-cache"")
    
    def compute_etag(self):
        return None
    
    def validate_absolute_path(self, root, absolute_path):
        """"""Validate and return the absolute path.
        
        Requires tornado 3.1
        
        Adding to tornado's own handling, forbids the serving of hidden files.
        """"""
        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)
        abs_root = os.path.abspath(root)
        if is_hidden(abs_path, abs_root):
            self.log.info(""Refusing to serve hidden file, via 404 Error"")
            raise web.HTTPError(404)
        return abs_path


def json_errors(method):
    """"""Decorate methods with this to return GitHub style JSON errors.
    
    This should be used on any JSON API on any handler method that can raise HTTPErrors.
    
    This will grab the latest HTTPError exception using sys.exc_info
    and then:
    
    1. Set the HTTP status code based on the HTTPError
    2. Create and return a JSON body with a message field describing
       the error in a human readable form.
    """"""
    @functools.wraps(method)
    @gen.coroutine
    def wrapper(self, *args, **kwargs):
        try:
            result = yield gen.maybe_future(method(self, *args, **kwargs))
        except web.HTTPError as e:
            self.set_header('Content-Type', 'application/json')
            status = e.status_code
            message = e.log_message
            self.log.warning(message)
            self.set_status(e.status_code)
            reply = dict(message=message, reason=e.reason)
            self.finish(json.dumps(reply))
        except Exception:
            self.set_header('Content-Type', 'application/json')
            self.log.error(""Unhandled error in API request"", exc_info=True)
            status = 500
            message = ""Unknown server error""
            t, value, tb = sys.exc_info()
            self.set_status(status)
            tb_text = ''.join(traceback.format_exception(t, value, tb))
            reply = dict(message=message, reason=None, traceback=tb_text)
            self.finish(json.dumps(reply))
        else:
            # FIXME: can use regular return in generators in py3
            raise gen.Return(result)
    return wrapper



#-----------------------------------------------------------------------------
# File handler
#-----------------------------------------------------------------------------

# to minimize subclass changes:
HTTPError = web.HTTPError

class FileFindHandler(IPythonHandler, web.StaticFileHandler):
    """"""subclass of StaticFileHandler for serving files from a search path""""""
    
    # cache search results, don't search for files more than once
    _static_paths = {}
    
    def set_headers(self):
        super(FileFindHandler, self).set_headers()
        # disable browser caching, rely on 304 replies for savings
        if ""v"" not in self.request.arguments or \
                any(self.request.path.startswith(path) for path in self.no_cache_paths):
            self.set_header(""Cache-Control"", ""no-cache"")
    
    def initialize(self, path, default_filename=None, no_cache_paths=None):
        self.no_cache_paths = no_cache_paths or []
        
        if isinstance(path, string_types):
            path = [path]
        
        self.root = tuple(
            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path
        )
        self.default_filename = default_filename
    
    def compute_etag(self):
        return None
    
    @classmethod
    def get_absolute_path(cls, roots, path):
        """"""locate a file to serve on our static file search path""""""
        with cls._lock:
            if path in cls._static_paths:
                return cls._static_paths[path]
            try:
                abspath = os.path.abspath(filefind(path, roots))
            except IOError:
                # IOError means not found
                return ''
            
            cls._static_paths[path] = abspath
            

            log().debug(""Path %s served from %s""%(path, abspath))
            return abspath
    
    def validate_absolute_path(self, root, absolute_path):
        """"""check if the file should be served (raises 404, 403, etc.)""""""
        if absolute_path == '':
            raise web.HTTPError(404)
        
        for root in self.root:
            if (absolute_path + os.sep).startswith(root):
                break
        
        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)


class APIVersionHandler(APIHandler):

    @json_errors
    def get(self):
        # not authenticated, so give as few info as possible
        self.finish(json.dumps({""version"":notebook.__version__}))


class TrailingSlashHandler(web.RequestHandler):
    """"""Simple redirect handler that strips trailing slashes
    
    This should be the first, highest priority handler.
    """"""
    
    def get(self):
        self.redirect(self.request.uri.rstrip('/'))
    
    post = put = get


class FilesRedirectHandler(IPythonHandler):
    """"""Handler for redirecting relative URLs to the /files/ handler""""""
    
    @staticmethod
    def redirect_to_files(self, path):
        """"""make redirect logic a reusable static method
        
        so it can be called from other handlers.
        """"""
        cm = self.contents_manager
        if cm.dir_exists(path):
            # it's a *directory*, redirect to /tree
            url = url_path_join(self.base_url, 'tree', url_escape(path))
        else:
            orig_path = path
            # otherwise, redirect to /files
            parts = path.split('/')

            if not cm.file_exists(path=path) and 'files' in parts:
                # redirect without files/ iff it would 404
                # this preserves pre-2.0-style 'files/' links
                self.log.warning(""Deprecated files/ URL: %s"", orig_path)
                parts.remove('files')
                path = '/'.join(parts)

            if not cm.file_exists(path=path):
                raise web.HTTPError(404)

            url = url_path_join(self.base_url, 'files', url_escape(path))
        self.log.debug(""Redirecting %s to %s"", self.request.path, url)
        self.redirect(url)
    
    def get(self, path=''):
        return self.redirect_to_files(self, path)


class RedirectWithParams(web.RequestHandler):
    """"""Sam as web.RedirectHandler, but preserves URL parameters""""""
    def initialize(self, url, permanent=True):
        self._url = url
        self._permanent = permanent

    def get(self):
        sep = '&' if '?' in self._url else '?'
        url = sep.join([self._url, self.request.query])
        self.redirect(url, permanent=self._permanent)

#-----------------------------------------------------------------------------
# URL pattern fragments for re-use
#-----------------------------------------------------------------------------

# path matches any number of `/foo[/bar...]` or just `/` or ''
path_regex = r""(?P<path>(?:(?:/[^/]+)+|/?))""

#-----------------------------------------------------------------------------
# URL to handler mappings
#-----------------------------------------------------------------------------


default_handlers = [
    (r"".*/"", TrailingSlashHandler),
    (r""api"", APIVersionHandler)
]
/n/n/n",1
