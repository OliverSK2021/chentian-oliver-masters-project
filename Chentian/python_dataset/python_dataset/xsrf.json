[{"id": "59fdbf02dac752fd22cb87eb4bea59d599b333dd", "code": "grab-monorail.py/n/n#!/usr/bin/env python3\nimport argparse\nimport glob\nimport logging\nimport os\nimport re\nimport requests\nimport subprocess\nimport sys\n\nOSS_FUZZ_BUGURL = \"https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=\"\nDOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='\n\ntestcase_pattern = re.compile(r'https://oss-fuzz\\.com/testcase\\?key=(\\d+)')\nproto_pattern = r'\\\\nFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\\\\n'\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable verbose logging\")\nparser.add_argument(\"--cookie-file\", \"-c\", help=\"File containing cookie value\")\n\n# Pass through options\nreporter_params = [\n    (\"report\", None),\n    (\"timeout\", int),\n    (\"memlimit\", int),\n    (\"memleaks\", None),\n]\nfor name, arg_type in reporter_params:\n    args = [\"--\" + name]\n    kwargs = {}\n    if arg_type:\n        kwargs[\"type\"] = arg_type\n    else:\n        kwargs[\"action\"] = \"store_true\"\n    kwargs[\"default\"] = None\n    kwargs[\"help\"] = \"Option is passed to the reporter\"\n    parser.add_argument(*args, **kwargs)\nparser.add_argument(\"--reporter-args\", \"-r\", help=\"Options to pass through\")\n\n\nparser.add_argument(\"issue_id\", type=int)\nargs = parser.parse_args()\n\nif args.debug:\n    logging.basicConfig(level=logging.DEBUG)\n\ndef fatal(*args):\n    logging.error(*args)\n    sys.exit(1)\n\ndef parse_cookies(text):\n    cookies = {}\n    for m in re.finditer(r'(SACSID)\\s+(~[0-9a-zA-Z_-]+)\\s+([a-z.-]+)(?:\\s|$)', text):\n        key, value, domain = m.groups()\n        cookies[domain] = (key, value)\n    # compatibility with Netscape cookie jar\n    garbage = r'(?:TRUE|FALSE)\\s+/\\s+(?:TRUE|FALSE)\\s+\\d+\\s+'\n    cj_pattern = r'([a-z.-]+)\\s+' + garbage + r'(SACSID)\\s+(~[0-9a-zA-Z_-]+)(?:\\s+|$)'\n    for m in re.finditer(cj_pattern, text):\n        domain, key, value = m.groups()\n        cookies[domain] = (key, value)\n    if any(not d in cookies for d in [\"bugs.chromium.org\", \"oss-fuzz.com\"]):\n        fatal(\"Missing domains, got: %s\", \" \".join(cookies.keys()))\n    return cookies\n\ncookie_file = args.cookie_file\nif not cookie_file:\n    # TODO maybe fallback to a default location?\n    parser.error(\"Missing cookie file\")\nsid_cookies = parse_cookies(open(cookie_file).read().strip())\n\nsession = requests.Session()\nfor domain, (key, value) in sid_cookies.items():\n    session.cookies.set(key, value, domain=domain)\n\n# Fetch bug contents\nissue_id = str(args.issue_id)\nbugurl = OSS_FUZZ_BUGURL + issue_id\nr = session.get(bugurl)\nr.raise_for_status()\n\n# Look for ID\npat = re.search(testcase_pattern, r.text)\nif not pat:\n    fatal('Cannot find testcase ID')\ntestcase_id = pat.group(1)\n\n# Look for type (IP, etc.)\npat = re.search(proto_pattern, r.text)\nif not pat:\n    # XXX maybe assume IP?\n    fatal('Protocol not found')\nprotocol = pat.group(1)\n\nattachment_name = None\n# Try to locate existing file\nfor prefix in [\"clusterfuzz-testcase-minimized-\", \"clusterfuzz-testcase-\"]:\n    for suffix in ['', '.pcap']:\n        name = prefix + testcase_id + suffix\n        if os.path.exists(name):\n            attachment_name = name\n            break\n\n# Download the attachment if missing\nif attachment_name is None:\n    att_url = DOWNLOAD_URL + testcase_id\n    r = session.get(att_url, stream=True)\n    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])\n    if not pat:\n        fatal('Cannot parse header: %s', r.headers['content-disposition'])\n    attachment_name = pat.group(1)\n    try:\n        # Open without overwriting existing contents.\n        with open(attachment_name, 'xb') as f:\n            for chunk in r.iter_content(chunk_size=4096):\n                f.write(chunk)\n        logging.info(\"Downloaded: %s\", attachment_name)\n    except FileExistsError:\n        # Ignore existing file.\n        pass\n\ncmd = [\n    \"oss-fuzz-report.py\",\n    \"--proto\", protocol,\n    attachment_name,\n    issue_id\n]\nif args.reporter_args:\n    cmd += args.reporter_args.split()\nfor name, arg_type in reporter_params:\n    value = getattr(args, name)\n    if value is not None:\n        cmd.append(\"--\" + name)\n        if arg_type:\n            cmd.append(str(value))\nprint(' '.join(cmd))\n\nos.execvp(cmd[0], cmd)\n/n/n/n", "label": 0}, {"id": "59fdbf02dac752fd22cb87eb4bea59d599b333dd", "code": "/grab-monorail.py/n/n#!/usr/bin/env python3\nimport argparse\nimport glob\nimport logging\nimport os\nimport re\nimport requests\nimport subprocess\nimport sys\n\nOSS_FUZZ_BUGURL = \"https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=\"\nDOWNLOAD_URL = 'https://oss-fuzz.com/download?testcase_id='\n\ntestcase_pattern = re.compile(r'https://oss-fuzz\\.com/testcase\\?key=(\\d+)')\nproto_pattern = r'\\bFuzzer: (?:afl|libFuzzer)_wireshark_fuzzshark_([a-z_-]+)\\b'\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable verbose logging\")\nparser.add_argument(\"--cookie-file\", \"-c\", help=\"File containing cookie value\")\n\n# Pass through options\nreporter_params = [\n    (\"report\", None),\n    (\"timeout\", int),\n    (\"memlimit\", int),\n    (\"memleaks\", None),\n]\nfor name, arg_type in reporter_params:\n    args = [\"--\" + name]\n    kwargs = {}\n    if arg_type:\n        kwargs[\"type\"] = arg_type\n    else:\n        kwargs[\"action\"] = \"store_true\"\n    kwargs[\"default\"] = None\n    kwargs[\"help\"] = \"Option is passed to the reporter\"\n    parser.add_argument(*args, **kwargs)\nparser.add_argument(\"--reporter-args\", \"-r\", help=\"Options to pass through\")\n\n\nparser.add_argument(\"issue_id\", type=int)\nargs = parser.parse_args()\n\nif args.debug:\n    logging.basicConfig(level=logging.DEBUG)\n\ndef fatal(*args):\n    logging.error(*args)\n    sys.exit(1)\n\ndef parse_cookies(text):\n    cookies = {}\n    for m in re.finditer(r'(SACSID)\\s+(~[0-9a-zA-Z_-]+)\\s+([a-z.-]+)(?:\\s|$)', text):\n        key, value, domain = m.groups()\n        cookies[domain] = (key, value)\n    # compatibility with Netscape cookie jar\n    garbage = r'(?:TRUE|FALSE)\\s+/\\s+(?:TRUE|FALSE)\\s+\\d+\\s+'\n    cj_pattern = r'([a-z.-]+)\\s+' + garbage + r'(SACSID)\\s+(~[0-9a-zA-Z_-]+)(?:\\s+|$)'\n    for m in re.finditer(cj_pattern, text):\n        domain, key, value = m.groups()\n        cookies[domain] = (key, value)\n    if any(not d in cookies for d in [\"bugs.chromium.org\", \"oss-fuzz.com\"]):\n        fatal(\"Missing domains, got: %s\", \" \".join(cookies.keys()))\n    return cookies\n\ncookie_file = args.cookie_file\nif not cookie_file:\n    # TODO maybe fallback to a default location?\n    parser.error(\"Missing cookie file\")\nsid_cookies = parse_cookies(open(cookie_file).read().strip())\n\nsession = requests.Session()\nfor domain, (key, value) in sid_cookies.items():\n    session.cookies.set(key, value, domain=domain)\n\n# Fetch bug contents\nissue_id = str(args.issue_id)\nbugurl = OSS_FUZZ_BUGURL + issue_id\nr = session.get(bugurl)\nr.raise_for_status()\n\n# Look for ID\npat = re.search(testcase_pattern, r.text)\nif not pat:\n    fatal('Cannot find testcase ID')\ntestcase_id = pat.group(1)\n\n# Look for type (IP, etc.)\npat = re.search(proto_pattern, r.text)\nif not pat:\n    # XXX maybe assume IP?\n    fatal('Protocol not found')\nprotocol = pat.group(1)\n\nattachment_name = None\n# Try to locate existing file\nfor prefix in [\"clusterfuzz-testcase-minimized-\", \"clusterfuzz-testcase-\"]:\n    for suffix in ['', '.pcap']:\n        name = prefix + testcase_id + suffix\n        if os.path.exists(name):\n            attachment_name = name\n            break\n\n# Download the attachment if missing\nif attachment_name is None:\n    att_url = DOWNLOAD_URL + testcase_id\n    r = session.get(att_url, stream=True)\n    pat = re.search(r'filename=([a-z0-9_-]+)', r.headers['content-disposition'])\n    if not pat:\n        fatal('Cannot parse header: %s', r.headers['content-disposition'])\n    attachment_name = pat.group(1)\n    try:\n        # Open without overwriting existing contents.\n        with open(attachment_name, 'xb') as f:\n            for chunk in r.iter_content(chunk_size=4096):\n                f.write(chunk)\n        logging.info(\"Downloaded: %s\", attachment_name)\n    except FileExistsError:\n        # Ignore existing file.\n        pass\n\ncmd = [\n    \"oss-fuzz-report.py\",\n    \"--proto\", protocol,\n    attachment_name,\n    issue_id\n]\nif args.reporter_args:\n    cmd += args.reporter_args.split()\nfor name, arg_type in reporter_params:\n    value = getattr(args, name)\n    if value is not None:\n        cmd.append(\"--\" + name)\n        if arg_type:\n            cmd.append(str(value))\nprint(' '.join(cmd))\n\nos.execvp(cmd[0], cmd)\n/n/n/n", "label": 1}, {"id": "398ed11584313a371763240392c4dda1cf986deb", "code": "core/logger.py/n/n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#-:-:-:-:-:-:-::-:-:#\n#    XSRF Probe     #\n#-:-:-:-:-:-:-::-:-:#\n\n# Author: 0xInfection\n# This module requires XSRFProbe\n# https://github.com/0xInfection/XSRFProbe\n\nimport os\nfrom core.colors import *\nfrom files.config import *\nfrom core.verbout import verbout\nfrom files.discovered import INTERNAL_URLS, FILES_EXEC, SCAN_ERRORS\nfrom files.discovered import VULN_LIST, FORMS_TESTED, REQUEST_TOKENS, STRENGTH_LIST\n\ndef logger(filename, content):\n    '''\n    This module is for logging all the stuff we found\n            while crawling and scanning.\n    '''\n    output_file = OUTPUT_DIR + filename + '.log'\n    with open(output_file, 'w+', encoding='utf8') as f:\n        if type(content) is tuple or type(content) is list:\n            for m in content:  # if it is list or tuple, it is iterable\n                f.write(m+'\\n')\n        else:\n            f.write(content)  # else we write out as it is... ;)\n        f.write('\\n')\n\ndef pheaders(tup):\n    '''\n    This module prints out the headers as received in the\n                    requests normally.\n    '''\n    verbout(GR, 'Receiving headers...\\n')\n    verbout(color.GREY,'  '+color.UNDERLINE+'HEADERS'+color.END+color.GREY+':'+'\\n')\n    for key, val in tup.items():\n        verbout('  ',color.CYAN+key+': '+color.ORANGE+val)\n    verbout('','')\n\ndef GetLogger():\n    if INTERNAL_URLS:\n        logger('internal-links', INTERNAL_URLS)\n    if SCAN_ERRORS:\n        logger('errored', SCAN_ERRORS)\n    if FILES_EXEC:\n        logger('files-found', FILES_EXEC)\n    if REQUEST_TOKENS:\n        logger('anti-csrf-tokens', REQUEST_TOKENS)\n    if FORMS_TESTED:\n        logger('forms-tested', FORMS_TESTED)\n    if VULN_LIST:\n        logger('vulnerabilities', VULN_LIST)\n    if STRENGTH_LIST:\n        logger('strengths', STRENGTH_LIST)\n\ndef ErrorLogger(url, error):\n    con = '(i) '+url+' -> '+error.__str__()\n    SCAN_ERRORS.append(con)\n\ndef VulnLogger(url, vuln):\n    tent = '[!] '+url+' -> '+vuln\n    VULN_LIST.append(tent)\n\ndef NovulLogger(url, strength):\n    tent = '[+] '+url+' -> '+strength\n    STRENGTH_LIST.append(tent)\n/n/n/ncore/main.py/n/n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#-:-:-:-:-:-:-:-:-:#\n#    XSRFProbe     #\n#-:-:-:-:-:-:-:-:-:#\n\n# Author: 0xInfection\n# This module requires XSRFProbe\n# https://github.com/0xInfection/XSRFProbe\n\n# Standard Package imports\nimport os\nimport re\nimport time\nimport warnings\nimport difflib\nimport http.cookiejar\nfrom bs4 import BeautifulSoup\ntry:\n    from urllib.parse import urlencode\n    from urllib.error import HTTPError, URLError\n    from urllib.request import build_opener, HTTPCookieProcessor\nexcept ImportError:  # Throws exception in Case of Python2\n    print(\"\\033[1;91m [-] \\033[1;93mXSRFProbe\\033[0m isn't compatible with Python 2.x versions.\\n\\033[1;91m [-] \\033[0mUse Python 3.x to run \\033[1;93mXSRFProbe.\")\n    quit()\ntry:\n    import requests, stringdist, lxml, bs4\nexcept ImportError:\n    print(' [-] Required dependencies are not installed.\\n [-] Run \\033[1;93mpip3 install -r requirements.txt\\033[0m to fix it.')\n\n# Imports from core\nfrom core.options import *\nfrom core.colors import *\nfrom core.inputin import inputin\nfrom core.request import Get, Post\nfrom core.verbout import verbout\nfrom core.forms import form10, form20\nfrom core.banner import banner, banabout\nfrom core.logger import ErrorLogger, GetLogger\nfrom core.logger import VulnLogger, NovulLogger\n\n# Imports from files\nfrom files.config import *\nfrom files.discovered import FORMS_TESTED\n\n# Imports from modules\nfrom modules import Debugger\nfrom modules import Parser\nfrom modules import Crawler\nfrom modules.Origin import Origin\nfrom modules.Cookie import Cookie\nfrom modules.Tamper import Tamper\nfrom modules.Entropy import Entropy\nfrom modules.Referer import Referer\nfrom modules.Encoding import Encoding\nfrom modules.Analysis import Analysis\nfrom modules.Checkpost import PostBased\n# Import Ends\n\n# First rule, remove the warnings!\nwarnings.filterwarnings('ignore')\n\ndef Engine():  # lets begin it!\n\n    os.system('clear')  # Clear shit from terminal :p\n    banner()  # Print the banner\n    banabout()  # The second banner\n    web, fld = inputin()  # Take the input\n    form1 = form10()  # Get the form 1 ready\n    form2 = form20()  # Get the form 2 ready\n\n    # For the cookies that we encounter during requests...\n    Cookie0 = http.cookiejar.CookieJar()  # First as User1\n    Cookie1 = http.cookiejar.CookieJar()  # Then as User2\n    resp1 = build_opener(HTTPCookieProcessor(Cookie0))  # Process cookies\n    resp2 = build_opener(HTTPCookieProcessor(Cookie1))  # Process cookies\n\n    actionDone = []  # init to the done stuff\n\n    csrf = ''  # no token initialise / invalid token\n    ref_detect = 0x00  # Null Char Flag\n    ori_detect = 0x00  # Null Char Flags\n    form = Debugger.Form_Debugger()  # init to the form parser+token generator\n\n    bs1 = BeautifulSoup(form1).findAll('form',action=True)[0]  # make sure the stuff works properly\n    bs2 = BeautifulSoup(form2).findAll('form',action=True)[0]  # same as above\n\n    init1 = web  # First init\n    resp1.open(init1)  # Makes request as User2\n    resp2.open(init1)  # Make request as User1\n\n    # Now there are 2 different modes of scanning and crawling here.\n    # 1st -> Testing a single endpoint without the --crawl flag.\n    # 2nd -> Testing all endpoints with the --crawl flag.\n    try:\n        # Implementing the first mode. [NO CRAWL]\n        if not CRAWL_SITE:\n            url = web\n            response = Get(url).text\n            try:\n                verbout(O,'Trying to parse response...')\n                soup = BeautifulSoup(response)  # Parser init\n            except HTMLParser.HTMLParseError:\n                verbout(R,'BeautifulSoup Error: '+url)\n            i = 0 # Init user number\n            if REFERER_ORIGIN_CHECKS:\n                # Referer Based Checks if True...\n                verbout(O, 'Checking endpoint request validation via '+color.GREY+'Referer'+color.END+' Checks...')\n                if Referer(url):\n                    ref_detect = 0x01\n                verbout(O, 'Confirming the vulnerability...')\n\n                # We have finished with Referer Based Checks, lets go for Origin Based Ones...\n                verbout(O, 'Confirming endpoint request validation via '+color.GREY+'Origin'+color.END+' Checks...')\n                if Origin(url):\n                    ori_detect = 0x01\n            if COOKIE_BASED:\n                Cookie(url)\n            # Now lets get the forms...\n            verbout(O, 'Retrieving all forms on ' +color.GREY+url+color.END+'...')\n            for m in Debugger.getAllForms(soup):  # iterating over all forms extracted\n                verbout(O,'Testing form:\\n\\n'+color.CYAN+' %s' % (m.prettify()))\n                FORMS_TESTED.append('(i) '+url+':\\n\\n'+m.prettify()+'\\n')\n                try:\n                    if m['action']:\n                        pass\n                except KeyError:\n                    m['action'] = '/' + url.rsplit('/', 1)[1]\n                    ErrorLogger(url, 'No standard form \"action\".')\n                action = Parser.buildAction(url, m['action'])  # get all forms which have 'action' attribute\n                if not action in actionDone and action!='':  # if url returned is not a null value nor duplicate...\n                    # If form submission is kept to True\n                    if FORM_SUBMISSION:\n                        try:\n                            # NOTE: Slow connections may cause read timeouts which may result in AttributeError\n                            result, genpoc = form.prepareFormInputs(m)  # prepare inputs\n                            r1 = Post(url, action, result).text  # make request with token values generated as user1\n                            result, genpoc = form.prepareFormInputs(m)  # prepare the input types\n                            r2 = Post(url, action, result).text  # again make request with token values generated as user2\n                            # Go for token based entropy checks...\n                            try:\n                                if m['name']:\n                                    query, token = Entropy(result, url, m['action'], m['name'])\n                            except KeyError:\n                                query, token = Entropy(result, url, m['action'])\n                            # Now its time to detect the encoding type (if any) of the Anti-CSRF token.\n                            fnd = Encoding(token)\n                            if fnd == 0x01:\n                                VulnLogger(url, 'Token is a string encoded value which can be probably decrypted.')\n                            else:\n                                NovulLogger(url, 'Anti-CSRF token is not a string encoded value.')\n                            # Go for token parameter tamper checks.\n                            if (query and token):\n                                Tamper(url, action, result, r2, query, token)\n                            o2 = resp2.open(url).read()  # make request as user2\n                            try:\n                                form2 = Debugger.getAllForms(BeautifulSoup(o2))[i]  # user2 gets his form\n                            except IndexError:\n                                verbout(R, 'Form Error')\n                                ErrorLogger(url, 'Form Index Error.')\n                                continue  # making sure program won't end here (dirty fix :( )\n                            verbout(GR, 'Preparing form inputs...')\n                            contents2, genpoc = form.prepareFormInputs(form2)  # prepare for form 2 as user2\n                            r3 = Post(url,action,contents2).text  # make request as user3 with user2's form\n                            if POST_BASED and not query and not token:\n                                try:\n                                    if m['name']:\n                                        PostBased(url, r1, r2, r3, m['action'], result, genpoc, m['name'])\n                                except KeyError:\n                                    PostBased(url, r1, r2, r3, m['action'], result, genpoc)\n                            else:\n                                print(color.GREEN+' [+] The form was requested with a Anti-CSRF token.')\n                                print(color.GREEN+' [+] Endpoint '+color.BG+' NOT VULNERABLE '+color.END+color.GREEN+' to POST-Based CSRF Attacks!')\n                                NovulLogger(url, 'Not vulnerable to POST-Based CSRF Attacks.')\n                        except HTTPError as msg:  # if runtime exception...\n                            verbout(R, 'Exception : '+msg.__str__())  # again exception :(\n                            ErrorLogger(url, msg)\n\n                actionDone.append(action)  # add the stuff done\n                i+=1  # Increase user iteration\n\n        else:\n            # Implementing the 2nd mode [CRAWLING AND SCANNING].\n            verbout(GR, \"Initializing crawling and scanning...\")\n            crawler = Crawler.Handler(init1, resp1)  # Init to the Crawler handler\n\n            while crawler.noinit():  # Until 0 urls left\n                url = next(crawler)  # Go for next!\n\n                print(C+'Testing :> '+color.CYAN+url)  # Display what url its crawling\n\n                try:\n                    soup = crawler.process(fld)  # Start the parser\n                    if not soup:\n                        continue  # Making sure not to end the program yet...\n                    i = 0  # Set count = 0 (user number 0, which will be subsequently incremented)\n                    if REFERER_ORIGIN_CHECKS:\n                        # Referer Based Checks if True...\n                        verbout(O, 'Checking endpoint request validation via '+color.GREY+'Referer'+color.END+' Checks...')\n                        if Referer(url):\n                            ref_detect = 0x01\n                        verbout(O, 'Confirming the vulnerability...')\n\n                        # We have finished with Referer Based Checks, lets go for Origin Based Ones...\n                        verbout(O, 'Confirming endpoint request validation via '+color.GREY+'Origin'+color.END+' Checks...')\n                        if Origin(url):\n                            ori_detect = 0x01\n\n                    if COOKIE_BASED:\n                        Cookie(url)\n\n                    # Now lets get the forms...\n                    verbout(O, 'Retrieving all forms on ' +color.GREY+url+color.END+'...')\n                    for m in Debugger.getAllForms(soup):  # iterating over all forms extracted\n                        FORMS_TESTED.append('(i) '+url+':\\n\\n'+m.prettify()+'\\n')\n                        try:\n                            if m['action']:\n                                pass\n                        except KeyError:\n                            m['action'] = '/' + url.rsplit('/', 1)[1]\n                            ErrorLogger(url, 'No standard \"action\" attribute.')\n                        action = Parser.buildAction(url, m['action'])  # get all forms which have 'action' attribute\n                        if not action in actionDone and action != '':  # if url returned is not a null value nor duplicate...\n                            # If form submission is kept to True\n                            if FORM_SUBMISSION:\n                                try:\n                                    result, genpoc = form.prepareFormInputs(m)  # prepare inputs\n                                    r1 = Post(url, action, result).text  # make request with token values generated as user1\n                                    result, genpoc = form.prepareFormInputs(m)  # prepare the input types\n                                    r2 = Post(url, action, result).text  # again make request with token values generated as user2\n                                    # Go for token based entropy checks...\n                                    try:\n                                        if m['name']:\n                                            query, token = Entropy(result, url, m['action'], m['name'])\n                                    except KeyError:\n                                        query, token = Entropy(result, url, m['action'])\n                                        ErrorLogger(url, 'No standard form \"name\".')\n                                    # Now its time to detect the encoding type (if any) of the Anti-CSRF token.\n                                    fnd = Encoding(token)\n                                    if fnd == 0x01:\n                                        VulnLogger(url, 'String encoded token value. Token might be decrypted.')\n                                    else:\n                                        NovulLogger(url, 'Anti-CSRF token is not a string encoded value.')\n                                    # Go for token parameter tamper checks.\n                                    if (query and token):\n                                        Tamper(url, action, result, r2, query, token)\n                                    o2 = resp2.open(url).read()  # make request as user2\n                                    try:\n                                        form2 = Debugger.getAllForms(BeautifulSoup(o2))[i]  # user2 gets his form\n                                    except IndexError:\n                                        verbout(R, 'Form Error')\n                                        ErrorLogger(url, 'Form Index Error.')\n                                        continue  # making sure program won't end here (dirty fix :( )\n                                    verbout(GR, 'Preparing form inputs...')\n                                    contents2, genpoc = form.prepareFormInputs(form2)  # prepare for form 2 as user2\n                                    r3 = Post(url,action,contents2).text  # make request as user3 with user2's form\n                                    if POST_BASED and not query and not token:\n                                        try:\n                                            if m['name']:\n                                                PostBased(url, r1, r2, r3, m['action'], result, genpoc, m['name'])\n                                        except KeyError:\n                                            PostBased(url, r1, r2, r3, m['action'], result, genpoc)\n                                    else:\n                                        print(color.GREEN+' [+] The form was requested with a Anti-CSRF token.')\n                                        print(color.GREEN+' [+] Endpoint '+color.BG+' NOT VULNERABLE '+color.END+color.GREEN+' to P0ST-Based CSRF Attacks!')\n                                        NovulLogger(url, 'Not vulnerable to POST-Based CSRF Attacks.')\n                                except HTTPError as msg:  # if runtime exception...\n                                    verbout(color.RED, ' [-] Exception : '+color.END+msg.__str__())  # again exception :(\n                                    ErrorLogger(url, msg)\n                        actionDone.append(action)  # add the stuff done\n                        i+=1  # Increase user iteration\n                except URLError as e:  # if again...\n                    verbout(R, 'Exception at : '+url)  # again exception -_-\n                    time.sleep(0.4)\n                    verbout(O, 'Moving on...')\n                    ErrorLogger(url, e)\n                    continue  # make sure it doesn't stop at exceptions\n                # This error usually happens when some sites are protected by some load balancer\n                # example Cloudflare. These domains return a 403 forbidden response in various\n                # contexts. For example when making reverse DNS queries.\n                except HTTPError as e:\n                    if str(e.code) == '403':\n                        verbout(R, 'HTTP Authentication Error!')\n                        verbout(R, 'Error Code : ' +O+ str(e.code))\n                        ErrorLogger(url, e)\n                        quit()\n        GetLogger()  # The scanning has finished, so now we can log out all the links ;)\n        print('\\n'+G+\"Scan completed!\"+'\\n')\n        Analysis()  # For Post Scan Analysis\n    except KeyboardInterrupt as e:  # Incase user wants to exit :') (while crawling)\n        verbout(R, 'User Interrupt!')\n        time.sleep(1.5)\n        Analysis()  # For Post scan Analysis\n        print(R+'Aborted!')  # say goodbye\n        ErrorLogger('KeyBoard Interrupt', 'Aborted')\n        quit()\n    except Exception as e:\n        verbout(R, e.__str__())\n        ErrorLogger(url, e)\n/n/n/ncore/options.py/n/n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#-:-:-:-:-:-:-::-:-:#\n#    XSRF Probe     #\n#-:-:-:-:-:-:-::-:-:#\n\n# Author: 0xInfection\n# This module requires XSRFProbe\n# https://github.com/0xInfection/XSRFProbe\n\n# Importing stuff\nimport argparse, sys, tld\nimport urllib.parse, os\nfrom files import config\nfrom core.colors import R, G\nfrom core.updater import updater\n\n# Processing command line arguments\nparser = argparse.ArgumentParser('python3 xsrfprobe.py')\nparser._action_groups.pop()\n\n# A simple hack to have required argumentsa and optional arguments separately\nrequired = parser.add_argument_group('Required Arguments')\noptional = parser.add_argument_group('Optional Arguments')\n\n# Required Options\nrequired.add_argument('-u', '--url', help='Main URL to test', dest='url')\n\n# Optional Arguments (main stuff and necessary)\noptional.add_argument('-c', '--cookie', help='Cookie value to be requested with each successive request. If there are multiple cookies, separate them with commas. For example: `-c PHPSESSID=i837c5n83u4, _gid=jdhfbuysf`.', dest='cookie')\noptional.add_argument('-o', '--output', help='Output directory where files to be stored. Default is the`files` folder where all files generated will be stored.', dest='output')\noptional.add_argument('-d', '--delay', help='Time delay between requests in seconds. Default is zero.', dest='delay', type=float)\noptional.add_argument('-q', '--quiet', help='Set the DEBUG mode to quiet. Report only when vulnerabilities are found. Minimal output will be printed on screen. ', dest='quiet', action='store_true')\noptional.add_argument('-v', '--verbose', help='Increase the verbosity of the output (e.g., -vv is more than -v). ', dest='verbose', action='store_true')\n\n# Other Options\n# optional.add_argument('-h', '--help', help='Show this help message and exit', dest='disp', default=argparse.SUPPRESS, action='store_true')\noptional.add_argument('--user-agent', help='Custom user-agent to be used. Only one user-agent can be specified.', dest='user_agent', type=str)\noptional.add_argument('--headers', help='Comma separated list of custom headers you\\'d want to use. For example: ``--headers \"Accept=text/php, X-Requested-With=Dumb\"``.', dest='headers', type=str)\noptional.add_argument('--exclude', help='Comma separated list of paths or directories to be excluded which are not in scope. These paths/dirs won\\'t be scanned. For example: `--exclude somepage/, sensitive-dir/, pleasedontscan/`', dest='exclude', type=str)\noptional.add_argument('--timeout', help='HTTP request timeout value in seconds. The entered value must be in floating point decimal. Example: ``--timeout 10.0``', dest='timeout', type=float)\noptional.add_argument('--max-chars', help='Maximum allowed character length for the custom token value to be generated. For example: `--max-chars 5`. Default value is 6.', dest='maxchars', type=int)\noptional.add_argument('--crawl', help=\"Crawl the whole site and simultaneously test all discovered endpoints for CSRF.\", dest='crawl', action='store_true')\noptional.add_argument('--skip-analysis', help='Skip the Post-Scan Analysis of Tokens which were gathered during requests', dest='skipal', action='store_true')\noptional.add_argument('--skip-poc', help='Skip the PoC Form Generation of POST-Based Cross Site Request Forgeries.', dest='skippoc', action='store_true')\noptional.add_argument('--display', help='Print out response headers of requests while making requests.', dest='disphead', action='store_true')\noptional.add_argument('--update', help='Update XSRFProbe to latest version on GitHub via git.', dest='update', action='store_true')\noptional.add_argument('--random-agent', help='Use random user-agents for making requests.', dest='randagent', action='store_true')\noptional.add_argument('--version', help='Display the version of XSRFProbe and exit.', dest='version', action='store_true')\nargs = parser.parse_args()\n\nif not len(sys.argv) > 1:\n    print('''\n    \\033[1;91mXSRFProbe\\033[0m, \\033[1;97mA \\033[1;93mCross Site Request Forgery \\033[1;97mAudit Toolkit\\033[0m\n''')\n    parser.print_help()\n    quit('')\n\n# Update XSRFProbe to latest version\nif args.update:\n    updater()\n    quit('')\n\n# Print out XSRFProbe version\nif args.version:\n    print('\\n\\033[1;97m [+] \\033[1;91mXSRFProbe Version\\033[0m : \\033[1;97m'+open('files/VersionNum').read())\n    quit()\n\n# Now lets update some global config variables\nif args.maxchars:\n    config.TOKEN_GENERATION_LENGTH = args.maxchars\n\n# Setting custom user-agent\nif args.user_agent:\n    config.USER_AGENT = args.user_agent\n\n# Option to skip analysis\nif args.skipal:\n    config.SCAN_ANALYSIS = False\n\n# Option to skip poc generation\nif args.skippoc:\n    config.POC_GENERATION = False\n\n# Updating main root url\nif not args.version and not args.update:\n    if args.url: # and not args.help:\n        if 'http' in args.url:\n            config.SITE_URL = args.url\n        else:\n            config.SITE_URL = 'http://'+args.url\n    else:\n        print(R+'You must supply a url/endpoint.')\n\n# Crawl the site if --crawl supplied.\nif args.crawl:\n    config.CRAWL_SITE = True\n    # Turning off the display header feature due to too much log generation.\n    config.DISPLAY_HEADERS = False\n\nif args.cookie:\n    # Assigning Cookie\n    if ',' in args.cookie:\n        for cook in args.cookie.split(','):\n            config.COOKIE_VALUE.append(cook.strip())\n            # This is necessary when a cookie value is supplied\n            # Since if the user-agent used to make the request changes\n            # from time to time, the remote site might trigger up\n            # security mechanisms (or worse, perhaps block your ip?)\n            config.USER_AGENT_RANDOM = False\n\n# Set the headers displayer to 1 (actively display headers)\nif args.disphead:\n    config.DISPLAY_HEADERS = True\n\n# Timeout value\nif args.timeout:\n    config.TIMEOUT_VALUE = args.timeout\n\n# Custom header values if specified\nif args.headers:\n    # NOTE: As a default idea, when the user supplies custom headers, we\n    # simply add the custom headers to a list of existing headers in\n    # files/config.py.\n    # Uncomment the following lines to just reinitialise the headers everytime\n    # they make a request.\n    #\n    #config.HEADER_VALUES = {}\n    for m in args.headers.split(','):\n        config.HEADER_VALUES[m.split('=')[0]] = m.split('=')[1]  # nice hack ;)\n\nif args.exclude:\n    exc = args.exclude\n    #config.EXCLUDE_URLS = [s for s in exc.split(',').strip()]\n    m = exc.split(',').strip()\n    for s in m:\n        config.EXCLUDE_DIRS.append(urllib.parse.urljoin(config.SITE_URL, s))\n\nif args.randagent:\n    # If random-agent argument supplied...\n    config.USER_AGENT_RANDOM = True\n    # Turn off a single User-Agent mechanism...\n    config.USER_AGENT = ''\n\nif config.SITE_URL:\n    if args.output:\n        # If output directory is mentioned...\n        try:\n            if not os.path.exists(args.output+tld.get_fld(config.SITE_URL)):\n                os.makedirs(args.output+tld.get_fld(config.SITE_URL))\n        except FileExistsError:\n            pass\n        config.OUTPUT_DIR = args.output+tld.get_fld(config.SITE_URL) + '/'\n    else:\n        try:\n            os.makedirs(tld.get_fld(config.SITE_URL))\n        except FileExistsError:\n            pass\n        config.OUTPUT_DIR = tld.get_fld(config.SITE_URL) + '/'\n\nif args.quiet:\n    config.DEBUG = False\n/n/n/ncore/utils.py/n/n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#-:-:-:-:-:-:-:-:-:#\n#    XSRFProbe     #\n#-:-:-:-:-:-:-:-:-:#\n\n# Author: 0xInfection\n# This module requires XSRFProbe\n# https://github.com/0xInfection/XSRFProbe\n\nfrom difflib import SequenceMatcher\n\ndef sameSequence(str1,str2):\n    '''\n    This function is intended to find same sequence\n                between str1 and str2.\n    '''\n    # Initialize SequenceMatcher object with\n    # Input string\n    seqMatch = SequenceMatcher(None, str1, str2)\n\n    # Find match of longest sub-string\n    # Output will be like Match(a=0, b=0, size=5)\n    match = seqMatch.find_longest_match(0, len(str1), 0, len(str2))\n\n    # Print longest substring\n    if (match.size!=0):\n        return (str1[match.a: match.a + match.size])\n    else:\n        return ''\n\ndef replaceStrIndex(text, index=0, replacement=''):\n    '''\n    This method returns a tampered string by\n                    replacement\n    '''\n    return '%s%s%s' % (text[:index], replacement, text[index+1:])\n\ndef checkDuplicates(iterable):\n    '''\n    This function works as a byte sequence checker for\n            tuples passed onto this function.\n    '''\n    seen = set()\n    for x in iterable:\n        if x in seen:\n            return True\n        seen.add(x)\n    return False\n\ndef byteString(s, encoding='utf8'):\n    \"\"\"\n    Return a byte-string version of 's',\n            Encoded as utf-8.\n    \"\"\"\n    try:\n        s = s.encode(encoding)\n    except (UnicodeEncodeError, UnicodeDecodeError):\n        s = str(s)\n    return s\n\ndef subSequence(str1,str2):\n    '''\n    Returns whether 'str1' and 'str2' are subsequence\n                    of one another.\n    '''\n    j = 0    # Index of str1\n    i = 0    # Index of str2\n\n    # Traverse both str1 and str2\n    # Compare current character of str2 with\n    # First unmatched character of str1\n    # If matched, then move ahead in str1\n    m = len(str1)\n    n = len(str2)\n    while j<m and i<n:\n        if str1[j] == str2[i]:\n            j = j+1\n        i = i + 1\n\n    # If all characters of str1 matched, then j is equal to m\n    return j==m\n/n/n/n", "label": 0}, {"id": "398ed11584313a371763240392c4dda1cf986deb", "code": "/core/logger.py/n/n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#-:-:-:-:-:-:-::-:-:#\n#    XSRF Probe     #\n#-:-:-:-:-:-:-::-:-:#\n\n# Author: 0xInfection\n# This module requires XSRFProbe\n# https://github.com/0xInfection/XSRFProbe\n\nimport os\nfrom core.colors import *\nfrom files.config import *\nfrom core.verbout import verbout\nfrom files.discovered import INTERNAL_URLS, FILES_EXEC, SCAN_ERRORS\nfrom files.discovered import VULN_LIST, FORMS_TESTED, REQUEST_TOKENS\n\ndef logger(filename, content):\n    '''\n    This module is for logging all the stuff we found\n            while crawling and scanning.\n    '''\n    output_file = OUTPUT_DIR + filename + '.log'\n    with open(output_file, 'w+', encoding='utf8') as f:\n        if type(content) is tuple or type(content) is list:\n            for m in content:  # if it is list or tuple, it is iterable\n                f.write(m+'\\n')\n        else:\n            f.write(content)  # else we write out as it is... ;)\n        f.write('\\n')\n\ndef pheaders(tup):\n    '''\n    This module prints out the headers as received in the\n                    requests normally.\n    '''\n    verbout(GR, 'Receiving headers...\\n')\n    verbout(color.GREY,'  '+color.UNDERLINE+'HEADERS'+color.END+color.GREY+':'+'\\n')\n    for key, val in tup.items():\n        verbout('  ',color.CYAN+key+': '+color.ORANGE+val)\n    verbout('','')\n\ndef GetLogger():\n    if INTERNAL_URLS:\n        logger('internal-links', INTERNAL_URLS)\n    if SCAN_ERRORS:\n        logger('errored', SCAN_ERRORS)\n    if FILES_EXEC:\n        logger('files-found', FILES_EXEC)\n    if REQUEST_TOKENS:\n        logger('anti-csrf-tokens', REQUEST_TOKENS)\n    if FORMS_TESTED:\n        logger('forms-tested', FORMS_TESTED)\n    if VULN_LIST:\n        logger('vulnerabilities', VULN_LIST)\n\ndef ErrorLogger(url, error):\n    con = '(i) '+url+' -> '+error.__str__()\n    SCAN_ERRORS.append(con)\n\ndef VulnLogger(url, vuln):\n    tent = '[!] '+url+' -> '+vuln\n    VULN_LIST.append(tent)\n/n/n/n/core/options.py/n/n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n#-:-:-:-:-:-:-::-:-:#\n#    XSRF Probe     #\n#-:-:-:-:-:-:-::-:-:#\n\n# Author: 0xInfection\n# This module requires XSRFProbe\n# https://github.com/0xInfection/XSRFProbe\n\n# Importing stuff\nimport argparse, sys, tld\nimport urllib.parse, os\nfrom files import config\nfrom core.colors import R, G\nfrom core.updater import updater\n\n# Processing command line arguments\nparser = argparse.ArgumentParser('python3 xsrfprobe.py')\nparser._action_groups.pop()\n\n# A simple hack to have required argumentsa and optional arguments separately\nrequired = parser.add_argument_group('Required Arguments')\noptional = parser.add_argument_group('Optional Arguments')\n\n# Required Options\nrequired.add_argument('-u', '--url', help='Main URL to test', dest='url')\n\n# Optional Arguments (main stuff and necessary)\noptional.add_argument('-c', '--cookie', help='Cookie value to be requested with each successive request. If there are multiple cookies, separate them with commas. For example: `-c PHPSESSID=i837c5n83u4, _gid=jdhfbuysf`.', dest='cookie')\noptional.add_argument('-o', '--output', help='Output directory where files to be stored. Default is the`files` folder where all files generated will be stored.', dest='output')\noptional.add_argument('-d', '--delay', help='Time delay between requests in seconds. Default is zero.', dest='delay', type=float)\noptional.add_argument('-q', '--quiet', help='Set the DEBUG mode to quiet. Report only when vulnerabilities are found. Minimal output will be printed on screen. ', dest='quiet', action='store_true')\noptional.add_argument('-v', '--verbose', help='Increase the verbosity of the output (e.g., -vv is more than -v). ', dest='verbose', action='store_true')\n\n# Other Options\n# optional.add_argument('-h', '--help', help='Show this help message and exit', dest='disp', default=argparse.SUPPRESS, action='store_true')\noptional.add_argument('--user-agent', help='Custom user-agent to be used. Only one user-agent can be specified.', dest='user_agent', type=str)\noptional.add_argument('--headers', help='Comma separated list of custom headers you\\'d want to use. For example: ``--headers \"Accept=text/php, X-Requested-With=Dumb\"``.', dest='headers', type=str)\noptional.add_argument('--exclude', help='Comma separated list of paths or directories to be excluded which are not in scope. These paths/dirs won\\'t be scanned. For example: `--exclude somepage/, sensitive-dir/, pleasedontscan/`', dest='exclude', type=str)\noptional.add_argument('--timeout', help='HTTP request timeout value in seconds. The entered value must be in floating point decimal. Example: ``--timeout 10.0``', dest='timeout', type=float)\noptional.add_argument('--max-chars', help='Maximum allowed character length for the custom token value to be generated. For example: `--max-chars 5`. Default value is 6.', dest='maxchars', type=int)\noptional.add_argument('--crawl', help=\"Crawl the whole site and simultaneously test all discovered endpoints for CSRF.\", dest='crawl', action='store_true')\noptional.add_argument('--skip-analysis', help='Skip the Post-Scan Analysis of Tokens which were gathered during requests', dest='skipal', action='store_true')\noptional.add_argument('--skip-poc', help='Skip the PoC Form Generation of POST-Based Cross Site Request Forgeries.', dest='skippoc', action='store_true')\noptional.add_argument('--update', help='Update XSRFProbe to latest version on GitHub via git.', dest='update', action='store_true')\noptional.add_argument('--random-agent', help='Use random user-agents for making requests.', dest='randagent', action='store_true')\noptional.add_argument('--version', help='Display the version of XSRFProbe and exit.', dest='version', action='store_true')\nargs = parser.parse_args()\n\nif not len(sys.argv) > 1:\n    print('''\n    \\033[1;91mXSRFProbe\\033[0m, \\033[1;97mA \\033[1;93mCross Site Request Forgery \\033[1;97mAudit Toolkit\\033[0m\n''')\n    parser.print_help()\n    quit('')\n\n# Update XSRFProbe to latest version\nif args.update:\n    updater()\n    quit('')\n\n# Print out XSRFProbe version\nif args.version:\n    print('\\n\\033[1;97m [+] \\033[1;91mXSRFProbe Version\\033[0m : \\033[1;97m'+open('files/VersionNum').read())\n    quit()\n\n# Now lets update some global config variables\nif args.maxchars:\n    config.TOKEN_GENERATION_LENGTH = args.maxchars\n\n# Setting custom user-agent\nif args.user_agent:\n    config.USER_AGENT = args.user_agent\n\n# Option to skip analysis\nif args.skipal:\n    config.SCAN_ANALYSIS = False\n\n# Option to skip poc generation\nif args.skippoc:\n    config.POC_GENERATION = False\n\n# Updating main root url\nif not args.version and not args.update:\n    if args.url: # and not args.help:\n        if 'http' in args.url:\n            config.SITE_URL = args.url\n        else:\n            config.SITE_URL = 'http://'+args.url\n    else:\n        print(R+'You must supply a url/endpoint.')\n\n# Crawl the site if --crawl supplied.\nif args.crawl:\n    config.CRAWL_SITE = True\n\nif args.cookie:\n    # Assigning Cookie\n    if ',' in args.cookie:\n        for cook in args.cookie.split(','):\n            config.COOKIE_VALUE.append(cook.strip())\n            # This is necessary when a cookie value is supplied\n            # Since if the user-agent used to make the request changes\n            # from time to time, the remote site might trigger up\n            # security mechanisms (or worse, perhaps block your ip?)\n            config.USER_AGENT_RANDOM = False\n\n# Timeout value\nif args.timeout:\n    config.TIMEOUT_VALUE = args.timeout\n\n# Custom header values if specified\nif args.headers:\n    # NOTE: As a default idea, when the user supplies custom headers, we\n    # simply add the custom headers to a list of existing headers in\n    # files/config.py.\n    # Uncomment the following lines to just reinitialise the headers everytime\n    # they make a request.\n    #\n    #config.HEADER_VALUES = {}\n    for m in args.headers.split(','):\n        config.HEADER_VALUES[m.split('=')[0]] = m.split('=')[1]\n\nif args.exclude:\n    exc = args.exclude\n    #config.EXCLUDE_URLS = [s for s in exc.split(',').strip()]\n    m = exc.split(',').strip()\n    for s in m:\n        config.EXCLUDE_DIRS.append(urllib.parse.urljoin(config.SITE_URL, s))\n\nif args.randagent:\n    # If random-agent argument supplied...\n    config.USER_AGENT_RANDOM = True\n    # Turn off a single User-Agent mechanism...\n    config.USER_AGENT = ''\n\nif config.SITE_URL:\n    if args.output:\n        # If output directory is mentioned...\n        try:\n            if not os.path.exists(args.output+tld.get_fld(config.SITE_URL)):\n                os.makedirs(args.output+tld.get_fld(config.SITE_URL))\n        except FileExistsError:\n            pass\n        config.OUTPUT_DIR = args.output+tld.get_fld(config.SITE_URL) + '/'\n    else:\n        try:\n            os.makedirs(tld.get_fld(config.SITE_URL))\n        except FileExistsError:\n            pass\n        config.OUTPUT_DIR = tld.get_fld(config.SITE_URL) + '/'\n\nif args.quiet:\n    config.DEBUG = False\n/n/n/n", "label": 1}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token\n                                 expires. Defaults to 300 seconds.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n\nOAUTHCLIENT_STATE_EXPIRES = 300\n\"\"\"Number of seconds after which the state token expires.\"\"\"\n/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate',\n                              'show_login': 'true'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef get_session_next_url(remote_app):\n    return session.get(\n        \"%s_%s\" % (token_session_key(remote_app), \"next_url\")\n    )\n\n\ndef set_session_next_url(remote_app, url):\n    session[\"%s_%s\" % (token_session_key(remote_app), \"next_url\")] = \\\n        url\n\n\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    next_url = get_session_next_url(remote.name)\n    if next_url:\n        return redirect(next_url)\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        next_url = get_session_next_url(remote.name)\n        if next_url:\n            return redirect(next_url)\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite\nfrom mock import MagicMock, Mock, patch\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nclass FormTestCase(InvenioTestCase):\n\n    @patch('invenio.modules.oauthclient.forms.User')\n    def test_validate_email(self, user):\n        from invenio.modules.oauthclient.forms import EmailSignUpForm\n\n        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())\n\n        # Mock query\n        obj = MagicMock()\n        obj.one = MagicMock(side_effect=SQLAlchemyError())\n        user.query.filter = Mock(return_value=obj)\n        self.assertTrue(\n            EmailSignUpForm(email='good@invenio-software.org').validate()\n        )\n\n        user.query.filter = MagicMock()\n        self.assertFalse(\n            EmailSignUpForm(email='bad@invenio-software.org').validate()\n        )\n\n\nTEST_SUITE = make_test_suite(FormTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nimport time\nfrom flask import url_for, session\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sqlalchemy import db\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom itsdangerous import TimedJSONWebSignatureSerializer\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import parse_qs, urlparse\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_redirect_uri(self):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test',\n                    next='http://invenio-software.org')\n        )\n        self.assertStatus(resp, 302)\n\n        # Verify parameters\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Verify next parameter in state token does not allow blanco redirects\n        state = serializer.loads(params['state'][0])\n        self.assertIsNone(state['next'])\n\n        # Assert redirect uri does not have any parameters.\n        params = parse_qs(urlparse(params['redirect_uri'][0]).query)\n        self.assertEqual(params, {})\n\n        # Assert that local redirects are allowed\n        test_urls = [\n            '/search',\n            url_for('oauthclient.disconnect', remote_app='test',\n                    _external=True)\n        ]\n        for url in test_urls:\n            resp = self.client.get(\n                url_for(\"oauthclient.login\", remote_app='test', next=url)\n            )\n            self.assertStatus(resp, 302)\n            state = serializer.loads(\n                parse_qs(urlparse(resp.location).query)['state'][0]\n            )\n            self.assertEqual(url, state['next'])\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test', next='/')\n        )\n        self.assertStatus(resp, 302)\n\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            from invenio.modules.oauthclient.views.client import serializer\n\n            state = serializer.dumps({\n                'app': 'test',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                    state=state\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            state = serializer.dumps({\n                'app': 'test_invalid',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                    state=state,\n                )\n            )\n\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_state_token(self, session):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Mock session id\n        session.sid = '1234'\n\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n\n            # Good state token\n            state = serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            resp = c.get(\n                url_for(\"oauthclient.authorized\", remote_app='test',\n                        code='test', state=state)\n            )\n            self.assert200(resp)\n\n            outdated_serializer = TimedJSONWebSignatureSerializer(\n                cfg['SECRET_KEY'],\n                expires_in=0,\n            )\n\n            # Bad state - timeout\n            state1 = outdated_serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - app\n            state2 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test_invalid', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - sid\n            state3 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test', 'sid': 'bad',  'next': None, }\n            )\n            time.sleep(1)\n            for s in [state1, state2, state3]:\n                resp = c.get(\n                    url_for(\"oauthclient.authorized\", remote_app='test',\n                            code='test', state=s)\n                )\n                self.assert403(resp)\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_token_getter_setter(self, session, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                state = parse_qs(urlparse(res.location).query)['state'][0]\n\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state,\n                ))\n\n                # Assert if everything is as it should be.\n                from flask import session as flask_session\n                assert flask_session['oauth_token_full'] == \\\n                    ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                # Mock a new authorized request\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_rejected(self, session, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user id\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                from invenio.modules.oauthclient.views.client import serializer\n                state = serializer.dumps({\n                    'app': 'full', 'sid': '1234',  'next': None,\n                })\n\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Client blueprint used to handle OAuth callbacks.\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, request, session, url_for\nfrom flask.ext.login import user_logged_out\nfrom itsdangerous import TimedJSONWebSignatureSerializer, BadData\nfrom werkzeug.local import LocalProxy\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\nfrom invenio.utils.url import get_safe_redirect_target\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler, \\\n    set_session_next_url\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\nserializer = LocalProxy(\n    lambda: TimedJSONWebSignatureSerializer(\n        cfg['SECRET_KEY'],\n        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],\n    )\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\"Setup OAuth clients.\"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\"Send user to remote application for authentication.\"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    # Get redirect target in safe manner.\n    next_param = get_safe_redirect_target(arg='next')\n\n    # Redirect URI - must be registered in the remote service.\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        _external=True,\n    )\n\n    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES\n    # seconds.\n    state_token = serializer.dumps({\n        'app': remote_app,\n        'next': next_param,\n        'sid': session.sid,\n    })\n\n    return oauth.remote_apps[remote_app].authorize(\n        callback=callback_url,\n        state=state_token,\n    )\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\"Authorized handler callback.\"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n\n    state_token = request.args.get('state')\n\n    # Verify state parameter\n    try:\n        assert state_token\n        # Checks authenticity and integrity of state and decodes the value.\n        state = serializer.loads(state_token)\n        # Verify that state is for this session, app and that next parameter\n        # have not been modified.\n        assert state['sid'] == session.sid\n        assert state['app'] == remote_app\n        # Store next URL\n        set_session_next_url(remote_app, state['next'])\n    except (AssertionError, BadData):\n        abort(403)\n\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\"Extra signup step.\"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\"Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"\nurlutils.py -- helper functions for URL related problems such as\nargument washing, redirection, etc.\n\"\"\"\n\n__revision__ = \"$Id$\"\n\nimport time\nimport base64\nimport hmac\nimport re\nimport sys\nimport os\nimport inspect\nimport urllib\nimport urllib2\nfrom urllib import urlencode, quote_plus, quote, FancyURLopener\nfrom six.moves.urllib.parse import urlparse, urlunparse\nfrom cgi import parse_qs, parse_qsl, escape\nfrom werkzeug import cached_property\nfrom werkzeug.local import LocalProxy\n\ntry:\n    import BeautifulSoup\n    BEAUTIFUL_SOUP_IMPORTED = True\nexcept ImportError:\n    BEAUTIFUL_SOUP_IMPORTED = False\n\nfrom invenio.base.globals import cfg\nfrom invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED\nfrom invenio.utils.text import wash_for_utf8\nfrom invenio.utils import apache\n\n\ndef wash_url_argument(var, new_type):\n    \"\"\"\n    Wash argument into 'new_type', that can be 'list', 'str',\n                                               'int', 'tuple' or 'dict'.\n    If needed, the check 'type(var) is not None' should be done before\n    calling this function.\n    @param var: variable value\n    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'\n    @return: as much as possible, value var as type new_type\n            If var is a list, will change first element into new_type.\n            If int check unsuccessful, returns 0\n    \"\"\"\n    out = []\n    if new_type == 'list':  # return lst\n        if isinstance(var, list):\n            out = var\n        else:\n            out = [var]\n    elif new_type == 'str':  # return str\n        if isinstance(var, list):\n            try:\n                out = \"%s\" % var[0]\n            except:\n                out = \"\"\n        elif isinstance(var, str):\n            out = var\n        else:\n            out = \"%s\" % var\n    elif new_type == 'int': # return int\n        if isinstance(var, list):\n            try:\n                out = int(var[0])\n            except:\n                out = 0\n        elif isinstance(var, (int, long)):\n            out = var\n        elif isinstance(var, str):\n            try:\n                out = int(var)\n            except:\n                out = 0\n        else:\n            out = 0\n    elif new_type == 'tuple': # return tuple\n        if isinstance(var, tuple):\n            out = var\n        else:\n            out = (var, )\n    elif new_type == 'dict': # return dictionary\n        if isinstance(var, dict):\n            out = var\n        else:\n            out = {0: var}\n    return out\n\n\nfrom urlparse import urlparse, urljoin\nfrom flask import request, url_for\n\ndef is_local_url(target):\n    \"\"\"Determine if URL is a local.\"\"\"\n    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))\n    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))\n    return test_url.scheme in ('http', 'https') and \\\n           ref_url.netloc == test_url.netloc\n\n\ndef get_safe_redirect_target(arg='next'):\n    \"\"\"Get URL to redirect to and ensure that it is local.\"\"\"\n    for target in request.args.get(arg), request.referrer:\n        if not target:\n            continue\n        if is_local_url(target):\n            return target\n    return None\n\n\ndef redirect_to_url(req, url, redirection_type=None, norobot=False):\n    \"\"\"\n    Redirect current page to url.\n    @param req: request as received from apache\n    @param url: url to redirect to\n    @param redirection_type: what kind of redirection is required:\n    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300\n          apache.HTTP_MOVED_PERMANENTLY            = 301\n          apache.HTTP_MOVED_TEMPORARILY            = 302\n          apache.HTTP_SEE_OTHER                    = 303\n          apache.HTTP_NOT_MODIFIED                 = 304\n          apache.HTTP_USE_PROXY                    = 305\n          apache.HTTP_TEMPORARY_REDIRECT           = 307\n    The default is apache.HTTP_MOVED_TEMPORARILY\n    @param norobot: wether to instruct crawlers and robots such as GoogleBot\n        not to index past this point.\n    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3\n    \"\"\"\n    url = url.strip()\n    if redirection_type is None:\n        redirection_type = apache.HTTP_MOVED_TEMPORARILY\n\n    from flask import redirect\n    r = redirect(url, code=redirection_type)\n    raise apache.SERVER_RETURN, r\n    #FIXME enable code bellow\n\n    del req.headers_out[\"Cache-Control\"]\n    req.headers_out[\"Cache-Control\"] = \"no-cache, private, no-store, \" \\\n        \"must-revalidate, post-check=0, pre-check=0, max-age=0\"\n    req.headers_out[\"Pragma\"] = \"no-cache\"\n\n    if norobot:\n        req.headers_out[\"X-Robots-Tag\"] = \"noarchive, nosnippet, noindex, nocache\"\n\n    user_agent = req.headers_in.get('User-Agent', '')\n    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:\n        ## HACK: this is to workaround Microsoft Office trying to be smart\n        ## when users click on URLs in Office documents that require\n        ## authentication. Office will check the validity of the URL\n        ## but will pass the browser the redirected URL rather than\n        ## the original one. This is incompatible with e.g. Shibboleth\n        ## based SSO since the referer would be lost.\n        ## See: http://support.microsoft.com/kb/899927\n        req.status = 200\n        req.content_type = 'text/html'\n        if req.method != 'HEAD':\n            req.write(\"\"\"\n<html>\n    <head>\n        <title>Intermediate page for URLs clicked on MS Office Documents</title>\n        <meta http-equiv=\"REFRESH\" content=\"5;url=%(url)s\"></meta>\n    </head>\n    <body>\n        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=\"%(url)s\">%(url_ok)s</a>.</p>\n    </body>\n</html>\"\"\" % {\n                'url': escape(req.unparsed_uri, True),\n                'url_ok': escape(req.unparsed_uri)\n            })\n        raise apache.SERVER_RETURN(apache.DONE)\n\n    req.headers_out[\"Location\"] = url\n\n    if req.response_sent_p:\n        raise IOError(\"Cannot redirect after headers have already been sent.\")\n\n    req.status = redirection_type\n    req.write('<p>Please go to <a href=\"%s\">here</a></p>\\n' % url)\n\n    raise apache.SERVER_RETURN, apache.DONE\n\n\ndef rewrite_to_secure_url(url, secure_base=None):\n    \"\"\"\n    Rewrite URL to a Secure URL\n\n    @param url URL to be rewritten to a secure URL.\n    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).\n    \"\"\"\n    if secure_base is None:\n        secure_base = cfg.get('CFG_SITE_SECURE_URL')\n    url_parts = list(urlparse(url))\n    url_secure_parts = urlparse(secure_base)\n    url_parts[0] = url_secure_parts[0]\n    url_parts[1] = url_secure_parts[1]\n    return urlunparse(url_parts)\n\n\ndef get_referer(req, replace_ampersands=False):\n    \"\"\" Return the referring page of a request.\n    Referer (wikipedia): Referer is a common misspelling of the word\n    \"referrer\"; so common, in fact, that it made it into the official\n    specification of HTTP. When visiting a webpage, the referer or\n    referring page is the URL of the previous webpage from which a link was\n    followed.\n    @param req: request\n    @param replace_ampersands: if 1, replace & by &amp; in url\n                               (correct HTML cannot contain & characters alone)\n    \"\"\"\n    try:\n        referer = req.headers_in['Referer']\n        if replace_ampersands == 1:\n            return referer.replace('&', '&amp;')\n        return referer\n    except KeyError:\n        return ''\n\n\ndef drop_default_urlargd(urlargd, default_urlargd):\n    lndefault = {}\n    lndefault.update(default_urlargd)\n\n    ## Commented out. An Invenio URL now should always specify the desired\n    ## language, in order not to raise the automatic language discovery\n    ## (client browser language can be used now in place of CFG_SITE_LANG)\n    # lndefault['ln'] = (str, CFG_SITE_LANG)\n\n    canonical = {}\n    canonical.update(urlargd)\n\n    for k, v in urlargd.items():\n        try:\n            d = lndefault[k]\n\n            if d[1] == v:\n                del canonical[k]\n\n        except KeyError:\n            pass\n\n    return canonical\n\n\ndef make_canonical_urlargd(urlargd, default_urlargd):\n    \"\"\" Build up the query part of an URL from the arguments passed in\n    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which\n    contains tuples of the form (type, default value) for the query\n    arguments (this is the same dictionary as the one you can pass to\n    webinterface_handler.wash_urlargd).\n\n    When a query element has its default value, it is discarded, so\n    that the simplest (canonical) url query is returned.\n\n    The result contains the initial '?' if there are actual query\n    items remaining.\n    \"\"\"\n\n    canonical = drop_default_urlargd(urlargd, default_urlargd)\n\n    if canonical:\n        return '?' + urlencode(canonical, doseq=True)\n        #FIXME double escaping of '&'? .replace('&', '&amp;')\n\n    return ''\n\n\ndef create_html_link(urlbase, urlargd, link_label, linkattrd=None,\n                     escape_urlargd=True, escape_linkattrd=True,\n                     urlhash=None):\n    \"\"\"Creates a W3C compliant link.\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})\n    @param link_label: text displayed in a browser (has to be already escaped)\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    attributes_separator = ' '\n    output = '<a href=\"' + \\\n             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '\"'\n    if linkattrd:\n        output += ' '\n        if escape_linkattrd:\n            attributes = [escape(str(key), quote=True) + '=\"' + \\\n                          escape(str(linkattrd[key]), quote=True) + '\"'\n                                for key in linkattrd.keys()]\n        else:\n            attributes = [str(key) + '=\"' + str(linkattrd[key]) + '\"'\n                                for key in linkattrd.keys()]\n        output += attributes_separator.join(attributes)\n    output = wash_for_utf8(output)\n    output += '>' + wash_for_utf8(link_label) + '</a>'\n    return output\n\n\ndef create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,\n        link_label=\"%(email)s\", linkattrd=None, escape_urlargd=True,\n        escape_linkattrd=True, email_obfuscation_mode=None):\n    \"\"\"Creates a W3C compliant 'mailto' link.\n\n    Encode/encrypt given email to reduce undesired automated email\n    harvesting when embedded in a web page.\n\n    NOTE: there is no ultimate solution to protect against email\n    harvesting. All have drawbacks and can more or less be\n    circumvented. There are other techniques to protect email\n    addresses. We implement the less annoying one for users.\n\n    @param email: the recipient of the email\n    @param subject: a default subject for the email (must not contain\n                    line feeds)\n    @param body: a default body for the email\n    @param cc: the co-recipient(s) of the email\n    @param bcc: the hidden co-recpient(s) of the email\n    @param link_label: the label of this mailto link. String\n                       replacement is performed on key %(email)s with\n                       the email address if needed.\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param email_obfuscation_mode: the protection mode. See below:\n\n    You can choose among several modes to protect emails. It is\n    advised to keep the default\n    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is\n    possible for an admin to change the policy globally.\n\n    Available modes ([t] means \"transparent\" for the user):\n\n         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and\n             CFG_SITE_SUPPORT_EMAIL.\n\n      [t] 0 : no protection, email returned as is.\n                foo@example.com => foo@example.com\n\n          1 : basic email munging: replaces @ by [at] and . by [dot]\n                foo@example.com => foo [at] example [dot] com\n\n      [t] 2 : transparent name mangling: characters are replaced by\n              equivalent HTML entities.\n                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;\n\n      [t] 3 : javascript insertion. Requires Javascript enabled on client side.\n\n          4 : replaces @ and . characters by gif equivalents.\n                foo@example.com => foo<img src=\"at.gif\" alt=\" [at] \">example<img src=\"dot.gif\" alt=\" [dot] \">com\n    \"\"\"\n    # TODO: implement other protection modes to encode/encript email:\n    #\n    ## [t] 5 : form submission. User is redirected to a form that he can\n    ##         fills in to send the email (??Use webmessage??).\n    ##         Depending on WebAccess, ask to answer a question.\n    ##\n    ## [t] 6 : if user can see (controlled by WebAccess), display. Else\n    ##         ask to login to see email. If user cannot see, display\n    ##         form submission.\n\n    if email_obfuscation_mode is None:\n        email_obfuscation_mode = cfg.get(\n            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')\n\n    if linkattrd is None:\n        linkattrd = {}\n\n    parameters = {}\n    if subject:\n        parameters[\"subject\"] = subject\n    if body:\n        parameters[\"body\"] = body.replace('\\r\\n', '\\n').replace('\\n', '\\r\\n')\n    if cc:\n        parameters[\"cc\"] = cc\n    if bcc:\n        parameters[\"bcc\"] = bcc\n\n    # Preprocessing values for some modes\n    if email_obfuscation_mode == 1:\n        # Basic Munging\n        email = email.replace(\"@\", \" [at] \").replace(\".\", \" [dot] \")\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        email = string_to_numeric_char_reference(email)\n\n    if '%(email)s' in link_label:\n        link_label = link_label % {'email': email}\n\n    mailto_link = create_html_link('mailto:' + email, parameters,\n                                   link_label, linkattrd,\n                                   escape_urlargd, escape_linkattrd)\n\n    if email_obfuscation_mode == 0:\n        # Return \"as is\"\n        return mailto_link\n    elif email_obfuscation_mode == 1:\n        # Basic Munging\n        return mailto_link\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        return mailto_link\n    elif email_obfuscation_mode == 3:\n        # Javascript-based\n        return '''<script language=\"JavaScript\" ''' \\\n            '''type=\"text/javascript\">''' \\\n            '''document.write('%s'.split(\"\").reverse().join(\"\"))''' \\\n            '''</script>''' % \\\n               mailto_link[::-1].replace(\"'\", \"\\\\'\")\n    elif email_obfuscation_mode == 4:\n        # GIFs-based\n        email = email.replace('.',\n            '<img src=\"%s/img/dot.gif\" alt=\" [dot] \" '\n            'style=\"vertical-align:bottom\"  />' % cfg.get('CFG_SITE_URL'))\n        email = email.replace('@',\n            '<img src=\"%s/img/at.gif\" alt=\" [at] \" '\n            'style=\"vertical-align:baseline\" />' % cfg.get('CFG_SITE_URL'))\n        return email\n\n    # All other cases, including mode -1:\n    return \"\"\n\n\ndef string_to_numeric_char_reference(string):\n    \"\"\"\n    Encode a string to HTML-compatible numeric character reference.\n    Eg: encode_html_entities(\"abc\") == '&#97;&#98;&#99;'\n    \"\"\"\n    out = \"\"\n    for char in string:\n        out += \"&#\" + str(ord(char)) + \";\"\n    return out\n\ndef get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):\n    \"\"\"\n    Given an Invenio URL returns a tuple with two elements. The first is the\n    canonical URL, that is the original URL with CFG_SITE_URL prefix, and\n    where the ln= argument stripped. The second element element is mapping,\n    language code -> alternate URL\n\n    @param quote_path: if True, the path section of the given C{url}\n                       is quoted according to RFC 2396\n    \"\"\"\n    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)\n    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]\n    parsed_query = washed_argd or parse_qsl(query)\n    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']\n    if drop_ln:\n        canonical_parsed_query = no_ln_parsed_query\n    else:\n        canonical_parsed_query = parsed_query\n    if quote_path:\n        path = urllib.quote(path)\n    canonical_query = urlencode(canonical_parsed_query)\n    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))\n    alternate_urls = {}\n    for ln in cfg.get('CFG_SITE_LANGS'):\n        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])\n        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))\n        alternate_urls[ln] = alternate_url\n    return canonical_url, alternate_urls\n\ndef create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):\n    \"\"\"Creates a W3C compliant URL. Output will look like this:\n    'urlbase?param1=value1&amp;param2=value2'\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    separator = '&amp;'\n    output = urlbase\n    if urlargd:\n        output += '?'\n        if escape_urlargd:\n            arguments = [escape(quote(str(key)), quote=True) + '=' + \\\n                         escape(quote(str(urlargd[key])), quote=True)\n                                for key in urlargd.keys()]\n        else:\n            arguments = [str(key) + '=' + str(urlargd[key])\n                            for key in urlargd.keys()]\n        output += separator.join(arguments)\n    if urlhash:\n        output += \"#\" + escape(quote(str(urlhash)))\n    return output\n\n\ndef same_urls_p(a, b):\n    \"\"\" Compare two URLs, ignoring reorganizing of query arguments \"\"\"\n\n    ua = list(urlparse(a))\n    ub = list(urlparse(b))\n\n    ua[4] = parse_qs(ua[4])\n    ub[4] = parse_qs(ub[4])\n\n    return ua == ub\n\n\ndef urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):\n    \"\"\"Analyze `urlargs' (URL CGI GET query arguments in string form)\n       and for each occurrence of argument matching `regexp_argname'\n       replace every substring `text_old' by `text_new'.  Return the\n       resulting new URL.\n\n       Used to be used for search engine's create_nearest_terms_box,\n       now it is not used there anymore.  It is left here in case it\n       will become possibly useful later.\n    \"\"\"\n    out = \"\"\n    # parse URL arguments into a dictionary:\n    urlargsdict = parse_qs(urlargs)\n    ## construct new URL arguments:\n    urlargsdictnew = {}\n    for key in urlargsdict.keys():\n        if re.match(regexp_argname, key): # replace `arg' by new values\n            urlargsdictnew[key] = []\n            for parg in urlargsdict[key]:\n                urlargsdictnew[key].append(parg.replace(text_old, text_new))\n        else: # keep old values\n            urlargsdictnew[key] = urlargsdict[key]\n    # build new URL for this word:\n    for key in urlargsdictnew.keys():\n        for val in urlargsdictnew[key]:\n            out += \"&amp;\" + key + \"=\" + quote_plus(val, '')\n    if out.startswith(\"&amp;\"):\n        out = out[5:]\n    return out\n\ndef get_title_of_page(url):\n    \"\"\"\n    @param url: page to get the title from\n    @return: the page title in utf-8 or None in case\n    that any kind of exception occured e.g. connection error,\n    URL not known\n    \"\"\"\n    if BEAUTIFUL_SOUP_IMPORTED:\n        try:\n            opener = make_invenio_opener('UrlUtils')\n            soup = BeautifulSoup.BeautifulSoup(opener.open(url))\n            return soup.title.string.encode(\"utf-8\")\n        except:\n            return None\n    else:\n        return \"Title not available\"\n\n\ndef make_user_agent_string(component=None):\n    \"\"\"\n    Return a nice and uniform user-agent string to be used when Invenio\n    act as a client in HTTP requests.\n    \"\"\"\n    ret = \"Invenio-%s (+%s; \\\"%s\\\")\" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))\n    if component:\n        ret += \" %s\" % component\n    return ret\n\n\nclass InvenioFancyURLopener(FancyURLopener):\n    \"\"\"Provide default user agent string.\"\"\"\n\n    @cached_property\n    def version(self):\n        return make_user_agent_string()\n\n    def prompt_user_passwd(self, host, realm):\n        \"\"\"Don't prompt\"\"\"\n        return None, None\n\n## Let's override default useragent string\n## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html\nurllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())\n\ndef make_invenio_opener(component=None):\n    \"\"\"\n    Return an urllib2 opener with the useragent already set in the appropriate\n    way.\n    \"\"\"\n    opener = urllib2.build_opener()\n    opener.addheaders = [('User-agent', make_user_agent_string(component))]\n    return opener\n\ndef create_AWS_request_url(base_url, argd, _amazon_secret_access_key,\n                           _timestamp=None):\n    \"\"\"\n    Create a signed AWS (Amazon Web Service) request URL corresponding\n    to the given parameters.\n\n    Example:\n    >> create_AWS_request_url(\"http://ecs.amazon.com/onca/xml\",\n                             {'AWSAccessKeyID': '0000000000',\n                              'Service': 'AWSECommerceService',\n                              'Operation': 'ItemLookup',\n                              'ItemID': '0679722769',\n                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},\n                             \"1234567890\")\n\n    @param base_url: Service URL of the Amazon store to query\n    @param argd: dictionary of arguments defining the query\n    @param _amazon_secret_access_key: your Amazon secret key\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @type base_url: string\n    @type argd: dict\n    @type _amazon_secret_access_key: string\n    @type _timestamp: string\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    ## First define a few util functions\n\n    def get_AWS_signature(argd, _amazon_secret_access_key,\n                          method=\"GET\", request_host=\"webservices.amazon.com\",\n                          request_uri=\"/onca/xml\",\n                          _timestamp=None):\n        \"\"\"\n        Returns the signature of an Amazon request, based on the\n        arguments of the request.\n\n        @param argd: dictionary of arguments defining the query\n        @param _amazon_secret_access_key: your Amazon secret key\n        @param method: method of the request POST or GET\n        @param request_host: host contacted for the query. To embed in the signature.\n        @param request_uri: uri contacted at 'request_host'. To embed in the signature.\n        @param _timestamp: for testing purpose only (default: current timestamp)\n\n        @type argd: dict\n        @type _amazon_secret_access_key: string\n        @type method: string\n        @type host_header: string\n        @type http_request_uri: string\n        @type _timestamp: string\n\n        @return signature of the request (string)\n        \"\"\"\n\n        # Add timestamp\n        if not _timestamp:\n            argd[\"Timestamp\"] = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\",\n                                              time.gmtime())\n        else:\n            argd[\"Timestamp\"] = _timestamp\n\n        # Order parameter keys by byte value\n        parameter_keys = argd.keys()\n        parameter_keys.sort()\n\n        # Encode arguments, according to RFC 3986. Make sure we\n        # generate a list which is ordered by byte value of the keys\n        arguments = [quote(str(key), safe=\"~/\") + \"=\" + \\\n                     quote(str(argd[key]), safe=\"~/\") \\\n                     for key in parameter_keys]\n\n        # Join\n        parameters_string = \"&\".join(arguments)\n\n        # Prefix\n        parameters_string = method.upper() + \"\\n\" + \\\n                            request_host.lower() + \"\\n\" + \\\n                            (request_uri or \"/\") + \"\\n\" + \\\n                            parameters_string\n\n        # Sign and return\n        return calculate_RFC2104_HMAC(parameters_string,\n                                      _amazon_secret_access_key)\n\n    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):\n        \"\"\"\n        Computes a RFC 2104 compliant HMAC Signature and then Base64\n        encodes it.\n\n        Module hashlib must be installed if Python < 2.5\n        <http://pypi.python.org/pypi/hashlib/20081119>\n\n        @param data: data to sign\n        @param _amazon_secret_access_key: your Amazon secret key\n\n        @type data: string\n        @type _amazon_secret_access_key: string. Empty if hashlib module not installed\n        \"\"\"\n        if not HASHLIB_IMPORTED:\n            try:\n                raise Exception(\"Module hashlib not installed. Please install it.\")\n            except:\n                from invenio.ext.logging import register_exception\n                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n                return \"\"\n        else:\n            if sys.version_info < (2, 5):\n                # compatibility mode for Python < 2.5 and hashlib\n                my_digest_algo = _MySHA256(sha256())\n            else:\n                my_digest_algo = sha256\n\n        return base64.encodestring(hmac.new(_amazon_secret_access_key,\n                                            data, my_digest_algo).digest()).strip()\n     ## End util functions\n\n    parsed_url = urlparse(base_url)\n    signature = get_AWS_signature(argd, _amazon_secret_access_key,\n                                  request_host=parsed_url[1],\n                                  request_uri=parsed_url[2],\n                                  _timestamp=_timestamp)\n    if signature:\n        argd[\"Signature\"] = signature\n    return base_url + \"?\" + urlencode(argd)\n\n\ndef create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):\n    \"\"\"\n    Create a signed Indico request URL to access Indico HTTP Export APIs.\n\n    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more\n    information.\n\n    Example:\n    >> create_Indico_request_url(\"https://indico.cern.ch\",\n                                 \"categ\",\n                                 \"\",\n                                 [1, 7],\n                                 \"xml\",\n                                 {'onlypublic': 'yes',\n                                  'order': 'title',\n                                  'from': 'today',\n                                  'to': 'tomorrow'},\n                                 '00000000-0000-0000-0000-000000000000',\n                                 '00000000-0000-0000-0000-000000000000')\n\n    @param base_url: Service base URL of the Indico instance to query\n    @param indico_what: element to export\n    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}\n    @param indico_loc: location of the element(s) specified by ID (only used for some elements)\n    @param indico_id: ID of the element to be exported\n    @type indico_id: a string or a list/tuple of strings\n    @param indico_type: output format\n    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}\n    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}\n    @param indico_key: API key provided for the given Indico instance\n    @param indico_sig: API secret key (signature) provided for the given Indico instance\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    url = '/export/' + indico_what + '/'\n    if indico_loc:\n        url += indico_loc + '/'\n    if type(indico_id) in (list, tuple):\n        # dash separated list of values\n        indico_id = '-'.join([str(x) for x in indico_id])\n    url += indico_id + '.' + str(indico_type)\n\n    if hasattr(indico_params, 'items'):\n        items = indico_params.items()\n    else:\n        items = list(indico_params)\n    if indico_key:\n        items.append(('apikey', indico_key))\n    if indico_sig and HASHLIB_IMPORTED:\n        if _timestamp:\n            items.append(('timestamp', str(_timestamp)))\n        else:\n            items.append(('timestamp', str(int(time.time()))))\n        items = sorted(items, key=lambda x: x[0].lower())\n        url_to_sign = '%s?%s' % (url, urlencode(items))\n        if sys.version_info < (2, 5):\n            # compatibility mode for Python < 2.5 and hashlib\n            my_digest_algo = _MySHA1(sha1())\n        else:\n            my_digest_algo = sha1\n        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()\n        items.append(('signature', signature))\n    elif not HASHLIB_IMPORTED:\n        try:\n            raise Exception(\"Module hashlib not installed. Please install it.\")\n        except:\n            from invenio.ext.logging import register_exception\n            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n    if not items:\n        return url\n\n    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))\n    return url\n\nclass _MyHashlibAlgo(object):\n    '''\n    Define a subclass of any hashlib algorithm class, with an additional \"new()\"\n    function, to work with the Python < 2.5 version of the hmac module.\n\n    (This class is more complex than it should, but it is not\n    possible to subclass haslib algorithm)\n    '''\n\n    def __init__(self, obj):\n        \"\"\"Set the wrapped object.\"\"\"\n        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)\n\n        methods = []\n        for name_value in inspect.getmembers(obj, inspect.ismethod):\n            methods.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)\n\n        def isnotmethod(object_):\n            \"Opposite of ismethod(..)\"\n            return not inspect.ismethod(object_)\n        members = []\n        for name_value in inspect.getmembers(obj, isnotmethod):\n            members.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__members__', members)\n\n    def __getattr__(self, name):\n        \"\"\"Redirect unhandled get attribute to self._obj.\"\"\"\n        if not hasattr(self._obj, name):\n            raise AttributeError, (\"'%s' has no attribute %s\" %\n                                   (self.__class__.__name__, name))\n        else:\n            return getattr(self._obj, name)\n\n    def __setattr__(self, name, value):\n        \"\"\"Redirect set attribute to self._obj if necessary.\"\"\"\n        self_has_attr = True\n        try:\n            super(_MyHashlibAlgo, self).__getattribute__(name)\n        except AttributeError:\n            self_has_attr = False\n\n        if (name == \"_obj\" or not hasattr(self, \"_obj\") or\n            not hasattr(self._obj, name) or self_has_attr):\n            return super(_MyHashlibAlgo, self).__setattr__(name, value)\n        else:\n            return setattr(self._obj, name, value)\n\nif HASHLIB_IMPORTED:\n    from invenio.utils.hash import sha256\n\n\n    class _MySHA256(_MyHashlibAlgo):\n        \"A _MyHashlibAlgo subsclass for sha256\"\n        new = lambda d = '': sha256()\n\n\nclass _MySHA1(_MyHashlibAlgo):\n    \"A _MyHashlibAlgo subsclass for sha1\"\n    new = lambda d = '': sha1()\n\ndef auto_version_url(file_path):\n    \"\"\" Appends modification time of the file to the request URL in order for the\n        browser to refresh the cache when file changes\n\n        @param file_path: path to the file, e.g js/foo.js\n        @return: file_path with modification time appended to URL\n    \"\"\"\n    file_md5 = \"\"\n    try:\n        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()\n    except IOError:\n        pass\n    return file_path + \"?%s\" % file_md5\n\ndef get_relative_url(url):\n    \"\"\"\n    Returns the relative URL from a URL. For example:\n\n    'http://web.net' -> ''\n    'http://web.net/' -> ''\n    'http://web.net/1222' -> '/1222'\n    'http://web.net/wsadas/asd' -> '/wsadas/asd'\n\n    It will never return a trailing \"/\".\n\n    @param url: A url to transform\n    @type url: str\n\n    @return: relative URL\n    \"\"\"\n    # remove any protocol info before\n    stripped_site_url = url.replace(\"://\", \"\")\n    baseurl = \"/\" + \"/\".join(stripped_site_url.split(\"/\")[1:])\n\n    # remove any trailing slash (\"/\")\n    if baseurl[-1] == \"/\":\n        return baseurl[:-1]\n    else:\n        return baseurl\n/n/n/n", "label": 0}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize#show_login\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                    next=request.args.get('next', '/')\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    if request.args.get('next', None):\n        return redirect(request.args.get('next'))\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        if request.args.get('next', None):\n            return redirect(request.args.get('next'))\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import quote_plus\nfrom flask import url_for, session\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom invenio.ext.sqlalchemy import db\n\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(url_for(\"oauthclient.login\", remote_app='test'))\n        self.assertStatus(resp, 302)\n        self.assertEqual(\n            resp.location,\n            \"https://foo.bar/oauth/authorize?response_type=code&\"\n            \"client_id=testid&redirect_uri=%s\" % quote_plus(url_for(\n                \"oauthclient.authorized\", remote_app='test', _external=True\n            ))\n        )\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            resp = self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                )\n            )\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_token_getter_setter(self, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                # Assert if every is as it should be.\n                assert session['oauth_token_full'] == ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_rejected(self, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Client blueprint used to handle OAuth callbacks. \"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, url_for, request\n\nfrom flask.ext.login import user_logged_out\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\" Setup OAuth clients. \"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\" Send user to remote application for authentication. \"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        next=request.args.get('next') or request.referrer or None,\n        _external=True,\n    )\n\n    return oauth.remote_apps[remote_app].authorize(callback=callback_url)\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\" Authorized handler callback. \"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\" Extra signup step. \"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\" Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/n", "label": 1}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token\n                                 expires. Defaults to 300 seconds.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n\nOAUTHCLIENT_STATE_EXPIRES = 300\n\"\"\"Number of seconds after which the state token expires.\"\"\"\n/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate',\n                              'show_login': 'true'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef get_session_next_url(remote_app):\n    return session.get(\n        \"%s_%s\" % (token_session_key(remote_app), \"next_url\")\n    )\n\n\ndef set_session_next_url(remote_app, url):\n    session[\"%s_%s\" % (token_session_key(remote_app), \"next_url\")] = \\\n        url\n\n\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    next_url = get_session_next_url(remote.name)\n    if next_url:\n        return redirect(next_url)\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        next_url = get_session_next_url(remote.name)\n        if next_url:\n            return redirect(next_url)\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite\nfrom mock import MagicMock, Mock, patch\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nclass FormTestCase(InvenioTestCase):\n\n    @patch('invenio.modules.oauthclient.forms.User')\n    def test_validate_email(self, user):\n        from invenio.modules.oauthclient.forms import EmailSignUpForm\n\n        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())\n\n        # Mock query\n        obj = MagicMock()\n        obj.one = MagicMock(side_effect=SQLAlchemyError())\n        user.query.filter = Mock(return_value=obj)\n        self.assertTrue(\n            EmailSignUpForm(email='good@invenio-software.org').validate()\n        )\n\n        user.query.filter = MagicMock()\n        self.assertFalse(\n            EmailSignUpForm(email='bad@invenio-software.org').validate()\n        )\n\n\nTEST_SUITE = make_test_suite(FormTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nimport time\nfrom flask import url_for, session\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sqlalchemy import db\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom itsdangerous import TimedJSONWebSignatureSerializer\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import parse_qs, urlparse\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_redirect_uri(self):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test',\n                    next='http://invenio-software.org')\n        )\n        self.assertStatus(resp, 302)\n\n        # Verify parameters\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Verify next parameter in state token does not allow blanco redirects\n        state = serializer.loads(params['state'][0])\n        self.assertIsNone(state['next'])\n\n        # Assert redirect uri does not have any parameters.\n        params = parse_qs(urlparse(params['redirect_uri'][0]).query)\n        self.assertEqual(params, {})\n\n        # Assert that local redirects are allowed\n        test_urls = [\n            '/search',\n            url_for('oauthclient.disconnect', remote_app='test',\n                    _external=True)\n        ]\n        for url in test_urls:\n            resp = self.client.get(\n                url_for(\"oauthclient.login\", remote_app='test', next=url)\n            )\n            self.assertStatus(resp, 302)\n            state = serializer.loads(\n                parse_qs(urlparse(resp.location).query)['state'][0]\n            )\n            self.assertEqual(url, state['next'])\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test', next='/')\n        )\n        self.assertStatus(resp, 302)\n\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            from invenio.modules.oauthclient.views.client import serializer\n\n            state = serializer.dumps({\n                'app': 'test',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                    state=state\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            state = serializer.dumps({\n                'app': 'test_invalid',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                    state=state,\n                )\n            )\n\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_state_token(self, session):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Mock session id\n        session.sid = '1234'\n\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n\n            # Good state token\n            state = serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            resp = c.get(\n                url_for(\"oauthclient.authorized\", remote_app='test',\n                        code='test', state=state)\n            )\n            self.assert200(resp)\n\n            outdated_serializer = TimedJSONWebSignatureSerializer(\n                cfg['SECRET_KEY'],\n                expires_in=0,\n            )\n\n            # Bad state - timeout\n            state1 = outdated_serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - app\n            state2 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test_invalid', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - sid\n            state3 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test', 'sid': 'bad',  'next': None, }\n            )\n            time.sleep(1)\n            for s in [state1, state2, state3]:\n                resp = c.get(\n                    url_for(\"oauthclient.authorized\", remote_app='test',\n                            code='test', state=s)\n                )\n                self.assert403(resp)\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_token_getter_setter(self, session, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                state = parse_qs(urlparse(res.location).query)['state'][0]\n\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state,\n                ))\n\n                # Assert if everything is as it should be.\n                from flask import session as flask_session\n                assert flask_session['oauth_token_full'] == \\\n                    ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                # Mock a new authorized request\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_rejected(self, session, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user id\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                from invenio.modules.oauthclient.views.client import serializer\n                state = serializer.dumps({\n                    'app': 'full', 'sid': '1234',  'next': None,\n                })\n\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Client blueprint used to handle OAuth callbacks.\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, request, session, url_for\nfrom flask.ext.login import user_logged_out\nfrom itsdangerous import TimedJSONWebSignatureSerializer, BadData\nfrom werkzeug.local import LocalProxy\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\nfrom invenio.utils.url import get_safe_redirect_target\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler, \\\n    set_session_next_url\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\nserializer = LocalProxy(\n    lambda: TimedJSONWebSignatureSerializer(\n        cfg['SECRET_KEY'],\n        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],\n    )\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\"Setup OAuth clients.\"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\"Send user to remote application for authentication.\"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    # Get redirect target in safe manner.\n    next_param = get_safe_redirect_target(arg='next')\n\n    # Redirect URI - must be registered in the remote service.\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        _external=True,\n    )\n\n    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES\n    # seconds.\n    state_token = serializer.dumps({\n        'app': remote_app,\n        'next': next_param,\n        'sid': session.sid,\n    })\n\n    return oauth.remote_apps[remote_app].authorize(\n        callback=callback_url,\n        state=state_token,\n    )\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\"Authorized handler callback.\"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n\n    state_token = request.args.get('state')\n\n    # Verify state parameter\n    try:\n        assert state_token\n        # Checks authenticity and integrity of state and decodes the value.\n        state = serializer.loads(state_token)\n        # Verify that state is for this session, app and that next parameter\n        # have not been modified.\n        assert state['sid'] == session.sid\n        assert state['app'] == remote_app\n        # Store next URL\n        set_session_next_url(remote_app, state['next'])\n    except (AssertionError, BadData):\n        abort(403)\n\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\"Extra signup step.\"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\"Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"\nurlutils.py -- helper functions for URL related problems such as\nargument washing, redirection, etc.\n\"\"\"\n\n__revision__ = \"$Id$\"\n\nimport time\nimport base64\nimport hmac\nimport re\nimport sys\nimport os\nimport inspect\nimport urllib\nimport urllib2\nfrom urllib import urlencode, quote_plus, quote, FancyURLopener\nfrom six.moves.urllib.parse import urlparse, urlunparse\nfrom cgi import parse_qs, parse_qsl, escape\nfrom werkzeug import cached_property\nfrom werkzeug.local import LocalProxy\n\ntry:\n    import BeautifulSoup\n    BEAUTIFUL_SOUP_IMPORTED = True\nexcept ImportError:\n    BEAUTIFUL_SOUP_IMPORTED = False\n\nfrom invenio.base.globals import cfg\nfrom invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED\nfrom invenio.utils.text import wash_for_utf8\nfrom invenio.utils import apache\n\n\ndef wash_url_argument(var, new_type):\n    \"\"\"\n    Wash argument into 'new_type', that can be 'list', 'str',\n                                               'int', 'tuple' or 'dict'.\n    If needed, the check 'type(var) is not None' should be done before\n    calling this function.\n    @param var: variable value\n    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'\n    @return: as much as possible, value var as type new_type\n            If var is a list, will change first element into new_type.\n            If int check unsuccessful, returns 0\n    \"\"\"\n    out = []\n    if new_type == 'list':  # return lst\n        if isinstance(var, list):\n            out = var\n        else:\n            out = [var]\n    elif new_type == 'str':  # return str\n        if isinstance(var, list):\n            try:\n                out = \"%s\" % var[0]\n            except:\n                out = \"\"\n        elif isinstance(var, str):\n            out = var\n        else:\n            out = \"%s\" % var\n    elif new_type == 'int': # return int\n        if isinstance(var, list):\n            try:\n                out = int(var[0])\n            except:\n                out = 0\n        elif isinstance(var, (int, long)):\n            out = var\n        elif isinstance(var, str):\n            try:\n                out = int(var)\n            except:\n                out = 0\n        else:\n            out = 0\n    elif new_type == 'tuple': # return tuple\n        if isinstance(var, tuple):\n            out = var\n        else:\n            out = (var, )\n    elif new_type == 'dict': # return dictionary\n        if isinstance(var, dict):\n            out = var\n        else:\n            out = {0: var}\n    return out\n\n\nfrom urlparse import urlparse, urljoin\nfrom flask import request, url_for\n\ndef is_local_url(target):\n    \"\"\"Determine if URL is a local.\"\"\"\n    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))\n    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))\n    return test_url.scheme in ('http', 'https') and \\\n           ref_url.netloc == test_url.netloc\n\n\ndef get_safe_redirect_target(arg='next'):\n    \"\"\"Get URL to redirect to and ensure that it is local.\"\"\"\n    for target in request.args.get(arg), request.referrer:\n        if not target:\n            continue\n        if is_local_url(target):\n            return target\n    return None\n\n\ndef redirect_to_url(req, url, redirection_type=None, norobot=False):\n    \"\"\"\n    Redirect current page to url.\n    @param req: request as received from apache\n    @param url: url to redirect to\n    @param redirection_type: what kind of redirection is required:\n    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300\n          apache.HTTP_MOVED_PERMANENTLY            = 301\n          apache.HTTP_MOVED_TEMPORARILY            = 302\n          apache.HTTP_SEE_OTHER                    = 303\n          apache.HTTP_NOT_MODIFIED                 = 304\n          apache.HTTP_USE_PROXY                    = 305\n          apache.HTTP_TEMPORARY_REDIRECT           = 307\n    The default is apache.HTTP_MOVED_TEMPORARILY\n    @param norobot: wether to instruct crawlers and robots such as GoogleBot\n        not to index past this point.\n    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3\n    \"\"\"\n    url = url.strip()\n    if redirection_type is None:\n        redirection_type = apache.HTTP_MOVED_TEMPORARILY\n\n    from flask import redirect\n    r = redirect(url, code=redirection_type)\n    raise apache.SERVER_RETURN, r\n    #FIXME enable code bellow\n\n    del req.headers_out[\"Cache-Control\"]\n    req.headers_out[\"Cache-Control\"] = \"no-cache, private, no-store, \" \\\n        \"must-revalidate, post-check=0, pre-check=0, max-age=0\"\n    req.headers_out[\"Pragma\"] = \"no-cache\"\n\n    if norobot:\n        req.headers_out[\"X-Robots-Tag\"] = \"noarchive, nosnippet, noindex, nocache\"\n\n    user_agent = req.headers_in.get('User-Agent', '')\n    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:\n        ## HACK: this is to workaround Microsoft Office trying to be smart\n        ## when users click on URLs in Office documents that require\n        ## authentication. Office will check the validity of the URL\n        ## but will pass the browser the redirected URL rather than\n        ## the original one. This is incompatible with e.g. Shibboleth\n        ## based SSO since the referer would be lost.\n        ## See: http://support.microsoft.com/kb/899927\n        req.status = 200\n        req.content_type = 'text/html'\n        if req.method != 'HEAD':\n            req.write(\"\"\"\n<html>\n    <head>\n        <title>Intermediate page for URLs clicked on MS Office Documents</title>\n        <meta http-equiv=\"REFRESH\" content=\"5;url=%(url)s\"></meta>\n    </head>\n    <body>\n        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=\"%(url)s\">%(url_ok)s</a>.</p>\n    </body>\n</html>\"\"\" % {\n                'url': escape(req.unparsed_uri, True),\n                'url_ok': escape(req.unparsed_uri)\n            })\n        raise apache.SERVER_RETURN(apache.DONE)\n\n    req.headers_out[\"Location\"] = url\n\n    if req.response_sent_p:\n        raise IOError(\"Cannot redirect after headers have already been sent.\")\n\n    req.status = redirection_type\n    req.write('<p>Please go to <a href=\"%s\">here</a></p>\\n' % url)\n\n    raise apache.SERVER_RETURN, apache.DONE\n\n\ndef rewrite_to_secure_url(url, secure_base=None):\n    \"\"\"\n    Rewrite URL to a Secure URL\n\n    @param url URL to be rewritten to a secure URL.\n    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).\n    \"\"\"\n    if secure_base is None:\n        secure_base = cfg.get('CFG_SITE_SECURE_URL')\n    url_parts = list(urlparse(url))\n    url_secure_parts = urlparse(secure_base)\n    url_parts[0] = url_secure_parts[0]\n    url_parts[1] = url_secure_parts[1]\n    return urlunparse(url_parts)\n\n\ndef get_referer(req, replace_ampersands=False):\n    \"\"\" Return the referring page of a request.\n    Referer (wikipedia): Referer is a common misspelling of the word\n    \"referrer\"; so common, in fact, that it made it into the official\n    specification of HTTP. When visiting a webpage, the referer or\n    referring page is the URL of the previous webpage from which a link was\n    followed.\n    @param req: request\n    @param replace_ampersands: if 1, replace & by &amp; in url\n                               (correct HTML cannot contain & characters alone)\n    \"\"\"\n    try:\n        referer = req.headers_in['Referer']\n        if replace_ampersands == 1:\n            return referer.replace('&', '&amp;')\n        return referer\n    except KeyError:\n        return ''\n\n\ndef drop_default_urlargd(urlargd, default_urlargd):\n    lndefault = {}\n    lndefault.update(default_urlargd)\n\n    ## Commented out. An Invenio URL now should always specify the desired\n    ## language, in order not to raise the automatic language discovery\n    ## (client browser language can be used now in place of CFG_SITE_LANG)\n    # lndefault['ln'] = (str, CFG_SITE_LANG)\n\n    canonical = {}\n    canonical.update(urlargd)\n\n    for k, v in urlargd.items():\n        try:\n            d = lndefault[k]\n\n            if d[1] == v:\n                del canonical[k]\n\n        except KeyError:\n            pass\n\n    return canonical\n\n\ndef make_canonical_urlargd(urlargd, default_urlargd):\n    \"\"\" Build up the query part of an URL from the arguments passed in\n    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which\n    contains tuples of the form (type, default value) for the query\n    arguments (this is the same dictionary as the one you can pass to\n    webinterface_handler.wash_urlargd).\n\n    When a query element has its default value, it is discarded, so\n    that the simplest (canonical) url query is returned.\n\n    The result contains the initial '?' if there are actual query\n    items remaining.\n    \"\"\"\n\n    canonical = drop_default_urlargd(urlargd, default_urlargd)\n\n    if canonical:\n        return '?' + urlencode(canonical, doseq=True)\n        #FIXME double escaping of '&'? .replace('&', '&amp;')\n\n    return ''\n\n\ndef create_html_link(urlbase, urlargd, link_label, linkattrd=None,\n                     escape_urlargd=True, escape_linkattrd=True,\n                     urlhash=None):\n    \"\"\"Creates a W3C compliant link.\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})\n    @param link_label: text displayed in a browser (has to be already escaped)\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    attributes_separator = ' '\n    output = '<a href=\"' + \\\n             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '\"'\n    if linkattrd:\n        output += ' '\n        if escape_linkattrd:\n            attributes = [escape(str(key), quote=True) + '=\"' + \\\n                          escape(str(linkattrd[key]), quote=True) + '\"'\n                                for key in linkattrd.keys()]\n        else:\n            attributes = [str(key) + '=\"' + str(linkattrd[key]) + '\"'\n                                for key in linkattrd.keys()]\n        output += attributes_separator.join(attributes)\n    output = wash_for_utf8(output)\n    output += '>' + wash_for_utf8(link_label) + '</a>'\n    return output\n\n\ndef create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,\n        link_label=\"%(email)s\", linkattrd=None, escape_urlargd=True,\n        escape_linkattrd=True, email_obfuscation_mode=None):\n    \"\"\"Creates a W3C compliant 'mailto' link.\n\n    Encode/encrypt given email to reduce undesired automated email\n    harvesting when embedded in a web page.\n\n    NOTE: there is no ultimate solution to protect against email\n    harvesting. All have drawbacks and can more or less be\n    circumvented. There are other techniques to protect email\n    addresses. We implement the less annoying one for users.\n\n    @param email: the recipient of the email\n    @param subject: a default subject for the email (must not contain\n                    line feeds)\n    @param body: a default body for the email\n    @param cc: the co-recipient(s) of the email\n    @param bcc: the hidden co-recpient(s) of the email\n    @param link_label: the label of this mailto link. String\n                       replacement is performed on key %(email)s with\n                       the email address if needed.\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param email_obfuscation_mode: the protection mode. See below:\n\n    You can choose among several modes to protect emails. It is\n    advised to keep the default\n    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is\n    possible for an admin to change the policy globally.\n\n    Available modes ([t] means \"transparent\" for the user):\n\n         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and\n             CFG_SITE_SUPPORT_EMAIL.\n\n      [t] 0 : no protection, email returned as is.\n                foo@example.com => foo@example.com\n\n          1 : basic email munging: replaces @ by [at] and . by [dot]\n                foo@example.com => foo [at] example [dot] com\n\n      [t] 2 : transparent name mangling: characters are replaced by\n              equivalent HTML entities.\n                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;\n\n      [t] 3 : javascript insertion. Requires Javascript enabled on client side.\n\n          4 : replaces @ and . characters by gif equivalents.\n                foo@example.com => foo<img src=\"at.gif\" alt=\" [at] \">example<img src=\"dot.gif\" alt=\" [dot] \">com\n    \"\"\"\n    # TODO: implement other protection modes to encode/encript email:\n    #\n    ## [t] 5 : form submission. User is redirected to a form that he can\n    ##         fills in to send the email (??Use webmessage??).\n    ##         Depending on WebAccess, ask to answer a question.\n    ##\n    ## [t] 6 : if user can see (controlled by WebAccess), display. Else\n    ##         ask to login to see email. If user cannot see, display\n    ##         form submission.\n\n    if email_obfuscation_mode is None:\n        email_obfuscation_mode = cfg.get(\n            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')\n\n    if linkattrd is None:\n        linkattrd = {}\n\n    parameters = {}\n    if subject:\n        parameters[\"subject\"] = subject\n    if body:\n        parameters[\"body\"] = body.replace('\\r\\n', '\\n').replace('\\n', '\\r\\n')\n    if cc:\n        parameters[\"cc\"] = cc\n    if bcc:\n        parameters[\"bcc\"] = bcc\n\n    # Preprocessing values for some modes\n    if email_obfuscation_mode == 1:\n        # Basic Munging\n        email = email.replace(\"@\", \" [at] \").replace(\".\", \" [dot] \")\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        email = string_to_numeric_char_reference(email)\n\n    if '%(email)s' in link_label:\n        link_label = link_label % {'email': email}\n\n    mailto_link = create_html_link('mailto:' + email, parameters,\n                                   link_label, linkattrd,\n                                   escape_urlargd, escape_linkattrd)\n\n    if email_obfuscation_mode == 0:\n        # Return \"as is\"\n        return mailto_link\n    elif email_obfuscation_mode == 1:\n        # Basic Munging\n        return mailto_link\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        return mailto_link\n    elif email_obfuscation_mode == 3:\n        # Javascript-based\n        return '''<script language=\"JavaScript\" ''' \\\n            '''type=\"text/javascript\">''' \\\n            '''document.write('%s'.split(\"\").reverse().join(\"\"))''' \\\n            '''</script>''' % \\\n               mailto_link[::-1].replace(\"'\", \"\\\\'\")\n    elif email_obfuscation_mode == 4:\n        # GIFs-based\n        email = email.replace('.',\n            '<img src=\"%s/img/dot.gif\" alt=\" [dot] \" '\n            'style=\"vertical-align:bottom\"  />' % cfg.get('CFG_SITE_URL'))\n        email = email.replace('@',\n            '<img src=\"%s/img/at.gif\" alt=\" [at] \" '\n            'style=\"vertical-align:baseline\" />' % cfg.get('CFG_SITE_URL'))\n        return email\n\n    # All other cases, including mode -1:\n    return \"\"\n\n\ndef string_to_numeric_char_reference(string):\n    \"\"\"\n    Encode a string to HTML-compatible numeric character reference.\n    Eg: encode_html_entities(\"abc\") == '&#97;&#98;&#99;'\n    \"\"\"\n    out = \"\"\n    for char in string:\n        out += \"&#\" + str(ord(char)) + \";\"\n    return out\n\ndef get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):\n    \"\"\"\n    Given an Invenio URL returns a tuple with two elements. The first is the\n    canonical URL, that is the original URL with CFG_SITE_URL prefix, and\n    where the ln= argument stripped. The second element element is mapping,\n    language code -> alternate URL\n\n    @param quote_path: if True, the path section of the given C{url}\n                       is quoted according to RFC 2396\n    \"\"\"\n    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)\n    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]\n    parsed_query = washed_argd or parse_qsl(query)\n    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']\n    if drop_ln:\n        canonical_parsed_query = no_ln_parsed_query\n    else:\n        canonical_parsed_query = parsed_query\n    if quote_path:\n        path = urllib.quote(path)\n    canonical_query = urlencode(canonical_parsed_query)\n    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))\n    alternate_urls = {}\n    for ln in cfg.get('CFG_SITE_LANGS'):\n        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])\n        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))\n        alternate_urls[ln] = alternate_url\n    return canonical_url, alternate_urls\n\ndef create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):\n    \"\"\"Creates a W3C compliant URL. Output will look like this:\n    'urlbase?param1=value1&amp;param2=value2'\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    separator = '&amp;'\n    output = urlbase\n    if urlargd:\n        output += '?'\n        if escape_urlargd:\n            arguments = [escape(quote(str(key)), quote=True) + '=' + \\\n                         escape(quote(str(urlargd[key])), quote=True)\n                                for key in urlargd.keys()]\n        else:\n            arguments = [str(key) + '=' + str(urlargd[key])\n                            for key in urlargd.keys()]\n        output += separator.join(arguments)\n    if urlhash:\n        output += \"#\" + escape(quote(str(urlhash)))\n    return output\n\n\ndef same_urls_p(a, b):\n    \"\"\" Compare two URLs, ignoring reorganizing of query arguments \"\"\"\n\n    ua = list(urlparse(a))\n    ub = list(urlparse(b))\n\n    ua[4] = parse_qs(ua[4])\n    ub[4] = parse_qs(ub[4])\n\n    return ua == ub\n\n\ndef urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):\n    \"\"\"Analyze `urlargs' (URL CGI GET query arguments in string form)\n       and for each occurrence of argument matching `regexp_argname'\n       replace every substring `text_old' by `text_new'.  Return the\n       resulting new URL.\n\n       Used to be used for search engine's create_nearest_terms_box,\n       now it is not used there anymore.  It is left here in case it\n       will become possibly useful later.\n    \"\"\"\n    out = \"\"\n    # parse URL arguments into a dictionary:\n    urlargsdict = parse_qs(urlargs)\n    ## construct new URL arguments:\n    urlargsdictnew = {}\n    for key in urlargsdict.keys():\n        if re.match(regexp_argname, key): # replace `arg' by new values\n            urlargsdictnew[key] = []\n            for parg in urlargsdict[key]:\n                urlargsdictnew[key].append(parg.replace(text_old, text_new))\n        else: # keep old values\n            urlargsdictnew[key] = urlargsdict[key]\n    # build new URL for this word:\n    for key in urlargsdictnew.keys():\n        for val in urlargsdictnew[key]:\n            out += \"&amp;\" + key + \"=\" + quote_plus(val, '')\n    if out.startswith(\"&amp;\"):\n        out = out[5:]\n    return out\n\ndef get_title_of_page(url):\n    \"\"\"\n    @param url: page to get the title from\n    @return: the page title in utf-8 or None in case\n    that any kind of exception occured e.g. connection error,\n    URL not known\n    \"\"\"\n    if BEAUTIFUL_SOUP_IMPORTED:\n        try:\n            opener = make_invenio_opener('UrlUtils')\n            soup = BeautifulSoup.BeautifulSoup(opener.open(url))\n            return soup.title.string.encode(\"utf-8\")\n        except:\n            return None\n    else:\n        return \"Title not available\"\n\n\ndef make_user_agent_string(component=None):\n    \"\"\"\n    Return a nice and uniform user-agent string to be used when Invenio\n    act as a client in HTTP requests.\n    \"\"\"\n    ret = \"Invenio-%s (+%s; \\\"%s\\\")\" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))\n    if component:\n        ret += \" %s\" % component\n    return ret\n\n\nclass InvenioFancyURLopener(FancyURLopener):\n    \"\"\"Provide default user agent string.\"\"\"\n\n    @cached_property\n    def version(self):\n        return make_user_agent_string()\n\n    def prompt_user_passwd(self, host, realm):\n        \"\"\"Don't prompt\"\"\"\n        return None, None\n\n## Let's override default useragent string\n## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html\nurllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())\n\ndef make_invenio_opener(component=None):\n    \"\"\"\n    Return an urllib2 opener with the useragent already set in the appropriate\n    way.\n    \"\"\"\n    opener = urllib2.build_opener()\n    opener.addheaders = [('User-agent', make_user_agent_string(component))]\n    return opener\n\ndef create_AWS_request_url(base_url, argd, _amazon_secret_access_key,\n                           _timestamp=None):\n    \"\"\"\n    Create a signed AWS (Amazon Web Service) request URL corresponding\n    to the given parameters.\n\n    Example:\n    >> create_AWS_request_url(\"http://ecs.amazon.com/onca/xml\",\n                             {'AWSAccessKeyID': '0000000000',\n                              'Service': 'AWSECommerceService',\n                              'Operation': 'ItemLookup',\n                              'ItemID': '0679722769',\n                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},\n                             \"1234567890\")\n\n    @param base_url: Service URL of the Amazon store to query\n    @param argd: dictionary of arguments defining the query\n    @param _amazon_secret_access_key: your Amazon secret key\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @type base_url: string\n    @type argd: dict\n    @type _amazon_secret_access_key: string\n    @type _timestamp: string\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    ## First define a few util functions\n\n    def get_AWS_signature(argd, _amazon_secret_access_key,\n                          method=\"GET\", request_host=\"webservices.amazon.com\",\n                          request_uri=\"/onca/xml\",\n                          _timestamp=None):\n        \"\"\"\n        Returns the signature of an Amazon request, based on the\n        arguments of the request.\n\n        @param argd: dictionary of arguments defining the query\n        @param _amazon_secret_access_key: your Amazon secret key\n        @param method: method of the request POST or GET\n        @param request_host: host contacted for the query. To embed in the signature.\n        @param request_uri: uri contacted at 'request_host'. To embed in the signature.\n        @param _timestamp: for testing purpose only (default: current timestamp)\n\n        @type argd: dict\n        @type _amazon_secret_access_key: string\n        @type method: string\n        @type host_header: string\n        @type http_request_uri: string\n        @type _timestamp: string\n\n        @return signature of the request (string)\n        \"\"\"\n\n        # Add timestamp\n        if not _timestamp:\n            argd[\"Timestamp\"] = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\",\n                                              time.gmtime())\n        else:\n            argd[\"Timestamp\"] = _timestamp\n\n        # Order parameter keys by byte value\n        parameter_keys = argd.keys()\n        parameter_keys.sort()\n\n        # Encode arguments, according to RFC 3986. Make sure we\n        # generate a list which is ordered by byte value of the keys\n        arguments = [quote(str(key), safe=\"~/\") + \"=\" + \\\n                     quote(str(argd[key]), safe=\"~/\") \\\n                     for key in parameter_keys]\n\n        # Join\n        parameters_string = \"&\".join(arguments)\n\n        # Prefix\n        parameters_string = method.upper() + \"\\n\" + \\\n                            request_host.lower() + \"\\n\" + \\\n                            (request_uri or \"/\") + \"\\n\" + \\\n                            parameters_string\n\n        # Sign and return\n        return calculate_RFC2104_HMAC(parameters_string,\n                                      _amazon_secret_access_key)\n\n    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):\n        \"\"\"\n        Computes a RFC 2104 compliant HMAC Signature and then Base64\n        encodes it.\n\n        Module hashlib must be installed if Python < 2.5\n        <http://pypi.python.org/pypi/hashlib/20081119>\n\n        @param data: data to sign\n        @param _amazon_secret_access_key: your Amazon secret key\n\n        @type data: string\n        @type _amazon_secret_access_key: string. Empty if hashlib module not installed\n        \"\"\"\n        if not HASHLIB_IMPORTED:\n            try:\n                raise Exception(\"Module hashlib not installed. Please install it.\")\n            except:\n                from invenio.ext.logging import register_exception\n                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n                return \"\"\n        else:\n            if sys.version_info < (2, 5):\n                # compatibility mode for Python < 2.5 and hashlib\n                my_digest_algo = _MySHA256(sha256())\n            else:\n                my_digest_algo = sha256\n\n        return base64.encodestring(hmac.new(_amazon_secret_access_key,\n                                            data, my_digest_algo).digest()).strip()\n     ## End util functions\n\n    parsed_url = urlparse(base_url)\n    signature = get_AWS_signature(argd, _amazon_secret_access_key,\n                                  request_host=parsed_url[1],\n                                  request_uri=parsed_url[2],\n                                  _timestamp=_timestamp)\n    if signature:\n        argd[\"Signature\"] = signature\n    return base_url + \"?\" + urlencode(argd)\n\n\ndef create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):\n    \"\"\"\n    Create a signed Indico request URL to access Indico HTTP Export APIs.\n\n    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more\n    information.\n\n    Example:\n    >> create_Indico_request_url(\"https://indico.cern.ch\",\n                                 \"categ\",\n                                 \"\",\n                                 [1, 7],\n                                 \"xml\",\n                                 {'onlypublic': 'yes',\n                                  'order': 'title',\n                                  'from': 'today',\n                                  'to': 'tomorrow'},\n                                 '00000000-0000-0000-0000-000000000000',\n                                 '00000000-0000-0000-0000-000000000000')\n\n    @param base_url: Service base URL of the Indico instance to query\n    @param indico_what: element to export\n    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}\n    @param indico_loc: location of the element(s) specified by ID (only used for some elements)\n    @param indico_id: ID of the element to be exported\n    @type indico_id: a string or a list/tuple of strings\n    @param indico_type: output format\n    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}\n    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}\n    @param indico_key: API key provided for the given Indico instance\n    @param indico_sig: API secret key (signature) provided for the given Indico instance\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    url = '/export/' + indico_what + '/'\n    if indico_loc:\n        url += indico_loc + '/'\n    if type(indico_id) in (list, tuple):\n        # dash separated list of values\n        indico_id = '-'.join([str(x) for x in indico_id])\n    url += indico_id + '.' + str(indico_type)\n\n    if hasattr(indico_params, 'items'):\n        items = indico_params.items()\n    else:\n        items = list(indico_params)\n    if indico_key:\n        items.append(('apikey', indico_key))\n    if indico_sig and HASHLIB_IMPORTED:\n        if _timestamp:\n            items.append(('timestamp', str(_timestamp)))\n        else:\n            items.append(('timestamp', str(int(time.time()))))\n        items = sorted(items, key=lambda x: x[0].lower())\n        url_to_sign = '%s?%s' % (url, urlencode(items))\n        if sys.version_info < (2, 5):\n            # compatibility mode for Python < 2.5 and hashlib\n            my_digest_algo = _MySHA1(sha1())\n        else:\n            my_digest_algo = sha1\n        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()\n        items.append(('signature', signature))\n    elif not HASHLIB_IMPORTED:\n        try:\n            raise Exception(\"Module hashlib not installed. Please install it.\")\n        except:\n            from invenio.ext.logging import register_exception\n            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n    if not items:\n        return url\n\n    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))\n    return url\n\nclass _MyHashlibAlgo(object):\n    '''\n    Define a subclass of any hashlib algorithm class, with an additional \"new()\"\n    function, to work with the Python < 2.5 version of the hmac module.\n\n    (This class is more complex than it should, but it is not\n    possible to subclass haslib algorithm)\n    '''\n\n    def __init__(self, obj):\n        \"\"\"Set the wrapped object.\"\"\"\n        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)\n\n        methods = []\n        for name_value in inspect.getmembers(obj, inspect.ismethod):\n            methods.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)\n\n        def isnotmethod(object_):\n            \"Opposite of ismethod(..)\"\n            return not inspect.ismethod(object_)\n        members = []\n        for name_value in inspect.getmembers(obj, isnotmethod):\n            members.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__members__', members)\n\n    def __getattr__(self, name):\n        \"\"\"Redirect unhandled get attribute to self._obj.\"\"\"\n        if not hasattr(self._obj, name):\n            raise AttributeError, (\"'%s' has no attribute %s\" %\n                                   (self.__class__.__name__, name))\n        else:\n            return getattr(self._obj, name)\n\n    def __setattr__(self, name, value):\n        \"\"\"Redirect set attribute to self._obj if necessary.\"\"\"\n        self_has_attr = True\n        try:\n            super(_MyHashlibAlgo, self).__getattribute__(name)\n        except AttributeError:\n            self_has_attr = False\n\n        if (name == \"_obj\" or not hasattr(self, \"_obj\") or\n            not hasattr(self._obj, name) or self_has_attr):\n            return super(_MyHashlibAlgo, self).__setattr__(name, value)\n        else:\n            return setattr(self._obj, name, value)\n\nif HASHLIB_IMPORTED:\n    from invenio.utils.hash import sha256\n\n\n    class _MySHA256(_MyHashlibAlgo):\n        \"A _MyHashlibAlgo subsclass for sha256\"\n        new = lambda d = '': sha256()\n\n\nclass _MySHA1(_MyHashlibAlgo):\n    \"A _MyHashlibAlgo subsclass for sha1\"\n    new = lambda d = '': sha1()\n\ndef auto_version_url(file_path):\n    \"\"\" Appends modification time of the file to the request URL in order for the\n        browser to refresh the cache when file changes\n\n        @param file_path: path to the file, e.g js/foo.js\n        @return: file_path with modification time appended to URL\n    \"\"\"\n    file_md5 = \"\"\n    try:\n        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()\n    except IOError:\n        pass\n    return file_path + \"?%s\" % file_md5\n\ndef get_relative_url(url):\n    \"\"\"\n    Returns the relative URL from a URL. For example:\n\n    'http://web.net' -> ''\n    'http://web.net/' -> ''\n    'http://web.net/1222' -> '/1222'\n    'http://web.net/wsadas/asd' -> '/wsadas/asd'\n\n    It will never return a trailing \"/\".\n\n    @param url: A url to transform\n    @type url: str\n\n    @return: relative URL\n    \"\"\"\n    # remove any protocol info before\n    stripped_site_url = url.replace(\"://\", \"\")\n    baseurl = \"/\" + \"/\".join(stripped_site_url.split(\"/\")[1:])\n\n    # remove any trailing slash (\"/\")\n    if baseurl[-1] == \"/\":\n        return baseurl[:-1]\n    else:\n        return baseurl\n/n/n/n", "label": 0}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize#show_login\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                    next=request.args.get('next', '/')\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    if request.args.get('next', None):\n        return redirect(request.args.get('next'))\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        if request.args.get('next', None):\n            return redirect(request.args.get('next'))\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import quote_plus\nfrom flask import url_for, session\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom invenio.ext.sqlalchemy import db\n\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(url_for(\"oauthclient.login\", remote_app='test'))\n        self.assertStatus(resp, 302)\n        self.assertEqual(\n            resp.location,\n            \"https://foo.bar/oauth/authorize?response_type=code&\"\n            \"client_id=testid&redirect_uri=%s\" % quote_plus(url_for(\n                \"oauthclient.authorized\", remote_app='test', _external=True\n            ))\n        )\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            resp = self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                )\n            )\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_token_getter_setter(self, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                # Assert if every is as it should be.\n                assert session['oauth_token_full'] == ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_rejected(self, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Client blueprint used to handle OAuth callbacks. \"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, url_for, request\n\nfrom flask.ext.login import user_logged_out\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\" Setup OAuth clients. \"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\" Send user to remote application for authentication. \"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        next=request.args.get('next') or request.referrer or None,\n        _external=True,\n    )\n\n    return oauth.remote_apps[remote_app].authorize(callback=callback_url)\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\" Authorized handler callback. \"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\" Extra signup step. \"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\" Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/n", "label": 1}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token\n                                 expires. Defaults to 300 seconds.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n\nOAUTHCLIENT_STATE_EXPIRES = 300\n\"\"\"Number of seconds after which the state token expires.\"\"\"\n/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate',\n                              'show_login': 'true'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef get_session_next_url(remote_app):\n    return session.get(\n        \"%s_%s\" % (token_session_key(remote_app), \"next_url\")\n    )\n\n\ndef set_session_next_url(remote_app, url):\n    session[\"%s_%s\" % (token_session_key(remote_app), \"next_url\")] = \\\n        url\n\n\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    next_url = get_session_next_url(remote.name)\n    if next_url:\n        return redirect(next_url)\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        next_url = get_session_next_url(remote.name)\n        if next_url:\n            return redirect(next_url)\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite\nfrom mock import MagicMock, Mock, patch\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nclass FormTestCase(InvenioTestCase):\n\n    @patch('invenio.modules.oauthclient.forms.User')\n    def test_validate_email(self, user):\n        from invenio.modules.oauthclient.forms import EmailSignUpForm\n\n        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())\n\n        # Mock query\n        obj = MagicMock()\n        obj.one = MagicMock(side_effect=SQLAlchemyError())\n        user.query.filter = Mock(return_value=obj)\n        self.assertTrue(\n            EmailSignUpForm(email='good@invenio-software.org').validate()\n        )\n\n        user.query.filter = MagicMock()\n        self.assertFalse(\n            EmailSignUpForm(email='bad@invenio-software.org').validate()\n        )\n\n\nTEST_SUITE = make_test_suite(FormTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nimport time\nfrom flask import url_for, session\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sqlalchemy import db\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom itsdangerous import TimedJSONWebSignatureSerializer\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import parse_qs, urlparse\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_redirect_uri(self):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test',\n                    next='http://invenio-software.org')\n        )\n        self.assertStatus(resp, 302)\n\n        # Verify parameters\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Verify next parameter in state token does not allow blanco redirects\n        state = serializer.loads(params['state'][0])\n        self.assertIsNone(state['next'])\n\n        # Assert redirect uri does not have any parameters.\n        params = parse_qs(urlparse(params['redirect_uri'][0]).query)\n        self.assertEqual(params, {})\n\n        # Assert that local redirects are allowed\n        test_urls = [\n            '/search',\n            url_for('oauthclient.disconnect', remote_app='test',\n                    _external=True)\n        ]\n        for url in test_urls:\n            resp = self.client.get(\n                url_for(\"oauthclient.login\", remote_app='test', next=url)\n            )\n            self.assertStatus(resp, 302)\n            state = serializer.loads(\n                parse_qs(urlparse(resp.location).query)['state'][0]\n            )\n            self.assertEqual(url, state['next'])\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test', next='/')\n        )\n        self.assertStatus(resp, 302)\n\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            from invenio.modules.oauthclient.views.client import serializer\n\n            state = serializer.dumps({\n                'app': 'test',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                    state=state\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            state = serializer.dumps({\n                'app': 'test_invalid',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                    state=state,\n                )\n            )\n\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_state_token(self, session):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Mock session id\n        session.sid = '1234'\n\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n\n            # Good state token\n            state = serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            resp = c.get(\n                url_for(\"oauthclient.authorized\", remote_app='test',\n                        code='test', state=state)\n            )\n            self.assert200(resp)\n\n            outdated_serializer = TimedJSONWebSignatureSerializer(\n                cfg['SECRET_KEY'],\n                expires_in=0,\n            )\n\n            # Bad state - timeout\n            state1 = outdated_serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - app\n            state2 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test_invalid', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - sid\n            state3 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test', 'sid': 'bad',  'next': None, }\n            )\n            time.sleep(1)\n            for s in [state1, state2, state3]:\n                resp = c.get(\n                    url_for(\"oauthclient.authorized\", remote_app='test',\n                            code='test', state=s)\n                )\n                self.assert403(resp)\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_token_getter_setter(self, session, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                state = parse_qs(urlparse(res.location).query)['state'][0]\n\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state,\n                ))\n\n                # Assert if everything is as it should be.\n                from flask import session as flask_session\n                assert flask_session['oauth_token_full'] == \\\n                    ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                # Mock a new authorized request\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_rejected(self, session, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user id\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                from invenio.modules.oauthclient.views.client import serializer\n                state = serializer.dumps({\n                    'app': 'full', 'sid': '1234',  'next': None,\n                })\n\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Client blueprint used to handle OAuth callbacks.\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, request, session, url_for\nfrom flask.ext.login import user_logged_out\nfrom itsdangerous import TimedJSONWebSignatureSerializer, BadData\nfrom werkzeug.local import LocalProxy\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\nfrom invenio.utils.url import get_safe_redirect_target\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler, \\\n    set_session_next_url\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\nserializer = LocalProxy(\n    lambda: TimedJSONWebSignatureSerializer(\n        cfg['SECRET_KEY'],\n        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],\n    )\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\"Setup OAuth clients.\"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\"Send user to remote application for authentication.\"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    # Get redirect target in safe manner.\n    next_param = get_safe_redirect_target(arg='next')\n\n    # Redirect URI - must be registered in the remote service.\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        _external=True,\n    )\n\n    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES\n    # seconds.\n    state_token = serializer.dumps({\n        'app': remote_app,\n        'next': next_param,\n        'sid': session.sid,\n    })\n\n    return oauth.remote_apps[remote_app].authorize(\n        callback=callback_url,\n        state=state_token,\n    )\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\"Authorized handler callback.\"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n\n    state_token = request.args.get('state')\n\n    # Verify state parameter\n    try:\n        assert state_token\n        # Checks authenticity and integrity of state and decodes the value.\n        state = serializer.loads(state_token)\n        # Verify that state is for this session, app and that next parameter\n        # have not been modified.\n        assert state['sid'] == session.sid\n        assert state['app'] == remote_app\n        # Store next URL\n        set_session_next_url(remote_app, state['next'])\n    except (AssertionError, BadData):\n        abort(403)\n\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\"Extra signup step.\"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\"Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"\nurlutils.py -- helper functions for URL related problems such as\nargument washing, redirection, etc.\n\"\"\"\n\n__revision__ = \"$Id$\"\n\nimport time\nimport base64\nimport hmac\nimport re\nimport sys\nimport os\nimport inspect\nimport urllib\nimport urllib2\nfrom urllib import urlencode, quote_plus, quote, FancyURLopener\nfrom six.moves.urllib.parse import urlparse, urlunparse\nfrom cgi import parse_qs, parse_qsl, escape\nfrom werkzeug import cached_property\nfrom werkzeug.local import LocalProxy\n\ntry:\n    import BeautifulSoup\n    BEAUTIFUL_SOUP_IMPORTED = True\nexcept ImportError:\n    BEAUTIFUL_SOUP_IMPORTED = False\n\nfrom invenio.base.globals import cfg\nfrom invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED\nfrom invenio.utils.text import wash_for_utf8\nfrom invenio.utils import apache\n\n\ndef wash_url_argument(var, new_type):\n    \"\"\"\n    Wash argument into 'new_type', that can be 'list', 'str',\n                                               'int', 'tuple' or 'dict'.\n    If needed, the check 'type(var) is not None' should be done before\n    calling this function.\n    @param var: variable value\n    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'\n    @return: as much as possible, value var as type new_type\n            If var is a list, will change first element into new_type.\n            If int check unsuccessful, returns 0\n    \"\"\"\n    out = []\n    if new_type == 'list':  # return lst\n        if isinstance(var, list):\n            out = var\n        else:\n            out = [var]\n    elif new_type == 'str':  # return str\n        if isinstance(var, list):\n            try:\n                out = \"%s\" % var[0]\n            except:\n                out = \"\"\n        elif isinstance(var, str):\n            out = var\n        else:\n            out = \"%s\" % var\n    elif new_type == 'int': # return int\n        if isinstance(var, list):\n            try:\n                out = int(var[0])\n            except:\n                out = 0\n        elif isinstance(var, (int, long)):\n            out = var\n        elif isinstance(var, str):\n            try:\n                out = int(var)\n            except:\n                out = 0\n        else:\n            out = 0\n    elif new_type == 'tuple': # return tuple\n        if isinstance(var, tuple):\n            out = var\n        else:\n            out = (var, )\n    elif new_type == 'dict': # return dictionary\n        if isinstance(var, dict):\n            out = var\n        else:\n            out = {0: var}\n    return out\n\n\nfrom urlparse import urlparse, urljoin\nfrom flask import request, url_for\n\ndef is_local_url(target):\n    \"\"\"Determine if URL is a local.\"\"\"\n    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))\n    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))\n    return test_url.scheme in ('http', 'https') and \\\n           ref_url.netloc == test_url.netloc\n\n\ndef get_safe_redirect_target(arg='next'):\n    \"\"\"Get URL to redirect to and ensure that it is local.\"\"\"\n    for target in request.args.get(arg), request.referrer:\n        if not target:\n            continue\n        if is_local_url(target):\n            return target\n    return None\n\n\ndef redirect_to_url(req, url, redirection_type=None, norobot=False):\n    \"\"\"\n    Redirect current page to url.\n    @param req: request as received from apache\n    @param url: url to redirect to\n    @param redirection_type: what kind of redirection is required:\n    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300\n          apache.HTTP_MOVED_PERMANENTLY            = 301\n          apache.HTTP_MOVED_TEMPORARILY            = 302\n          apache.HTTP_SEE_OTHER                    = 303\n          apache.HTTP_NOT_MODIFIED                 = 304\n          apache.HTTP_USE_PROXY                    = 305\n          apache.HTTP_TEMPORARY_REDIRECT           = 307\n    The default is apache.HTTP_MOVED_TEMPORARILY\n    @param norobot: wether to instruct crawlers and robots such as GoogleBot\n        not to index past this point.\n    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3\n    \"\"\"\n    url = url.strip()\n    if redirection_type is None:\n        redirection_type = apache.HTTP_MOVED_TEMPORARILY\n\n    from flask import redirect\n    r = redirect(url, code=redirection_type)\n    raise apache.SERVER_RETURN, r\n    #FIXME enable code bellow\n\n    del req.headers_out[\"Cache-Control\"]\n    req.headers_out[\"Cache-Control\"] = \"no-cache, private, no-store, \" \\\n        \"must-revalidate, post-check=0, pre-check=0, max-age=0\"\n    req.headers_out[\"Pragma\"] = \"no-cache\"\n\n    if norobot:\n        req.headers_out[\"X-Robots-Tag\"] = \"noarchive, nosnippet, noindex, nocache\"\n\n    user_agent = req.headers_in.get('User-Agent', '')\n    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:\n        ## HACK: this is to workaround Microsoft Office trying to be smart\n        ## when users click on URLs in Office documents that require\n        ## authentication. Office will check the validity of the URL\n        ## but will pass the browser the redirected URL rather than\n        ## the original one. This is incompatible with e.g. Shibboleth\n        ## based SSO since the referer would be lost.\n        ## See: http://support.microsoft.com/kb/899927\n        req.status = 200\n        req.content_type = 'text/html'\n        if req.method != 'HEAD':\n            req.write(\"\"\"\n<html>\n    <head>\n        <title>Intermediate page for URLs clicked on MS Office Documents</title>\n        <meta http-equiv=\"REFRESH\" content=\"5;url=%(url)s\"></meta>\n    </head>\n    <body>\n        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=\"%(url)s\">%(url_ok)s</a>.</p>\n    </body>\n</html>\"\"\" % {\n                'url': escape(req.unparsed_uri, True),\n                'url_ok': escape(req.unparsed_uri)\n            })\n        raise apache.SERVER_RETURN(apache.DONE)\n\n    req.headers_out[\"Location\"] = url\n\n    if req.response_sent_p:\n        raise IOError(\"Cannot redirect after headers have already been sent.\")\n\n    req.status = redirection_type\n    req.write('<p>Please go to <a href=\"%s\">here</a></p>\\n' % url)\n\n    raise apache.SERVER_RETURN, apache.DONE\n\n\ndef rewrite_to_secure_url(url, secure_base=None):\n    \"\"\"\n    Rewrite URL to a Secure URL\n\n    @param url URL to be rewritten to a secure URL.\n    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).\n    \"\"\"\n    if secure_base is None:\n        secure_base = cfg.get('CFG_SITE_SECURE_URL')\n    url_parts = list(urlparse(url))\n    url_secure_parts = urlparse(secure_base)\n    url_parts[0] = url_secure_parts[0]\n    url_parts[1] = url_secure_parts[1]\n    return urlunparse(url_parts)\n\n\ndef get_referer(req, replace_ampersands=False):\n    \"\"\" Return the referring page of a request.\n    Referer (wikipedia): Referer is a common misspelling of the word\n    \"referrer\"; so common, in fact, that it made it into the official\n    specification of HTTP. When visiting a webpage, the referer or\n    referring page is the URL of the previous webpage from which a link was\n    followed.\n    @param req: request\n    @param replace_ampersands: if 1, replace & by &amp; in url\n                               (correct HTML cannot contain & characters alone)\n    \"\"\"\n    try:\n        referer = req.headers_in['Referer']\n        if replace_ampersands == 1:\n            return referer.replace('&', '&amp;')\n        return referer\n    except KeyError:\n        return ''\n\n\ndef drop_default_urlargd(urlargd, default_urlargd):\n    lndefault = {}\n    lndefault.update(default_urlargd)\n\n    ## Commented out. An Invenio URL now should always specify the desired\n    ## language, in order not to raise the automatic language discovery\n    ## (client browser language can be used now in place of CFG_SITE_LANG)\n    # lndefault['ln'] = (str, CFG_SITE_LANG)\n\n    canonical = {}\n    canonical.update(urlargd)\n\n    for k, v in urlargd.items():\n        try:\n            d = lndefault[k]\n\n            if d[1] == v:\n                del canonical[k]\n\n        except KeyError:\n            pass\n\n    return canonical\n\n\ndef make_canonical_urlargd(urlargd, default_urlargd):\n    \"\"\" Build up the query part of an URL from the arguments passed in\n    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which\n    contains tuples of the form (type, default value) for the query\n    arguments (this is the same dictionary as the one you can pass to\n    webinterface_handler.wash_urlargd).\n\n    When a query element has its default value, it is discarded, so\n    that the simplest (canonical) url query is returned.\n\n    The result contains the initial '?' if there are actual query\n    items remaining.\n    \"\"\"\n\n    canonical = drop_default_urlargd(urlargd, default_urlargd)\n\n    if canonical:\n        return '?' + urlencode(canonical, doseq=True)\n        #FIXME double escaping of '&'? .replace('&', '&amp;')\n\n    return ''\n\n\ndef create_html_link(urlbase, urlargd, link_label, linkattrd=None,\n                     escape_urlargd=True, escape_linkattrd=True,\n                     urlhash=None):\n    \"\"\"Creates a W3C compliant link.\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})\n    @param link_label: text displayed in a browser (has to be already escaped)\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    attributes_separator = ' '\n    output = '<a href=\"' + \\\n             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '\"'\n    if linkattrd:\n        output += ' '\n        if escape_linkattrd:\n            attributes = [escape(str(key), quote=True) + '=\"' + \\\n                          escape(str(linkattrd[key]), quote=True) + '\"'\n                                for key in linkattrd.keys()]\n        else:\n            attributes = [str(key) + '=\"' + str(linkattrd[key]) + '\"'\n                                for key in linkattrd.keys()]\n        output += attributes_separator.join(attributes)\n    output = wash_for_utf8(output)\n    output += '>' + wash_for_utf8(link_label) + '</a>'\n    return output\n\n\ndef create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,\n        link_label=\"%(email)s\", linkattrd=None, escape_urlargd=True,\n        escape_linkattrd=True, email_obfuscation_mode=None):\n    \"\"\"Creates a W3C compliant 'mailto' link.\n\n    Encode/encrypt given email to reduce undesired automated email\n    harvesting when embedded in a web page.\n\n    NOTE: there is no ultimate solution to protect against email\n    harvesting. All have drawbacks and can more or less be\n    circumvented. There are other techniques to protect email\n    addresses. We implement the less annoying one for users.\n\n    @param email: the recipient of the email\n    @param subject: a default subject for the email (must not contain\n                    line feeds)\n    @param body: a default body for the email\n    @param cc: the co-recipient(s) of the email\n    @param bcc: the hidden co-recpient(s) of the email\n    @param link_label: the label of this mailto link. String\n                       replacement is performed on key %(email)s with\n                       the email address if needed.\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param email_obfuscation_mode: the protection mode. See below:\n\n    You can choose among several modes to protect emails. It is\n    advised to keep the default\n    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is\n    possible for an admin to change the policy globally.\n\n    Available modes ([t] means \"transparent\" for the user):\n\n         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and\n             CFG_SITE_SUPPORT_EMAIL.\n\n      [t] 0 : no protection, email returned as is.\n                foo@example.com => foo@example.com\n\n          1 : basic email munging: replaces @ by [at] and . by [dot]\n                foo@example.com => foo [at] example [dot] com\n\n      [t] 2 : transparent name mangling: characters are replaced by\n              equivalent HTML entities.\n                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;\n\n      [t] 3 : javascript insertion. Requires Javascript enabled on client side.\n\n          4 : replaces @ and . characters by gif equivalents.\n                foo@example.com => foo<img src=\"at.gif\" alt=\" [at] \">example<img src=\"dot.gif\" alt=\" [dot] \">com\n    \"\"\"\n    # TODO: implement other protection modes to encode/encript email:\n    #\n    ## [t] 5 : form submission. User is redirected to a form that he can\n    ##         fills in to send the email (??Use webmessage??).\n    ##         Depending on WebAccess, ask to answer a question.\n    ##\n    ## [t] 6 : if user can see (controlled by WebAccess), display. Else\n    ##         ask to login to see email. If user cannot see, display\n    ##         form submission.\n\n    if email_obfuscation_mode is None:\n        email_obfuscation_mode = cfg.get(\n            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')\n\n    if linkattrd is None:\n        linkattrd = {}\n\n    parameters = {}\n    if subject:\n        parameters[\"subject\"] = subject\n    if body:\n        parameters[\"body\"] = body.replace('\\r\\n', '\\n').replace('\\n', '\\r\\n')\n    if cc:\n        parameters[\"cc\"] = cc\n    if bcc:\n        parameters[\"bcc\"] = bcc\n\n    # Preprocessing values for some modes\n    if email_obfuscation_mode == 1:\n        # Basic Munging\n        email = email.replace(\"@\", \" [at] \").replace(\".\", \" [dot] \")\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        email = string_to_numeric_char_reference(email)\n\n    if '%(email)s' in link_label:\n        link_label = link_label % {'email': email}\n\n    mailto_link = create_html_link('mailto:' + email, parameters,\n                                   link_label, linkattrd,\n                                   escape_urlargd, escape_linkattrd)\n\n    if email_obfuscation_mode == 0:\n        # Return \"as is\"\n        return mailto_link\n    elif email_obfuscation_mode == 1:\n        # Basic Munging\n        return mailto_link\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        return mailto_link\n    elif email_obfuscation_mode == 3:\n        # Javascript-based\n        return '''<script language=\"JavaScript\" ''' \\\n            '''type=\"text/javascript\">''' \\\n            '''document.write('%s'.split(\"\").reverse().join(\"\"))''' \\\n            '''</script>''' % \\\n               mailto_link[::-1].replace(\"'\", \"\\\\'\")\n    elif email_obfuscation_mode == 4:\n        # GIFs-based\n        email = email.replace('.',\n            '<img src=\"%s/img/dot.gif\" alt=\" [dot] \" '\n            'style=\"vertical-align:bottom\"  />' % cfg.get('CFG_SITE_URL'))\n        email = email.replace('@',\n            '<img src=\"%s/img/at.gif\" alt=\" [at] \" '\n            'style=\"vertical-align:baseline\" />' % cfg.get('CFG_SITE_URL'))\n        return email\n\n    # All other cases, including mode -1:\n    return \"\"\n\n\ndef string_to_numeric_char_reference(string):\n    \"\"\"\n    Encode a string to HTML-compatible numeric character reference.\n    Eg: encode_html_entities(\"abc\") == '&#97;&#98;&#99;'\n    \"\"\"\n    out = \"\"\n    for char in string:\n        out += \"&#\" + str(ord(char)) + \";\"\n    return out\n\ndef get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):\n    \"\"\"\n    Given an Invenio URL returns a tuple with two elements. The first is the\n    canonical URL, that is the original URL with CFG_SITE_URL prefix, and\n    where the ln= argument stripped. The second element element is mapping,\n    language code -> alternate URL\n\n    @param quote_path: if True, the path section of the given C{url}\n                       is quoted according to RFC 2396\n    \"\"\"\n    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)\n    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]\n    parsed_query = washed_argd or parse_qsl(query)\n    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']\n    if drop_ln:\n        canonical_parsed_query = no_ln_parsed_query\n    else:\n        canonical_parsed_query = parsed_query\n    if quote_path:\n        path = urllib.quote(path)\n    canonical_query = urlencode(canonical_parsed_query)\n    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))\n    alternate_urls = {}\n    for ln in cfg.get('CFG_SITE_LANGS'):\n        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])\n        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))\n        alternate_urls[ln] = alternate_url\n    return canonical_url, alternate_urls\n\ndef create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):\n    \"\"\"Creates a W3C compliant URL. Output will look like this:\n    'urlbase?param1=value1&amp;param2=value2'\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    separator = '&amp;'\n    output = urlbase\n    if urlargd:\n        output += '?'\n        if escape_urlargd:\n            arguments = [escape(quote(str(key)), quote=True) + '=' + \\\n                         escape(quote(str(urlargd[key])), quote=True)\n                                for key in urlargd.keys()]\n        else:\n            arguments = [str(key) + '=' + str(urlargd[key])\n                            for key in urlargd.keys()]\n        output += separator.join(arguments)\n    if urlhash:\n        output += \"#\" + escape(quote(str(urlhash)))\n    return output\n\n\ndef same_urls_p(a, b):\n    \"\"\" Compare two URLs, ignoring reorganizing of query arguments \"\"\"\n\n    ua = list(urlparse(a))\n    ub = list(urlparse(b))\n\n    ua[4] = parse_qs(ua[4])\n    ub[4] = parse_qs(ub[4])\n\n    return ua == ub\n\n\ndef urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):\n    \"\"\"Analyze `urlargs' (URL CGI GET query arguments in string form)\n       and for each occurrence of argument matching `regexp_argname'\n       replace every substring `text_old' by `text_new'.  Return the\n       resulting new URL.\n\n       Used to be used for search engine's create_nearest_terms_box,\n       now it is not used there anymore.  It is left here in case it\n       will become possibly useful later.\n    \"\"\"\n    out = \"\"\n    # parse URL arguments into a dictionary:\n    urlargsdict = parse_qs(urlargs)\n    ## construct new URL arguments:\n    urlargsdictnew = {}\n    for key in urlargsdict.keys():\n        if re.match(regexp_argname, key): # replace `arg' by new values\n            urlargsdictnew[key] = []\n            for parg in urlargsdict[key]:\n                urlargsdictnew[key].append(parg.replace(text_old, text_new))\n        else: # keep old values\n            urlargsdictnew[key] = urlargsdict[key]\n    # build new URL for this word:\n    for key in urlargsdictnew.keys():\n        for val in urlargsdictnew[key]:\n            out += \"&amp;\" + key + \"=\" + quote_plus(val, '')\n    if out.startswith(\"&amp;\"):\n        out = out[5:]\n    return out\n\ndef get_title_of_page(url):\n    \"\"\"\n    @param url: page to get the title from\n    @return: the page title in utf-8 or None in case\n    that any kind of exception occured e.g. connection error,\n    URL not known\n    \"\"\"\n    if BEAUTIFUL_SOUP_IMPORTED:\n        try:\n            opener = make_invenio_opener('UrlUtils')\n            soup = BeautifulSoup.BeautifulSoup(opener.open(url))\n            return soup.title.string.encode(\"utf-8\")\n        except:\n            return None\n    else:\n        return \"Title not available\"\n\n\ndef make_user_agent_string(component=None):\n    \"\"\"\n    Return a nice and uniform user-agent string to be used when Invenio\n    act as a client in HTTP requests.\n    \"\"\"\n    ret = \"Invenio-%s (+%s; \\\"%s\\\")\" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))\n    if component:\n        ret += \" %s\" % component\n    return ret\n\n\nclass InvenioFancyURLopener(FancyURLopener):\n    \"\"\"Provide default user agent string.\"\"\"\n\n    @cached_property\n    def version(self):\n        return make_user_agent_string()\n\n    def prompt_user_passwd(self, host, realm):\n        \"\"\"Don't prompt\"\"\"\n        return None, None\n\n## Let's override default useragent string\n## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html\nurllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())\n\ndef make_invenio_opener(component=None):\n    \"\"\"\n    Return an urllib2 opener with the useragent already set in the appropriate\n    way.\n    \"\"\"\n    opener = urllib2.build_opener()\n    opener.addheaders = [('User-agent', make_user_agent_string(component))]\n    return opener\n\ndef create_AWS_request_url(base_url, argd, _amazon_secret_access_key,\n                           _timestamp=None):\n    \"\"\"\n    Create a signed AWS (Amazon Web Service) request URL corresponding\n    to the given parameters.\n\n    Example:\n    >> create_AWS_request_url(\"http://ecs.amazon.com/onca/xml\",\n                             {'AWSAccessKeyID': '0000000000',\n                              'Service': 'AWSECommerceService',\n                              'Operation': 'ItemLookup',\n                              'ItemID': '0679722769',\n                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},\n                             \"1234567890\")\n\n    @param base_url: Service URL of the Amazon store to query\n    @param argd: dictionary of arguments defining the query\n    @param _amazon_secret_access_key: your Amazon secret key\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @type base_url: string\n    @type argd: dict\n    @type _amazon_secret_access_key: string\n    @type _timestamp: string\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    ## First define a few util functions\n\n    def get_AWS_signature(argd, _amazon_secret_access_key,\n                          method=\"GET\", request_host=\"webservices.amazon.com\",\n                          request_uri=\"/onca/xml\",\n                          _timestamp=None):\n        \"\"\"\n        Returns the signature of an Amazon request, based on the\n        arguments of the request.\n\n        @param argd: dictionary of arguments defining the query\n        @param _amazon_secret_access_key: your Amazon secret key\n        @param method: method of the request POST or GET\n        @param request_host: host contacted for the query. To embed in the signature.\n        @param request_uri: uri contacted at 'request_host'. To embed in the signature.\n        @param _timestamp: for testing purpose only (default: current timestamp)\n\n        @type argd: dict\n        @type _amazon_secret_access_key: string\n        @type method: string\n        @type host_header: string\n        @type http_request_uri: string\n        @type _timestamp: string\n\n        @return signature of the request (string)\n        \"\"\"\n\n        # Add timestamp\n        if not _timestamp:\n            argd[\"Timestamp\"] = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\",\n                                              time.gmtime())\n        else:\n            argd[\"Timestamp\"] = _timestamp\n\n        # Order parameter keys by byte value\n        parameter_keys = argd.keys()\n        parameter_keys.sort()\n\n        # Encode arguments, according to RFC 3986. Make sure we\n        # generate a list which is ordered by byte value of the keys\n        arguments = [quote(str(key), safe=\"~/\") + \"=\" + \\\n                     quote(str(argd[key]), safe=\"~/\") \\\n                     for key in parameter_keys]\n\n        # Join\n        parameters_string = \"&\".join(arguments)\n\n        # Prefix\n        parameters_string = method.upper() + \"\\n\" + \\\n                            request_host.lower() + \"\\n\" + \\\n                            (request_uri or \"/\") + \"\\n\" + \\\n                            parameters_string\n\n        # Sign and return\n        return calculate_RFC2104_HMAC(parameters_string,\n                                      _amazon_secret_access_key)\n\n    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):\n        \"\"\"\n        Computes a RFC 2104 compliant HMAC Signature and then Base64\n        encodes it.\n\n        Module hashlib must be installed if Python < 2.5\n        <http://pypi.python.org/pypi/hashlib/20081119>\n\n        @param data: data to sign\n        @param _amazon_secret_access_key: your Amazon secret key\n\n        @type data: string\n        @type _amazon_secret_access_key: string. Empty if hashlib module not installed\n        \"\"\"\n        if not HASHLIB_IMPORTED:\n            try:\n                raise Exception(\"Module hashlib not installed. Please install it.\")\n            except:\n                from invenio.ext.logging import register_exception\n                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n                return \"\"\n        else:\n            if sys.version_info < (2, 5):\n                # compatibility mode for Python < 2.5 and hashlib\n                my_digest_algo = _MySHA256(sha256())\n            else:\n                my_digest_algo = sha256\n\n        return base64.encodestring(hmac.new(_amazon_secret_access_key,\n                                            data, my_digest_algo).digest()).strip()\n     ## End util functions\n\n    parsed_url = urlparse(base_url)\n    signature = get_AWS_signature(argd, _amazon_secret_access_key,\n                                  request_host=parsed_url[1],\n                                  request_uri=parsed_url[2],\n                                  _timestamp=_timestamp)\n    if signature:\n        argd[\"Signature\"] = signature\n    return base_url + \"?\" + urlencode(argd)\n\n\ndef create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):\n    \"\"\"\n    Create a signed Indico request URL to access Indico HTTP Export APIs.\n\n    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more\n    information.\n\n    Example:\n    >> create_Indico_request_url(\"https://indico.cern.ch\",\n                                 \"categ\",\n                                 \"\",\n                                 [1, 7],\n                                 \"xml\",\n                                 {'onlypublic': 'yes',\n                                  'order': 'title',\n                                  'from': 'today',\n                                  'to': 'tomorrow'},\n                                 '00000000-0000-0000-0000-000000000000',\n                                 '00000000-0000-0000-0000-000000000000')\n\n    @param base_url: Service base URL of the Indico instance to query\n    @param indico_what: element to export\n    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}\n    @param indico_loc: location of the element(s) specified by ID (only used for some elements)\n    @param indico_id: ID of the element to be exported\n    @type indico_id: a string or a list/tuple of strings\n    @param indico_type: output format\n    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}\n    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}\n    @param indico_key: API key provided for the given Indico instance\n    @param indico_sig: API secret key (signature) provided for the given Indico instance\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    url = '/export/' + indico_what + '/'\n    if indico_loc:\n        url += indico_loc + '/'\n    if type(indico_id) in (list, tuple):\n        # dash separated list of values\n        indico_id = '-'.join([str(x) for x in indico_id])\n    url += indico_id + '.' + str(indico_type)\n\n    if hasattr(indico_params, 'items'):\n        items = indico_params.items()\n    else:\n        items = list(indico_params)\n    if indico_key:\n        items.append(('apikey', indico_key))\n    if indico_sig and HASHLIB_IMPORTED:\n        if _timestamp:\n            items.append(('timestamp', str(_timestamp)))\n        else:\n            items.append(('timestamp', str(int(time.time()))))\n        items = sorted(items, key=lambda x: x[0].lower())\n        url_to_sign = '%s?%s' % (url, urlencode(items))\n        if sys.version_info < (2, 5):\n            # compatibility mode for Python < 2.5 and hashlib\n            my_digest_algo = _MySHA1(sha1())\n        else:\n            my_digest_algo = sha1\n        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()\n        items.append(('signature', signature))\n    elif not HASHLIB_IMPORTED:\n        try:\n            raise Exception(\"Module hashlib not installed. Please install it.\")\n        except:\n            from invenio.ext.logging import register_exception\n            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n    if not items:\n        return url\n\n    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))\n    return url\n\nclass _MyHashlibAlgo(object):\n    '''\n    Define a subclass of any hashlib algorithm class, with an additional \"new()\"\n    function, to work with the Python < 2.5 version of the hmac module.\n\n    (This class is more complex than it should, but it is not\n    possible to subclass haslib algorithm)\n    '''\n\n    def __init__(self, obj):\n        \"\"\"Set the wrapped object.\"\"\"\n        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)\n\n        methods = []\n        for name_value in inspect.getmembers(obj, inspect.ismethod):\n            methods.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)\n\n        def isnotmethod(object_):\n            \"Opposite of ismethod(..)\"\n            return not inspect.ismethod(object_)\n        members = []\n        for name_value in inspect.getmembers(obj, isnotmethod):\n            members.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__members__', members)\n\n    def __getattr__(self, name):\n        \"\"\"Redirect unhandled get attribute to self._obj.\"\"\"\n        if not hasattr(self._obj, name):\n            raise AttributeError, (\"'%s' has no attribute %s\" %\n                                   (self.__class__.__name__, name))\n        else:\n            return getattr(self._obj, name)\n\n    def __setattr__(self, name, value):\n        \"\"\"Redirect set attribute to self._obj if necessary.\"\"\"\n        self_has_attr = True\n        try:\n            super(_MyHashlibAlgo, self).__getattribute__(name)\n        except AttributeError:\n            self_has_attr = False\n\n        if (name == \"_obj\" or not hasattr(self, \"_obj\") or\n            not hasattr(self._obj, name) or self_has_attr):\n            return super(_MyHashlibAlgo, self).__setattr__(name, value)\n        else:\n            return setattr(self._obj, name, value)\n\nif HASHLIB_IMPORTED:\n    from invenio.utils.hash import sha256\n\n\n    class _MySHA256(_MyHashlibAlgo):\n        \"A _MyHashlibAlgo subsclass for sha256\"\n        new = lambda d = '': sha256()\n\n\nclass _MySHA1(_MyHashlibAlgo):\n    \"A _MyHashlibAlgo subsclass for sha1\"\n    new = lambda d = '': sha1()\n\ndef auto_version_url(file_path):\n    \"\"\" Appends modification time of the file to the request URL in order for the\n        browser to refresh the cache when file changes\n\n        @param file_path: path to the file, e.g js/foo.js\n        @return: file_path with modification time appended to URL\n    \"\"\"\n    file_md5 = \"\"\n    try:\n        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()\n    except IOError:\n        pass\n    return file_path + \"?%s\" % file_md5\n\ndef get_relative_url(url):\n    \"\"\"\n    Returns the relative URL from a URL. For example:\n\n    'http://web.net' -> ''\n    'http://web.net/' -> ''\n    'http://web.net/1222' -> '/1222'\n    'http://web.net/wsadas/asd' -> '/wsadas/asd'\n\n    It will never return a trailing \"/\".\n\n    @param url: A url to transform\n    @type url: str\n\n    @return: relative URL\n    \"\"\"\n    # remove any protocol info before\n    stripped_site_url = url.replace(\"://\", \"\")\n    baseurl = \"/\" + \"/\".join(stripped_site_url.split(\"/\")[1:])\n\n    # remove any trailing slash (\"/\")\n    if baseurl[-1] == \"/\":\n        return baseurl[:-1]\n    else:\n        return baseurl\n/n/n/n", "label": 0}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize#show_login\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                    next=request.args.get('next', '/')\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    if request.args.get('next', None):\n        return redirect(request.args.get('next'))\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        if request.args.get('next', None):\n            return redirect(request.args.get('next'))\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import quote_plus\nfrom flask import url_for, session\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom invenio.ext.sqlalchemy import db\n\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(url_for(\"oauthclient.login\", remote_app='test'))\n        self.assertStatus(resp, 302)\n        self.assertEqual(\n            resp.location,\n            \"https://foo.bar/oauth/authorize?response_type=code&\"\n            \"client_id=testid&redirect_uri=%s\" % quote_plus(url_for(\n                \"oauthclient.authorized\", remote_app='test', _external=True\n            ))\n        )\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            resp = self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                )\n            )\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_token_getter_setter(self, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                # Assert if every is as it should be.\n                assert session['oauth_token_full'] == ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_rejected(self, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Client blueprint used to handle OAuth callbacks. \"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, url_for, request\n\nfrom flask.ext.login import user_logged_out\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\" Setup OAuth clients. \"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\" Send user to remote application for authentication. \"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        next=request.args.get('next') or request.referrer or None,\n        _external=True,\n    )\n\n    return oauth.remote_apps[remote_app].authorize(callback=callback_url)\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\" Authorized handler callback. \"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\" Extra signup step. \"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\" Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/n", "label": 1}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token\n                                 expires. Defaults to 300 seconds.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n\nOAUTHCLIENT_STATE_EXPIRES = 300\n\"\"\"Number of seconds after which the state token expires.\"\"\"\n/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate',\n                              'show_login': 'true'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef get_session_next_url(remote_app):\n    return session.get(\n        \"%s_%s\" % (token_session_key(remote_app), \"next_url\")\n    )\n\n\ndef set_session_next_url(remote_app, url):\n    session[\"%s_%s\" % (token_session_key(remote_app), \"next_url\")] = \\\n        url\n\n\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    next_url = get_session_next_url(remote.name)\n    if next_url:\n        return redirect(next_url)\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        next_url = get_session_next_url(remote.name)\n        if next_url:\n            return redirect(next_url)\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite\nfrom mock import MagicMock, Mock, patch\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nclass FormTestCase(InvenioTestCase):\n\n    @patch('invenio.modules.oauthclient.forms.User')\n    def test_validate_email(self, user):\n        from invenio.modules.oauthclient.forms import EmailSignUpForm\n\n        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())\n\n        # Mock query\n        obj = MagicMock()\n        obj.one = MagicMock(side_effect=SQLAlchemyError())\n        user.query.filter = Mock(return_value=obj)\n        self.assertTrue(\n            EmailSignUpForm(email='good@invenio-software.org').validate()\n        )\n\n        user.query.filter = MagicMock()\n        self.assertFalse(\n            EmailSignUpForm(email='bad@invenio-software.org').validate()\n        )\n\n\nTEST_SUITE = make_test_suite(FormTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nimport time\nfrom flask import url_for, session\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sqlalchemy import db\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom itsdangerous import TimedJSONWebSignatureSerializer\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import parse_qs, urlparse\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_redirect_uri(self):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test',\n                    next='http://invenio-software.org')\n        )\n        self.assertStatus(resp, 302)\n\n        # Verify parameters\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Verify next parameter in state token does not allow blanco redirects\n        state = serializer.loads(params['state'][0])\n        self.assertIsNone(state['next'])\n\n        # Assert redirect uri does not have any parameters.\n        params = parse_qs(urlparse(params['redirect_uri'][0]).query)\n        self.assertEqual(params, {})\n\n        # Assert that local redirects are allowed\n        test_urls = [\n            '/search',\n            url_for('oauthclient.disconnect', remote_app='test',\n                    _external=True)\n        ]\n        for url in test_urls:\n            resp = self.client.get(\n                url_for(\"oauthclient.login\", remote_app='test', next=url)\n            )\n            self.assertStatus(resp, 302)\n            state = serializer.loads(\n                parse_qs(urlparse(resp.location).query)['state'][0]\n            )\n            self.assertEqual(url, state['next'])\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test', next='/')\n        )\n        self.assertStatus(resp, 302)\n\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            from invenio.modules.oauthclient.views.client import serializer\n\n            state = serializer.dumps({\n                'app': 'test',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                    state=state\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            state = serializer.dumps({\n                'app': 'test_invalid',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                    state=state,\n                )\n            )\n\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_state_token(self, session):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Mock session id\n        session.sid = '1234'\n\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n\n            # Good state token\n            state = serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            resp = c.get(\n                url_for(\"oauthclient.authorized\", remote_app='test',\n                        code='test', state=state)\n            )\n            self.assert200(resp)\n\n            outdated_serializer = TimedJSONWebSignatureSerializer(\n                cfg['SECRET_KEY'],\n                expires_in=0,\n            )\n\n            # Bad state - timeout\n            state1 = outdated_serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - app\n            state2 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test_invalid', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - sid\n            state3 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test', 'sid': 'bad',  'next': None, }\n            )\n            time.sleep(1)\n            for s in [state1, state2, state3]:\n                resp = c.get(\n                    url_for(\"oauthclient.authorized\", remote_app='test',\n                            code='test', state=s)\n                )\n                self.assert403(resp)\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_token_getter_setter(self, session, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                state = parse_qs(urlparse(res.location).query)['state'][0]\n\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state,\n                ))\n\n                # Assert if everything is as it should be.\n                from flask import session as flask_session\n                assert flask_session['oauth_token_full'] == \\\n                    ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                # Mock a new authorized request\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_rejected(self, session, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user id\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                from invenio.modules.oauthclient.views.client import serializer\n                state = serializer.dumps({\n                    'app': 'full', 'sid': '1234',  'next': None,\n                })\n\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Client blueprint used to handle OAuth callbacks.\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, request, session, url_for\nfrom flask.ext.login import user_logged_out\nfrom itsdangerous import TimedJSONWebSignatureSerializer, BadData\nfrom werkzeug.local import LocalProxy\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\nfrom invenio.utils.url import get_safe_redirect_target\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler, \\\n    set_session_next_url\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\nserializer = LocalProxy(\n    lambda: TimedJSONWebSignatureSerializer(\n        cfg['SECRET_KEY'],\n        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],\n    )\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\"Setup OAuth clients.\"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\"Send user to remote application for authentication.\"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    # Get redirect target in safe manner.\n    next_param = get_safe_redirect_target(arg='next')\n\n    # Redirect URI - must be registered in the remote service.\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        _external=True,\n    )\n\n    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES\n    # seconds.\n    state_token = serializer.dumps({\n        'app': remote_app,\n        'next': next_param,\n        'sid': session.sid,\n    })\n\n    return oauth.remote_apps[remote_app].authorize(\n        callback=callback_url,\n        state=state_token,\n    )\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\"Authorized handler callback.\"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n\n    state_token = request.args.get('state')\n\n    # Verify state parameter\n    try:\n        assert state_token\n        # Checks authenticity and integrity of state and decodes the value.\n        state = serializer.loads(state_token)\n        # Verify that state is for this session, app and that next parameter\n        # have not been modified.\n        assert state['sid'] == session.sid\n        assert state['app'] == remote_app\n        # Store next URL\n        set_session_next_url(remote_app, state['next'])\n    except (AssertionError, BadData):\n        abort(403)\n\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\"Extra signup step.\"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\"Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"\nurlutils.py -- helper functions for URL related problems such as\nargument washing, redirection, etc.\n\"\"\"\n\n__revision__ = \"$Id$\"\n\nimport time\nimport base64\nimport hmac\nimport re\nimport sys\nimport os\nimport inspect\nimport urllib\nimport urllib2\nfrom urllib import urlencode, quote_plus, quote, FancyURLopener\nfrom six.moves.urllib.parse import urlparse, urlunparse\nfrom cgi import parse_qs, parse_qsl, escape\nfrom werkzeug import cached_property\nfrom werkzeug.local import LocalProxy\n\ntry:\n    import BeautifulSoup\n    BEAUTIFUL_SOUP_IMPORTED = True\nexcept ImportError:\n    BEAUTIFUL_SOUP_IMPORTED = False\n\nfrom invenio.base.globals import cfg\nfrom invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED\nfrom invenio.utils.text import wash_for_utf8\nfrom invenio.utils import apache\n\n\ndef wash_url_argument(var, new_type):\n    \"\"\"\n    Wash argument into 'new_type', that can be 'list', 'str',\n                                               'int', 'tuple' or 'dict'.\n    If needed, the check 'type(var) is not None' should be done before\n    calling this function.\n    @param var: variable value\n    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'\n    @return: as much as possible, value var as type new_type\n            If var is a list, will change first element into new_type.\n            If int check unsuccessful, returns 0\n    \"\"\"\n    out = []\n    if new_type == 'list':  # return lst\n        if isinstance(var, list):\n            out = var\n        else:\n            out = [var]\n    elif new_type == 'str':  # return str\n        if isinstance(var, list):\n            try:\n                out = \"%s\" % var[0]\n            except:\n                out = \"\"\n        elif isinstance(var, str):\n            out = var\n        else:\n            out = \"%s\" % var\n    elif new_type == 'int': # return int\n        if isinstance(var, list):\n            try:\n                out = int(var[0])\n            except:\n                out = 0\n        elif isinstance(var, (int, long)):\n            out = var\n        elif isinstance(var, str):\n            try:\n                out = int(var)\n            except:\n                out = 0\n        else:\n            out = 0\n    elif new_type == 'tuple': # return tuple\n        if isinstance(var, tuple):\n            out = var\n        else:\n            out = (var, )\n    elif new_type == 'dict': # return dictionary\n        if isinstance(var, dict):\n            out = var\n        else:\n            out = {0: var}\n    return out\n\n\nfrom urlparse import urlparse, urljoin\nfrom flask import request, url_for\n\ndef is_local_url(target):\n    \"\"\"Determine if URL is a local.\"\"\"\n    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))\n    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))\n    return test_url.scheme in ('http', 'https') and \\\n           ref_url.netloc == test_url.netloc\n\n\ndef get_safe_redirect_target(arg='next'):\n    \"\"\"Get URL to redirect to and ensure that it is local.\"\"\"\n    for target in request.args.get(arg), request.referrer:\n        if not target:\n            continue\n        if is_local_url(target):\n            return target\n    return None\n\n\ndef redirect_to_url(req, url, redirection_type=None, norobot=False):\n    \"\"\"\n    Redirect current page to url.\n    @param req: request as received from apache\n    @param url: url to redirect to\n    @param redirection_type: what kind of redirection is required:\n    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300\n          apache.HTTP_MOVED_PERMANENTLY            = 301\n          apache.HTTP_MOVED_TEMPORARILY            = 302\n          apache.HTTP_SEE_OTHER                    = 303\n          apache.HTTP_NOT_MODIFIED                 = 304\n          apache.HTTP_USE_PROXY                    = 305\n          apache.HTTP_TEMPORARY_REDIRECT           = 307\n    The default is apache.HTTP_MOVED_TEMPORARILY\n    @param norobot: wether to instruct crawlers and robots such as GoogleBot\n        not to index past this point.\n    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3\n    \"\"\"\n    url = url.strip()\n    if redirection_type is None:\n        redirection_type = apache.HTTP_MOVED_TEMPORARILY\n\n    from flask import redirect\n    r = redirect(url, code=redirection_type)\n    raise apache.SERVER_RETURN, r\n    #FIXME enable code bellow\n\n    del req.headers_out[\"Cache-Control\"]\n    req.headers_out[\"Cache-Control\"] = \"no-cache, private, no-store, \" \\\n        \"must-revalidate, post-check=0, pre-check=0, max-age=0\"\n    req.headers_out[\"Pragma\"] = \"no-cache\"\n\n    if norobot:\n        req.headers_out[\"X-Robots-Tag\"] = \"noarchive, nosnippet, noindex, nocache\"\n\n    user_agent = req.headers_in.get('User-Agent', '')\n    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:\n        ## HACK: this is to workaround Microsoft Office trying to be smart\n        ## when users click on URLs in Office documents that require\n        ## authentication. Office will check the validity of the URL\n        ## but will pass the browser the redirected URL rather than\n        ## the original one. This is incompatible with e.g. Shibboleth\n        ## based SSO since the referer would be lost.\n        ## See: http://support.microsoft.com/kb/899927\n        req.status = 200\n        req.content_type = 'text/html'\n        if req.method != 'HEAD':\n            req.write(\"\"\"\n<html>\n    <head>\n        <title>Intermediate page for URLs clicked on MS Office Documents</title>\n        <meta http-equiv=\"REFRESH\" content=\"5;url=%(url)s\"></meta>\n    </head>\n    <body>\n        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=\"%(url)s\">%(url_ok)s</a>.</p>\n    </body>\n</html>\"\"\" % {\n                'url': escape(req.unparsed_uri, True),\n                'url_ok': escape(req.unparsed_uri)\n            })\n        raise apache.SERVER_RETURN(apache.DONE)\n\n    req.headers_out[\"Location\"] = url\n\n    if req.response_sent_p:\n        raise IOError(\"Cannot redirect after headers have already been sent.\")\n\n    req.status = redirection_type\n    req.write('<p>Please go to <a href=\"%s\">here</a></p>\\n' % url)\n\n    raise apache.SERVER_RETURN, apache.DONE\n\n\ndef rewrite_to_secure_url(url, secure_base=None):\n    \"\"\"\n    Rewrite URL to a Secure URL\n\n    @param url URL to be rewritten to a secure URL.\n    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).\n    \"\"\"\n    if secure_base is None:\n        secure_base = cfg.get('CFG_SITE_SECURE_URL')\n    url_parts = list(urlparse(url))\n    url_secure_parts = urlparse(secure_base)\n    url_parts[0] = url_secure_parts[0]\n    url_parts[1] = url_secure_parts[1]\n    return urlunparse(url_parts)\n\n\ndef get_referer(req, replace_ampersands=False):\n    \"\"\" Return the referring page of a request.\n    Referer (wikipedia): Referer is a common misspelling of the word\n    \"referrer\"; so common, in fact, that it made it into the official\n    specification of HTTP. When visiting a webpage, the referer or\n    referring page is the URL of the previous webpage from which a link was\n    followed.\n    @param req: request\n    @param replace_ampersands: if 1, replace & by &amp; in url\n                               (correct HTML cannot contain & characters alone)\n    \"\"\"\n    try:\n        referer = req.headers_in['Referer']\n        if replace_ampersands == 1:\n            return referer.replace('&', '&amp;')\n        return referer\n    except KeyError:\n        return ''\n\n\ndef drop_default_urlargd(urlargd, default_urlargd):\n    lndefault = {}\n    lndefault.update(default_urlargd)\n\n    ## Commented out. An Invenio URL now should always specify the desired\n    ## language, in order not to raise the automatic language discovery\n    ## (client browser language can be used now in place of CFG_SITE_LANG)\n    # lndefault['ln'] = (str, CFG_SITE_LANG)\n\n    canonical = {}\n    canonical.update(urlargd)\n\n    for k, v in urlargd.items():\n        try:\n            d = lndefault[k]\n\n            if d[1] == v:\n                del canonical[k]\n\n        except KeyError:\n            pass\n\n    return canonical\n\n\ndef make_canonical_urlargd(urlargd, default_urlargd):\n    \"\"\" Build up the query part of an URL from the arguments passed in\n    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which\n    contains tuples of the form (type, default value) for the query\n    arguments (this is the same dictionary as the one you can pass to\n    webinterface_handler.wash_urlargd).\n\n    When a query element has its default value, it is discarded, so\n    that the simplest (canonical) url query is returned.\n\n    The result contains the initial '?' if there are actual query\n    items remaining.\n    \"\"\"\n\n    canonical = drop_default_urlargd(urlargd, default_urlargd)\n\n    if canonical:\n        return '?' + urlencode(canonical, doseq=True)\n        #FIXME double escaping of '&'? .replace('&', '&amp;')\n\n    return ''\n\n\ndef create_html_link(urlbase, urlargd, link_label, linkattrd=None,\n                     escape_urlargd=True, escape_linkattrd=True,\n                     urlhash=None):\n    \"\"\"Creates a W3C compliant link.\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})\n    @param link_label: text displayed in a browser (has to be already escaped)\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    attributes_separator = ' '\n    output = '<a href=\"' + \\\n             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '\"'\n    if linkattrd:\n        output += ' '\n        if escape_linkattrd:\n            attributes = [escape(str(key), quote=True) + '=\"' + \\\n                          escape(str(linkattrd[key]), quote=True) + '\"'\n                                for key in linkattrd.keys()]\n        else:\n            attributes = [str(key) + '=\"' + str(linkattrd[key]) + '\"'\n                                for key in linkattrd.keys()]\n        output += attributes_separator.join(attributes)\n    output = wash_for_utf8(output)\n    output += '>' + wash_for_utf8(link_label) + '</a>'\n    return output\n\n\ndef create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,\n        link_label=\"%(email)s\", linkattrd=None, escape_urlargd=True,\n        escape_linkattrd=True, email_obfuscation_mode=None):\n    \"\"\"Creates a W3C compliant 'mailto' link.\n\n    Encode/encrypt given email to reduce undesired automated email\n    harvesting when embedded in a web page.\n\n    NOTE: there is no ultimate solution to protect against email\n    harvesting. All have drawbacks and can more or less be\n    circumvented. There are other techniques to protect email\n    addresses. We implement the less annoying one for users.\n\n    @param email: the recipient of the email\n    @param subject: a default subject for the email (must not contain\n                    line feeds)\n    @param body: a default body for the email\n    @param cc: the co-recipient(s) of the email\n    @param bcc: the hidden co-recpient(s) of the email\n    @param link_label: the label of this mailto link. String\n                       replacement is performed on key %(email)s with\n                       the email address if needed.\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param email_obfuscation_mode: the protection mode. See below:\n\n    You can choose among several modes to protect emails. It is\n    advised to keep the default\n    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is\n    possible for an admin to change the policy globally.\n\n    Available modes ([t] means \"transparent\" for the user):\n\n         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and\n             CFG_SITE_SUPPORT_EMAIL.\n\n      [t] 0 : no protection, email returned as is.\n                foo@example.com => foo@example.com\n\n          1 : basic email munging: replaces @ by [at] and . by [dot]\n                foo@example.com => foo [at] example [dot] com\n\n      [t] 2 : transparent name mangling: characters are replaced by\n              equivalent HTML entities.\n                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;\n\n      [t] 3 : javascript insertion. Requires Javascript enabled on client side.\n\n          4 : replaces @ and . characters by gif equivalents.\n                foo@example.com => foo<img src=\"at.gif\" alt=\" [at] \">example<img src=\"dot.gif\" alt=\" [dot] \">com\n    \"\"\"\n    # TODO: implement other protection modes to encode/encript email:\n    #\n    ## [t] 5 : form submission. User is redirected to a form that he can\n    ##         fills in to send the email (??Use webmessage??).\n    ##         Depending on WebAccess, ask to answer a question.\n    ##\n    ## [t] 6 : if user can see (controlled by WebAccess), display. Else\n    ##         ask to login to see email. If user cannot see, display\n    ##         form submission.\n\n    if email_obfuscation_mode is None:\n        email_obfuscation_mode = cfg.get(\n            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')\n\n    if linkattrd is None:\n        linkattrd = {}\n\n    parameters = {}\n    if subject:\n        parameters[\"subject\"] = subject\n    if body:\n        parameters[\"body\"] = body.replace('\\r\\n', '\\n').replace('\\n', '\\r\\n')\n    if cc:\n        parameters[\"cc\"] = cc\n    if bcc:\n        parameters[\"bcc\"] = bcc\n\n    # Preprocessing values for some modes\n    if email_obfuscation_mode == 1:\n        # Basic Munging\n        email = email.replace(\"@\", \" [at] \").replace(\".\", \" [dot] \")\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        email = string_to_numeric_char_reference(email)\n\n    if '%(email)s' in link_label:\n        link_label = link_label % {'email': email}\n\n    mailto_link = create_html_link('mailto:' + email, parameters,\n                                   link_label, linkattrd,\n                                   escape_urlargd, escape_linkattrd)\n\n    if email_obfuscation_mode == 0:\n        # Return \"as is\"\n        return mailto_link\n    elif email_obfuscation_mode == 1:\n        # Basic Munging\n        return mailto_link\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        return mailto_link\n    elif email_obfuscation_mode == 3:\n        # Javascript-based\n        return '''<script language=\"JavaScript\" ''' \\\n            '''type=\"text/javascript\">''' \\\n            '''document.write('%s'.split(\"\").reverse().join(\"\"))''' \\\n            '''</script>''' % \\\n               mailto_link[::-1].replace(\"'\", \"\\\\'\")\n    elif email_obfuscation_mode == 4:\n        # GIFs-based\n        email = email.replace('.',\n            '<img src=\"%s/img/dot.gif\" alt=\" [dot] \" '\n            'style=\"vertical-align:bottom\"  />' % cfg.get('CFG_SITE_URL'))\n        email = email.replace('@',\n            '<img src=\"%s/img/at.gif\" alt=\" [at] \" '\n            'style=\"vertical-align:baseline\" />' % cfg.get('CFG_SITE_URL'))\n        return email\n\n    # All other cases, including mode -1:\n    return \"\"\n\n\ndef string_to_numeric_char_reference(string):\n    \"\"\"\n    Encode a string to HTML-compatible numeric character reference.\n    Eg: encode_html_entities(\"abc\") == '&#97;&#98;&#99;'\n    \"\"\"\n    out = \"\"\n    for char in string:\n        out += \"&#\" + str(ord(char)) + \";\"\n    return out\n\ndef get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):\n    \"\"\"\n    Given an Invenio URL returns a tuple with two elements. The first is the\n    canonical URL, that is the original URL with CFG_SITE_URL prefix, and\n    where the ln= argument stripped. The second element element is mapping,\n    language code -> alternate URL\n\n    @param quote_path: if True, the path section of the given C{url}\n                       is quoted according to RFC 2396\n    \"\"\"\n    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)\n    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]\n    parsed_query = washed_argd or parse_qsl(query)\n    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']\n    if drop_ln:\n        canonical_parsed_query = no_ln_parsed_query\n    else:\n        canonical_parsed_query = parsed_query\n    if quote_path:\n        path = urllib.quote(path)\n    canonical_query = urlencode(canonical_parsed_query)\n    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))\n    alternate_urls = {}\n    for ln in cfg.get('CFG_SITE_LANGS'):\n        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])\n        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))\n        alternate_urls[ln] = alternate_url\n    return canonical_url, alternate_urls\n\ndef create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):\n    \"\"\"Creates a W3C compliant URL. Output will look like this:\n    'urlbase?param1=value1&amp;param2=value2'\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    separator = '&amp;'\n    output = urlbase\n    if urlargd:\n        output += '?'\n        if escape_urlargd:\n            arguments = [escape(quote(str(key)), quote=True) + '=' + \\\n                         escape(quote(str(urlargd[key])), quote=True)\n                                for key in urlargd.keys()]\n        else:\n            arguments = [str(key) + '=' + str(urlargd[key])\n                            for key in urlargd.keys()]\n        output += separator.join(arguments)\n    if urlhash:\n        output += \"#\" + escape(quote(str(urlhash)))\n    return output\n\n\ndef same_urls_p(a, b):\n    \"\"\" Compare two URLs, ignoring reorganizing of query arguments \"\"\"\n\n    ua = list(urlparse(a))\n    ub = list(urlparse(b))\n\n    ua[4] = parse_qs(ua[4])\n    ub[4] = parse_qs(ub[4])\n\n    return ua == ub\n\n\ndef urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):\n    \"\"\"Analyze `urlargs' (URL CGI GET query arguments in string form)\n       and for each occurrence of argument matching `regexp_argname'\n       replace every substring `text_old' by `text_new'.  Return the\n       resulting new URL.\n\n       Used to be used for search engine's create_nearest_terms_box,\n       now it is not used there anymore.  It is left here in case it\n       will become possibly useful later.\n    \"\"\"\n    out = \"\"\n    # parse URL arguments into a dictionary:\n    urlargsdict = parse_qs(urlargs)\n    ## construct new URL arguments:\n    urlargsdictnew = {}\n    for key in urlargsdict.keys():\n        if re.match(regexp_argname, key): # replace `arg' by new values\n            urlargsdictnew[key] = []\n            for parg in urlargsdict[key]:\n                urlargsdictnew[key].append(parg.replace(text_old, text_new))\n        else: # keep old values\n            urlargsdictnew[key] = urlargsdict[key]\n    # build new URL for this word:\n    for key in urlargsdictnew.keys():\n        for val in urlargsdictnew[key]:\n            out += \"&amp;\" + key + \"=\" + quote_plus(val, '')\n    if out.startswith(\"&amp;\"):\n        out = out[5:]\n    return out\n\ndef get_title_of_page(url):\n    \"\"\"\n    @param url: page to get the title from\n    @return: the page title in utf-8 or None in case\n    that any kind of exception occured e.g. connection error,\n    URL not known\n    \"\"\"\n    if BEAUTIFUL_SOUP_IMPORTED:\n        try:\n            opener = make_invenio_opener('UrlUtils')\n            soup = BeautifulSoup.BeautifulSoup(opener.open(url))\n            return soup.title.string.encode(\"utf-8\")\n        except:\n            return None\n    else:\n        return \"Title not available\"\n\n\ndef make_user_agent_string(component=None):\n    \"\"\"\n    Return a nice and uniform user-agent string to be used when Invenio\n    act as a client in HTTP requests.\n    \"\"\"\n    ret = \"Invenio-%s (+%s; \\\"%s\\\")\" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))\n    if component:\n        ret += \" %s\" % component\n    return ret\n\n\nclass InvenioFancyURLopener(FancyURLopener):\n    \"\"\"Provide default user agent string.\"\"\"\n\n    @cached_property\n    def version(self):\n        return make_user_agent_string()\n\n    def prompt_user_passwd(self, host, realm):\n        \"\"\"Don't prompt\"\"\"\n        return None, None\n\n## Let's override default useragent string\n## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html\nurllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())\n\ndef make_invenio_opener(component=None):\n    \"\"\"\n    Return an urllib2 opener with the useragent already set in the appropriate\n    way.\n    \"\"\"\n    opener = urllib2.build_opener()\n    opener.addheaders = [('User-agent', make_user_agent_string(component))]\n    return opener\n\ndef create_AWS_request_url(base_url, argd, _amazon_secret_access_key,\n                           _timestamp=None):\n    \"\"\"\n    Create a signed AWS (Amazon Web Service) request URL corresponding\n    to the given parameters.\n\n    Example:\n    >> create_AWS_request_url(\"http://ecs.amazon.com/onca/xml\",\n                             {'AWSAccessKeyID': '0000000000',\n                              'Service': 'AWSECommerceService',\n                              'Operation': 'ItemLookup',\n                              'ItemID': '0679722769',\n                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},\n                             \"1234567890\")\n\n    @param base_url: Service URL of the Amazon store to query\n    @param argd: dictionary of arguments defining the query\n    @param _amazon_secret_access_key: your Amazon secret key\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @type base_url: string\n    @type argd: dict\n    @type _amazon_secret_access_key: string\n    @type _timestamp: string\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    ## First define a few util functions\n\n    def get_AWS_signature(argd, _amazon_secret_access_key,\n                          method=\"GET\", request_host=\"webservices.amazon.com\",\n                          request_uri=\"/onca/xml\",\n                          _timestamp=None):\n        \"\"\"\n        Returns the signature of an Amazon request, based on the\n        arguments of the request.\n\n        @param argd: dictionary of arguments defining the query\n        @param _amazon_secret_access_key: your Amazon secret key\n        @param method: method of the request POST or GET\n        @param request_host: host contacted for the query. To embed in the signature.\n        @param request_uri: uri contacted at 'request_host'. To embed in the signature.\n        @param _timestamp: for testing purpose only (default: current timestamp)\n\n        @type argd: dict\n        @type _amazon_secret_access_key: string\n        @type method: string\n        @type host_header: string\n        @type http_request_uri: string\n        @type _timestamp: string\n\n        @return signature of the request (string)\n        \"\"\"\n\n        # Add timestamp\n        if not _timestamp:\n            argd[\"Timestamp\"] = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\",\n                                              time.gmtime())\n        else:\n            argd[\"Timestamp\"] = _timestamp\n\n        # Order parameter keys by byte value\n        parameter_keys = argd.keys()\n        parameter_keys.sort()\n\n        # Encode arguments, according to RFC 3986. Make sure we\n        # generate a list which is ordered by byte value of the keys\n        arguments = [quote(str(key), safe=\"~/\") + \"=\" + \\\n                     quote(str(argd[key]), safe=\"~/\") \\\n                     for key in parameter_keys]\n\n        # Join\n        parameters_string = \"&\".join(arguments)\n\n        # Prefix\n        parameters_string = method.upper() + \"\\n\" + \\\n                            request_host.lower() + \"\\n\" + \\\n                            (request_uri or \"/\") + \"\\n\" + \\\n                            parameters_string\n\n        # Sign and return\n        return calculate_RFC2104_HMAC(parameters_string,\n                                      _amazon_secret_access_key)\n\n    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):\n        \"\"\"\n        Computes a RFC 2104 compliant HMAC Signature and then Base64\n        encodes it.\n\n        Module hashlib must be installed if Python < 2.5\n        <http://pypi.python.org/pypi/hashlib/20081119>\n\n        @param data: data to sign\n        @param _amazon_secret_access_key: your Amazon secret key\n\n        @type data: string\n        @type _amazon_secret_access_key: string. Empty if hashlib module not installed\n        \"\"\"\n        if not HASHLIB_IMPORTED:\n            try:\n                raise Exception(\"Module hashlib not installed. Please install it.\")\n            except:\n                from invenio.ext.logging import register_exception\n                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n                return \"\"\n        else:\n            if sys.version_info < (2, 5):\n                # compatibility mode for Python < 2.5 and hashlib\n                my_digest_algo = _MySHA256(sha256())\n            else:\n                my_digest_algo = sha256\n\n        return base64.encodestring(hmac.new(_amazon_secret_access_key,\n                                            data, my_digest_algo).digest()).strip()\n     ## End util functions\n\n    parsed_url = urlparse(base_url)\n    signature = get_AWS_signature(argd, _amazon_secret_access_key,\n                                  request_host=parsed_url[1],\n                                  request_uri=parsed_url[2],\n                                  _timestamp=_timestamp)\n    if signature:\n        argd[\"Signature\"] = signature\n    return base_url + \"?\" + urlencode(argd)\n\n\ndef create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):\n    \"\"\"\n    Create a signed Indico request URL to access Indico HTTP Export APIs.\n\n    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more\n    information.\n\n    Example:\n    >> create_Indico_request_url(\"https://indico.cern.ch\",\n                                 \"categ\",\n                                 \"\",\n                                 [1, 7],\n                                 \"xml\",\n                                 {'onlypublic': 'yes',\n                                  'order': 'title',\n                                  'from': 'today',\n                                  'to': 'tomorrow'},\n                                 '00000000-0000-0000-0000-000000000000',\n                                 '00000000-0000-0000-0000-000000000000')\n\n    @param base_url: Service base URL of the Indico instance to query\n    @param indico_what: element to export\n    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}\n    @param indico_loc: location of the element(s) specified by ID (only used for some elements)\n    @param indico_id: ID of the element to be exported\n    @type indico_id: a string or a list/tuple of strings\n    @param indico_type: output format\n    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}\n    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}\n    @param indico_key: API key provided for the given Indico instance\n    @param indico_sig: API secret key (signature) provided for the given Indico instance\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    url = '/export/' + indico_what + '/'\n    if indico_loc:\n        url += indico_loc + '/'\n    if type(indico_id) in (list, tuple):\n        # dash separated list of values\n        indico_id = '-'.join([str(x) for x in indico_id])\n    url += indico_id + '.' + str(indico_type)\n\n    if hasattr(indico_params, 'items'):\n        items = indico_params.items()\n    else:\n        items = list(indico_params)\n    if indico_key:\n        items.append(('apikey', indico_key))\n    if indico_sig and HASHLIB_IMPORTED:\n        if _timestamp:\n            items.append(('timestamp', str(_timestamp)))\n        else:\n            items.append(('timestamp', str(int(time.time()))))\n        items = sorted(items, key=lambda x: x[0].lower())\n        url_to_sign = '%s?%s' % (url, urlencode(items))\n        if sys.version_info < (2, 5):\n            # compatibility mode for Python < 2.5 and hashlib\n            my_digest_algo = _MySHA1(sha1())\n        else:\n            my_digest_algo = sha1\n        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()\n        items.append(('signature', signature))\n    elif not HASHLIB_IMPORTED:\n        try:\n            raise Exception(\"Module hashlib not installed. Please install it.\")\n        except:\n            from invenio.ext.logging import register_exception\n            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n    if not items:\n        return url\n\n    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))\n    return url\n\nclass _MyHashlibAlgo(object):\n    '''\n    Define a subclass of any hashlib algorithm class, with an additional \"new()\"\n    function, to work with the Python < 2.5 version of the hmac module.\n\n    (This class is more complex than it should, but it is not\n    possible to subclass haslib algorithm)\n    '''\n\n    def __init__(self, obj):\n        \"\"\"Set the wrapped object.\"\"\"\n        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)\n\n        methods = []\n        for name_value in inspect.getmembers(obj, inspect.ismethod):\n            methods.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)\n\n        def isnotmethod(object_):\n            \"Opposite of ismethod(..)\"\n            return not inspect.ismethod(object_)\n        members = []\n        for name_value in inspect.getmembers(obj, isnotmethod):\n            members.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__members__', members)\n\n    def __getattr__(self, name):\n        \"\"\"Redirect unhandled get attribute to self._obj.\"\"\"\n        if not hasattr(self._obj, name):\n            raise AttributeError, (\"'%s' has no attribute %s\" %\n                                   (self.__class__.__name__, name))\n        else:\n            return getattr(self._obj, name)\n\n    def __setattr__(self, name, value):\n        \"\"\"Redirect set attribute to self._obj if necessary.\"\"\"\n        self_has_attr = True\n        try:\n            super(_MyHashlibAlgo, self).__getattribute__(name)\n        except AttributeError:\n            self_has_attr = False\n\n        if (name == \"_obj\" or not hasattr(self, \"_obj\") or\n            not hasattr(self._obj, name) or self_has_attr):\n            return super(_MyHashlibAlgo, self).__setattr__(name, value)\n        else:\n            return setattr(self._obj, name, value)\n\nif HASHLIB_IMPORTED:\n    from invenio.utils.hash import sha256\n\n\n    class _MySHA256(_MyHashlibAlgo):\n        \"A _MyHashlibAlgo subsclass for sha256\"\n        new = lambda d = '': sha256()\n\n\nclass _MySHA1(_MyHashlibAlgo):\n    \"A _MyHashlibAlgo subsclass for sha1\"\n    new = lambda d = '': sha1()\n\ndef auto_version_url(file_path):\n    \"\"\" Appends modification time of the file to the request URL in order for the\n        browser to refresh the cache when file changes\n\n        @param file_path: path to the file, e.g js/foo.js\n        @return: file_path with modification time appended to URL\n    \"\"\"\n    file_md5 = \"\"\n    try:\n        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()\n    except IOError:\n        pass\n    return file_path + \"?%s\" % file_md5\n\ndef get_relative_url(url):\n    \"\"\"\n    Returns the relative URL from a URL. For example:\n\n    'http://web.net' -> ''\n    'http://web.net/' -> ''\n    'http://web.net/1222' -> '/1222'\n    'http://web.net/wsadas/asd' -> '/wsadas/asd'\n\n    It will never return a trailing \"/\".\n\n    @param url: A url to transform\n    @type url: str\n\n    @return: relative URL\n    \"\"\"\n    # remove any protocol info before\n    stripped_site_url = url.replace(\"://\", \"\")\n    baseurl = \"/\" + \"/\".join(stripped_site_url.split(\"/\")[1:])\n\n    # remove any trailing slash (\"/\")\n    if baseurl[-1] == \"/\":\n        return baseurl[:-1]\n    else:\n        return baseurl\n/n/n/n", "label": 0}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize#show_login\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                    next=request.args.get('next', '/')\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    if request.args.get('next', None):\n        return redirect(request.args.get('next'))\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        if request.args.get('next', None):\n            return redirect(request.args.get('next'))\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import quote_plus\nfrom flask import url_for, session\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom invenio.ext.sqlalchemy import db\n\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(url_for(\"oauthclient.login\", remote_app='test'))\n        self.assertStatus(resp, 302)\n        self.assertEqual(\n            resp.location,\n            \"https://foo.bar/oauth/authorize?response_type=code&\"\n            \"client_id=testid&redirect_uri=%s\" % quote_plus(url_for(\n                \"oauthclient.authorized\", remote_app='test', _external=True\n            ))\n        )\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            resp = self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                )\n            )\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_token_getter_setter(self, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                # Assert if every is as it should be.\n                assert session['oauth_token_full'] == ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_rejected(self, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Client blueprint used to handle OAuth callbacks. \"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, url_for, request\n\nfrom flask.ext.login import user_logged_out\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\" Setup OAuth clients. \"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\" Send user to remote application for authentication. \"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        next=request.args.get('next') or request.referrer or None,\n        _external=True,\n    )\n\n    return oauth.remote_apps[remote_app].authorize(callback=callback_url)\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\" Authorized handler callback. \"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\" Extra signup step. \"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\" Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/n", "label": 1}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n`OAUTHCLIENT_STATE_EXPIRES`      Number of seconds after which the state token\n                                 expires. Defaults to 300 seconds.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n\nOAUTHCLIENT_STATE_EXPIRES = 300\n\"\"\"Number of seconds after which the state token expires.\"\"\"\n/n/n/ninvenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate',\n                              'show_login': 'true'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/ninvenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef get_session_next_url(remote_app):\n    return session.get(\n        \"%s_%s\" % (token_session_key(remote_app), \"next_url\")\n    )\n\n\ndef set_session_next_url(remote_app, url):\n    session[\"%s_%s\" % (token_session_key(remote_app), \"next_url\")] = \\\n        url\n\n\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    next_url = get_session_next_url(remote.name)\n    if next_url:\n        return redirect(next_url)\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        next_url = get_session_next_url(remote.name)\n        if next_url:\n            return redirect(next_url)\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/ninvenio/modules/oauthclient/testsuite/test_forms.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom invenio.testsuite import InvenioTestCase, make_test_suite, run_test_suite\nfrom mock import MagicMock, Mock, patch\nfrom sqlalchemy.exc import SQLAlchemyError\n\n\nclass FormTestCase(InvenioTestCase):\n\n    @patch('invenio.modules.oauthclient.forms.User')\n    def test_validate_email(self, user):\n        from invenio.modules.oauthclient.forms import EmailSignUpForm\n\n        self.assertFalse(EmailSignUpForm(email='invalidemail').validate())\n\n        # Mock query\n        obj = MagicMock()\n        obj.one = MagicMock(side_effect=SQLAlchemyError())\n        user.query.filter = Mock(return_value=obj)\n        self.assertTrue(\n            EmailSignUpForm(email='good@invenio-software.org').validate()\n        )\n\n        user.query.filter = MagicMock()\n        self.assertFalse(\n            EmailSignUpForm(email='bad@invenio-software.org').validate()\n        )\n\n\nTEST_SUITE = make_test_suite(FormTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nimport time\nfrom flask import url_for, session\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sqlalchemy import db\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom itsdangerous import TimedJSONWebSignatureSerializer\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import parse_qs, urlparse\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_redirect_uri(self):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test',\n                    next='http://invenio-software.org')\n        )\n        self.assertStatus(resp, 302)\n\n        # Verify parameters\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Verify next parameter in state token does not allow blanco redirects\n        state = serializer.loads(params['state'][0])\n        self.assertIsNone(state['next'])\n\n        # Assert redirect uri does not have any parameters.\n        params = parse_qs(urlparse(params['redirect_uri'][0]).query)\n        self.assertEqual(params, {})\n\n        # Assert that local redirects are allowed\n        test_urls = [\n            '/search',\n            url_for('oauthclient.disconnect', remote_app='test',\n                    _external=True)\n        ]\n        for url in test_urls:\n            resp = self.client.get(\n                url_for(\"oauthclient.login\", remote_app='test', next=url)\n            )\n            self.assertStatus(resp, 302)\n            state = serializer.loads(\n                parse_qs(urlparse(resp.location).query)['state'][0]\n            )\n            self.assertEqual(url, state['next'])\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='test', next='/')\n        )\n        self.assertStatus(resp, 302)\n\n        params = parse_qs(urlparse(resp.location).query)\n        self.assertEqual(params['response_type'], ['code'])\n        self.assertEqual(params['client_id'], ['testid'])\n        assert params['redirect_uri']\n        assert params['state']\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            from invenio.modules.oauthclient.views.client import serializer\n\n            state = serializer.dumps({\n                'app': 'test',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                    state=state\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            state = serializer.dumps({\n                'app': 'test_invalid',\n                'sid': session.sid,\n                'next': None,\n            })\n\n            self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                    state=state,\n                )\n            )\n\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_state_token(self, session):\n        from invenio.modules.oauthclient.views.client import serializer\n\n        # Mock session id\n        session.sid = '1234'\n\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n\n            # Good state token\n            state = serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            resp = c.get(\n                url_for(\"oauthclient.authorized\", remote_app='test',\n                        code='test', state=state)\n            )\n            self.assert200(resp)\n\n            outdated_serializer = TimedJSONWebSignatureSerializer(\n                cfg['SECRET_KEY'],\n                expires_in=0,\n            )\n\n            # Bad state - timeout\n            state1 = outdated_serializer.dumps(\n                {'app': 'test', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - app\n            state2 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test_invalid', 'sid': '1234',  'next': None, }\n            )\n            # Bad state - sid\n            state3 = serializer.dumps(\n                # State for another existing app (test_invalid exists)\n                {'app': 'test', 'sid': 'bad',  'next': None, }\n            )\n            time.sleep(1)\n            for s in [state1, state2, state3]:\n                resp = c.get(\n                    url_for(\"oauthclient.authorized\", remote_app='test',\n                            code='test', state=s)\n                )\n                self.assert403(resp)\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_token_getter_setter(self, session, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                state = parse_qs(urlparse(res.location).query)['state'][0]\n\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state,\n                ))\n\n                # Assert if everything is as it should be.\n                from flask import session as flask_session\n                assert flask_session['oauth_token_full'] == \\\n                    ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                # Mock a new authorized request\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    @patch('invenio.modules.oauthclient.views.client.session')\n    def test_rejected(self, session, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock user id\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n\n        # Mock session id\n        session.sid = '1234'\n\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                from invenio.modules.oauthclient.views.client import serializer\n                state = serializer.dumps({\n                    'app': 'full', 'sid': '1234',  'next': None,\n                })\n\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                    state=state\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/ninvenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Client blueprint used to handle OAuth callbacks.\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, request, session, url_for\nfrom flask.ext.login import user_logged_out\nfrom itsdangerous import TimedJSONWebSignatureSerializer, BadData\nfrom werkzeug.local import LocalProxy\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\nfrom invenio.utils.url import get_safe_redirect_target\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler, \\\n    set_session_next_url\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\nserializer = LocalProxy(\n    lambda: TimedJSONWebSignatureSerializer(\n        cfg['SECRET_KEY'],\n        expires_in=cfg['OAUTHCLIENT_STATE_EXPIRES'],\n    )\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\"Setup OAuth clients.\"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\"Send user to remote application for authentication.\"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    # Get redirect target in safe manner.\n    next_param = get_safe_redirect_target(arg='next')\n\n    # Redirect URI - must be registered in the remote service.\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        _external=True,\n    )\n\n    # Create a JSON Web Token that expires after OAUTHCLIENT_STATE_EXPIRES\n    # seconds.\n    state_token = serializer.dumps({\n        'app': remote_app,\n        'next': next_param,\n        'sid': session.sid,\n    })\n\n    return oauth.remote_apps[remote_app].authorize(\n        callback=callback_url,\n        state=state_token,\n    )\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\"Authorized handler callback.\"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n\n    state_token = request.args.get('state')\n\n    # Verify state parameter\n    try:\n        assert state_token\n        # Checks authenticity and integrity of state and decodes the value.\n        state = serializer.loads(state_token)\n        # Verify that state is for this session, app and that next parameter\n        # have not been modified.\n        assert state['sid'] == session.sid\n        assert state['app'] == remote_app\n        # Store next URL\n        set_session_next_url(remote_app, state['next'])\n    except (AssertionError, BadData):\n        abort(403)\n\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\"Extra signup step.\"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\"Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/ninvenio/utils/url.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"\nurlutils.py -- helper functions for URL related problems such as\nargument washing, redirection, etc.\n\"\"\"\n\n__revision__ = \"$Id$\"\n\nimport time\nimport base64\nimport hmac\nimport re\nimport sys\nimport os\nimport inspect\nimport urllib\nimport urllib2\nfrom urllib import urlencode, quote_plus, quote, FancyURLopener\nfrom six.moves.urllib.parse import urlparse, urlunparse\nfrom cgi import parse_qs, parse_qsl, escape\nfrom werkzeug import cached_property\nfrom werkzeug.local import LocalProxy\n\ntry:\n    import BeautifulSoup\n    BEAUTIFUL_SOUP_IMPORTED = True\nexcept ImportError:\n    BEAUTIFUL_SOUP_IMPORTED = False\n\nfrom invenio.base.globals import cfg\nfrom invenio.utils.hash import sha1, md5, HASHLIB_IMPORTED\nfrom invenio.utils.text import wash_for_utf8\nfrom invenio.utils import apache\n\n\ndef wash_url_argument(var, new_type):\n    \"\"\"\n    Wash argument into 'new_type', that can be 'list', 'str',\n                                               'int', 'tuple' or 'dict'.\n    If needed, the check 'type(var) is not None' should be done before\n    calling this function.\n    @param var: variable value\n    @param new_type: variable type, 'list', 'str', 'int', 'tuple' or 'dict'\n    @return: as much as possible, value var as type new_type\n            If var is a list, will change first element into new_type.\n            If int check unsuccessful, returns 0\n    \"\"\"\n    out = []\n    if new_type == 'list':  # return lst\n        if isinstance(var, list):\n            out = var\n        else:\n            out = [var]\n    elif new_type == 'str':  # return str\n        if isinstance(var, list):\n            try:\n                out = \"%s\" % var[0]\n            except:\n                out = \"\"\n        elif isinstance(var, str):\n            out = var\n        else:\n            out = \"%s\" % var\n    elif new_type == 'int': # return int\n        if isinstance(var, list):\n            try:\n                out = int(var[0])\n            except:\n                out = 0\n        elif isinstance(var, (int, long)):\n            out = var\n        elif isinstance(var, str):\n            try:\n                out = int(var)\n            except:\n                out = 0\n        else:\n            out = 0\n    elif new_type == 'tuple': # return tuple\n        if isinstance(var, tuple):\n            out = var\n        else:\n            out = (var, )\n    elif new_type == 'dict': # return dictionary\n        if isinstance(var, dict):\n            out = var\n        else:\n            out = {0: var}\n    return out\n\n\nfrom urlparse import urlparse, urljoin\nfrom flask import request, url_for\n\ndef is_local_url(target):\n    \"\"\"Determine if URL is a local.\"\"\"\n    ref_url = urlparse(cfg.get('CFG_SITE_SECURE_URL'))\n    test_url = urlparse(urljoin(cfg.get('CFG_SITE_SECURE_URL'), target))\n    return test_url.scheme in ('http', 'https') and \\\n           ref_url.netloc == test_url.netloc\n\n\ndef get_safe_redirect_target(arg='next'):\n    \"\"\"Get URL to redirect to and ensure that it is local.\"\"\"\n    for target in request.args.get(arg), request.referrer:\n        if not target:\n            continue\n        if is_local_url(target):\n            return target\n    return None\n\n\ndef redirect_to_url(req, url, redirection_type=None, norobot=False):\n    \"\"\"\n    Redirect current page to url.\n    @param req: request as received from apache\n    @param url: url to redirect to\n    @param redirection_type: what kind of redirection is required:\n    e.g.: apache.HTTP_MULTIPLE_CHOICES             = 300\n          apache.HTTP_MOVED_PERMANENTLY            = 301\n          apache.HTTP_MOVED_TEMPORARILY            = 302\n          apache.HTTP_SEE_OTHER                    = 303\n          apache.HTTP_NOT_MODIFIED                 = 304\n          apache.HTTP_USE_PROXY                    = 305\n          apache.HTTP_TEMPORARY_REDIRECT           = 307\n    The default is apache.HTTP_MOVED_TEMPORARILY\n    @param norobot: wether to instruct crawlers and robots such as GoogleBot\n        not to index past this point.\n    @see: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3\n    \"\"\"\n    url = url.strip()\n    if redirection_type is None:\n        redirection_type = apache.HTTP_MOVED_TEMPORARILY\n\n    from flask import redirect\n    r = redirect(url, code=redirection_type)\n    raise apache.SERVER_RETURN, r\n    #FIXME enable code bellow\n\n    del req.headers_out[\"Cache-Control\"]\n    req.headers_out[\"Cache-Control\"] = \"no-cache, private, no-store, \" \\\n        \"must-revalidate, post-check=0, pre-check=0, max-age=0\"\n    req.headers_out[\"Pragma\"] = \"no-cache\"\n\n    if norobot:\n        req.headers_out[\"X-Robots-Tag\"] = \"noarchive, nosnippet, noindex, nocache\"\n\n    user_agent = req.headers_in.get('User-Agent', '')\n    if 'Microsoft Office Existence Discovery' in user_agent or 'ms-office' in user_agent:\n        ## HACK: this is to workaround Microsoft Office trying to be smart\n        ## when users click on URLs in Office documents that require\n        ## authentication. Office will check the validity of the URL\n        ## but will pass the browser the redirected URL rather than\n        ## the original one. This is incompatible with e.g. Shibboleth\n        ## based SSO since the referer would be lost.\n        ## See: http://support.microsoft.com/kb/899927\n        req.status = 200\n        req.content_type = 'text/html'\n        if req.method != 'HEAD':\n            req.write(\"\"\"\n<html>\n    <head>\n        <title>Intermediate page for URLs clicked on MS Office Documents</title>\n        <meta http-equiv=\"REFRESH\" content=\"5;url=%(url)s\"></meta>\n    </head>\n    <body>\n        <p>You are going to be redirected to the desired content within 5 seconds. If the redirection does not happen automatically please click on <a href=\"%(url)s\">%(url_ok)s</a>.</p>\n    </body>\n</html>\"\"\" % {\n                'url': escape(req.unparsed_uri, True),\n                'url_ok': escape(req.unparsed_uri)\n            })\n        raise apache.SERVER_RETURN(apache.DONE)\n\n    req.headers_out[\"Location\"] = url\n\n    if req.response_sent_p:\n        raise IOError(\"Cannot redirect after headers have already been sent.\")\n\n    req.status = redirection_type\n    req.write('<p>Please go to <a href=\"%s\">here</a></p>\\n' % url)\n\n    raise apache.SERVER_RETURN, apache.DONE\n\n\ndef rewrite_to_secure_url(url, secure_base=None):\n    \"\"\"\n    Rewrite URL to a Secure URL\n\n    @param url URL to be rewritten to a secure URL.\n    @param secure_base: Base URL of secure site (defaults to CFG_SITE_SECURE_URL).\n    \"\"\"\n    if secure_base is None:\n        secure_base = cfg.get('CFG_SITE_SECURE_URL')\n    url_parts = list(urlparse(url))\n    url_secure_parts = urlparse(secure_base)\n    url_parts[0] = url_secure_parts[0]\n    url_parts[1] = url_secure_parts[1]\n    return urlunparse(url_parts)\n\n\ndef get_referer(req, replace_ampersands=False):\n    \"\"\" Return the referring page of a request.\n    Referer (wikipedia): Referer is a common misspelling of the word\n    \"referrer\"; so common, in fact, that it made it into the official\n    specification of HTTP. When visiting a webpage, the referer or\n    referring page is the URL of the previous webpage from which a link was\n    followed.\n    @param req: request\n    @param replace_ampersands: if 1, replace & by &amp; in url\n                               (correct HTML cannot contain & characters alone)\n    \"\"\"\n    try:\n        referer = req.headers_in['Referer']\n        if replace_ampersands == 1:\n            return referer.replace('&', '&amp;')\n        return referer\n    except KeyError:\n        return ''\n\n\ndef drop_default_urlargd(urlargd, default_urlargd):\n    lndefault = {}\n    lndefault.update(default_urlargd)\n\n    ## Commented out. An Invenio URL now should always specify the desired\n    ## language, in order not to raise the automatic language discovery\n    ## (client browser language can be used now in place of CFG_SITE_LANG)\n    # lndefault['ln'] = (str, CFG_SITE_LANG)\n\n    canonical = {}\n    canonical.update(urlargd)\n\n    for k, v in urlargd.items():\n        try:\n            d = lndefault[k]\n\n            if d[1] == v:\n                del canonical[k]\n\n        except KeyError:\n            pass\n\n    return canonical\n\n\ndef make_canonical_urlargd(urlargd, default_urlargd):\n    \"\"\" Build up the query part of an URL from the arguments passed in\n    the 'urlargd' dictionary. 'default_urlargd' is a secondary dictionary which\n    contains tuples of the form (type, default value) for the query\n    arguments (this is the same dictionary as the one you can pass to\n    webinterface_handler.wash_urlargd).\n\n    When a query element has its default value, it is discarded, so\n    that the simplest (canonical) url query is returned.\n\n    The result contains the initial '?' if there are actual query\n    items remaining.\n    \"\"\"\n\n    canonical = drop_default_urlargd(urlargd, default_urlargd)\n\n    if canonical:\n        return '?' + urlencode(canonical, doseq=True)\n        #FIXME double escaping of '&'? .replace('&', '&amp;')\n\n    return ''\n\n\ndef create_html_link(urlbase, urlargd, link_label, linkattrd=None,\n                     escape_urlargd=True, escape_linkattrd=True,\n                     urlhash=None):\n    \"\"\"Creates a W3C compliant link.\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'})\n    @param link_label: text displayed in a browser (has to be already escaped)\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    attributes_separator = ' '\n    output = '<a href=\"' + \\\n             create_url(urlbase, urlargd, escape_urlargd, urlhash) + '\"'\n    if linkattrd:\n        output += ' '\n        if escape_linkattrd:\n            attributes = [escape(str(key), quote=True) + '=\"' + \\\n                          escape(str(linkattrd[key]), quote=True) + '\"'\n                                for key in linkattrd.keys()]\n        else:\n            attributes = [str(key) + '=\"' + str(linkattrd[key]) + '\"'\n                                for key in linkattrd.keys()]\n        output += attributes_separator.join(attributes)\n    output = wash_for_utf8(output)\n    output += '>' + wash_for_utf8(link_label) + '</a>'\n    return output\n\n\ndef create_html_mailto(email, subject=None, body=None, cc=None, bcc=None,\n        link_label=\"%(email)s\", linkattrd=None, escape_urlargd=True,\n        escape_linkattrd=True, email_obfuscation_mode=None):\n    \"\"\"Creates a W3C compliant 'mailto' link.\n\n    Encode/encrypt given email to reduce undesired automated email\n    harvesting when embedded in a web page.\n\n    NOTE: there is no ultimate solution to protect against email\n    harvesting. All have drawbacks and can more or less be\n    circumvented. There are other techniques to protect email\n    addresses. We implement the less annoying one for users.\n\n    @param email: the recipient of the email\n    @param subject: a default subject for the email (must not contain\n                    line feeds)\n    @param body: a default body for the email\n    @param cc: the co-recipient(s) of the email\n    @param bcc: the hidden co-recpient(s) of the email\n    @param link_label: the label of this mailto link. String\n                       replacement is performed on key %(email)s with\n                       the email address if needed.\n    @param linkattrd: dictionary of attributes (e.g. a={'class': 'img'})\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param escape_linkattrd: boolean indicating if the function should escape\n                           attributes (e.g. < becomes &lt; or \" becomes &quot;)\n    @param email_obfuscation_mode: the protection mode. See below:\n\n    You can choose among several modes to protect emails. It is\n    advised to keep the default\n    CFG_MISCUTIL_EMAIL_HARVESTING_PROTECTION value, so that it is\n    possible for an admin to change the policy globally.\n\n    Available modes ([t] means \"transparent\" for the user):\n\n         -1: hide all emails, excepted CFG_SITE_ADMIN_EMAIL and\n             CFG_SITE_SUPPORT_EMAIL.\n\n      [t] 0 : no protection, email returned as is.\n                foo@example.com => foo@example.com\n\n          1 : basic email munging: replaces @ by [at] and . by [dot]\n                foo@example.com => foo [at] example [dot] com\n\n      [t] 2 : transparent name mangling: characters are replaced by\n              equivalent HTML entities.\n                foo@example.com => &#102;&#111;&#111;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#111;&#109;\n\n      [t] 3 : javascript insertion. Requires Javascript enabled on client side.\n\n          4 : replaces @ and . characters by gif equivalents.\n                foo@example.com => foo<img src=\"at.gif\" alt=\" [at] \">example<img src=\"dot.gif\" alt=\" [dot] \">com\n    \"\"\"\n    # TODO: implement other protection modes to encode/encript email:\n    #\n    ## [t] 5 : form submission. User is redirected to a form that he can\n    ##         fills in to send the email (??Use webmessage??).\n    ##         Depending on WebAccess, ask to answer a question.\n    ##\n    ## [t] 6 : if user can see (controlled by WebAccess), display. Else\n    ##         ask to login to see email. If user cannot see, display\n    ##         form submission.\n\n    if email_obfuscation_mode is None:\n        email_obfuscation_mode = cfg.get(\n            'CFG_WEBSTYLE_EMAIL_ADDRESSES_OBFUSCATION_MODE')\n\n    if linkattrd is None:\n        linkattrd = {}\n\n    parameters = {}\n    if subject:\n        parameters[\"subject\"] = subject\n    if body:\n        parameters[\"body\"] = body.replace('\\r\\n', '\\n').replace('\\n', '\\r\\n')\n    if cc:\n        parameters[\"cc\"] = cc\n    if bcc:\n        parameters[\"bcc\"] = bcc\n\n    # Preprocessing values for some modes\n    if email_obfuscation_mode == 1:\n        # Basic Munging\n        email = email.replace(\"@\", \" [at] \").replace(\".\", \" [dot] \")\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        email = string_to_numeric_char_reference(email)\n\n    if '%(email)s' in link_label:\n        link_label = link_label % {'email': email}\n\n    mailto_link = create_html_link('mailto:' + email, parameters,\n                                   link_label, linkattrd,\n                                   escape_urlargd, escape_linkattrd)\n\n    if email_obfuscation_mode == 0:\n        # Return \"as is\"\n        return mailto_link\n    elif email_obfuscation_mode == 1:\n        # Basic Munging\n        return mailto_link\n    elif email_obfuscation_mode == 2:\n        # Transparent name mangling\n        return mailto_link\n    elif email_obfuscation_mode == 3:\n        # Javascript-based\n        return '''<script language=\"JavaScript\" ''' \\\n            '''type=\"text/javascript\">''' \\\n            '''document.write('%s'.split(\"\").reverse().join(\"\"))''' \\\n            '''</script>''' % \\\n               mailto_link[::-1].replace(\"'\", \"\\\\'\")\n    elif email_obfuscation_mode == 4:\n        # GIFs-based\n        email = email.replace('.',\n            '<img src=\"%s/img/dot.gif\" alt=\" [dot] \" '\n            'style=\"vertical-align:bottom\"  />' % cfg.get('CFG_SITE_URL'))\n        email = email.replace('@',\n            '<img src=\"%s/img/at.gif\" alt=\" [at] \" '\n            'style=\"vertical-align:baseline\" />' % cfg.get('CFG_SITE_URL'))\n        return email\n\n    # All other cases, including mode -1:\n    return \"\"\n\n\ndef string_to_numeric_char_reference(string):\n    \"\"\"\n    Encode a string to HTML-compatible numeric character reference.\n    Eg: encode_html_entities(\"abc\") == '&#97;&#98;&#99;'\n    \"\"\"\n    out = \"\"\n    for char in string:\n        out += \"&#\" + str(ord(char)) + \";\"\n    return out\n\ndef get_canonical_and_alternates_urls(url, drop_ln=True, washed_argd=None, quote_path=False):\n    \"\"\"\n    Given an Invenio URL returns a tuple with two elements. The first is the\n    canonical URL, that is the original URL with CFG_SITE_URL prefix, and\n    where the ln= argument stripped. The second element element is mapping,\n    language code -> alternate URL\n\n    @param quote_path: if True, the path section of the given C{url}\n                       is quoted according to RFC 2396\n    \"\"\"\n    dummy_scheme, dummy_netloc, path, dummy_params, query, fragment = urlparse(url)\n    canonical_scheme, canonical_netloc = urlparse(cfg.get('CFG_SITE_URL'))[0:2]\n    parsed_query = washed_argd or parse_qsl(query)\n    no_ln_parsed_query = [(key, value) for (key, value) in parsed_query if key != 'ln']\n    if drop_ln:\n        canonical_parsed_query = no_ln_parsed_query\n    else:\n        canonical_parsed_query = parsed_query\n    if quote_path:\n        path = urllib.quote(path)\n    canonical_query = urlencode(canonical_parsed_query)\n    canonical_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, canonical_query, fragment))\n    alternate_urls = {}\n    for ln in cfg.get('CFG_SITE_LANGS'):\n        alternate_query = urlencode(no_ln_parsed_query + [('ln', ln)])\n        alternate_url = urlunparse((canonical_scheme, canonical_netloc, path, dummy_params, alternate_query, fragment))\n        alternate_urls[ln] = alternate_url\n    return canonical_url, alternate_urls\n\ndef create_url(urlbase, urlargd, escape_urlargd=True, urlhash=None):\n    \"\"\"Creates a W3C compliant URL. Output will look like this:\n    'urlbase?param1=value1&amp;param2=value2'\n    @param urlbase: base url (e.g. invenio.config.CFG_SITE_URL/search)\n    @param urlargd: dictionary of parameters. (e.g. p={'recid':3, 'of'='hb'}\n    @param escape_urlargd: boolean indicating if the function should escape\n                           arguments (e.g. < becomes &lt; or \" becomes &quot;)\n    @param urlhash: hash string to add at the end of the link\n    \"\"\"\n    separator = '&amp;'\n    output = urlbase\n    if urlargd:\n        output += '?'\n        if escape_urlargd:\n            arguments = [escape(quote(str(key)), quote=True) + '=' + \\\n                         escape(quote(str(urlargd[key])), quote=True)\n                                for key in urlargd.keys()]\n        else:\n            arguments = [str(key) + '=' + str(urlargd[key])\n                            for key in urlargd.keys()]\n        output += separator.join(arguments)\n    if urlhash:\n        output += \"#\" + escape(quote(str(urlhash)))\n    return output\n\n\ndef same_urls_p(a, b):\n    \"\"\" Compare two URLs, ignoring reorganizing of query arguments \"\"\"\n\n    ua = list(urlparse(a))\n    ub = list(urlparse(b))\n\n    ua[4] = parse_qs(ua[4])\n    ub[4] = parse_qs(ub[4])\n\n    return ua == ub\n\n\ndef urlargs_replace_text_in_arg(urlargs, regexp_argname, text_old, text_new):\n    \"\"\"Analyze `urlargs' (URL CGI GET query arguments in string form)\n       and for each occurrence of argument matching `regexp_argname'\n       replace every substring `text_old' by `text_new'.  Return the\n       resulting new URL.\n\n       Used to be used for search engine's create_nearest_terms_box,\n       now it is not used there anymore.  It is left here in case it\n       will become possibly useful later.\n    \"\"\"\n    out = \"\"\n    # parse URL arguments into a dictionary:\n    urlargsdict = parse_qs(urlargs)\n    ## construct new URL arguments:\n    urlargsdictnew = {}\n    for key in urlargsdict.keys():\n        if re.match(regexp_argname, key): # replace `arg' by new values\n            urlargsdictnew[key] = []\n            for parg in urlargsdict[key]:\n                urlargsdictnew[key].append(parg.replace(text_old, text_new))\n        else: # keep old values\n            urlargsdictnew[key] = urlargsdict[key]\n    # build new URL for this word:\n    for key in urlargsdictnew.keys():\n        for val in urlargsdictnew[key]:\n            out += \"&amp;\" + key + \"=\" + quote_plus(val, '')\n    if out.startswith(\"&amp;\"):\n        out = out[5:]\n    return out\n\ndef get_title_of_page(url):\n    \"\"\"\n    @param url: page to get the title from\n    @return: the page title in utf-8 or None in case\n    that any kind of exception occured e.g. connection error,\n    URL not known\n    \"\"\"\n    if BEAUTIFUL_SOUP_IMPORTED:\n        try:\n            opener = make_invenio_opener('UrlUtils')\n            soup = BeautifulSoup.BeautifulSoup(opener.open(url))\n            return soup.title.string.encode(\"utf-8\")\n        except:\n            return None\n    else:\n        return \"Title not available\"\n\n\ndef make_user_agent_string(component=None):\n    \"\"\"\n    Return a nice and uniform user-agent string to be used when Invenio\n    act as a client in HTTP requests.\n    \"\"\"\n    ret = \"Invenio-%s (+%s; \\\"%s\\\")\" % (cfg.get('CFG_VERSION'), cfg.get('CFG_SITE_URL'), cfg.get('CFG_SITE_NAME'))\n    if component:\n        ret += \" %s\" % component\n    return ret\n\n\nclass InvenioFancyURLopener(FancyURLopener):\n    \"\"\"Provide default user agent string.\"\"\"\n\n    @cached_property\n    def version(self):\n        return make_user_agent_string()\n\n    def prompt_user_passwd(self, host, realm):\n        \"\"\"Don't prompt\"\"\"\n        return None, None\n\n## Let's override default useragent string\n## See: http://docs.python.org/release/2.4.4/lib/module-urllib.html\nurllib._urlopener = LocalProxy(lambda: InvenioFancyURLopener())\n\ndef make_invenio_opener(component=None):\n    \"\"\"\n    Return an urllib2 opener with the useragent already set in the appropriate\n    way.\n    \"\"\"\n    opener = urllib2.build_opener()\n    opener.addheaders = [('User-agent', make_user_agent_string(component))]\n    return opener\n\ndef create_AWS_request_url(base_url, argd, _amazon_secret_access_key,\n                           _timestamp=None):\n    \"\"\"\n    Create a signed AWS (Amazon Web Service) request URL corresponding\n    to the given parameters.\n\n    Example:\n    >> create_AWS_request_url(\"http://ecs.amazon.com/onca/xml\",\n                             {'AWSAccessKeyID': '0000000000',\n                              'Service': 'AWSECommerceService',\n                              'Operation': 'ItemLookup',\n                              'ItemID': '0679722769',\n                              'ResponseGroup': 'ItemAttributes,Offers,Images,Review'},\n                             \"1234567890\")\n\n    @param base_url: Service URL of the Amazon store to query\n    @param argd: dictionary of arguments defining the query\n    @param _amazon_secret_access_key: your Amazon secret key\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @type base_url: string\n    @type argd: dict\n    @type _amazon_secret_access_key: string\n    @type _timestamp: string\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    ## First define a few util functions\n\n    def get_AWS_signature(argd, _amazon_secret_access_key,\n                          method=\"GET\", request_host=\"webservices.amazon.com\",\n                          request_uri=\"/onca/xml\",\n                          _timestamp=None):\n        \"\"\"\n        Returns the signature of an Amazon request, based on the\n        arguments of the request.\n\n        @param argd: dictionary of arguments defining the query\n        @param _amazon_secret_access_key: your Amazon secret key\n        @param method: method of the request POST or GET\n        @param request_host: host contacted for the query. To embed in the signature.\n        @param request_uri: uri contacted at 'request_host'. To embed in the signature.\n        @param _timestamp: for testing purpose only (default: current timestamp)\n\n        @type argd: dict\n        @type _amazon_secret_access_key: string\n        @type method: string\n        @type host_header: string\n        @type http_request_uri: string\n        @type _timestamp: string\n\n        @return signature of the request (string)\n        \"\"\"\n\n        # Add timestamp\n        if not _timestamp:\n            argd[\"Timestamp\"] = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\",\n                                              time.gmtime())\n        else:\n            argd[\"Timestamp\"] = _timestamp\n\n        # Order parameter keys by byte value\n        parameter_keys = argd.keys()\n        parameter_keys.sort()\n\n        # Encode arguments, according to RFC 3986. Make sure we\n        # generate a list which is ordered by byte value of the keys\n        arguments = [quote(str(key), safe=\"~/\") + \"=\" + \\\n                     quote(str(argd[key]), safe=\"~/\") \\\n                     for key in parameter_keys]\n\n        # Join\n        parameters_string = \"&\".join(arguments)\n\n        # Prefix\n        parameters_string = method.upper() + \"\\n\" + \\\n                            request_host.lower() + \"\\n\" + \\\n                            (request_uri or \"/\") + \"\\n\" + \\\n                            parameters_string\n\n        # Sign and return\n        return calculate_RFC2104_HMAC(parameters_string,\n                                      _amazon_secret_access_key)\n\n    def calculate_RFC2104_HMAC(data, _amazon_secret_access_key):\n        \"\"\"\n        Computes a RFC 2104 compliant HMAC Signature and then Base64\n        encodes it.\n\n        Module hashlib must be installed if Python < 2.5\n        <http://pypi.python.org/pypi/hashlib/20081119>\n\n        @param data: data to sign\n        @param _amazon_secret_access_key: your Amazon secret key\n\n        @type data: string\n        @type _amazon_secret_access_key: string. Empty if hashlib module not installed\n        \"\"\"\n        if not HASHLIB_IMPORTED:\n            try:\n                raise Exception(\"Module hashlib not installed. Please install it.\")\n            except:\n                from invenio.ext.logging import register_exception\n                register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n                return \"\"\n        else:\n            if sys.version_info < (2, 5):\n                # compatibility mode for Python < 2.5 and hashlib\n                my_digest_algo = _MySHA256(sha256())\n            else:\n                my_digest_algo = sha256\n\n        return base64.encodestring(hmac.new(_amazon_secret_access_key,\n                                            data, my_digest_algo).digest()).strip()\n     ## End util functions\n\n    parsed_url = urlparse(base_url)\n    signature = get_AWS_signature(argd, _amazon_secret_access_key,\n                                  request_host=parsed_url[1],\n                                  request_uri=parsed_url[2],\n                                  _timestamp=_timestamp)\n    if signature:\n        argd[\"Signature\"] = signature\n    return base_url + \"?\" + urlencode(argd)\n\n\ndef create_Indico_request_url(base_url, indico_what, indico_loc, indico_id, indico_type, indico_params, indico_key, indico_sig, _timestamp=None):\n    \"\"\"\n    Create a signed Indico request URL to access Indico HTTP Export APIs.\n\n    See U{http://indico.cern.ch/ihelp/html/ExportAPI/index.html} for more\n    information.\n\n    Example:\n    >> create_Indico_request_url(\"https://indico.cern.ch\",\n                                 \"categ\",\n                                 \"\",\n                                 [1, 7],\n                                 \"xml\",\n                                 {'onlypublic': 'yes',\n                                  'order': 'title',\n                                  'from': 'today',\n                                  'to': 'tomorrow'},\n                                 '00000000-0000-0000-0000-000000000000',\n                                 '00000000-0000-0000-0000-000000000000')\n\n    @param base_url: Service base URL of the Indico instance to query\n    @param indico_what: element to export\n    @type indico_what: one of the strings: C{categ}, C{event}, C{room}, C{reservation}\n    @param indico_loc: location of the element(s) specified by ID (only used for some elements)\n    @param indico_id: ID of the element to be exported\n    @type indico_id: a string or a list/tuple of strings\n    @param indico_type: output format\n    @type indico_type: one of the strings: C{json}, C{jsonp}, C{xml}, C{html}, C{ics}, C{atom}\n    @param indico_params: parameters of the query. See U{http://indico.cern.ch/ihelp/html/ExportAPI/common.html}\n    @param indico_key: API key provided for the given Indico instance\n    @param indico_sig: API secret key (signature) provided for the given Indico instance\n    @param _timestamp: for testing purpose only (default: current timestamp)\n\n    @return signed URL of the request (string)\n    \"\"\"\n\n    url = '/export/' + indico_what + '/'\n    if indico_loc:\n        url += indico_loc + '/'\n    if type(indico_id) in (list, tuple):\n        # dash separated list of values\n        indico_id = '-'.join([str(x) for x in indico_id])\n    url += indico_id + '.' + str(indico_type)\n\n    if hasattr(indico_params, 'items'):\n        items = indico_params.items()\n    else:\n        items = list(indico_params)\n    if indico_key:\n        items.append(('apikey', indico_key))\n    if indico_sig and HASHLIB_IMPORTED:\n        if _timestamp:\n            items.append(('timestamp', str(_timestamp)))\n        else:\n            items.append(('timestamp', str(int(time.time()))))\n        items = sorted(items, key=lambda x: x[0].lower())\n        url_to_sign = '%s?%s' % (url, urlencode(items))\n        if sys.version_info < (2, 5):\n            # compatibility mode for Python < 2.5 and hashlib\n            my_digest_algo = _MySHA1(sha1())\n        else:\n            my_digest_algo = sha1\n        signature = hmac.new(indico_sig, url_to_sign, my_digest_algo).hexdigest()\n        items.append(('signature', signature))\n    elif not HASHLIB_IMPORTED:\n        try:\n            raise Exception(\"Module hashlib not installed. Please install it.\")\n        except:\n            from invenio.ext.logging import register_exception\n            register_exception(stream='warning', alert_admin=True, subject='Cannot create AWS signature')\n    if not items:\n        return url\n\n    url = '%s%s?%s' % (base_url.strip('/'), url, urlencode(items))\n    return url\n\nclass _MyHashlibAlgo(object):\n    '''\n    Define a subclass of any hashlib algorithm class, with an additional \"new()\"\n    function, to work with the Python < 2.5 version of the hmac module.\n\n    (This class is more complex than it should, but it is not\n    possible to subclass haslib algorithm)\n    '''\n\n    def __init__(self, obj):\n        \"\"\"Set the wrapped object.\"\"\"\n        super(_MyHashlibAlgo, self).__setattr__('_obj', obj)\n\n        methods = []\n        for name_value in inspect.getmembers(obj, inspect.ismethod):\n            methods.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__methods__', methods)\n\n        def isnotmethod(object_):\n            \"Opposite of ismethod(..)\"\n            return not inspect.ismethod(object_)\n        members = []\n        for name_value in inspect.getmembers(obj, isnotmethod):\n            members.append(name_value[0])\n        super(_MyHashlibAlgo, self).__setattr__('__members__', members)\n\n    def __getattr__(self, name):\n        \"\"\"Redirect unhandled get attribute to self._obj.\"\"\"\n        if not hasattr(self._obj, name):\n            raise AttributeError, (\"'%s' has no attribute %s\" %\n                                   (self.__class__.__name__, name))\n        else:\n            return getattr(self._obj, name)\n\n    def __setattr__(self, name, value):\n        \"\"\"Redirect set attribute to self._obj if necessary.\"\"\"\n        self_has_attr = True\n        try:\n            super(_MyHashlibAlgo, self).__getattribute__(name)\n        except AttributeError:\n            self_has_attr = False\n\n        if (name == \"_obj\" or not hasattr(self, \"_obj\") or\n            not hasattr(self._obj, name) or self_has_attr):\n            return super(_MyHashlibAlgo, self).__setattr__(name, value)\n        else:\n            return setattr(self._obj, name, value)\n\nif HASHLIB_IMPORTED:\n    from invenio.utils.hash import sha256\n\n\n    class _MySHA256(_MyHashlibAlgo):\n        \"A _MyHashlibAlgo subsclass for sha256\"\n        new = lambda d = '': sha256()\n\n\nclass _MySHA1(_MyHashlibAlgo):\n    \"A _MyHashlibAlgo subsclass for sha1\"\n    new = lambda d = '': sha1()\n\ndef auto_version_url(file_path):\n    \"\"\" Appends modification time of the file to the request URL in order for the\n        browser to refresh the cache when file changes\n\n        @param file_path: path to the file, e.g js/foo.js\n        @return: file_path with modification time appended to URL\n    \"\"\"\n    file_md5 = \"\"\n    try:\n        file_md5 = md5(open(cfg.get('CFG_WEBDIR') + os.sep + file_path).read()).hexdigest()\n    except IOError:\n        pass\n    return file_path + \"?%s\" % file_md5\n\ndef get_relative_url(url):\n    \"\"\"\n    Returns the relative URL from a URL. For example:\n\n    'http://web.net' -> ''\n    'http://web.net/' -> ''\n    'http://web.net/1222' -> '/1222'\n    'http://web.net/wsadas/asd' -> '/wsadas/asd'\n\n    It will never return a trailing \"/\".\n\n    @param url: A url to transform\n    @type url: str\n\n    @return: relative URL\n    \"\"\"\n    # remove any protocol info before\n    stripped_site_url = url.replace(\"://\", \"\")\n    baseurl = \"/\" + \"/\".join(stripped_site_url.split(\"/\")[1:])\n\n    # remove any trailing slash (\"/\")\n    if baseurl[-1] == \"/\":\n        return baseurl[:-1]\n    else:\n        return baseurl\n/n/n/n", "label": 0}, {"id": "20edecca740c36a80b65678fce66c5d453281dd0", "code": "/invenio/modules/oauthclient/config.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Configuration variables for defining remote applications.\n\n================================ ==============================================\n`OAUTHCLIENT_REMOTE_APPS`        Dictionary of remote applications. See example\n                                 below. **Default:** ``{}``.\n`OAUTHCLIENT_SESSION_KEY_PREFIX` Prefix for the session key used to store the\n                                 an access token. **Default:** ``oauth_token``.\n================================ ==============================================\n\nEach remote application must be defined in the ``OAUTHCLIENT_REMOTE_APPS``\ndictionary, where the keys are the application names and the values the\nconfiguration parameters for the application.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # configuration values for myapp ...\n        ),\n    )\n\nThe application name is used in the login, authorized, sign-up and disconnect\nendpoints:\n\n- Login endpoint: ``/oauth/login/<REMOTE APP>/``.\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\n\nRemote application\n^^^^^^^^^^^^^^^^^^\nConfiguration of a single remote application is a dictionary with the following\nkeys:\n\n- ``title`` - Title of remote application. Displayed to end-users under Account\n  > Linked accounts.\n- ``description`` - Short description of remote application. Displayed to\n  end-users under Account > Linked accounts.\n- ``icon`` - CSS class for icon of service (e.g. ``fa fa-github`` for using the\n  Font-Awesome GitHub icon). Displayed to end-users.\n- ``params`` - Flask-OAuthlib remote application parameters..\n- ``authorized_handler`` - Import path to authorized callback handler.\n- ``disconnect_handler`` - Import path to disconnect callback handler.\n- ``signup_handler`` - A dictionary of import path to sign up callback handler.\n- ``remember`` - Boolean indicating if the session should be permament.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            title='...',\n            description='...',\n            icon='...',\n            authorized_handler=\"...\",\n            disconnect_handler=\"...\",\n            signup_handler=dict(\n                info=\"...\",\n                setup=\"...\",\n                view=\"...\",\n            ),\n            params=dict(...),\n            remember=True\n            )\n        )\n    )\n\n\nFlask-OAuthlib parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^\nThe Flask-OAuthlib parameters defines the remote application OAuth endpoints as\nwell as the client id and secret. Full description of these parameters are\ngiven in the `Flask-OAuthlib documentation <https://flask-oauthlib.readthedocs.org/en/latest/client.html>`_.\n\nNormally you will have to browse the remote application's API documentation to\nfind which URLs and scopes to use.\n\nBelow is an example for GitHub:\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        github=dict(\n            # ...\n            params=dict(\n                request_token_params={'scope': 'user:email'},\n                base_url='https://api.github.com/',\n                request_token_url=None,\n                access_token_url=\"https://github.com/login/oauth/access_token\",\n                access_token_method='POST',\n                authorize_url=\"https://github.com/login/oauth/authorize\",\n                app_key=\"GITHUB_APP_CREDENTIALS\",\n            )\n        )\n    )\n\n    GITHUB_APP_CREDENTIALS=dict(\n        consumer_key=\"changeme\"\n        consumer_secret=\"changeme\"\n    )\n\nThe ``app_key`` parameter allows you to put your sensitive client id and secret\nin your instance configuration (``var/invenio.base-instance/invenio.cfg``).\n\nHandlers\n^^^^^^^^\nHandlers allow customizing oauthclient endpoints for each remote\napplication:\n\n- Authorized endpoint: ``/oauth/authorized/<REMOTE APP>/``.\n- Disconnect endpoint: ``/oauth/disconnect/<REMOTE APP>/``.\n- Sign up endpoint: ``/oauth/login/<REMOTE APP>/``.\n\nBy default only authorized and disconnect handlers are required, and Invenio\nprovide default implementation that stores the access token in the user session\nas well as to the database if the user is authenticated:\n\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        myapp=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_default_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            # ...\n        )\n    )\n\nIf you want to provide sign in/up functionality using oauthclient, Invenio\ncomes with a default handler that will try to find a matching local user for\na given authorize request.\n\n.. code-block:: python\n\n    OAUTHCLIENT_REMOTE_APPS = dict(\n        orcid=dict(\n            # ...\n            authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n            disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n            )\n            signup_handler=dict(\n                info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n                setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n                view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n            ),\n            # ...\n        )\n    )\n\"\"\"\n\nOAUTHCLIENT_REMOTE_APPS = {}\n\"\"\"Configuration of remote applications.\"\"\"\n\nOAUTHCLIENT_SESSION_KEY_PREFIX = \"oauth_token\"\n\"\"\"Session key prefix used when storing the access token for a remote app.\"\"\"\n/n/n/n/invenio/modules/oauthclient/contrib/orcid.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Pre-configured remote application for enabling sign in/up with ORCID.\n\n**Usage:**\n\n1. Edit your configuration and add:\n\n   .. code-block:: python\n\n       from invenio.modules.oauthclient.contrib import orcid\n       OAUTHCLIENT_REMOTE_APPS = dict(\n           orcid=orcid.REMOTE_APP,\n       )\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"changeme\",\n           consumer_secret=\"changeme\",\n       )\n\n  Note, if you want to use the ORCID sandbox, use ``orcid.REMOTE_SANDBOX_APP``\n  instead of ``orcid.REMOTE_APP``.\n\n2. Register a new application with ORCID. When registering the\n   application ensure that the *Redirect URI* points to:\n   ``CFG_SITE_SECURE_URL/oauth/authorized/orcid/`` (note, ORCID does not\n   allow localhost to be used, thus testing on development machines is\n   somewhat complicated by this).\n\n\n3. Grab the *Client ID* and *Client Secret* after registering the application\n   and add them to your instance configuration (``invenio.cfg``):\n\n   .. code-block:: python\n\n       ORCID_APP_CREDENTIALS = dict(\n           consumer_key=\"<CLIENT ID>\",\n           consumer_secret=\"<CLIENT SECRET>\",\n       )\n\n4. Now go to ``CFG_SITE_SECURE_URL/oauth/login/orcid/`` (e.g.\n   http://localhost:4000/oauth/login/orcid/)\n\n5. Also, you should see ORCID listed under Linked accounts:\n   http://localhost:4000//account/settings/linkedaccounts/\n\nBy default the ORCID module will try first look if a link already exists\nbetween a ORCID account and a user. If no link is found, the user is asked\nto provide an email address to sign-up.\n\nIn templates you can add a sign in/up link:\n\n.. code-block:: jinja\n\n    <a href=\"{{url_for('oauthclient.login', remote_app='orcid')}}\">Sign in with ORCID</a>\n\n\"\"\"\n\nimport copy\n\nfrom flask import current_app, session\nfrom flask.ext.login import current_user\n\nfrom invenio.ext.sqlalchemy.utils import session_manager\n\n\nREMOTE_APP = dict(\n    title='ORCID',\n    description='Connecting Research and Researchers.',\n    icon='',\n    authorized_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":authorized_signup_handler\",\n    disconnect_handler=\"invenio.modules.oauthclient.handlers\"\n                       \":disconnect_handler\",\n    signup_handler=dict(\n        info=\"invenio.modules.oauthclient.contrib.orcid:account_info\",\n        setup=\"invenio.modules.oauthclient.contrib.orcid:account_setup\",\n        view=\"invenio.modules.oauthclient.handlers:signup_handler\",\n    ),\n    params=dict(\n        request_token_params={'scope': '/authenticate'},\n        base_url='https://pub.orcid.com/',\n        request_token_url=None,\n        access_token_url=\"https://pub.orcid.org/oauth/token\",\n        access_token_method='POST',\n        authorize_url=\"https://orcid.org/oauth/authorize#show_login\",\n        app_key=\"ORCID_APP_CREDENTIALS\",\n        content_type=\"application/json\",\n    )\n)\n\"\"\" ORCID Remote Application. \"\"\"\n\nREMOTE_SANDBOX_APP = copy.deepcopy(REMOTE_APP)\n\"\"\"ORCID Sandbox Remote Application.\"\"\"\n\nREMOTE_SANDBOX_APP['params'].update(dict(\n    base_url=\"https://api.sandbox.orcid.org/\",\n    access_token_url=\"https://api.sandbox.orcid.org/oauth/token\",\n    authorize_url=\"https://sandbox.orcid.org/oauth/authorize#show_login\",\n))\n\n\ndef account_info(remote, resp):\n    \"\"\"Retrieve remote account information used to find local user.\"\"\"\n    account_info = dict(external_id=resp.get(\"orcid\"), external_method=\"orcid\")\n\n    return account_info\n\n\n@session_manager\ndef account_setup(remote, token):\n    \"\"\"Perform additional setup after user have been logged in.\"\"\"\n    from invenio.modules.accounts.models import User, UserEXT\n    from invenio.ext.sqlalchemy import db\n    from ..handlers import token_session_key\n\n    from sqlalchemy.orm.exc import MultipleResultsFound, NoResultFound\n\n    import json\n    import requests\n\n    orcid = session.get(token_session_key(remote.name) +\n                        \"_account_info\").get(\"external_id\")\n\n    extra_data = {\n        \"orcid\": orcid\n        }\n    token.remote_account.extra_data = extra_data\n\n    try:\n        user = User.query.join(UserEXT).filter_by(id=orcid,\n                                                  method=\"orcid\").one()\n    except (MultipleResultsFound, NoResultFound):\n        current_app.logger.exception(\"No user entry in userEXT.\")\n\n    # Fill user full name if not already set\n    if user and not any([user.given_names, user.family_name]):\n        # Query ORCID to get the real name\n        request_url = 'http://orcid.org/{0}/orcid-bio'.format(orcid)\n\n        headers = {'Accept': 'application/orcid+json'}\n        response = requests.get(request_url, headers=headers)\n        code = response.status_code\n\n        if code == requests.codes.ok:\n            try:\n                orcid_bio = json.loads(response.content)\n            except ValueError:\n                current_app.logger.exception(\"Not valid JSON response from \" +\n                                             \"ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            try:\n                name = orcid_bio[\"orcid-profile\"][\"orcid-bio\"][\"personal-details\"]\n                user.given_names = name[\"given-names\"][\"value\"]\n                user.family_name = name[\"family-name\"][\"value\"]\n            except KeyError:\n                current_app.logger.exception(\"Unexpected return format \" +\n                                             \"from ORCID:\\n {0}\".format(repr(orcid_bio)))\n                return\n            db.session.add(user)\n            # Refresh user cache\n            current_user.reload()\n/n/n/n/invenio/modules/oauthclient/handlers.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014, 2015 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\"Handlers for customizing oauthclient endpoints.\"\"\"\n\nimport six\n\nfrom flask import current_app, flash, redirect, render_template, \\\n    request, session, url_for\nfrom flask.ext.login import current_user\nfrom functools import partial, wraps\nfrom werkzeug.utils import import_string\n\nfrom invenio.base.globals import cfg\n\nfrom .client import oauth, signup_handlers\nfrom .errors import OAuthClientError, OAuthError, \\\n    OAuthRejectedRequestError, OAuthResponseError\nfrom .forms import EmailSignUpForm\nfrom .models import RemoteAccount, RemoteToken\nfrom .utils import oauth_authenticate, oauth_get_user, oauth_register\n\n\n#\n# Token handling\n#\ndef token_session_key(remote_app):\n    \"\"\"Generate a session key used to store the token for a remote app.\"\"\"\n    return '%s_%s' % (cfg['OAUTHCLIENT_SESSION_KEY_PREFIX'], remote_app)\n\n\ndef response_token_setter(remote, resp):\n    \"\"\"Extract token from response and set it for the user.\"\"\"\n    if resp is None:\n        raise OAuthRejectedRequestError(\"User rejected request.\", remote, resp)\n    else:\n        if 'access_token' in resp:\n            return oauth2_token_setter(remote, resp)\n        elif 'oauth_token' in resp and 'oauth_token_secret' in resp:\n            return oauth1_token_setter(remote, resp)\n        elif 'error' in resp:\n            # Only OAuth2 specifies how to send error messages\n            raise OAuthClientError(\n                'Authorization with remote service failed.', remote, resp,\n            )\n    raise OAuthResponseError(\"Bad OAuth authorized request\", remote, resp)\n\n\ndef oauth1_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth1 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['oauth_token'],\n        secret=resp['oauth_token_secret'],\n        extra_data=extra_data,\n        token_type=token_type,\n    )\n\n\ndef oauth2_token_setter(remote, resp, token_type='', extra_data=None):\n    \"\"\"Set an OAuth2 token.\"\"\"\n    return token_setter(\n        remote,\n        resp['access_token'],\n        secret='',\n        token_type=token_type,\n        extra_data=extra_data,\n    )\n\n\ndef token_setter(remote, token, secret='', token_type='', extra_data=None):\n    \"\"\"Set token for user.\"\"\"\n    session[token_session_key(remote.name)] = (token, secret)\n\n    # Save token if used is authenticated\n    if current_user.is_authenticated():\n        uid = current_user.get_id()\n        cid = remote.consumer_key\n\n        # Check for already existing token\n        t = RemoteToken.get(uid, cid, token_type=token_type)\n\n        if t:\n            t.update_token(token, secret)\n        else:\n            t = RemoteToken.create(\n                uid, cid, token, secret,\n                token_type=token_type, extra_data=extra_data\n            )\n        return t\n    return None\n\n\ndef token_getter(remote, token=''):\n    \"\"\"Retrieve OAuth access token.\n\n    Ued by flask-oauthlib to get the access token when making requests.\n\n    :param token: Type of token to get. Data passed from ``oauth.request()`` to\n         identify which token to retrieve.\n    \"\"\"\n    session_key = token_session_key(remote.name)\n\n    if session_key not in session and current_user.is_authenticated():\n        # Fetch key from token store if user is authenticated, and the key\n        # isn't already cached in the session.\n        remote_token = RemoteToken.get(\n            current_user.get_id(),\n            remote.consumer_key,\n            token_type=token,\n        )\n\n        if remote_token is None:\n            return None\n\n        # Store token and secret in session\n        session[session_key] = remote_token.token()\n\n    return session.get(session_key, None)\n\n\ndef token_delete(remote, token=''):\n    \"\"\"Remove OAuth access tokens from session.\"\"\"\n    session_key = token_session_key(remote.name)\n    return session.pop(session_key, None)\n\n\n#\n# Error handling decorators\n#\ndef oauth_error_handler(f):\n    \"\"\"Decorator to handle exceptions.\"\"\"\n    @wraps(f)\n    def inner(*args, **kwargs):\n        # OAuthErrors should not happen, so they are not caught here. Hence\n        # they will result in a 500 Internal Server Error which is what we\n        # are interested in.\n        try:\n            return f(*args, **kwargs)\n        except OAuthClientError as e:\n            current_app.logger.warning(e.message, exc_info=True)\n            return oauth2_handle_error(\n                e.remote, e.response, e.code, e.uri, e.description\n            )\n        except OAuthRejectedRequestError:\n            flash(\"You rejected the authentication request.\")\n            return redirect('/')\n    return inner\n\n\n#\n# Handlers\n#\n@oauth_error_handler\ndef authorized_default_handler(resp, remote, *args, **kwargs):\n    \"\"\"Store access token in session.\n\n    Default authorized handler.\n    \"\"\"\n    response_token_setter(remote, resp)\n    return redirect('/')\n\n\n@oauth_error_handler\ndef authorized_signup_handler(resp, remote, *args, **kwargs):\n    \"\"\"Handle sign-in/up functionality.\"\"\"\n    # Remove any previously stored auto register session key\n    session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n    # Store token in session\n    # ----------------------\n    # Set token in session - token object only returned if\n    # current_user.is_autenticated().\n    token = response_token_setter(remote, resp)\n    handlers = signup_handlers[remote.name]\n\n    # Sign-in/up user\n    # ---------------\n    if not current_user.is_authenticated():\n        account_info = handlers['info'](resp)\n\n        user = oauth_get_user(\n            remote.consumer_key,\n            account_info=account_info,\n            access_token=token_getter(remote)[0],\n        )\n\n        if user is None:\n            # Auto sign-up if user not found\n            user = oauth_register(account_info)\n            if user is None:\n                # Auto sign-up requires extra information\n                session[\n                    token_session_key(remote.name) + '_autoregister'] = True\n                session[token_session_key(remote.name) +\n                        \"_account_info\"] = account_info\n                return redirect(url_for(\n                    \".signup\",\n                    remote_app=remote.name,\n                    next=request.args.get('next', '/')\n                ))\n\n        # Authenticate user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account\n        # ------------\n        # Need to store token in database instead of only the session when\n        # called first time.\n        token = response_token_setter(remote, resp)\n\n    # Setup account\n    # -------------\n    if not token.remote_account.extra_data and \\\n       remote.name in signup_handlers:\n        handlers['setup'](token)\n\n    # Redirect to next\n    if request.args.get('next', None):\n        return redirect(request.args.get('next'))\n    else:\n        return redirect('/')\n\n\n@oauth_error_handler\ndef disconnect_handler(remote, *args, **kwargs):\n    \"\"\"Handle unlinking of remote account.\n\n    This default handler will just delete the remote account link. You may\n    wish to extend this module to perform clean-up in the remote service\n    before removing the link (e.g. removing install webhooks).\n    \"\"\"\n    if not current_user.is_authenticated():\n        return current_app.login_manager.unauthorized()\n\n    account = RemoteAccount.get(\n        user_id=current_user.get_id(),\n        client_id=remote.consumer_key\n    )\n    if account:\n        account.delete()\n\n    return redirect(url_for('oauthclient_settings.index'))\n\n\ndef signup_handler(remote, *args, **kwargs):\n    \"\"\"Handle extra signup information.\"\"\"\n    # User already authenticated so move on\n    if current_user.is_authenticated():\n        return redirect(\"/\")\n\n    # Retrieve token from session\n    oauth_token = token_getter(remote)\n    if not oauth_token:\n        return redirect(\"/\")\n\n    # Test to see if this is coming from on authorized request\n    if not session.get(token_session_key(remote.name) + '_autoregister',\n                       False):\n        return redirect(url_for(\".login\", remote_app=remote.name))\n\n    form = EmailSignUpForm(request.form)\n\n    if form.validate_on_submit():\n        account_info = session.get(token_session_key(remote.name) +\n                                   \"_account_info\")\n        # Register user\n        user = oauth_register(account_info, form.data)\n\n        if user is None:\n            raise OAuthError(\"Could not create user.\", remote)\n\n        # Remove session key\n        session.pop(token_session_key(remote.name) + '_autoregister', None)\n\n        # Authenticate the user\n        if not oauth_authenticate(remote.consumer_key, user,\n                                  require_existing_link=False,\n                                  remember=cfg['OAUTHCLIENT_REMOTE_APPS']\n                                  [remote.name].get('remember', False)):\n            return current_app.login_manager.unauthorized()\n\n        # Link account and set session data\n        token = token_setter(remote, oauth_token[0], secret=oauth_token[1])\n        handlers = signup_handlers[remote.name]\n\n        if token is None:\n            raise OAuthError(\"Could not create token for user.\", remote)\n\n        if not token.remote_account.extra_data:\n            handlers['setup'](token)\n\n        # Remove account info from session\n        session.pop(token_session_key(remote.name) + '_account_info', None)\n\n        # Redirect to next\n        if request.args.get('next', None):\n            return redirect(request.args.get('next'))\n        else:\n            return redirect('/')\n\n    return render_template(\n        \"oauthclient/signup.html\",\n        form=form,\n        remote=remote,\n        app_title=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('title', ''),\n        app_description=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get(\n            'description', ''\n        ),\n        app_icon=cfg['OAUTHCLIENT_REMOTE_APPS'][remote.name].get('icon', None),\n    )\n\n\ndef oauth_logout_handler(sender_app, user=None):\n    \"\"\"Remove all access tokens from session on logout.\"\"\"\n    for remote in oauth.remote_apps.values():\n        token_delete(remote)\n\n\n#\n# Helpers\n#\ndef make_handler(f, remote, with_response=True):\n    \"\"\"Make a handler for authorized and disconnect callbacks.\n\n    :param f: Callable or an import path to a callable\n    \"\"\"\n    if isinstance(f, six.text_type):\n        f = import_string(f)\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if with_response:\n            return f(args[0], remote, *args[1:], **kwargs)\n        else:\n            return f(remote, *args, **kwargs)\n    return inner\n\n\ndef make_token_getter(remote):\n    \"\"\"Make a token getter for a remote application.\"\"\"\n    return partial(token_getter, remote)\n\n\ndef oauth2_handle_error(remote, resp, error_code, error_uri,\n                        error_description):\n    \"\"\"Handle errors during exchange of one-time code for an access tokens.\"\"\"\n    flash(\"Authorization with remote service failed.\")\n    return redirect('/')\n/n/n/n/invenio/modules/oauthclient/testsuite/test_views.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\nfrom __future__ import absolute_import\n\nfrom mock import MagicMock, patch\nfrom six.moves.urllib_parse import quote_plus\nfrom flask import url_for, session\nfrom invenio.testsuite import make_test_suite, run_test_suite\nfrom invenio.ext.sqlalchemy import db\n\nfrom .helpers import OAuth2ClientTestCase\n\n\nclass RemoteAccountTestCase(OAuth2ClientTestCase):\n    def setUp(self):\n        params = lambda x: dict(\n            request_token_params={'scope': ''},\n            base_url='https://foo.bar/',\n            request_token_url=None,\n            access_token_url=\"https://foo.bar/oauth/access_token\",\n            authorize_url=\"https://foo.bar/oauth/authorize\",\n            consumer_key=x,\n            consumer_secret='testsecret',\n        )\n\n        self.app.config['OAUTHCLIENT_REMOTE_APPS'] = dict(\n            test=dict(\n                authorized_handler=self.handler,\n                params=params('testid'),\n                title='MyLinkedTestAccount',\n            ),\n            test_invalid=dict(\n                authorized_handler=self.handler_invalid,\n                params=params('test_invalidid'),\n                title='Test Invalid',\n            ),\n            full=dict(\n                params=params(\"fullid\"),\n                title='Full',\n            ),\n        )\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def tearDown(self):\n        self.handled_resp = None\n        self.handled_remote = None\n        self.handled_args = None\n        self.handled_kwargs = None\n\n        from invenio.modules.oauthclient.models import RemoteToken, \\\n            RemoteAccount\n        RemoteToken.query.delete()\n        RemoteAccount.query.delete()\n        db.session.commit()\n\n    def handler(self, resp, remote, *args, **kwargs):\n        self.handled_resp = resp\n        self.handled_remote = remote\n        self.handled_args = args\n        self.handled_kwargs = kwargs\n        return \"TEST\"\n\n    def handler_invalid(self):\n        self.handled_resp = 1\n        self.handled_remote = 1\n        self.handled_args = 1\n        self.handled_kwargs = 1\n\n    def mock_response(self, app='test', data=None):\n        \"\"\" Mock the oauth response to use the remote \"\"\"\n        from invenio.modules.oauthclient.client import oauth\n\n        # Mock oauth remote application\n        oauth.remote_apps[app].handle_oauth2_response = MagicMock(\n            return_value=data or {\n                \"access_token\": \"test_access_token\",\n                \"scope\": \"\",\n                \"token_type\": \"bearer\"\n            }\n        )\n\n    def test_login(self):\n        # Test redirect\n        resp = self.client.get(url_for(\"oauthclient.login\", remote_app='test'))\n        self.assertStatus(resp, 302)\n        self.assertEqual(\n            resp.location,\n            \"https://foo.bar/oauth/authorize?response_type=code&\"\n            \"client_id=testid&redirect_uri=%s\" % quote_plus(url_for(\n                \"oauthclient.authorized\", remote_app='test', _external=True\n            ))\n        )\n\n        # Invalid remote\n        resp = self.client.get(\n            url_for(\"oauthclient.login\", remote_app='invalid')\n        )\n        self.assertStatus(resp, 404)\n\n    def test_authorized(self):\n        # Fake an authorized request\n        with self.app.test_client() as c:\n            # Ensure remote apps have been loaded (due to before first\n            # request)\n            c.get(url_for(\"oauthclient.login\", remote_app='test'))\n            self.mock_response(app='test')\n            self.mock_response(app='test_invalid')\n\n            resp = c.get(\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test',\n                    code='test',\n                )\n            )\n            assert resp.data == \"TEST\"\n            assert self.handled_remote.name == 'test'\n            assert not self.handled_args\n            assert not self.handled_kwargs\n            assert self.handled_resp['access_token'] == 'test_access_token'\n\n            resp = self.assertRaises(\n                TypeError,\n                c.get,\n                url_for(\n                    \"oauthclient.authorized\",\n                    remote_app='test_invalid',\n                    code='test',\n                )\n            )\n\n    def test_no_remote_app(self):\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.authorized\", remote_app='invalid')\n        ))\n\n        self.assert404(self.client.get(\n            url_for(\"oauthclient.disconnect\", remote_app='invalid')\n        ))\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_token_getter_setter(self, save_session):\n        from invenio.modules.oauthclient.models import RemoteToken\n        from invenio.modules.oauthclient.handlers import token_getter\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n                # Mock resposen class\n                self.mock_response(app='full')\n\n                # Imitate that the user authorized our request in the remote\n                # application.\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                # Assert if every is as it should be.\n                assert session['oauth_token_full'] == ('test_access_token', '')\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.remote_account.client_id == 'fullid'\n                assert t.access_token == 'test_access_token'\n                assert RemoteToken.query.count() == 1\n\n                self.mock_response(app='full', data={\n                    \"access_token\": \"new_access_token\",\n                    \"scope\": \"\",\n                    \"token_type\": \"bearer\"\n                })\n\n                c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n\n                t = RemoteToken.get(1, \"fullid\")\n                assert t.access_token == 'new_access_token'\n                assert RemoteToken.query.count() == 1\n\n                val = token_getter(oauth.remote_apps['full'])\n                assert val == ('new_access_token', '')\n\n                # Disconnect account\n                res = c.get(url_for(\n                    \"oauthclient.disconnect\", remote_app='full',\n                ))\n                assert res.status_code == 302\n                assert res.location.endswith(\n                    url_for('oauthclient_settings.index')\n                )\n                # Assert that remote account have been removed.\n                t = RemoteToken.get(1, \"fullid\")\n                assert t is None\n\n    @patch('invenio.ext.session.interface.SessionInterface.save_session')\n    def test_rejected(self, save_session):\n        from invenio.modules.oauthclient.client import oauth\n\n        user = MagicMock()\n        user.get_id = MagicMock(return_value=1)\n        user.is_authenticated = MagicMock(return_value=True)\n        with patch('flask.ext.login._get_user', return_value=user):\n            with self.app.test_client() as c:\n                # First call login to be redirected\n                res = c.get(url_for(\"oauthclient.login\", remote_app='full'))\n                assert res.status_code == 302\n                assert res.location.startswith(\n                    oauth.remote_apps['full'].authorize_url\n                )\n\n                # Mock response to imitate an invalid response. Here, an\n                # example from GitHub when the code is expired.\n                self.mock_response(app='full', data=dict(\n                    error_uri='http://developer.github.com/v3/oauth/'\n                              '#bad-verification-code',\n                    error_description='The code passed is '\n                                      'incorrect or expired.',\n                    error='bad_verification_code',\n                ))\n\n                # Imitate that the user authorized our request in the remote\n                # application (however, the remote app will son reply with an\n                # error)\n                res = c.get(url_for(\n                    \"oauthclient.authorized\", remote_app='full', code='test',\n                ))\n                assert res.status_code == 302\n\n    def test_settings_view(self):\n        # Create a remove account (linked account)\n        from invenio.modules.oauthclient.models import RemoteAccount\n        RemoteAccount.create(1, 'testid', None)\n\n        self.assert401(self.client.get(url_for('oauthclient_settings.index'),\n                                       follow_redirects=True))\n        self.login(\"admin\", \"\")\n\n        res = self.client.get(url_for('oauthclient_settings.index'))\n        self.assert200(res)\n        assert 'MyLinkedTestAccount' in res.data\n        assert url_for('oauthclient.disconnect', remote_app='test') in res.data\n        assert url_for('oauthclient.login', remote_app='full') in res.data\n        assert url_for('oauthclient.login', remote_app='test_invalid') in \\\n            res.data\n\n\nTEST_SUITE = make_test_suite(RemoteAccountTestCase)\n\nif __name__ == \"__main__\":\n    run_test_suite(TEST_SUITE)\n/n/n/n/invenio/modules/oauthclient/views/client.py/n/n# -*- coding: utf-8 -*-\n##\n## This file is part of Invenio.\n## Copyright (C) 2014 CERN.\n##\n## Invenio is free software; you can redistribute it and/or\n## modify it under the terms of the GNU General Public License as\n## published by the Free Software Foundation; either version 2 of the\n## License, or (at your option) any later version.\n##\n## Invenio is distributed in the hope that it will be useful, but\n## WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n## General Public License for more details.\n##\n## You should have received a copy of the GNU General Public License\n## along with Invenio; if not, write to the Free Software Foundation, Inc.,\n## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.\n\n\"\"\" Client blueprint used to handle OAuth callbacks. \"\"\"\n\nfrom __future__ import absolute_import\n\nfrom flask import Blueprint, abort, current_app, url_for, request\n\nfrom flask.ext.login import user_logged_out\n\nfrom invenio.base.globals import cfg\nfrom invenio.ext.sslify import ssl_required\n\nfrom ..client import oauth, handlers, disconnect_handlers, signup_handlers\nfrom ..handlers import authorized_default_handler, make_token_getter, \\\n    make_handler, disconnect_handler, oauth_logout_handler\n\n\nblueprint = Blueprint(\n    'oauthclient',\n    __name__,\n    url_prefix=\"/oauth\",\n    static_folder=\"../static\",\n    template_folder=\"../templates\",\n)\n\n\n@blueprint.before_app_first_request\ndef setup_app():\n    \"\"\" Setup OAuth clients. \"\"\"\n    # Connect signal to remove access tokens on logout\n    user_logged_out.connect(oauth_logout_handler)\n\n    # Add remote applications\n    oauth.init_app(current_app)\n\n    for remote_app, conf in cfg['OAUTHCLIENT_REMOTE_APPS'].items():\n        # Prevent double creation problems\n        if remote_app not in oauth.remote_apps:\n            remote = oauth.remote_app(\n                remote_app,\n                **conf['params']\n            )\n\n        remote = oauth.remote_apps[remote_app]\n\n        # Set token getter for remote\n        remote.tokengetter(make_token_getter(remote))\n\n        # Register authorized handler\n        handlers.register(\n            remote_app,\n            remote.authorized_handler(make_handler(\n                conf.get('authorized_handler', authorized_default_handler),\n                remote,\n            ))\n        )\n\n        # Register disconnect handler\n        disconnect_handlers.register(\n            remote_app, make_handler(\n                conf.get('disconnect_handler', disconnect_handler),\n                remote,\n                with_response=False,\n            )\n        )\n\n        # Register sign-up handlers\n        def dummy_handler(remote, *args, **kargs):\n            pass\n\n        signup_handler = conf.get('signup_handler', dict())\n        account_info_handler = make_handler(\n            signup_handler.get('info', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_setup_handler = make_handler(\n            signup_handler.get('setup', dummy_handler),\n            remote,\n            with_response=False\n        )\n        account_view_handler = make_handler(\n            signup_handler.get('view', dummy_handler),\n            remote,\n            with_response=False\n        )\n\n        signup_handlers.register(\n            remote_app,\n            dict(\n                info=account_info_handler,\n                setup=account_setup_handler,\n                view=account_view_handler,\n            )\n        )\n\n\n@blueprint.route('/login/<remote_app>/')\n@ssl_required\ndef login(remote_app):\n    \"\"\" Send user to remote application for authentication. \"\"\"\n    if remote_app not in oauth.remote_apps:\n        return abort(404)\n\n    callback_url = url_for(\n        '.authorized',\n        remote_app=remote_app,\n        next=request.args.get('next') or request.referrer or None,\n        _external=True,\n    )\n\n    return oauth.remote_apps[remote_app].authorize(callback=callback_url)\n\n\n@blueprint.route('/authorized/<remote_app>/')\n@ssl_required\ndef authorized(remote_app=None):\n    \"\"\" Authorized handler callback. \"\"\"\n    if remote_app not in handlers:\n        return abort(404)\n    return handlers[remote_app]()\n\n\n@blueprint.route('/signup/<remote_app>/', methods=['GET', 'POST'])\n@ssl_required\ndef signup(remote_app):\n    \"\"\" Extra signup step. \"\"\"\n    if remote_app not in signup_handlers:\n        return abort(404)\n    res = signup_handlers[remote_app]['view']()\n    return abort(404) if res is None else res\n\n\n@blueprint.route('/disconnect/<remote_app>/')\n@ssl_required\ndef disconnect(remote_app):\n    \"\"\" Disconnect user from remote application.\n\n    Removes application as well as associated information.\n    \"\"\"\n    if remote_app not in disconnect_handlers:\n        return abort(404)\n\n    return disconnect_handlers[remote_app]()\n/n/n/n", "label": 1}, {"id": "ae7e50d52016e4c9471e39bb4ac03b4c7dfe33bb", "code": "bzs/core.py/n/n\nimport socket\nimport threading\nimport tornado\n\nimport tornado.concurrent\nimport tornado.httputil\nimport tornado.httpserver\nimport tornado.gen\nimport tornado.ioloop\nimport tornado.process\nimport tornado.web\n\nfrom bzs import const\nfrom bzs import db\nfrom bzs import files\n\nfrom bzs import module_error404\nfrom bzs import module_files\nfrom bzs import module_home\nfrom bzs import module_index\nfrom bzs import module_static\n\nWEB_PORT = 80\n\ndef main():\n    # Creating web application\n    web_app = tornado.web.Application([\n            (r'^/$', module_index.MainframeHandler),\n            (r'/static/(.*)$', module_static.StaticHandler),\n            # (r'/static/(.*)', tornado.web.StaticFileHandler, {\n            #     \"path\": \"./static/\" # Optimized static file handler with cache\n            # }),\n            (r'^/home', module_home.HomeHandler),\n            (r'^/files/?()$', module_files.FilesListHandler),\n            (r'^/files/list/(.*)', module_files.FilesListHandler),\n            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),\n            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),\n            (r'^/files/operation/?', module_files.FilesOperationHandler),\n            (r'.*', module_error404.Error404Handler)\n        ],\n        xsrf_cookies=False # True to prevent CSRF third party attacks\n    )\n    # Starting server\n    web_sockets = tornado.netutil.bind_sockets(\n        const.get_const('server-port'),\n        family=socket.AF_INET)\n    if const.get_const('server-threads') > 1:\n        if hasattr(os, 'fork'):\n            # os.fork() operation unavailable on Windows.\n            tornado.process.fork_processes(const.get_const('server-threads') - 1)\n    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)\n    web_server.add_sockets(web_sockets)\n    # Boot I/O thread for asynchronous purposes\n    tornado.ioloop.IOLoop.instance().start()\n    return\n/n/n/nbzs/module_error404.py/n/n\nimport re\nimport tornado\n\nfrom bzs import files\nfrom bzs import const\n\nclass Error404Handler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        try:\n            file_data = files.get_static_data('./static/404.html')\n        except Exception:\n            file_data = '404 Not Found'\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_data)))\n        self.write(file_data)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n/n/n/nbzs/module_files.py/n/n\nimport base64\nimport binascii\nimport cgi\nimport io\nimport json\nimport re\nimport time\nimport tornado\nimport urllib\n\nfrom bzs import const\nfrom bzs import db\nfrom bzs import files\nfrom bzs import preproc\nfrom bzs import users\n\ndef encode_str_to_hexed_b64(data):\n    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')\ndef decode_hexed_b64_to_str(data):\n    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')\n\n################################################################################\n\nclass FilesListHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self, target_path):\n        \"\"\"/files/list/HEXED_BASE64_STRING_OF_PATH/\"\"\"\n        # Another concurrency blob...\n        future = tornado.concurrent.Future()\n\n        def get_final_html_async(target_path):\n            # Getting file template.\n            file_temp = files.get_static_data('./static/files.html')\n\n            # Retrieving list operation target.\n            try:\n                target_path = decode_hexed_b64_to_str(target_path)\n            except:\n                target_path = '/'\n            if not target_path:\n                target_path = '/'\n\n            # Getting hierarchical file path\n            files_hierarchy = target_path.split('/')\n            files_hierarchy_list = list()\n            while '' in files_hierarchy:\n                files_hierarchy.remove('')\n            files_hierarchy = [''] + files_hierarchy\n            files_hierarchy_cwd = ''\n            for i in range(0, len(files_hierarchy)):\n                files_hierarchy[i] += '/'\n                files_hierarchy_cwd += files_hierarchy[i]\n                files_hierarchy_list.append(dict(\n                    folder_name=files_hierarchy[i],\n                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),\n                    disabled=(i == len(files_hierarchy) - 1)))\n                continue\n\n            # Getting current directory content\n            files_attrib_list = list()\n            for f_handle in db.Filesystem.listdir(target_path):\n                # try:\n                    file_name = f_handle['file-name']\n                    actual_path = target_path + file_name\n                    attrib = dict()\n                    attrib['file-name'] = file_name\n                    attrib['file-name-url'] = urllib.parse.quote(file_name)\n                    attrib['file-name-escaped'] = cgi.escape(file_name)\n                    attrib['size'] = f_handle['file-size']\n                    attrib['size-str'] = files.format_file_size(attrib['size'])\n                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!\n                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))\n                    # Encoding MIME types\n                    if f_handle['is-dir']:\n                        attrib['mime-type'] = 'directory/folder'\n                    else:\n                        attrib['mime-type'] = files.guess_mime_type(file_name)\n                    # Encoding hyperlinks\n                    if attrib['mime-type'] == 'directory/folder':\n                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')\n                    else:\n                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])\n                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)\n                    files_attrib_list.append(attrib)\n                # except Exception:\n                #     pass\n            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)\n\n            # File actually exists, sending data\n            working_user = users.get_user_by_cookie(\n                self.get_cookie('user_active_login', default=''))\n            file_temp = preproc.preprocess_webpage(file_temp, working_user,\n                files_attrib_list=files_attrib_list,\n                files_hierarchy_list=files_hierarchy_list,\n                cwd_uuid=cwd_uuid)\n            future.set_result(file_temp)\n        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,\n            target_path)\n        file_temp = yield future\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_temp)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        # Push result to client in one blob\n        self.write(file_temp)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n\n################################################################################\n\nclass FilesDownloadHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self, file_path, file_name):\n        \"\"\"/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME\"\"\"\n        # Something that I do not wish to write too many times..\n        def invoke_404():\n            self.set_status(404, \"Not Found\")\n            self.add_header('Content-Length', '0')\n            self.flush()\n            return\n\n        # Get file location (exactly...)\n        try:\n            file_path = decode_hexed_b64_to_str(file_path)\n        except Exception:\n            file_path = ''\n        if not file_path:\n            invoke_404()\n            return\n\n        # Asynchronous web request...\n        file_block_size = 64 * 1024 # 64 KiB / Chunk\n        file_block = bytes()\n        file_data = None\n\n        future = tornado.concurrent.Future()\n        def inquire_data_async():\n            _tf_data = db.Filesystem.get_content(file_path)\n            future.set_result(_tf_data)\n        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)\n        file_data = yield future\n        file_stream = io.BytesIO(file_data)\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'application/x-download')\n        self.add_header('Content-Length', str(len(file_data)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        while file_stream.tell() < len(file_data):\n            byte_pos = file_stream.tell()\n            # Entry to the concurrency worker\n            future = tornado.concurrent.Future()\n            # Concurrent worker\n            def retrieve_data_async():\n                block = file_stream.read(file_block_size)\n                future.set_result(block)\n            # Injection and pending\n            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)\n            # Reset or read\n            file_block = yield future\n            self.write(file_block)\n            file_block = None\n            self.flush()\n        file_block = None\n        self.finish()\n\n        # Release memory...\n        file_stream = None\n        file_data = None\n        return self\n\n    head=get\n    pass\n\n################################################################################\n\nclass FilesOperationHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['POST']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def post(self):\n        \"\"\"/files/operation/\"\"\"\n        # Another concurrency blob...\n        future = tornado.concurrent.Future()\n\n        def get_final_html_async():\n            operation_content_raw = self.request.body\n            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))\n            action = operation_content['action']\n            sources = operation_content['source']\n            if type(sources) == list:\n                for i in range(0, len(sources)):\n                    try:\n                        sources[i] = decode_hexed_b64_to_str(sources[i])\n                    except:\n                        pass\n            else:\n                sources = decode_hexed_b64_to_str(sources)\n            if action in ['copy', 'move']:\n                try:\n                    target = decode_hexed_b64_to_str(operation_content['target'])\n                except:\n                    target = '/'\n            elif action in ['rename', 'new-folder']:\n                try:\n                    target = operation_content['target']\n                except:\n                    target = sources # I am not handling more exceptions as this is brutal enough\n            # Done assigning values, now attempting to perform operation\n            if action == 'copy':\n                for source in sources:\n                    db.Filesystem.copy(source, target, new_owner='user-cp')\n            elif action == 'move':\n                for source in sources:\n                    db.Filesystem.move(source, target)\n            elif action == 'delete':\n                for source in sources:\n                    db.Filesystem.remove(source)\n            elif action == 'rename':\n                db.Filesystem.rename(sources, target)\n            elif action == 'new-folder':\n                db.Filesystem.mkdir(sources, target, 'user-nf')\n            future.set_result('')\n        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)\n        file_temp = yield future\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_temp)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        # Push result to client in one blob\n        self.write(file_temp)\n        self.flush()\n        self.finish()\n        return self\n    pass\n\n################################################################################\n\nclass FilesUploadHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['POST']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def post(self, target_path, file_name):\n        \"\"\"/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME\"\"\"\n        # Another concurrency blob...\n        future = tornado.concurrent.Future()\n        working_user = users.get_user_by_cookie(\n            self.get_cookie('user_active_login', default=''))\n\n        def save_file_async(alter_ego, target_path, file_name, working_user):\n            upload_data = alter_ego.request.body\n            # Crucial, to release data.\n            alter_ego.request.body = None\n            target_path = decode_hexed_b64_to_str(target_path)\n            # Committing changes to database\n            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)\n            # Final return\n            future.set_result('bzs_upload_success')\n        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,\n            self, target_path, file_name, working_user)\n\n        response_temp = yield future\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(response_temp)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        # Push result to client in one blob\n        self.write(response_temp)\n        self.flush()\n        self.finish()\n        return self\n    pass\n/n/n/nbzs/module_home.py/n/n\nimport re\nimport tornado\n\nfrom bzs import files\nfrom bzs import const\nfrom bzs import users\nfrom bzs import preproc\n\nclass HomeHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        # In case it does not exist.\n        try:\n            future = tornado.concurrent.Future()\n            def get_index_html_async():\n                file_data = files.get_static_data('./static/home.html')\n                working_user = users.get_user_by_cookie(\n                    self.get_cookie('user_active_login', default=''))\n                file_data = preproc.preprocess_webpage(file_data, working_user)\n                future.set_result(file_data)\n            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)\n            file_data = yield future\n        except Exception:\n            self.set_status(404, \"Not Found\")\n            self.add_header('Content-Length', '0')\n            self.flush()\n            return None\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_data)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        # Push result to client in one blob\n        self.write(file_data)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n/n/n/nbzs/module_index.py/n/n\nimport re\nimport tornado\n\nfrom bzs import files\nfrom bzs import const\nfrom bzs import users\nfrom bzs import preproc\n\nclass MainframeHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        # In case it does not exist.\n        try:\n            future = tornado.concurrent.Future()\n            def get_index_html_async():\n                file_data = files.get_static_data('./static/index.html')\n                working_user = users.get_user_by_cookie(\n                    self.get_cookie('user_active_login', default=''))\n                file_data = preproc.preprocess_webpage(file_data, working_user)\n                future.set_result(file_data)\n            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)\n            file_data = yield future\n        except Exception:\n            print(Exception)\n            self.set_status(404, \"Not Found\")\n            self.add_header('Content-Length', '0')\n            self.flush()\n            return None\n\n        # File actually exists, sending data\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_data)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        # Push result to client in one blob\n        self.write(file_data)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n/n/n/nbzs/module_static.py/n/n\nimport re\nimport tornado\n\nfrom bzs import files\nfrom bzs import const\n\nclass StaticHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self, file_path):\n        \"\"\"/static/PATH\"\"\"\n        file_path = './static/' + file_path\n        # In case it does not exist.\n        try:\n            future = tornado.concurrent.Future()\n            def get_file_data_async():\n                file_data = files.get_static_data(file_path)\n                future.set_result(file_data)\n            tornado.ioloop.IOLoop.instance().add_callback(get_file_data_async)\n            file_data = yield future\n        except Exception:\n            self.set_status(404, \"Not Found\")\n            self._headers = tornado.httputil.HTTPHeaders()\n            self.add_header('Content-Length', '0')\n            self.flush()\n            return None\n\n        # File actually exists, sending data\n        self.set_status(200, \"OK\")\n        self._headers = tornado.httputil.HTTPHeaders()\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', files.guess_mime_type(file_path))\n        self.add_header('Content-Length', str(len(file_data)))\n        self.xsrf_form_html() # Prefent CSRF attacks\n\n        # Push result to client in one blob\n        self.write(file_data)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n/n/n/n", "label": 0}, {"id": "ae7e50d52016e4c9471e39bb4ac03b4c7dfe33bb", "code": "/bzs/core.py/n/n\nimport socket\nimport threading\nimport tornado\n\nimport tornado.concurrent\nimport tornado.httputil\nimport tornado.httpserver\nimport tornado.gen\nimport tornado.ioloop\nimport tornado.process\nimport tornado.web\n\nfrom bzs import const\nfrom bzs import db\nfrom bzs import files\n\nfrom bzs import module_error404\nfrom bzs import module_files\nfrom bzs import module_home\nfrom bzs import module_index\nfrom bzs import module_static\n\nWEB_PORT = 80\n\ndef main():\n    # Creating web application\n    web_app = tornado.web.Application([\n            (r'^/$', module_index.MainframeHandler),\n            (r'/static/.*', module_static.StaticHandler),\n            # (r'/static/(.*)', tornado.web.StaticFileHandler, {\n            #     \"path\": \"./static/\" # Optimized static file handler with cache\n            # }),\n            (r'^/home', module_home.HomeHandler),\n            (r'^/files/?()$', module_files.FilesListHandler),\n            (r'^/files/list/(.*)', module_files.FilesListHandler),\n            (r'^/files/download/(.*)/(.*)/?$', module_files.FilesDownloadHandler),\n            (r'^/files/upload/(.*)/(.*)$', module_files.FilesUploadHandler),\n            (r'^/files/operation/?', module_files.FilesOperationHandler),\n            (r'.*', module_error404.Error404Handler)\n        ],\n        xsrf_cookies=False # True to prevent CSRF third party attacks\n    )\n    # Starting server\n    web_sockets = tornado.netutil.bind_sockets(\n        const.get_const('server-port'),\n        family=socket.AF_INET)\n    if const.get_const('server-threads') > 1:\n        if hasattr(os, 'fork'):\n            # os.fork() operation unavailable on Windows.\n            tornado.process.fork_processes(const.get_const('server-threads') - 1)\n    web_server = tornado.httpserver.HTTPServer(web_app, xheaders=True)\n    web_server.add_sockets(web_sockets)\n    # Boot I/O thread for asynchronous purposes\n    tornado.ioloop.IOLoop.instance().start()\n    return\n/n/n/n/bzs/module_error404.py/n/n\nimport re\nimport tornado\n\nfrom bzs import files\nfrom bzs import const\n\nclass Error404Handler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        try:\n            file_data = files.get_static_data('./static/404.html')\n        except Exception:\n            file_data = '404 Not Found'\n        self.set_status(200, \"OK\")\n        self._headers = tornado.httputil.HTTPHeaders()\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_data)))\n        self.write(file_data)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n/n/n/n/bzs/module_files.py/n/n\nimport base64\nimport binascii\nimport cgi\nimport io\nimport json\nimport re\nimport time\nimport tornado\nimport urllib\n\nfrom bzs import const\nfrom bzs import db\nfrom bzs import files\nfrom bzs import preproc\nfrom bzs import users\n\ndef encode_str_to_hexed_b64(data):\n    return binascii.b2a_hex(base64.b64encode(data.encode('utf-8'))).decode('utf-8')\ndef decode_hexed_b64_to_str(data):\n    return base64.b64decode(binascii.unhexlify(data.encode('utf-8'))).decode('utf-8')\n\n################################################################################\n\nclass FilesListHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self, target_path):\n        \"\"\"/files/list/HEXED_BASE64_STRING_OF_PATH/\"\"\"\n        # Another concurrency blob...\n        future = tornado.concurrent.Future()\n\n        def get_final_html_async(target_path):\n            # Getting file template.\n            file_temp = files.get_static_data('./static/files.html')\n\n            # Retrieving list operation target.\n            try:\n                target_path = decode_hexed_b64_to_str(target_path)\n            except:\n                target_path = '/'\n            if not target_path:\n                target_path = '/'\n\n            # Getting hierarchical file path\n            files_hierarchy = target_path.split('/')\n            files_hierarchy_list = list()\n            while '' in files_hierarchy:\n                files_hierarchy.remove('')\n            files_hierarchy = [''] + files_hierarchy\n            files_hierarchy_cwd = ''\n            for i in range(0, len(files_hierarchy)):\n                files_hierarchy[i] += '/'\n                files_hierarchy_cwd += files_hierarchy[i]\n                files_hierarchy_list.append(dict(\n                    folder_name=files_hierarchy[i],\n                    href_path='/files/list/%s' % encode_str_to_hexed_b64(files_hierarchy_cwd),\n                    disabled=(i == len(files_hierarchy) - 1)))\n                continue\n\n            # Getting current directory content\n            files_attrib_list = list()\n            for f_handle in db.Filesystem.listdir(target_path):\n                # try:\n                    file_name = f_handle['file-name']\n                    actual_path = target_path + file_name\n                    attrib = dict()\n                    attrib['file-name'] = file_name\n                    attrib['file-name-url'] = urllib.parse.quote(file_name)\n                    attrib['file-name-escaped'] = cgi.escape(file_name)\n                    attrib['size'] = f_handle['file-size']\n                    attrib['size-str'] = files.format_file_size(attrib['size'])\n                    attrib['owner'] = f_handle['owner'] # FIXME: DO NOT USE HANDLE, USE NAME!\n                    attrib['date-uploaded'] = time.strftime(const.get_const('time-format'), time.localtime(f_handle['upload-time']))\n                    # Encoding MIME types\n                    if f_handle['is-dir']:\n                        attrib['mime-type'] = 'directory/folder'\n                    else:\n                        attrib['mime-type'] = files.guess_mime_type(file_name)\n                    # Encoding hyperlinks\n                    if attrib['mime-type'] == 'directory/folder':\n                        attrib['target-link'] = '/files/list/%s' % encode_str_to_hexed_b64(actual_path + '/')\n                    else:\n                        attrib['target-link'] = '/files/download/%s/%s' % (encode_str_to_hexed_b64(actual_path), attrib['file-name-url'])\n                    attrib['uuid'] = encode_str_to_hexed_b64(actual_path)\n                    files_attrib_list.append(attrib)\n                # except Exception:\n                #     pass\n            cwd_uuid = encode_str_to_hexed_b64(files_hierarchy_cwd)\n\n            # File actually exists, sending data\n            working_user = users.get_user_by_cookie(\n                self.get_cookie('user_active_login', default=''))\n            file_temp = preproc.preprocess_webpage(file_temp, working_user,\n                files_attrib_list=files_attrib_list,\n                files_hierarchy_list=files_hierarchy_list,\n                cwd_uuid=cwd_uuid)\n            future.set_result(file_temp)\n        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async,\n            target_path)\n        file_temp = yield future\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_temp)))\n        self.write(file_temp)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n\n################################################################################\n\nclass FilesDownloadHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self, file_path, file_name):\n        \"\"\"/files/download/HEXED_BASE64_STRING_OF_PATH/ACTUAL_FILENAME\"\"\"\n        # Something that I do not wish to write too many times..\n        def invoke_404():\n            self.set_status(404, \"Not Found\")\n            self._headers = tornado.httputil.HTTPHeaders()\n            self.add_header('Content-Length', '0')\n            self.flush()\n            return\n\n        # Get file location (exactly...)\n        try:\n            file_path = decode_hexed_b64_to_str(file_path)\n        except Exception:\n            file_path = ''\n        if not file_path:\n            invoke_404()\n            return\n\n        # Asynchronous web request...\n        file_block_size = 64 * 1024 # 64 KiB / Chunk\n        file_block = bytes()\n        file_data = None\n\n        future = tornado.concurrent.Future()\n        def inquire_data_async():\n            _tf_data = db.Filesystem.get_content(file_path)\n            future.set_result(_tf_data)\n        tornado.ioloop.IOLoop.instance().add_callback(inquire_data_async)\n        file_data = yield future\n        file_stream = io.BytesIO(file_data)\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'application/x-download')\n        self.add_header('Content-Length', str(len(file_data)))\n\n        while file_stream.tell() < len(file_data):\n            byte_pos = file_stream.tell()\n            # Entry to the concurrency worker\n            future = tornado.concurrent.Future()\n            # Concurrent worker\n            def retrieve_data_async():\n                block = file_stream.read(file_block_size)\n                future.set_result(block)\n            # Injection and pending\n            tornado.ioloop.IOLoop.instance().add_callback(retrieve_data_async)\n            # Reset or read\n            file_block = yield future\n            self.write(file_block)\n            file_block = None\n            self.flush()\n        file_block = None\n        self.finish()\n\n        # Release memory...\n        file_stream = None\n        file_data = None\n        return self\n\n    head=get\n    pass\n\n################################################################################\n\nclass FilesOperationHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['POST']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def post(self):\n        \"\"\"/files/operation/\"\"\"\n        # Another concurrency blob...\n        future = tornado.concurrent.Future()\n\n        def get_final_html_async():\n            operation_content_raw = self.request.body\n            operation_content = json.loads(operation_content_raw.decode('utf-8', 'ignore'))\n            action = operation_content['action']\n            sources = operation_content['source']\n            if type(sources) == list:\n                for i in range(0, len(sources)):\n                    try:\n                        sources[i] = decode_hexed_b64_to_str(sources[i])\n                    except:\n                        pass\n            else:\n                sources = decode_hexed_b64_to_str(sources)\n            if action in ['copy', 'move']:\n                try:\n                    target = decode_hexed_b64_to_str(operation_content['target'])\n                except:\n                    target = '/'\n            elif action in ['rename', 'new-folder']:\n                try:\n                    target = operation_content['target']\n                except:\n                    target = sources # I am not handling more exceptions as this is brutal enough\n            # Done assigning values, now attempting to perform operation\n            if action == 'copy':\n                for source in sources:\n                    db.Filesystem.copy(source, target, new_owner='user-cp')\n            elif action == 'move':\n                for source in sources:\n                    db.Filesystem.move(source, target)\n            elif action == 'delete':\n                for source in sources:\n                    db.Filesystem.remove(source)\n            elif action == 'rename':\n                db.Filesystem.rename(sources, target)\n            elif action == 'new-folder':\n                db.Filesystem.mkdir(sources, target, 'user-nf')\n            future.set_result('')\n        tornado.ioloop.IOLoop.instance().add_callback(get_final_html_async)\n        file_temp = yield future\n\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_temp)))\n        self.write(file_temp)\n        self.flush()\n        self.finish()\n        return self\n    pass\n\n################################################################################\n\nclass FilesUploadHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['POST']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def post(self, target_path, file_name):\n        \"\"\"/files/upload/HEXED_BASE64_STRING_OF_PATH_OF_PARENT/ACTUAL_FILENAME\"\"\"\n        # Another concurrency blob...\n        future = tornado.concurrent.Future()\n        working_user = users.get_user_by_cookie(\n            self.get_cookie('user_active_login', default=''))\n\n        def save_file_async(alter_ego, target_path, file_name, working_user):\n            upload_data = alter_ego.request.body\n            # Crucial, to release data.\n            alter_ego.request.body = None\n            target_path = decode_hexed_b64_to_str(target_path)\n            # Committing changes to database\n            db.Filesystem.mkfile(target_path, file_name, working_user.username, upload_data)\n            # Final return\n            future.set_result('bzs_upload_success')\n        tornado.ioloop.IOLoop.instance().add_callback(save_file_async,\n            self, target_path, file_name, working_user)\n\n        response_temp = yield future\n        self.set_status(200, \"OK\")\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(response_temp)))\n        self.write(response_temp)\n        self.flush()\n        self.finish()\n        return self\n    pass\n/n/n/n/bzs/module_home.py/n/n\nimport re\nimport tornado\n\nfrom bzs import files\nfrom bzs import const\nfrom bzs import users\nfrom bzs import preproc\n\nclass HomeHandler(tornado.web.RequestHandler):\n    SUPPORTED_METHODS = ['GET', 'HEAD']\n\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        # In case it does not exist.\n        try:\n            future = tornado.concurrent.Future()\n            def get_index_html_async():\n                file_data = files.get_static_data('./static/home.html')\n                working_user = users.get_user_by_cookie(\n                    self.get_cookie('user_active_login', default=''))\n                file_data = preproc.preprocess_webpage(file_data, working_user)\n                future.set_result(file_data)\n            tornado.ioloop.IOLoop.instance().add_callback(get_index_html_async)\n            file_data = yield future\n        except Exception:\n            self.set_status(404, \"Not Found\")\n            self._headers = tornado.httputil.HTTPHeaders()\n            self.add_header('Content-Length', '0')\n            self.flush()\n            return None\n\n        self.set_status(200, \"OK\")\n        self._headers = tornado.httputil.HTTPHeaders()\n        self.add_header('Cache-Control', 'max-age=0')\n        self.add_header('Connection', 'close')\n        self.add_header('Content-Type', 'text/html')\n        self.add_header('Content-Length', str(len(file_data)))\n        self.write(file_data)\n        self.flush()\n        self.finish()\n        return self\n\n    head=get\n    pass\n/n/n/n", "label": 1}, {"id": "4164d239f0f59b9ef04e3d168e68f958991fe88f", "code": "titlebot.py/n/n#!/usr/bin/env python2\n# coding: utf-8\n\nimport os\nimport sys\nimport socket\nimport string\nimport time\nimport urllib2\nimport HTMLParser\nimport zlib\n\nimport libirc\n\nHOST=\"irc.freenode.net\"\nPORT=6667\nNICK=\"titlebot\"\nIDENT=\"titlebot\"\nREALNAME=\"titlebot\"\nCHANS=[\"##Orz\"]\n\ndef ParseURL(s):\n    http_idx=s.find('http:')\n    https_idx=s.find('https:')\n    if https_idx==-1:\n        if http_idx==-1:\n            return None\n        else:\n            return s[http_idx:]\n    else:\n        if http_idx==-1:\n            return s[https_idx:]\n        else:\n            return s[min(http_idx, https_idx):]\n\ntry:\n    c=libirc.IRCConnection()\n    c.connect((HOST, PORT))\n    c.setnick(NICK)\n    c.setuser(IDENT, REALNAME)\n    for CHAN in CHANS:\n        c.join(CHAN)\nexcept:\n    time.sleep(10)\n    sys.stderr.write(\"Restarting...\\n\")\n    os.execlp(\"python2\", \"python2\", __file__)\n    raise\nCHAN=CHANS[0]\nsocket.setdefaulttimeout(10)\n\nhtml_parser=HTMLParser.HTMLParser()\n\nquiting=False\nwhile not quiting:\n    if not c.sock:\n        quiting=True\n        time.sleep(10)\n        sys.stderr.write(\"Restarting...\\n\")\n        os.execlp(\"python2\", \"python2\", __file__)\n        break\n    try:\n        line=c.recvline(block=True)\n        if not line:\n            continue\n        sys.stderr.write(\"%s\\n\" % line.encode('utf-8', 'replace'))\n        line=c.parse(line=line)\n        if line and line[\"cmd\"]==\"PRIVMSG\":\n            if line[\"dest\"]==NICK:\n                if line[\"msg\"]==u\"Get out of this channel!\": # A small hack\n                    c.quit(u\"%s asked to leave.\" % line[\"nick\"])\n                    quiting=True\n            else:\n                CHAN=line[\"dest\"]\n                for w in line[\"msg\"].split():\n                    w=ParseURL(w)\n                    if w:\n                        w=w.split(\">\", 1)[0].split('\"', 1)[0]\n                        if re.match(\"https?:/*git.io(/|$)\", w): # Fix buggy git.io\n                            continue\n                        opener=urllib2.build_opener()\n                        opener.addheaders = [(\"Accept-Charset\", \"utf-8, iso-8859-1\"), (\"Accept-Language\", \"zh-cn, zh-hans, zh-tw, zh-hant, zh, en-us, en-gb, en\"), (\"Range\", \"bytes=0-16383\"), (\"User-Agent\", \"Mozilla/5.0 (compatible; Titlebot; like IRCbot; +https://github.com/m13253/titlebot)\"), (\"X-Forwarded-For\", \"10.2.0.101\"), (\"X-moz\", \"prefetch\"), (\"X-Prefetch\", \"yes\"), (\"X-Requested-With\", \"Titlebot\")]\n                        h=opener.open(w.encode(\"utf-8\", \"replace\"))\n                        if h.code==200 or h.code==206:\n                            if not \"Content-Type\" in h.info() or h.info()[\"Content-Type\"].split(\";\")[0]==\"text/html\":\n                                wbuf=h.read(16384)\n                                read_times=1\n                                while len(wbuf)<16384 and read_times<4:\n                                    read_times+=1\n                                    wbuf_=h.read(16384)\n                                    if wbuf_:\n                                        wbuf+=wbuf_\n                                    else:\n                                        break\n                                if \"Content-Encoding\" in h.info() and h.info()[\"Content-Encoding\"]==\"gzip\": # Fix buggy www.bilibili.tv\n                                    try:\n                                        gunzip_obj=zlib.decompressobj(16+zlib.MAX_WBITS)\n                                        wbuf=gunzip_obj.decompress(wbuf)\n                                    except:\n                                        pass\n                                if wbuf.find(\"<title>\")!=-1:\n                                    titleenc=wbuf.split(\"<title>\")[1].split(\"</title>\")[0]\n                                    title=None\n                                    for enc in (\"utf-8\", \"gbk\", \"gb18030\", \"iso-8859-1\"):\n                                        try:\n                                            title=titleenc.decode(enc)\n                                            break\n                                        except UnicodeDecodeError:\n                                            pass\n                                    if title==None:\n                                        title=title.decode(\"utf-8\", \"replace\")\n                                    title=html_parser.unescape(title).replace(\"\\r\", \"\").replace(\"\\n\", \" \").strip()\n                                    c.say(CHAN, u\"\u21ea\u6807\u9898: %s\" % title)\n                                else:\n                                    c.say(CHAN, u\"\u21ea\u65e0\u6807\u9898\u7f51\u9875\")\n                            else:\n                                if \"Content-Range\" in h.info():\n                                    c.say(CHAN, u\"\u21ea\u6587\u4ef6\u7c7b\u578b: %s, \u6587\u4ef6\u5927\u5c0f: %s \u5b57\u8282\\r\\n\" % (h.info()[\"Content-Type\"], h.info()[\"Content-Range\"].split(\"/\")[1]))\n                                elif \"Content-Length\" in h.info():\n                                    c.say(CHAN, u\"\u21ea\u6587\u4ef6\u7c7b\u578b: %s, \u6587\u4ef6\u5927\u5c0f: %s \u5b57\u8282\\r\\n\" % (h.info()[\"Content-Type\"], h.info()[\"Content-Length\"]))\n                                else:\n                                    c.say(CHAN, u\"\u21ea\u6587\u4ef6\u7c7b\u578b: %s\\r\\n\" % h.info()[\"Content-Type\"])\n                        else:\n                            c.say(CHAN, u\"\u21eaHTTP %d \u9519\u8bef\\r\\n\" % h.code)\n    except Exception as e:\n        try:\n            c.say(CHAN, u\"\u54ce\u5440\uff0c%s \u597d\u50cf\u51fa\u4e86\u70b9\u95ee\u9898: %s\" % (NICK, e))\n        except:\n            pass\n    except socket.error as e:\n        sys.stderr.write(\"Error: %s\\n\", e)\n        c.quit(\"Network error.\")\n\n# vim: et ft=python sts=4 sw=4 ts=4\n/n/n/n", "label": 0}, {"id": "4164d239f0f59b9ef04e3d168e68f958991fe88f", "code": "/titlebot.py/n/n#!/usr/bin/env python2\n# coding: utf-8\n\nimport os\nimport sys\nimport socket\nimport string\nimport time\nimport urllib2\nimport HTMLParser\nimport zlib\n\nimport libirc\n\nHOST=\"irc.freenode.net\"\nPORT=6667\nNICK=\"titlebot\"\nIDENT=\"titlebot\"\nREALNAME=\"titlebot\"\nCHANS=[\"##Orz\"]\n\ndef ParseURL(s):\n    http_idx=s.find('http:')\n    https_idx=s.find('https:')\n    if https_idx==-1:\n        if http_idx==-1:\n            return None\n        else:\n            return s[http_idx:]\n    else:\n        if http_idx==-1:\n            return s[https_idx:]\n        else:\n            return s[min(http_idx, https_idx):]\n\ntry:\n    c=libirc.IRCConnection()\n    c.connect((HOST, PORT))\n    c.setnick(NICK)\n    c.setuser(IDENT, REALNAME)\n    for CHAN in CHANS:\n        c.join(CHAN)\nexcept:\n    time.sleep(10)\n    sys.stderr.write(\"Restarting...\\n\")\n    os.execlp(\"python2\", \"python2\", __file__)\n    raise\nCHAN=CHANS[0]\nsocket.setdefaulttimeout(10)\n\nhtml_parser=HTMLParser.HTMLParser()\n\nquiting=False\nwhile not quiting:\n    if not c.sock:\n        quiting=True\n        time.sleep(10)\n        sys.stderr.write(\"Restarting...\\n\")\n        os.execlp(\"python2\", \"python2\", __file__)\n        break\n    try:\n        line=c.recvline(block=True)\n        if not line:\n            continue\n        sys.stderr.write(\"%s\\n\" % line.encode('utf-8', 'replace'))\n        line=c.parse(line=line)\n        if line and line[\"cmd\"]==\"PRIVMSG\":\n            if line[\"dest\"]==NICK:\n                if line[\"msg\"]==u\"Get out of this channel!\": # A small hack\n                    c.quit(u\"%s asked to leave.\" % line[\"nick\"])\n                    quiting=True\n            else:\n                CHAN=line[\"dest\"]\n                for w in line[\"msg\"].split():\n                    w=ParseURL(w)\n                    if w:\n                        w=w.split(\">\", 1)[0].split('\"', 1)[0]\n                        if re.match(\"https?:/*git.io(/|$)\", w): # Fix buggy git.io\n                            continue\n                        opener=urllib2.build_opener()\n                        opener.addheaders = [(\"Accept-Charset\", \"utf-8, iso-8859-1\"), (\"Accept-Language\", \"zh-cn, zh-hans, zh-tw, zh-hant, zh, en-us, en-gb, en\"), (\"Range\", \"bytes=0-16383\"), (\"User-Agent\", \"Mozilla/5.0 (compatible; Titlebot; like IRCbot; +https://github.com/m13253/titlebot)\"), (\"X-Forwarded-For\", \"10.2.0.101\"), (\"X-moz\", \"prefetch\"), (\"X-Prefetch\", \"yes\")]\n                        h=opener.open(w.encode(\"utf-8\", \"replace\"))\n                        if h.code==200 or h.code==206:\n                            if not \"Content-Type\" in h.info() or h.info()[\"Content-Type\"].split(\";\")[0]==\"text/html\":\n                                wbuf=h.read(16384)\n                                read_times=1\n                                while len(wbuf)<16384 and read_times<4:\n                                    read_times+=1\n                                    wbuf_=h.read(16384)\n                                    if wbuf_:\n                                        wbuf+=wbuf_\n                                    else:\n                                        break\n                                if \"Content-Encoding\" in h.info() and h.info()[\"Content-Encoding\"]==\"gzip\": # Fix buggy www.bilibili.tv\n                                    try:\n                                        gunzip_obj=zlib.decompressobj(16+zlib.MAX_WBITS)\n                                        wbuf=gunzip_obj.decompress(wbuf)\n                                    except:\n                                        pass\n                                if wbuf.find(\"<title>\")!=-1:\n                                    titleenc=wbuf.split(\"<title>\")[1].split(\"</title>\")[0]\n                                    title=None\n                                    for enc in (\"utf-8\", \"gbk\", \"gb18030\", \"iso-8859-1\"):\n                                        try:\n                                            title=titleenc.decode(enc)\n                                            break\n                                        except UnicodeDecodeError:\n                                            pass\n                                    if title==None:\n                                        title=title.decode(\"utf-8\", \"replace\")\n                                    title=html_parser.unescape(title).replace(\"\\r\", \"\").replace(\"\\n\", \" \").strip()\n                                    c.say(CHAN, u\"\u21ea\u6807\u9898: %s\" % title)\n                                else:\n                                    c.say(CHAN, u\"\u21ea\u65e0\u6807\u9898\u7f51\u9875\")\n                            else:\n                                if \"Content-Range\" in h.info():\n                                    c.say(CHAN, u\"\u21ea\u6587\u4ef6\u7c7b\u578b: %s, \u6587\u4ef6\u5927\u5c0f: %s \u5b57\u8282\\r\\n\" % (h.info()[\"Content-Type\"], h.info()[\"Content-Range\"].split(\"/\")[1]))\n                                elif \"Content-Length\" in h.info():\n                                    c.say(CHAN, u\"\u21ea\u6587\u4ef6\u7c7b\u578b: %s, \u6587\u4ef6\u5927\u5c0f: %s \u5b57\u8282\\r\\n\" % (h.info()[\"Content-Type\"], h.info()[\"Content-Length\"]))\n                                else:\n                                    c.say(CHAN, u\"\u21ea\u6587\u4ef6\u7c7b\u578b: %s\\r\\n\" % h.info()[\"Content-Type\"])\n                        else:\n                            c.say(CHAN, u\"\u21eaHTTP %d \u9519\u8bef\\r\\n\" % h.code)\n    except Exception as e:\n        try:\n            c.say(CHAN, u\"\u54ce\u5440\uff0c%s \u597d\u50cf\u51fa\u4e86\u70b9\u95ee\u9898: %s\" % (NICK, e))\n        except:\n            pass\n    except socket.error as e:\n        sys.stderr.write(\"Error: %s\\n\", e)\n        c.quit(\"Network error.\")\n\n# vim: et ft=python sts=4 sw=4 ts=4\n/n/n/n", "label": 1}, {"id": "3d7fb2f1011883da7b627693e001b132bdebf4ea", "code": "aeoid/handlers.py/n/n#!/usr/bin/env python\n#\n# Copyright 2007 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nimport logging\nimport os\n\nfrom google.appengine.ext import webapp\nfrom google.appengine.ext.webapp import template\nfrom openid.consumer.consumer import Consumer\nfrom openid.consumer.discover import DiscoveryFailure\nfrom openid.extensions import sreg\nfrom openid.extensions import ax\n\nfrom aeoid import store\nfrom aeoid import users\n\n\nclass BaseHandler(webapp.RequestHandler):\n  def initialize(self, request, response):\n    super(BaseHandler, self).initialize(request, response)\n    self.session = self.request.environ.get('aeoid.beaker.session')\n\n  def render_template(self, filename, template_args=None):\n    if not template_args:\n      template_args = {}\n    path = os.path.join(os.path.dirname(__file__), 'templates', filename)\n    self.response.out.write(template.render(path, template_args))\n\n  def get_consumer(self):\n    return Consumer(self.session, store.AppEngineStore())\n\n\nclass BeginLoginHandler(BaseHandler):\n  def get(self):\n    openid_url = self.request.get('openid_url')\n    if not openid_url:\n      self.render_template('login.html', {\n          'login_url': users.OPENID_LOGIN_PATH,\n          'continue': self.request.get('continue', '/')\n      })\n      return\n\n    try:\n      consumer = self.get_consumer()\n      request = consumer.begin(openid_url)\n\t\t\t\n      # TODO: Support custom specification of extensions\n      # TODO: Don't ask for data we already have, perhaps?\n      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    \n      ax_req = ax.FetchRequest()\n      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))\n      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))\n      request.addExtension(ax_req)\n      \n      continue_url = self.request.get('continue', '/')\n      return_to = \"%s%s?continue=%s\" % (self.request.host_url,\n                                        users.OPENID_FINISH_PATH, continue_url)\n      self.redirect(request.redirectURL(self.request.host_url, return_to))\n      self.session.save()\n    except DiscoveryFailure, ex:\n      logging.error(\"Unexpected error in OpenID authentication: %s\" % ex)\n      self.render_template('error.html', {'identity_url': openid_url})\n\n\n  def post(self):\n    self.get()\n\n\nclass FinishLoginHandler(BaseHandler):\n  def finish_login(self, response):\n    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}\n    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)\n    #if ax_fetch:\n    #  ax_data = ax_fetch.getExtensionArgs();\n    #else:\n    #  ax_data = {}\n      \n    #for k, v in ax_data.items():\n    #  logging.info(\"key: \" + k + \", value: \" + v)\n    \n    #user_info = users.UserInfo.update_or_insert(\n    #    response.endpoint.claimed_id,\n    #    server_url=response.endpoint.server_url,\n    #    **dict(sreg_data))\n\n    ax_data = {}\n    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)\n    if ax_fetch:\n      args = ax_fetch.getExtensionArgs()\n      i = 0\n      while \"type.ext%i\" % i in args:\n        t = args[\"type.ext%i\" % i]\n        logging.info(\"type: %s\" % t)\n        if t == \"http://axschema.org/namePerson/first\":\n          p = \"nickname\"\n        elif t == \"http://axschema.org/contact/email\":\n          p = \"email\"\n        else:\n          p = \"unknown\"\n        ax_data[p] = args[\"value.ext%i.1\" % i]\n        i = i + 1\n\n    res_data = {}\n    res_data.update(sreg_data)\n    res_data.update(ax_data)\n    \n    user_info = users.UserInfo.update_or_insert(\n        response.endpoint.claimed_id,\n        server_url=response.endpoint.server_url,\n        **dict(res_data))\n    \n    self.session['aeoid.user'] = str(user_info.key())\n    self.session.save()\n    users._current_user = users.User(None, _from_model_key=user_info.key(),\n                                     _from_model=user_info)\n    self.redirect(self.request.get('continue', '/'))\n\n  def get(self):\n    consumer = self.get_consumer()\n    response = consumer.complete(self.request.GET, self.request.url)\n    if response.status == 'success':\n      self.finish_login(response)\n    elif response.status in ('failure', 'cancel'):\n      self.render_template('failure.html', {\n          'response': response,\n          'login_url': users.OPENID_LOGIN_PATH,\n          'continue': self.request.get('continue', '/')\n      })\n    else:\n      logging.error(\"Unexpected error in OpenID authentication: %s\", response)\n      self.render_template('error.html', {'identity_url': response.identity_url()})\n\n\nclass LogoutHandler(BaseHandler):\n  def get(self):\n    # before logging user out, check that http referer contains the current hostname\n    httphost = str(self.request.environ.get('HTTP_HOST'))\n    httprefer = str(self.request.environ.get('HTTP_REFERER'))\n    # if it does, log them out as expected\n    if httprefer.startswith(('http://'+httphost,'https://'+httphost)):\n      if 'aeoid.user' in self.session:\n        del self.session['aeoid.user']\n      self.session.save()\n      self.redirect(self.request.get('continue', '/'))\n    # if it doesn't, prompt them via an interstitial page\n    else:\n      self.render_template('logout.html', {\n          'confirmurl': '?continue='+self.request.get('continue', '/'),\n          'cancelurl': self.request.get('continue', '/')\n      })\n\n\n# highly modified from example at:\n# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/\nclass StaticHandler(webapp.RequestHandler):\n  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }\n  \n  def get(self, filepath, fileext):\n    # build full system path to requested file\n    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )\n    \n    # only allow specified file extensions\n    if not self.allowed_exts.has_key(fileext):\n      logging.error(\"Not an allowed file extension: %s\" % fileext)\n      self.error(404)\n      return\n    \n    # file must exist before we can return it\n    if not os.path.isfile(resourcepath):\n      logging.error(\"Not an existing file: '%s'\" % resourcepath)\n      self.error(404)\n      return\n    \n    # only allow absolute paths (no symlinks or up-level references, for example)\n    testpath = os.path.normcase(resourcepath)\n    if testpath != os.path.abspath(testpath):\n      logging.error(\"Not an absolute path to file: '%s' != '%s'\" % (testpath, os.path.abspath(testpath)) )\n      self.error(403)\n      return\n    \n    # set appropriate content-type\n    self.response.headers['Content-Type'] = self.allowed_exts[fileext]\n    \n    # serve file (supporting client-side caching)\n    try:\n      import datetime\n      fileinfo = os.stat(resourcepath)\n      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])\n      if self.request.headers.has_key('If-Modified-Since'):\n        dt = self.request.headers.get('If-Modified-Since').split(';')[0]\n        modsince = datetime.datetime.strptime(dt, \"%a, %d %b %Y %H:%M:%S %Z\")\n        if modsince >= lastmod:\n        # The file is older than the cached copy (or exactly the same)\n          self.error(304)\n          return\n        else:\n        # The file is newer\n          self.output_file(resourcepath, lastmod)\n      else:\n        self.output_file(resourcepath, lastmod)\n    except Exception, e:\n      logging.error(\"Failed to serve file: %s\" % e)\n      self.error(404)\n      return\n\n  def output_file(self, resourcepath, lastmod):\n    import datetime\n    try:\n      self.response.headers['Cache-Control']='public, max-age=31536000'\n      self.response.headers['Last-Modified'] = lastmod.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n      expires=lastmod+datetime.timedelta(days=365)\n      self.response.headers['Expires'] = expires.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n      self.response.out.write( file(resourcepath, 'rb').read() )\n      return\n    except IOError, e:\n      logging.error(\"Failed to output file: %s\" % e)\n      self.error(404)\n      return\n\n\nhandler_map = [\n    (users.OPENID_LOGIN_PATH, BeginLoginHandler),\n    (users.OPENID_FINISH_PATH, FinishLoginHandler),\n    (users.OPENID_LOGOUT_PATH, LogoutHandler),\n    (users.OPENID_STATIC_PATH, StaticHandler),\n]\n/n/n/n", "label": 0}, {"id": "3d7fb2f1011883da7b627693e001b132bdebf4ea", "code": "/aeoid/handlers.py/n/n#!/usr/bin/env python\n#\n# Copyright 2007 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nimport logging\nimport os\n\nfrom google.appengine.ext import webapp\nfrom google.appengine.ext.webapp import template\nfrom openid.consumer.consumer import Consumer\nfrom openid.consumer.discover import DiscoveryFailure\nfrom openid.extensions import sreg\nfrom openid.extensions import ax\n\nfrom aeoid import store\nfrom aeoid import users\n\n\nclass BaseHandler(webapp.RequestHandler):\n  def initialize(self, request, response):\n    super(BaseHandler, self).initialize(request, response)\n    self.session = self.request.environ.get('aeoid.beaker.session')\n\n  def render_template(self, filename, template_args=None):\n    if not template_args:\n      template_args = {}\n    path = os.path.join(os.path.dirname(__file__), 'templates', filename)\n    self.response.out.write(template.render(path, template_args))\n\n  def get_consumer(self):\n    return Consumer(self.session, store.AppEngineStore())\n\n\nclass BeginLoginHandler(BaseHandler):\n  def get(self):\n    openid_url = self.request.get('openid_url')\n    if not openid_url:\n      self.render_template('login.html', {\n          'login_url': users.OPENID_LOGIN_PATH,\n          'continue': self.request.get('continue', '/')\n      })\n      return\n\n    try:\n      consumer = self.get_consumer()\n      request = consumer.begin(openid_url)\n\t\t\t\n      # TODO: Support custom specification of extensions\n      # TODO: Don't ask for data we already have, perhaps?\n      request.addExtension(sreg.SRegRequest(required=['nickname', 'email']))    \n      ax_req = ax.FetchRequest()\n      ax_req.add(ax.AttrInfo('http://axschema.org/contact/email', alias='email',required=True))\n      ax_req.add(ax.AttrInfo('http://axschema.org/namePerson/first', alias='firstname',required=True))\n      request.addExtension(ax_req)\n      \n      continue_url = self.request.get('continue', '/')\n      return_to = \"%s%s?continue=%s\" % (self.request.host_url,\n                                        users.OPENID_FINISH_PATH, continue_url)\n      self.redirect(request.redirectURL(self.request.host_url, return_to))\n      self.session.save()\n    except DiscoveryFailure, ex:\n      logging.error(\"Unexpected error in OpenID authentication: %s\" % ex)\n      self.render_template('error.html', {'identity_url': openid_url})\n\n\n  def post(self):\n    self.get()\n\n\nclass FinishLoginHandler(BaseHandler):\n  def finish_login(self, response):\n    sreg_data = sreg.SRegResponse.fromSuccessResponse(response) or {}\n    #ax_fetch = ax.FetchResponse.fromSuccessResponse(response)\n    #if ax_fetch:\n    #  ax_data = ax_fetch.getExtensionArgs();\n    #else:\n    #  ax_data = {}\n      \n    #for k, v in ax_data.items():\n    #  logging.info(\"key: \" + k + \", value: \" + v)\n    \n    #user_info = users.UserInfo.update_or_insert(\n    #    response.endpoint.claimed_id,\n    #    server_url=response.endpoint.server_url,\n    #    **dict(sreg_data))\n\n    ax_data = {}\n    ax_fetch = ax.FetchResponse.fromSuccessResponse(response)\n    if ax_fetch:\n      args = ax_fetch.getExtensionArgs()\n      i = 0\n      while \"type.ext%i\" % i in args:\n        t = args[\"type.ext%i\" % i]\n        logging.info(\"type: %s\" % t)\n        if t == \"http://axschema.org/namePerson/first\":\n          p = \"nickname\"\n        elif t == \"http://axschema.org/contact/email\":\n          p = \"email\"\n        else:\n          p = \"unknown\"\n        ax_data[p] = args[\"value.ext%i.1\" % i]\n        i = i + 1\n\n    res_data = {}\n    res_data.update(sreg_data)\n    res_data.update(ax_data)\n    \n    user_info = users.UserInfo.update_or_insert(\n        response.endpoint.claimed_id,\n        server_url=response.endpoint.server_url,\n        **dict(res_data))\n    \n    self.session['aeoid.user'] = str(user_info.key())\n    self.session.save()\n    users._current_user = users.User(None, _from_model_key=user_info.key(),\n                                     _from_model=user_info)\n    self.redirect(self.request.get('continue', '/'))\n\n  def get(self):\n    consumer = self.get_consumer()\n    response = consumer.complete(self.request.GET, self.request.url)\n    if response.status == 'success':\n      self.finish_login(response)\n    elif response.status in ('failure', 'cancel'):\n      self.render_template('failure.html', {\n          'response': response,\n          'login_url': users.OPENID_LOGIN_PATH,\n          'continue': self.request.get('continue', '/')\n      })\n    else:\n      logging.error(\"Unexpected error in OpenID authentication: %s\", response)\n      self.render_template('error.html', {'identity_url': response.identity_url()})\n\n\nclass LogoutHandler(BaseHandler):\n  def get(self):\n    # TODO: Handle the possibility of XSRF forcing a user to log out\n    if 'aeoid.user' in self.session:\n      del self.session['aeoid.user']\n    self.session.save()\n    self.redirect(self.request.get('continue', '/'))\n\n\n# highly modified from example at:\n# http://www.ipsojobs.com/blog/2008/06/17/how-to-create-a-simple-but-powerful-cdn-with-google-app-engine-gae/\nclass StaticHandler(webapp.RequestHandler):\n  allowed_exts = { 'js': 'application/x-javascript', 'css': 'text/css', 'png': 'image/png' }\n  \n  def get(self, filepath, fileext):\n    # build full system path to requested file\n    resourcepath = os.path.join( os.path.dirname(__file__), 'resources', filepath + '.' + fileext )\n    \n    # only allow specified file extensions\n    if not self.allowed_exts.has_key(fileext):\n      logging.error(\"Not an allowed file extension: %s\" % fileext)\n      self.error(404)\n      return\n    \n    # file must exist before we can return it\n    if not os.path.isfile(resourcepath):\n      logging.error(\"Not an existing file: '%s'\" % resourcepath)\n      self.error(404)\n      return\n    \n    # only allow absolute paths (no symlinks or up-level references, for example)\n    testpath = os.path.normcase(resourcepath)\n    if testpath != os.path.abspath(testpath):\n      logging.error(\"Not an absolute path to file: '%s' != '%s'\" % (testpath, os.path.abspath(testpath)) )\n      self.error(403)\n      return\n    \n    # set appropriate content-type\n    self.response.headers['Content-Type'] = self.allowed_exts[fileext]\n    \n    # serve file (supporting client-side caching)\n    try:\n      import datetime\n      fileinfo = os.stat(resourcepath)\n      lastmod = datetime.datetime.fromtimestamp(fileinfo[8])\n      if self.request.headers.has_key('If-Modified-Since'):\n        dt = self.request.headers.get('If-Modified-Since').split(';')[0]\n        modsince = datetime.datetime.strptime(dt, \"%a, %d %b %Y %H:%M:%S %Z\")\n        if modsince >= lastmod:\n        # The file is older than the cached copy (or exactly the same)\n          self.error(304)\n          return\n        else:\n        # The file is newer\n          self.output_file(resourcepath, lastmod)\n      else:\n        self.output_file(resourcepath, lastmod)\n    except Exception, e:\n      logging.error(\"Failed to serve file: %s\" % e)\n      self.error(404)\n      return\n\n  def output_file(self, resourcepath, lastmod):\n    import datetime\n    try:\n      self.response.headers['Cache-Control']='public, max-age=31536000'\n      self.response.headers['Last-Modified'] = lastmod.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n      expires=lastmod+datetime.timedelta(days=365)\n      self.response.headers['Expires'] = expires.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n      self.response.out.write( file(resourcepath, 'rb').read() )\n      return\n    except IOError, e:\n      logging.error(\"Failed to output file: %s\" % e)\n      self.error(404)\n      return\n\n\nhandler_map = [\n    (users.OPENID_LOGIN_PATH, BeginLoginHandler),\n    (users.OPENID_FINISH_PATH, FinishLoginHandler),\n    (users.OPENID_LOGOUT_PATH, LogoutHandler),\n    (users.OPENID_STATIC_PATH, StaticHandler),\n]\n/n/n/n", "label": 1}, {"id": "d81fc3b81a2255ae128c54bf50a83bebc2118439", "code": "app/admin_api_keys.py/n/n#!/usr/bin/python2.7\n# Copyright 2013 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport urllib\n\nfrom google.appengine.ext import db\nfrom google.appengine.api import users\n\nfrom model import Authorization, ApiKeyManagementLog\nimport utils\n\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\n\n\nAPI_KEY_LENGTH = 16\nKEYS_PER_PAGE = 50\n\ndef to_authorization_params(param):\n    param_list = [\n        'contact_name',\n        'contact_email',\n        'organization_name',\n        'domain_write_permission',\n        'read_permission',\n        'full_read_permission',\n        'search_permission',\n        'subscribe_permission',\n        'mark_notes_reviewed',\n        'believed_dead_permission',\n        'stats_permission',\n        'is_valid',\n    ]\n    ret = {}\n    for param_name in param_list:\n        ret[param_name] = getattr(param, param_name)\n    return ret\n\n\nclass ListApiKeys(utils.BaseHandler):\n    \"\"\"\n    A handler for listing API keys for a particular domain.\n    TODO(ryok): implement a search/filter and pagination feature.\n    \"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        user = users.get_current_user()\n        q = Authorization.all().filter('repo =', self.repo or '*')\n        authorizations = q.fetch(KEYS_PER_PAGE)\n        nav_html = ('<a href=\"%s\">%s</a> '\n                    % (self.get_url('admin/api_keys'),\n                       escape(_('Create a new API key'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render('admin_api_keys_list.html',\n                           nav_html=nav_html,\n                           admin_api_keys_url=self.get_url('/admin/api_keys'),\n                           user=user, authorizations=authorizations,\n                           user_email_with_tags=user_email_with_tags,\n                           xsrf_token=xsrf_tool.generate_token(\n                               user.user_id(), 'admin_api_keys'))\n\n\nclass CreateOrUpdateApiKey(utils.BaseHandler):\n    \"\"\"A handler for create/update API keys.\"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    def render_form(self, authorization=None, message=''):\n        \"\"\"Display a form for create/update Authorization\"\"\"\n        user = users.get_current_user()\n        if authorization:\n            operation_name = _('Update an existing key')\n            nav_html = ('<a href=\"%s\">%s</a> '\n                        % (self.get_url('admin/api_keys'),\n                           escape(_('Create a new API key'))))\n        else:\n            authorization = Authorization.DEFAULT_SETTINGS\n            operation_name = _('Create a new API key')\n            nav_html = ''\n\n        nav_html += ('<a href=\"%s\">%s</a>'\n                     % (self.get_url('admin/api_keys/list'),\n                        escape(_('List API keys'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render(\n            'admin_api_keys.html',\n            user=user, target_key=authorization,\n            user_email_with_tags=user_email_with_tags,\n            login_url=users.create_login_url(self.request.url),\n            logout_url=users.create_logout_url(self.request.url),\n            operation_name=operation_name, message=message,\n            nav_html=nav_html,\n            xsrf_token=xsrf_tool.generate_token(\n                user.user_id(), 'admin_api_keys'),\n        )\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        \"\"\"\n        It can be called with a key of ApiKeyManagementLog entity. In\n        such a case, it will show a detailed information of the key in\n        a form for updating the key, otherwise, it will show a form\n        for creating a new API key.\n        \"\"\"\n        management_log_key = self.request.get('log_key')\n        if management_log_key:\n            management_log = db.get(management_log_key)\n            message = ''\n            if management_log.action == ApiKeyManagementLog.CREATE:\n                message = _('A new API key has been created successfully.')\n            elif management_log.action == ApiKeyManagementLog.UPDATE:\n                message = _('The API key has been updated successfully.')\n            return self.render_form(management_log.authorization, message)\n        else:\n            # display a creation form\n            return self.render_form()\n\n    @utils.require_api_key_management_permission\n    def post(self):\n        \"\"\"Handle a post request from the create/update/edit form\"\"\"\n\n        user = users.get_current_user()\n        xsrf_tool = utils.XsrfTool()\n        if not (self.params.xsrf_token and xsrf_tool.verify_token(\n                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):\n            return self.error(403)\n\n        # Handle a form submission from list page\n        if self.request.get('edit_form'):\n            authorization = db.get(self.request.get('authorization_key'))\n            if not authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            return self.render_form(authorization)\n\n        # Handle authorization form submission\n        if not (self.params.contact_name and\n                self.params.contact_email and\n                self.params.organization_name):\n            return self.error(400, _('Please fill in all the required fields.'))\n\n        original_key = self.request.get('key')\n        if original_key:\n            # just override the existing one\n            existing_authorization = db.get(original_key)\n            if not existing_authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            key_str = existing_authorization.api_key\n            action = ApiKeyManagementLog.UPDATE\n        else:\n            key_str = utils.generate_random_key(API_KEY_LENGTH)\n            action = ApiKeyManagementLog.CREATE\n        repo = self.repo or '*'\n\n        authorization = Authorization.create(\n            repo, key_str,\n            **to_authorization_params(self.params))\n        authorization.put()\n\n        management_log = ApiKeyManagementLog(repo=repo,\n                                             api_key=authorization.api_key,\n                                             action=action)\n        management_log.put()\n\n        self.redirect('/admin/api_keys?repo=%s&log_key=%s'\n                      % (self.repo, management_log.key()))\n/n/n/napp/utils.py/n/n#!/usr/bin/python2.7\n# Copyright 2017 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'\n\nfrom django_setup import ugettext as _  # always keep this first\n\nimport calendar\nimport cgi\nfrom datetime import datetime, timedelta\nimport hmac\nimport httplib\nimport logging\nimport os\nimport random\nimport re\nimport string\nimport sys\nimport time\nimport traceback\nimport unicodedata\nimport urllib\nimport urlparse\nimport base64\n\nimport django.utils.html\nfrom django.template.defaulttags import register\nfrom google.appengine.api import images\nfrom google.appengine.api import taskqueue\nfrom google.appengine.api import users\nfrom google.appengine.ext import webapp\nimport google.appengine.ext.webapp.template\nimport google.appengine.ext.webapp.util\nfrom recaptcha.client import captcha\nfrom babel.dates import format_date\nfrom babel.dates import format_datetime\nfrom babel.dates import format_time\nimport babel\n\nimport const\nimport config\nimport model\nimport pfif\nimport resources\n\n# The domain name from which to send e-mail.\nEMAIL_DOMAIN = 'appspotmail.com'  # All apps on appspot.com use this for mail.\n\n# Query parameters which are automatically preserved on page transition\n# if you use utils.BaseHandler.get_url() or\n# env.hidden_input_tags_for_preserved_query_params.\nPRESERVED_QUERY_PARAM_NAMES = ['ui', 'charsets', 'referrer']\n\n@register.filter\ndef get_value(dictionary, key):\n    \"\"\"Django Template filter to get dictionary value based on the given key\"\"\"\n    return dictionary.get(key)\n\n# ==== Field value text ========================================================\n\n\ndef get_person_sex_text(person):\n    \"\"\"Returns the UI text for a person's sex field.\"\"\"\n    return const.PERSON_SEX_TEXT.get(person.sex or '')\n\n\ndef get_note_status_text(note):\n    \"\"\"Returns the UI text for a note's status field.\"\"\"\n    return const.NOTE_STATUS_TEXT.get(note.status or '')\n\n\ndef get_person_status_text(person):\n    \"\"\"Returns the UI text for a person's latest_status.\"\"\"\n    return const.PERSON_STATUS_TEXT.get(person.latest_status or '')\n\n\n# Things that occur as prefixes of global paths (i.e. no repository name).\nGLOBAL_PATH_RE = re.compile(r'^/(global|personfinder)(/?|/.*)$')\n\n\n# ==== String formatting =======================================================\n\n\ndef format_boolean(value):\n    return value and 'true' or 'false'\n\n\ndef format_utc_datetime(dt):\n    if not dt:\n        return ''\n    return dt.replace(microsecond=0).isoformat() + 'Z'\n\n\ndef format_utc_timestamp(timestamp):\n    if not isinstance(timestamp, (int, float)):\n        return ''\n    return format_utc_datetime(datetime.utcfromtimestamp(timestamp))\n\n\ndef format_sitemaps_datetime(dt):\n    integer_dt = datetime(\n        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)\n    return integer_dt.isoformat() + '+00:00'\n\n\ndef encode(string, encoding='utf-8'):\n    \"\"\"If unicode, encode to encoding; if 8-bit string, leave unchanged.\"\"\"\n    if isinstance(string, unicode):\n        string = string.encode(encoding)\n    return string\n\n\ndef urlencode(params, encoding='utf-8'):\n    \"\"\"Encode the key-value pairs in 'params' into a query string, applying\n    the specified encoding to any Unicode strings and ignoring any keys that\n    have value == None.  (urllib.urlencode doesn't support Unicode).\"\"\"\n    keys = params.keys()\n    keys.sort()  # Sort the keys to get canonical ordering\n    return urllib.urlencode([\n        (encode(key, encoding), encode(params[key], encoding))\n        for key in keys if isinstance(params[key], basestring)])\n\n\ndef set_param(params, param, value):\n    \"\"\"Take the params from a urlparse and override one of the values.\"\"\"\n    # This will strip out None-valued params and collapse repeated params.\n    params = dict(cgi.parse_qsl(params))\n    if value is None:\n        if param in params:\n            del(params[param])\n    else:\n        params[param] = value\n    return urlencode(params)\n\n\ndef set_url_param(url, param, value):\n    \"\"\"This modifies a URL setting the given param to the specified value.  This\n    may add the param or override an existing value, or, if the value is None,\n    it will remove the param.  Note that value must be a basestring and can't be\n    an int, for example.\"\"\"\n    url_parts = list(urlparse.urlparse(url))\n    url_parts[4] = set_param(url_parts[4], param, value)\n    return urlparse.urlunparse(url_parts)\n\n\ndef anchor_start(href):\n    \"\"\"Returns the HREF escaped and embedded in an anchor tag.\"\"\"\n    return '<a href=\"%s\">' % django.utils.html.escape(href)\n\n\ndef anchor(href, body):\n    \"\"\"Returns a string anchor HTML element with the given href and body.\"\"\"\n    return anchor_start(href) + django.utils.html.escape(body) + '</a>'\n\n\n# ==== Validators ==============================================================\n\n# These validator functions are used to check and parse query parameters.\n# Each validator should return a parsed, sanitized value, or return a default\n# value, or raise ValueError to display an error message to the user.\n\n\ndef strip(string):\n    # Trailing nulls appear in some strange character encodings like Shift-JIS.\n    return string.strip().rstrip('\\0')\n\n\ndef strip_and_lower(string):\n    return strip(string).lower()\n\n\ndef validate_yes(string):\n    return (strip(string).lower() == 'yes') and 'yes' or ''\n\n\ndef validate_checkbox(string):\n    return (strip(string).lower() == 'on') and 'yes' or ''\n\n\ndef validate_checkbox_as_bool(val):\n    if val.lower() in ['on', 'yes', 'true']:\n        return True\n    return False\n\n\ndef validate_role(string):\n    return (strip(string).lower() == 'provide') and 'provide' or 'seek'\n\n\ndef validate_int(string):\n    return string and int(strip(string))\n\n\ndef validate_sex(string):\n    \"\"\"Validates the 'sex' parameter, returning a canonical value or ''.\"\"\"\n    if string:\n        string = strip(string).lower()\n    return string in pfif.PERSON_SEX_VALUES and string or ''\n\n\ndef validate_expiry(value):\n    \"\"\"Validates that the 'expiry_option' parameter is a positive integer.\n\n    Returns:\n      the int() value if it's present and parses, or the default_expiry_days\n      for the repository, if it's set, otherwise -1 which represents the\n      'unspecified' status.\n    \"\"\"\n    try:\n        value = int(value)\n    except Exception, e:\n        return None\n    return value > 0 and value or None\n\n\nAPPROXIMATE_DATE_RE = re.compile(r'^\\d{4}(-\\d\\d)?(-\\d\\d)?$')\n\n\ndef validate_approximate_date(string):\n    if string:\n        string = strip(string)\n        if APPROXIMATE_DATE_RE.match(string):\n            return string\n    return ''\n\n\nAGE_RE = re.compile(r'^\\d+(-\\d+)?$')\n# Hyphen with possibly surrounding whitespaces.\nHYPHEN_RE = re.compile(\n    ur'\\s*[-\\u2010-\\u2015\\u2212\\u301c\\u30fc\\ufe58\\ufe63\\uff0d]\\s*',\n    re.UNICODE)\n\n\ndef validate_age(string):\n    \"\"\"Validates the 'age' parameter, returning a canonical value or ''.\"\"\"\n    if string:\n        string = strip(string)\n        string = unicodedata.normalize('NFKC', unicode(string))\n        string = HYPHEN_RE.sub('-', string)\n        if AGE_RE.match(string):\n            return string\n    return ''\n\n\ndef validate_status(string):\n    \"\"\"Validates an incoming status parameter, returning one of the canonical\n    status strings or ''.  Note that '' is always used as the Python value\n    to represent the 'unspecified' status.\"\"\"\n    if string:\n        string = strip(string).lower()\n    return string in pfif.NOTE_STATUS_VALUES and string or ''\n\n\nDATETIME_RE = re.compile(r'^(2\\d\\d\\d)-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d):(\\d\\d)Z$')\n\n\ndef validate_datetime(string):\n    if not string:\n        return None  # A missing value is okay.\n    match = DATETIME_RE.match(string)\n    if match:\n        return datetime(*map(int, match.groups()))\n    raise ValueError('Bad datetime: %r' % string)\n\n\ndef validate_timestamp(string):\n    try:\n        return string and datetime.utcfromtimestamp(float(strip(string)))\n    except:\n        raise ValueError('Bad timestamp: %s' % string)\n\n\ndef validate_image(bytestring):\n    try:\n        image = None\n        if bytestring:\n            image = images.Image(bytestring)\n            image.width\n        return image\n    except:\n        return False\n\n\ndef validate_version(string):\n    \"\"\"Version, if present, should be in pfif versions.\"\"\"\n    if string and strip(string) not in pfif.PFIF_VERSIONS:\n        raise ValueError('Bad pfif version: %s' % string)\n    return pfif.PFIF_VERSIONS[strip(string) or pfif.PFIF_DEFAULT_VERSION]\n\n\nREPO_RE = re.compile('^[a-z0-9-]+$')\n\n\ndef validate_repo(string):\n    string = (string or '').strip()\n    if not string:\n        return None\n    if string == 'global':\n        raise ValueError('\"global\" is an illegal repository name.')\n    if REPO_RE.match(string):\n        return string\n    raise ValueError('Repository names can only contain '\n                     'lowercase letters, digits, and hyphens.')\n\n\nRESOURCE_NAME_RE = re.compile('^[a-z0-9._-]+$')\n\n\ndef validate_resource_name(string):\n    \"\"\"A resource name or bundle label.\"\"\"\n    string = (string or '').strip().lower()\n    if not string:\n        return None\n    if RESOURCE_NAME_RE.match(string):\n        return string\n    raise ValueError('Invalid resource name or bundle name: %r' % string)\n\n\nLANG_RE = re.compile('^[A-Za-z0-9-]+$')\n\n\ndef validate_lang(string):\n    \"\"\"A BCP 47 language tag.\"\"\"\n    string = (string or '').strip().lower()\n    if not string:\n        return None\n    if LANG_RE.match(string):\n        return string\n    raise ValueError('Invalid language tag: %r' % string)\n\n\ndef validate_cache_seconds(string):\n    \"\"\"A number of seconds to cache a Resource in RAM.\"\"\"\n    string = (string or '').strip()\n    if string:\n        return float(string)\n    return 1.0\n\n\n# ==== Other utilities =========================================================\n\n\ndef url_is_safe(url):\n    current_scheme, _, _, _, _ = urlparse.urlsplit(url)\n    return current_scheme in ['http', 'https']\n\n\ndef get_app_name():\n    \"\"\"Canonical name of the app, without HR s~ nonsense.  This only works in\n    the context of the appserver (eg remote_api can't use it).\"\"\"\n    from google.appengine.api import app_identity\n    return app_identity.get_application_id()\n\n\ndef sanitize_urls(record):\n    \"\"\"Clean up URLs to protect against XSS.\"\"\"\n    # Single-line URLs.\n    for field in ['photo_url', 'source_url']:\n        url = getattr(record, field, None)\n        if url and not url_is_safe(url):\n            setattr(record, field, None)\n    # Multi-line URLs.\n    for field in ['profile_urls']:\n        urls = (getattr(record, field, None) or '').splitlines()\n        sanitized_urls = [url for url in urls if url and url_is_safe(url)]\n        if len(urls) != len(sanitized_urls):\n            setattr(record, field, '\\n'.join(sanitized_urls))\n\n\ndef get_host(host=None):\n    host = host or os.environ['HTTP_HOST']\n    \"\"\"Return the host name, without version specific details.\"\"\"\n    parts = host.split('.')\n    if len(parts) > 3:\n        return '.'.join(parts[-3:])\n    else:\n        return host\n\n\n# List of sensitive field names in person and note records.\nSENSITIVE_FIELDS = [\n  'date_of_birth',\n  'author_email',\n  'author_phone',\n  'email_of_found_person',\n  'phone_of_found_person',\n]\n\n\ndef optionally_filter_sensitive_fields(records, auth=None):\n    \"\"\"Removes sensitive fields from a list of dictionaries, unless the client\n    has full read authorization.\n\n    Args:\n        records (list of dict): A list of dictionaries which represent either of:\n            - a person record\n            - a note record\n            - a joined record of a person and a note\n    \"\"\"\n    if not (auth and auth.full_read_permission):\n        filter_sensitive_fields(records)\n\n\ndef filter_sensitive_fields(records):\n    \"\"\"Removes sensitive fields from a list of dictionaries.\n\n    Args:\n        records (list of dict): A list of dictionaries which represent either of:\n            - a person record\n            - a note record\n            - a joined record of a person and a note\n    \"\"\"\n    for record in records:\n        for prefix in ['', 'person_', 'note_']:\n            for field in SENSITIVE_FIELDS:\n                prefixed_field = prefix + field\n                if prefixed_field in record:\n                    record[prefixed_field] = ''\n\n\ndef join_person_and_note_record(person_record, note_record):\n    \"\"\"Join a person record and a note record into a single dictionary.\n\n    The field names are prefixed with 'person_' or 'note_' to avoid name\n    collision. note_record can be None. In that case, person record field\n    names are still prefixed.\n\n    Args:\n        person_record (dict): A dictionary representation of a person record.\n            Cannot be None.\n        note_record (dict): A dictionary representation of a note record for\n            the person. Can be None.\n    \"\"\"\n    joined_record = {}\n    for name, value in person_record.iteritems():\n        new_name = get_field_name_for_joined_record(name, 'person')\n        joined_record[new_name] = value\n    if note_record:\n        assert (note_record['person_record_id'] ==\n                person_record['person_record_id'])\n        for name, value in note_record.iteritems():\n            new_name = get_field_name_for_joined_record(name, 'note')\n            joined_record[new_name] = value\n    return joined_record\n\n\ndef get_field_name_for_joined_record(original_field_name, record_type):\n    \"\"\"Converts a field name in a person/note record into a field name used in\n    a joined record of a person and a note.\n\n    See also join_person_and_note_record().\n\n    Args:\n        original_field_name (str): A field name in a person/note record.\n        record_type (str): 'person' or 'note'.\n    \"\"\"\n    if original_field_name in ('person_record_id', 'note_record_id'):\n        return original_field_name\n    else:\n        return '%s_%s' % (record_type, original_field_name)\n\n\n# The current time for testing as a datetime object, or None if using real time.\n_utcnow_for_test = None\n\n\ndef set_utcnow_for_test(now):\n    \"\"\"Sets the current time for testing purposes.  Pass in a datetime object\n    or a timestamp in epoch seconds; or pass None to revert to real time.\"\"\"\n    global _utcnow_for_test\n    if isinstance(now, (int, float)):\n        now = datetime.utcfromtimestamp(float(now))\n    _utcnow_for_test = now\n\n\ndef get_utcnow():\n    \"\"\"Returns the current UTC datetime (settable with set_utcnow_for_test).\"\"\"\n    global _utcnow_for_test\n    return (_utcnow_for_test is None) and datetime.utcnow() or _utcnow_for_test\n\n\ndef get_timestamp(dt):\n    \"\"\"Converts datetime object to a float value in epoch seconds.\"\"\"\n    return calendar.timegm(dt.utctimetuple()) + dt.microsecond * 1e-6\n\n\ndef get_utcnow_timestamp():\n    \"\"\"Returns the current time in epoch seconds (settable with\n    set_utcnow_for_test).\"\"\"\n    return get_timestamp(get_utcnow())\n\n\ndef log_api_action(handler, action, num_person_records=0, num_note_records=0,\n                   people_skipped=0, notes_skipped=0):\n    \"\"\"Log an API action.\"\"\"\n    if handler.config and handler.config.api_action_logging:\n        model.ApiActionLog.record_action(\n            handler.repo, handler.params.key,\n            handler.params.version.version, action,\n            num_person_records, num_note_records,\n            people_skipped, notes_skipped,\n            handler.request.headers.get('User-Agent'),\n            handler.request.remote_addr, handler.request.url)\n\n\ndef get_full_name(given_name, family_name, config):\n    \"\"\"Return full name string obtained by concatenating given_name and\n    family_name in the order specified by config.family_name_first, or just\n    given_name if config.use_family_name is False.\"\"\"\n    if config.use_family_name:\n        separator = (given_name and family_name) and u' ' or u''\n        if config.family_name_first:\n            return separator.join([family_name, given_name])\n        else:\n            return separator.join([given_name, family_name])\n    else:\n        return given_name\n\n\ndef send_confirmation_email_to_record_author(\n    handler, person, action, confirm_url, record_id):\n    \"\"\"Send the author an email to confirm enabling/disabling notes\n    of a record.\"\"\"\n    if not person.author_email:\n        return handler.error(\n            400, _('No author email for record %(id)s.') % {'id' : record_id})\n\n    # i18n: Subject line of an e-mail message confirming the author\n    # wants to disable notes for this record\n    if action == 'enable':\n        subject = _('[Person Finder] Enable notes on \"%(full_name)s\"?'\n                ) % {'full_name': person.primary_full_name}\n    elif action == 'disable':\n        subject = _('[Person Finder] Disable notes on \"%(full_name)s\"?'\n                ) % {'full_name': person.primary_full_name}\n    else:\n        raise ValueError('Unknown action: %s' % action)\n\n    # send e-mail to record author confirming the lock of this record.\n    template_name = '%s_notes_email.txt' % action\n    handler.send_mail(\n        subject=subject,\n        to=person.author_email,\n        body=handler.render_to_string(\n            template_name,\n            author_name=person.author_name,\n            full_name=person.primary_full_name,\n            site_url=handler.get_url('/'),\n            confirm_url=confirm_url\n        )\n    )\n\n\ndef get_repo_url(request, repo, scheme=None):\n    \"\"\"Constructs the absolute root URL for a given repository.\"\"\"\n    req_scheme, req_netloc, req_path, _, _ = urlparse.urlsplit(request.url)\n    prefix = req_path.startswith('/personfinder') and '/personfinder' or ''\n    if is_dev_app_server():\n        scheme = 'http'  # HTTPS is not available when using dev_appserver\n    return (scheme or req_scheme) + '://' + req_netloc + prefix + '/' + repo\n\n\ndef get_url(request, repo, action, charset='utf-8', scheme=None, **params):\n    \"\"\"Constructs the absolute URL for a given action and query parameters,\n    preserving the current repo and the parameters listed in\n    PRESERVED_QUERY_PARAM_NAMES.\"\"\"\n    repo_url = get_repo_url(request, repo or 'global', scheme)\n    for name in PRESERVED_QUERY_PARAM_NAMES:\n        params[name] = params.get(name, request.get(name, None))\n    query = urlencode(params, charset)\n    return repo_url + '/' + action.lstrip('/') + (query and '?' + query or '')\n\n\ndef add_profile_icon_url(website, handler):\n    website['icon_url'] = \\\n        handler.env.global_url + '/' + website['icon_filename']\n    return website\n\n\ndef strip_url_scheme(url):\n    if not url:\n        return url\n    _, netloc, path, query, segment = urlparse.urlsplit(url)\n    return urlparse.urlunsplit(('', netloc, path, query, segment))\n\n\ndef is_dev_app_server():\n    return os.environ['APPLICATION_ID'].startswith('dev~')\n\n# ==== Struct ==================================================================\n\nclass Struct:\n    \"\"\"A simple bag of attributes.\"\"\"\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\n    def get(self, name, default=None):\n        return self.__dict__.get(name, default)\n\n\n# ==== Key management ======================================================\n\ndef generate_random_key(length):\n    \"\"\"Generates a random key with given length.\"\"\"\n    source = ('abcdefghijklmnopqrstuvwxyz'\n              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n              '1234567890'\n              '-_')\n    rng = random.SystemRandom()\n    return ''.join(rng.choice(source) for i in range(length))\n\n\n# ==== Decorators  ============================================================\n\ndef require_api_key_management_permission(handler_method):\n    \"\"\"\n    This is a decorator for API Key management feature. The limitation\n    is that the decorator can not preserve payloads within a POST/PUT\n    request.\n\n    Usage:\n    class SomeHandler(utils.BaseHandler):\n        @utils.require_api_key_management_permission\n        def get(self):\n            # ....\n            # ....\n    \"\"\"\n    def inner(*args, **kwargs):\n        handler = args[0]\n        user = users.get_current_user()\n        if (users.is_current_user_admin() or\n            (user and handler.config.key_management_operators and\n             user.email() in handler.config.key_management_operators)):\n            return handler_method(*args, **kwargs)\n        else:\n            return handler.redirect(\n                users.create_login_url(handler.request.url))\n    return inner\n\n\n# ==== Base Handler ============================================================\n\nclass BaseHandler(webapp.RequestHandler):\n    # Handlers that don't need a repository name can set this to False.\n    repo_required = True\n\n    # Handlers that require HTTPS can set this to True.\n    https_required = False\n\n    # Set this to True to enable a handler even for deactivated repositories.\n    ignore_deactivation = False\n\n    # Handlers that require an admin permission must set this to True.\n    admin_required = False\n\n    # List all accepted query parameters here with their associated validators.\n    auto_params = {\n        'action': strip,\n        'add_note': validate_yes,\n        'age': validate_age,\n        'alternate_family_names': strip,\n        'alternate_given_names': strip,\n        'author_email': strip,\n        'author_made_contact': validate_yes,\n        'author_name': strip,\n        'author_phone': strip,\n        'your_own_email': strip,\n        'your_own_phone': strip,\n        'believed_dead_permission': validate_checkbox_as_bool,\n        'cache_seconds': validate_cache_seconds,\n        'clone': validate_yes,\n        'confirm': validate_yes,\n        'contact_email': strip,\n        'contact_name': strip,\n        'content_id': strip,\n        'context': strip,\n        'cursor': strip,\n        'date_of_birth': validate_approximate_date,\n        'description': strip,\n        'domain_write_permission': strip,\n        'dupe_notes': validate_yes,\n        'email_of_found_person': strip,\n        'error': strip,\n        'expiry_option': validate_expiry,\n        'family_name': strip,\n        'full_read_permission': validate_checkbox_as_bool,\n        'given_name': strip,\n        'home_city': strip,\n        'home_country': strip,\n        'home_neighborhood': strip,\n        'home_postal_code': strip,\n        'home_state': strip,\n        'home_street': strip,\n        'id': strip,\n        'id1': strip,\n        'id2': strip,\n        'id3': strip,\n        'is_valid': validate_checkbox_as_bool,\n        'key': strip,\n        'lang': validate_lang,\n        'last_known_location': strip,\n        'mark_notes_reviewed': validate_checkbox_as_bool,\n        'max_results': validate_int,\n        'min_entry_date': validate_datetime,\n        'new_repo': validate_repo,\n        'note_photo': validate_image,\n        'note_photo_url': strip,\n        'omit_notes': validate_yes,\n        'operation': strip,\n        'organization_name': strip,\n        'person_record_id': strip,\n        'phone_of_found_person': strip,\n        'photo': validate_image,\n        'photo_url': strip,\n        'profile_url1': strip,\n        'profile_url2': strip,\n        'profile_url3': strip,\n        'query': strip,\n        'query_name': strip,\n        'query_location': strip,\n        'query_type': strip,\n        'read_permission': validate_checkbox_as_bool,\n        'referrer': strip,\n        'resource_bundle': validate_resource_name,\n        'resource_bundle_default': validate_resource_name,\n        'resource_bundle_original': validate_resource_name,\n        'resource_lang': validate_lang,\n        'resource_name': validate_resource_name,\n        'role': validate_role,\n        'search_engine_id': validate_int,\n        'search_permission': validate_checkbox_as_bool,\n        'sex': validate_sex,\n        'signature': strip,\n        'skip': validate_int,\n        'small': validate_yes,\n        'source': strip,\n        'source_date': strip,\n        'source_name': strip,\n        'source_url': strip,\n        'stats_permission': validate_checkbox_as_bool,\n        'status': validate_status,\n        'style': strip,\n        'subscribe': validate_checkbox,\n        'subscribe_own_info': validate_checkbox,\n        'subscribe_email': strip,\n        'subscribe_permission': validate_checkbox_as_bool,\n        'suppress_redirect': validate_yes,\n        'target': strip,\n        'text': strip,\n        'thumb': validate_checkbox_as_bool,\n        'timestamp': validate_timestamp,\n        'ui': strip_and_lower,\n        'utcnow': validate_timestamp,\n        'version': validate_version,\n        'own_info': validate_yes,\n        'xsrf_token': strip,\n    }\n\n    def redirect(self, path, repo=None, permanent=False, **params):\n        # This will prepend the repo to the path to create a working URL,\n        # unless the path has a global prefix or is an absolute URL.\n        if re.match('^[a-z]+:', path) or GLOBAL_PATH_RE.match(path):\n            if params:\n              path += '?' + urlencode(params, self.charset)\n        else:\n            path = self.get_url(path, repo, **params)\n        return webapp.RequestHandler.redirect(self, path, permanent=permanent)\n\n    def render(self, name, language_override=None, cache_seconds=0,\n               get_vars=lambda: {}, **vars):\n        \"\"\"Renders a template to the output stream, passing in the variables\n        specified in **vars as well as any additional variables returned by\n        get_vars().  Since this is intended for use by a dynamic page handler,\n        caching is off by default; if cache_seconds is positive, then\n        get_vars() will be called only when cached content is unavailable.\"\"\"\n        self.write(self.render_to_string(\n            name, language_override, cache_seconds, get_vars, **vars))\n\n    def render_to_string(self, name, language_override=None, cache_seconds=0,\n                         get_vars=lambda: {}, **vars):\n        \"\"\"Renders a template to a string, passing in the variables specified\n        in **vars as well as any additional variables returned by get_vars().\n        Since this is intended for use by a dynamic page handler, caching is\n        off by default; if cache_seconds is positive, then get_vars() will be\n        called only when cached content is unavailable.\"\"\"\n        # TODO(kpy): Make the contents of extra_key overridable by callers?\n        lang = language_override or self.env.lang\n        extra_key = (self.env.repo, self.env.charset, self.request.query_string)\n        def get_all_vars():\n            vars.update(get_vars())\n            for key in ('env', 'config', 'params'):\n                if key in vars:\n                    raise Exception(\n                        'Cannot use \"%s\" as a key in vars. It is reserved.'\n                        % key)\n            vars['env'] = self.env  # pass along application-wide context\n            vars['config'] = self.config  # pass along the configuration\n            vars['params'] = self.params  # pass along the query parameters\n            return vars\n        return resources.get_rendered(\n            name, lang, extra_key, get_all_vars, cache_seconds)\n\n    def error(self, code, message='', message_html=''):\n        self.info(code, message, message_html, style='error')\n\n    def info(self, code, message='', message_html='', style='info'):\n        \"\"\"Renders a simple page with a message.\n\n        Args:\n          code: HTTP status code.\n          message: A message in plain text.\n          message_html: A message in HTML.\n          style: 'info', 'error' or 'plain'. 'info' and 'error' differs in\n              appearance. 'plain' just renders the message without extra\n              HTML tags. Good for API response.\n        \"\"\"\n        is_error = 400 <= code < 600\n        if is_error:\n            webapp.RequestHandler.error(self, code)\n        else:\n            self.response.set_status(code)\n        if not message and not message_html:\n            message = '%d: %s' % (code, httplib.responses.get(code))\n        if style == 'plain':\n            self.__render_plain_message(message, message_html)\n        else:\n            try:\n                self.render('message.html', cls=style,\n                            message=message, message_html=message_html)\n            except:\n                self.__render_plain_message(message, message_html)\n        self.terminate_response()\n\n    def __render_plain_message(self, message, message_html):\n        self.response.out.write(\n            django.utils.html.escape(message) +\n            ('<p>' if message and message_html else '') +\n            message_html)\n\n    def terminate_response(self):\n        \"\"\"Prevents any further output from being written.\"\"\"\n        self.response.out.write = lambda *args: None\n        self.get = lambda *args: None\n        self.post = lambda *args: None\n\n    def write(self, text):\n        \"\"\"Sends text to the client using the charset from select_charset().\"\"\"\n        self.response.out.write(text.encode(self.env.charset, 'replace'))\n\n    def get_url(self, action, repo=None, scheme=None, **params):\n        \"\"\"Constructs the absolute URL for a given action and query parameters,\n        preserving the current repo and the parameters listed in\n        PRESERVED_QUERY_PARAM_NAMES.\"\"\"\n        return get_url(self.request, repo or self.env.repo, action,\n                       charset=self.env.charset, scheme=scheme, **params)\n\n    @staticmethod\n    def add_task_for_repo(repo, name, action, **kwargs):\n        \"\"\"Queues up a task for an individual repository.\"\"\"\n        task_name = '%s-%s-%s' % (repo, name, int(time.time()*1000))\n        path = '/%s/%s' % (repo, action)\n        taskqueue.add(name=task_name, method='GET', url=path, params=kwargs)\n\n    def send_mail(self, to, subject, body):\n        \"\"\"Sends e-mail using a sender address that's allowed for this app.\"\"\"\n        app_id = get_app_name()\n        sender = 'Do not reply <do-not-reply@%s.%s>' % (app_id, EMAIL_DOMAIN)\n        logging.info('Add mail task: recipient %r, subject %r' % (to, subject))\n        taskqueue.add(queue_name='send-mail', url='/global/admin/send_mail',\n                      params={'sender': sender,\n                              'to': to,\n                              'subject': subject,\n                              'body': body})\n\n    def get_captcha_html(self, error_code=None, use_ssl=False):\n        \"\"\"Generates the necessary HTML to display a CAPTCHA validation box.\"\"\"\n\n        # We use the 'custom_translations' parameter for UI messages, whereas\n        # the 'lang' parameter controls the language of the challenge itself.\n        # reCAPTCHA falls back to 'en' if this parameter isn't recognized.\n        lang = self.env.lang.split('-')[0]\n\n        return captcha.get_display_html(\n            site_key=config.get('captcha_site_key'),\n            use_ssl=use_ssl, error=error_code, lang=lang\n        )\n\n    def get_captcha_response(self):\n        \"\"\"Returns an object containing the CAPTCHA response information for the\n        given request's CAPTCHA field information.\"\"\"\n        # Allows faking the CAPTCHA response by an HTTP request parameter, but\n        # only locally, for testing purpose.\n        faked_captcha_response = self.request.get('faked_captcha_response')\n        if faked_captcha_response and self.request.remote_addr == '127.0.0.1':\n            return captcha.RecaptchaResponse(\n                is_valid=faked_captcha_response == 'success')\n\n        captcha_response = self.request.get('g-recaptcha-response')\n        return captcha.submit(captcha_response)\n\n    def handle_exception(self, exception, debug_mode):\n        logging.error(traceback.format_exc())\n        self.error(500, _(\n            'There was an error processing your request.  Sorry for the '\n            'inconvenience.  Our administrators will investigate the source '\n            'of the problem, but please check that the format of your '\n            'request is correct.'))\n\n    def __get_env_language_for_babel(self):\n        language_code = self.env.lang\n        try:\n            return babel.Locale.parse(language_code, sep='-')\n        except babel.UnknownLocaleError as e:\n            # fallback language\n            return babel.Locale('en')\n\n    def to_local_time(self, date):\n        \"\"\"Converts a datetime object to the local time configured for the\n        current repository.  For convenience, returns None if date is None.\"\"\"\n        # TODO(kpy): This only works for repositories that have a single fixed\n        # time zone offset and never use Daylight Saving Time.\n        if date:\n            if self.config.time_zone_offset:\n                return date + timedelta(0, 3600*self.config.time_zone_offset)\n            return date\n\n    def format_datetime_localized(self, dt):\n        \"\"\"Formats a datetime object to a localized human-readable string based\n        on the current locale.\"\"\"\n        return format_datetime(dt, locale=self.__get_env_language_for_babel());\n\n    def format_date_localized(self, dt):\n        \"\"\"Formats a datetime object to a localized human-readable string based\n        on the current locale containing only the date.\"\"\"\n        return format_date(dt, locale=self.__get_env_language_for_babel());\n\n    def format_time_localized(self, dt):\n        \"\"\"Formats a datetime object to a localized human-readable string based\n        on the current locale containing only the time.\"\"\"\n        return format_time(dt, locale=self.__get_env_language_for_babel());\n\n    def to_formatted_local_datetime(self, dt):\n        \"\"\"Converts a datetime object to the local datetime configured for the\n        current repository and formats to a localized human-readable string\n        based on the current locale.\"\"\"\n        dt = self.to_local_time(dt)\n        return self.format_datetime_localized(dt)\n\n    def to_formatted_local_date(self, dt):\n        \"\"\"Converts a datetime object to the local date configured for the\n        current repository and formats to a localized human-readable string\n        based on the current locale.\"\"\"\n        dt = self.to_local_time(dt)\n        return self.format_date_localized(dt)\n\n    def to_formatted_local_time(self, dt):\n        \"\"\"Converts a datetime object to the local time configured for the\n        current repository and formats to a localized human-readable string\n        based on the current locale.\"\"\"\n        dt = self.to_local_time(dt)\n        return self.format_time_localized(dt)\n\n    def maybe_redirect_for_repo_alias(self, request):\n        \"\"\"If the specified repository name is an alias, redirects to the URL\n        with the canonical repository name and returns True. Otherwise returns\n        False.\n        \"\"\"\n        # Config repo_alias is a dictionary from a repository name alias to\n        # its canonical.\n        # e.g., {'yol': '2013-yolanda', 'jam': '2014-jammu-kashmir-floods'}\n        #\n        # A repository name alias can be used instead of the canonical\n        # repository name in URLs. This is especially useful combined with\n        # the short URL. e.g., You can access\n        # https://www.google.org/personfinder/2014-jammu-kashmir-floods\n        # by http://g.co/pf/jam .\n        if not self.repo:\n            return False\n        repo_aliases = config.get('repo_aliases', default={})\n        if self.repo in repo_aliases:\n            canonical_repo = repo_aliases[self.repo]\n            params = {}\n            for name in request.arguments():\n                params[name] = request.get(name)\n            # Redirects to the same URL including the query parameters, except\n            # for the repository name.\n            self.redirect('/' + self.env.action, repo=canonical_repo, **params)\n            self.terminate_response()\n            return True\n        else:\n            return False\n\n    def should_show_inline_photo(self, photo_url):\n        \"\"\"Returns True if we should show the photo in our site directly with\n        <img> tag. In zero-rating mode, it returns True only if the photo is\n        served by our domain, to avoid loading resources in other domains in\n        Person Finder.\n\n        See \"Zero-rating\" section of the admin page\n        (app/resources/admin.html.template) for details of zero-rating mode.\n        \"\"\"\n        if not photo_url:\n            return False\n        elif self.env.config.zero_rating_mode:\n            _, our_netloc, _, _, _ = urlparse.urlsplit(self.request.url)\n            _, photo_netloc, _, _, _ = urlparse.urlsplit(photo_url)\n            return photo_netloc == our_netloc\n        else:\n            return True\n\n    URL_PARSE_QUERY_INDEX = 4\n\n    def get_thumbnail_url(self, photo_url):\n        \"\"\"Get a thumbnail URL for an uploaded photo's URL.\n\n        Args:\n            photo_url: a photo URL for an uploaded photo\n        \"\"\"\n        if not photo_url:\n            return None\n        parsed_url = list(urlparse.urlparse(photo_url))\n        params_dict = dict(urlparse.parse_qsl(\n            parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX]))\n        params_dict['thumb'] = 'true'\n        parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX] = urllib.urlencode(\n            params_dict)\n        return urlparse.urlunparse(parsed_url)\n\n    def __return_unimplemented_method_error(self):\n        return self.error(\n            405,\n            'HTTP method %s is not allowed for this URL.'\n                % self.request.method)\n\n    def __init__(self, request, response, env):\n        webapp.RequestHandler.__init__(self, request, response)\n        self.params = Struct()\n        self.env = env\n        self.repo = env.repo\n        self.config = env.config\n        self.charset = env.charset\n\n        # Set default Content-Type header.\n        self.response.headers['Content-Type'] = (\n            'text/html; charset=%s' % self.charset)\n\n        # Validate query parameters.\n        for name, validator in self.auto_params.items():\n            try:\n                value = self.request.get(name, '')\n                setattr(self.params, name, validator(value))\n            except Exception, e:\n                setattr(self.params, name, validator(None))\n                return self.error(400, 'Invalid parameter %s: %s' % (name, e))\n\n        # Ensure referrer is in whitelist, if it exists\n        if self.params.referrer and (not self.params.referrer in\n                                     self.config.referrer_whitelist):\n            setattr(self.params, 'referrer', '')\n\n        # Log the User-Agent header.\n        sample_rate = float(\n            self.config and self.config.user_agent_sample_rate or 0)\n        if random.random() < sample_rate:\n            model.UserAgentLog(\n                repo=self.repo, sample_rate=sample_rate,\n                user_agent=self.request.headers.get('User-Agent'), lang=lang,\n                accept_charset=self.request.headers.get('Accept-Charset', ''),\n                ip_address=self.request.remote_addr).put()\n\n        # Check for SSL (unless running local dev app server).\n        if self.https_required and not is_dev_app_server():\n            if self.env.scheme != 'https':\n                return self.error(403, 'HTTPS is required.')\n\n        # Handles repository alias.\n        if self.maybe_redirect_for_repo_alias(request):\n            return\n\n        # Check for an authorization key.\n        self.auth = None\n        if self.params.key:\n            if self.repo:\n                # check for domain specific one.\n                self.auth = model.Authorization.get(self.repo, self.params.key)\n            if not self.auth:\n                # perhaps this is a global key ('*' for consistency with config).\n                self.auth = model.Authorization.get('*', self.params.key)\n        if self.auth and not self.auth.is_valid:\n            self.auth = None\n\n        # Shows a custom error page here when the user is not an admin\n        # instead of \"login: admin\" in app.yaml\n        # If we use it, user can't sign out\n        # because the error page of \"login: admin\" doesn't have sign-out link.\n        if self.admin_required:\n            user = users.get_current_user()\n            if not user:\n                login_url = users.create_login_url(self.request.url)\n                webapp.RequestHandler.redirect(self, login_url)\n                self.terminate_response()\n                return\n            if not users.is_current_user_admin():\n                logout_url = users.create_logout_url(self.request.url)\n                self.render('not_admin_error.html', logout_url=logout_url, user=user)\n                self.terminate_response()\n                return\n\n        # Handlers that don't need a repository configuration can skip it.\n        if not self.repo:\n            if self.repo_required:\n                return self.error(400, 'No repository specified.')\n            return\n        # Everything after this requires a repo.\n\n        # Reject requests for repositories that don't exist.\n        if not model.Repo.get_by_key_name(self.repo):\n            html = 'No such repository. '\n            if self.env.repo_options:\n                html += 'Select:<p>' + self.render_to_string('repo-menu.html')\n            return self.error(404, message_html=html)\n\n        # If this repository has been deactivated, terminate with a message.\n        # The ignore_deactivation flag is for admin pages that bypass this.\n        if self.config.deactivated and not self.ignore_deactivation:\n            self.env.language_menu = []\n            self.env.robots_ok = True\n            self.render('message.html', cls='deactivation',\n                        message_html=self.config.deactivation_message_html)\n            self.terminate_response()\n\n    def get(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def post(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def put(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def head(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def options(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def delete(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def trace(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n\n# ==== XSRF protection =========================================================\n\nclass XsrfTool(object):\n\n    # XSRF tokens expire after 4 hours.\n    TOKEN_EXPIRATION_TIME = 60 * 60 * 4\n\n    # Characters with which to choose a key if it's not set yet.\n    TOKEN_CHARACTER_SET = string.letters + string.digits\n\n    def __init__(self):\n        configured_key = config.get('xsrf_token_key')\n        if configured_key:\n            # config.get returns unicode, but hmac is going to want a str\n            self._key = configured_key.encode('utf-8')\n        else:\n            configured_key = ''.join([\n                XsrfTool.TOKEN_CHARACTER_SET for _ in range(20)])\n            config.set(xsrf_token_key=configured_key)\n            self._key = configured_key\n\n    def generate_token(self, user_id, action_id):\n        action_time = get_utcnow_timestamp()\n        return '%s/%f' % (\n            self._generate_hmac_digest(user_id, action_id, action_time),\n            action_time)\n\n    def verify_token(self, token, user_id, action_id):\n        [hmac_digest, action_time_str] = token.split('/')\n        action_time = float(action_time_str)\n        if (action_time + XsrfTool.TOKEN_EXPIRATION_TIME <\n            get_utcnow_timestamp()):\n          return False\n        expected_hmac_digest = self._generate_hmac_digest(\n            user_id, action_id, action_time)\n        return hmac.compare_digest(\n            hmac_digest.encode('utf-8'), expected_hmac_digest)\n\n    def _generate_hmac_digest(self, user_id, action_id, action_time):\n        hmac_obj = hmac.new(\n            self._key, '%s/%s/%f' % (user_id, action_id, action_time))\n        return hmac_obj.hexdigest()\n/n/n/ntests/server_test_cases/xsrftool_tests.py/n/nimport datetime\n\nimport config\nfrom server_tests_base import ServerTestsBase\n\n\nclass XsrfToolTests(ServerTestsBase):\n\n    def setUp(self):\n        ServerTestsBase.setUp(self)\n        config.set(xsrf_token_key='abcdef')\n\n    def testRejectGlobalEdit(self):\n        self._checkPostIsRejected(\n            '/global/admin',\n            {'operation': 'save_global',\n             'tos_url': 'www.evil.com',\n             'sms_number_to_repo': '{}',\n             'repo_aliases': '{}',\n             'unreviewed_notes_threshold': '{}',})\n\n    def testRejectApiKeyEdit(self):\n        self._checkPostIsRejected(\n            '/global/admin/api_keys',\n            {'contact_name': 'Fred',\n             'contact_email': 'fred@example.com',\n             'organization_name': 'Fred Inc.',})\n\n    def testRejectCreateRepo(self):\n        self._checkPostIsRejected(\n            '/global/admin/create_repo',\n            {'new_repo': 'buffalo'})\n\n    def testRejectDeleteRecord(self):\n        self._checkPostIsRejected(\n            '/haiti/admin/delete_record',\n            {'operation': 'delete',\n             'id': 'localhost.person/123'})\n\n    def testRejectSetDefaultResourceBundle(self):\n        self._checkPostIsRejected(\n            '/global/admin/resources',\n            {'operation': 'set_default',\n             'resource_bundle_default': 'newbundle'})\n\n    def _checkPostIsRejected(self, path, data):\n        data['xsrf_token'] = 'NotTheRightDigest/123'\n        doc = self.go_as_admin(path, data=data)\n        self.assertEqual(doc.status, 403)\n/n/n/ntests/test_xsrftool.py/n/nimport datetime\nimport unittest\n\nimport config\nimport utils\n\n\nclass XsrfToolTests(unittest.TestCase):\n\n    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)\n\n    def setUp(self):\n        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)\n\n    def testGenerateAndVerifyGoodToken(self):\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))\n\n    def testRejectsInvalidToken(self):\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)\n        self.assertFalse(tool.verify_token(\n            'NotTheRightDigest/%f' % timestamp, 12345, 'test_action'))\n\n    def testRejectsExpiredToken(self):\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        utils.set_utcnow_for_test(\n            XsrfToolTests.TEST_NOW + datetime.timedelta(hours=4, minutes=1))\n        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))\n\n    def testGoodTokenWithNoPriorTokenKey(self):\n        # config seems to be shared across tests, so we have to specifically set\n        # it to None.\n        config.set(xsrf_token_key=None)\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))\n\n    def testBadTokenWithNoPriorTokenKey(self):\n        # config seems to be shared across tests, so we have to specifically set\n        # it to None.\n        config.set(xsrf_token_key=None)\n        tool = utils.XsrfTool()\n        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)\n        self.assertFalse(tool.verify_token(\n            'NotTheRightDigest/%f' % timestamp, 12345, 'test_action'))\n/n/n/n", "label": 0}, {"id": "d81fc3b81a2255ae128c54bf50a83bebc2118439", "code": "/app/admin_api_keys.py/n/n#!/usr/bin/python2.7\n# Copyright 2013 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport urllib\n\nfrom google.appengine.ext import db\nfrom google.appengine.api import users\n\nfrom model import Authorization, ApiKeyManagementLog\nimport utils\n\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\n\n\nAPI_KEY_LENGTH = 16\nKEYS_PER_PAGE = 50\n\ndef to_authorization_params(param):\n    param_list = [\n        'contact_name',\n        'contact_email',\n        'organization_name',\n        'domain_write_permission',\n        'read_permission',\n        'full_read_permission',\n        'search_permission',\n        'subscribe_permission',\n        'mark_notes_reviewed',\n        'believed_dead_permission',\n        'stats_permission',\n        'is_valid',\n    ]\n    ret = {}\n    for param_name in param_list:\n        ret[param_name] = getattr(param, param_name)\n    return ret\n\n\nclass ListApiKeys(utils.BaseHandler):\n    \"\"\"\n    A handler for listing API keys for a particular domain.\n    TODO(ryok): implement a search/filter and pagination feature.\n    \"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        user = users.get_current_user()\n        q = Authorization.all().filter('repo =', self.repo or '*')\n        authorizations = q.fetch(KEYS_PER_PAGE)\n        nav_html = ('<a href=\"%s\">%s</a> '\n                    % (self.get_url('admin/api_keys'),\n                       escape(_('Create a new API key'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        return self.render('admin_api_keys_list.html',\n                           nav_html=nav_html,\n                           admin_api_keys_url=self.get_url('/admin/api_keys'),\n                           user=user, authorizations=authorizations,\n                           user_email_with_tags=user_email_with_tags)\n\n\nclass CreateOrUpdateApiKey(utils.BaseHandler):\n    \"\"\"A handler for create/update API keys.\"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    def render_form(self, authorization=None, message=''):\n        \"\"\"Display a form for create/update Authorization\"\"\"\n        user = users.get_current_user()\n        if authorization:\n            operation_name = _('Update an existing key')\n            nav_html = ('<a href=\"%s\">%s</a> '\n                        % (self.get_url('admin/api_keys'),\n                           escape(_('Create a new API key'))))\n        else:\n            authorization = Authorization.DEFAULT_SETTINGS\n            operation_name = _('Create a new API key')\n            nav_html = ''\n\n        nav_html += ('<a href=\"%s\">%s</a>'\n                     % (self.get_url('admin/api_keys/list'),\n                        escape(_('List API keys'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render(\n            'admin_api_keys.html',\n            user=user, target_key=authorization,\n            user_email_with_tags=user_email_with_tags,\n            login_url=users.create_login_url(self.request.url),\n            logout_url=users.create_logout_url(self.request.url),\n            operation_name=operation_name, message=message,\n            nav_html=nav_html,\n            xsrf_token=xsrf_tool.generate_token(\n                user.user_id(), 'admin_api_keys'),\n        )\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        \"\"\"\n        It can be called with a key of ApiKeyManagementLog entity. In\n        such a case, it will show a detailed information of the key in\n        a form for updating the key, otherwise, it will show a form\n        for creating a new API key.\n        \"\"\"\n        management_log_key = self.request.get('log_key')\n        if management_log_key:\n            management_log = db.get(management_log_key)\n            message = ''\n            if management_log.action == ApiKeyManagementLog.CREATE:\n                message = _('A new API key has been created successfully.')\n            elif management_log.action == ApiKeyManagementLog.UPDATE:\n                message = _('The API key has been updated successfully.')\n            return self.render_form(management_log.authorization, message)\n        else:\n            # display a creation form\n            return self.render_form()\n\n    @utils.require_api_key_management_permission\n    def post(self):\n        \"\"\"Handle a post request from the create/update/edit form\"\"\"\n\n        user = users.get_current_user()\n        xsrf_tool = utils.XsrfTool()\n        if not (self.params.xsrf_token and xsrf_tool.verify_token(\n                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):\n            return self.error(403)\n\n        # Handle a form submission from list page\n        if self.request.get('edit_form'):\n            authorization = db.get(self.request.get('authorization_key'))\n            if not authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            return self.render_form(authorization)\n\n        # Handle authorization form submission\n        if not (self.params.contact_name and \n                self.params.contact_email and\n                self.params.organization_name):\n            return self.error(400, _('Please fill in all the required fields.'))\n\n        original_key = self.request.get('key')\n        if original_key:\n            # just override the existing one\n            existing_authorization = db.get(original_key)\n            if not existing_authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            key_str = existing_authorization.api_key\n            action = ApiKeyManagementLog.UPDATE\n        else:\n            key_str = utils.generate_random_key(API_KEY_LENGTH)\n            action = ApiKeyManagementLog.CREATE\n        repo = self.repo or '*'\n\n        authorization = Authorization.create(\n            repo, key_str,\n            **to_authorization_params(self.params))\n        authorization.put()\n\n        management_log = ApiKeyManagementLog(repo=repo,\n                                             api_key=authorization.api_key,\n                                             action=action)\n        management_log.put()\n\n        self.redirect('/admin/api_keys?repo=%s&log_key=%s'\n                      % (self.repo, management_log.key()))\n/n/n/n", "label": 1}, {"id": "047c9683b31aef990531ccd084962ddb25e88be5", "code": "app/urls.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"URL routing module.\"\"\"\n\nfrom django.conf import urls\n\nimport site_settings\nimport views.admin.statistics\n\n# We include an optional trailing slash in all the patterns (Django has support\n# for automatic redirection, but we don't want to send people redirect responses\n# if it's not really needed).\n_BASE_URL_PATTERNS = [('admin-statistics', r'global/admin/statistics/?',\n                       views.admin.statistics.AdminStatisticsView.as_view)]\n\n# pylint: disable=invalid-name\n# Pylint would prefer that this name be uppercased, but Django's going to look\n# for this value in the urls module; it has to be called urlpatterns.\nurlpatterns = [\n    urls.url('^%s$' % path_exp, view_func(), name=name)\n    for (name, path_exp, view_func) in _BASE_URL_PATTERNS\n]\n\nif site_settings.OPTIONAL_PATH_PREFIX:\n    urlpatterns += [\n        urls.url(\n            '^%(prefix)s/%(path)s$' % {\n                'prefix': site_settings.OPTIONAL_PATH_PREFIX,\n                'path': path_exp\n            },\n            view_func(),\n            name='prefixed:%s' % name)\n        for (name, path_exp, view_func) in _BASE_URL_PATTERNS\n    ]\n/n/n/napp/views/admin/base.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Code shared by admin view modules.\"\"\"\n\nimport django.shortcuts\nfrom google.appengine.api import users\n\nimport model\nimport utils\nimport views.base\n\n\nclass AdminBaseView(views.base.BaseView):\n    \"\"\"Base view for admin views.\"\"\"\n\n    _POST_PARAMETERS = {\n        'xsrf_token': utils.strip,\n    }\n\n    def setup(self, request, *args, **kwargs):\n        super(AdminBaseView, self).setup(request, *args, **kwargs)\n        self.read_params(post_params=AdminBaseView._POST_PARAMETERS)\n        self.env.show_logo = True\n        self.env.enable_javascript = True\n        self.env.user = users.get_current_user()\n        self.env.logout_url = users.create_logout_url(self.build_absolute_uri())\n        self.env.all_repo_options = [\n            utils.Struct(\n                repo=repo, url=self.build_absolute_path('/%s/admin' % repo))\n            for repo in sorted(model.Repo.list())\n        ]\n\n    def dispatch(self, request, *args, **kwargs):\n        # All the admin pages, and only the admin pages, require the user to be\n        # logged in as an admin.\n        # If we start requiring login for other pages, we should consider\n        # refactoring this into a decorator or something like that.\n        if not self.env.user:\n            return django.shortcuts.redirect(\n                users.create_login_url(self.build_absolute_uri()))\n        if not users.is_current_user_admin():\n            logout_url = users.create_logout_url(self.build_absolute_uri())\n            return self.render(\n                'not_admin_error.html',\n                status_code=403,\n                logout_url=logout_url,\n                user=self.env.user)\n        return super(AdminBaseView, self).dispatch(request, args, kwargs)\n/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"View-related code common to the whole app.\"\"\"\n\nimport functools\nimport re\n\nimport django.http\nimport django.utils.decorators\nimport django.views\n\nimport config\nimport const\nimport resources\nimport site_settings\nimport utils\n\n\nclass BaseView(django.views.View):\n    \"\"\"Base view class shared across the app.\"\"\"\n\n    # This should be overridden by subclasses.\n    ACTION_ID = None\n\n    _GET_PARAMETERS = {\n        'lang': utils.strip,\n    }\n\n    def setup(self, request, *args, **kwargs):\n        \"\"\"Sets up the handler.\n\n        Views aren't passed any request-specific information when they're\n        initialized, so you can't really do much in __init__. However, having a\n        function that gets called before dispatch is useful for all kinds of\n        things (in particular, it's useful to have a top-down function, where\n        the parent class functions run before those of subclasses). setup() is\n        essentially a substitute for __init__().\n\n        Args:\n            request (HttpRequest): The request object.\n            *args: Unused.\n            **kwargs: Arbitrary keyword arguments. Should include repository ID\n                (under the key 'repo') if applicable.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        # TODO(nworden): don't forget to call super.setup here once we upgrade\n        # to Django 2.2.\n        del request, args  # unused\n\n        # Set up the parameters and read in the base set of parameters.\n        self.params = utils.Struct()\n        self.read_params(get_params=BaseView._GET_PARAMETERS)\n\n        # Set up env variable with data needed by the whole app.\n        self.env = utils.Struct()\n        self.env.repo = kwargs.get('repo', None)\n        self.env.action = self.ACTION_ID\n        self.env.config = config.Configuration(self.env.repo or '*')\n        # Django will make a guess about what language to use, but Django's\n        # guess should be overridden by the lang CGI param if it's set.\n        # TODO(nworden): figure out how much of the logic below we still need\n        # now that Django can do a lot of the work for us.\n        lang = self.params.get('lang') or self.request.LANGUAGE_CODE\n        lang = re.sub('[^A-Za-z0-9-]', '', lang)\n        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)\n        if lang in const.LANGUAGE_ENDONYMS.keys():\n            self.env.lang = lang\n        else:\n            self.env.lang = (self.env.config.language_menu_options[0]\n                             if self.env.config.language_menu_options else\n                             const.DEFAULT_LANGUAGE_CODE)\n        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI\n        self.env.charset = const.CHARSET_UTF8\n        # TODO(nworden): try to eliminate use of global_url. It doesn't seem\n        # great that templates are building URLs by sticking things onto this.\n        self.env.global_url = self.build_absolute_uri('/global')\n\n    def read_params(self, get_params=None, post_params=None, file_params=None):\n        \"\"\"Reads CGI parameter values into self.params.\n\n        Args:\n            get_params (dict): A dictionary from GET parameter keys to validator\n                functions.\n            post_params (dict): A dictionary from POST parameter keys to\n                validator functions.\n            file_params (dict): A dictionary from POST parameter keys for\n                uploaded files to validator functions.\n        \"\"\"\n        if self.request.method == 'GET':\n            if get_params:\n                for key, validator in get_params.items():\n                    if key in self.request.GET:\n                        setattr(self.params, key,\n                                validator(self.request.GET[key]))\n        else:\n            if post_params:\n                for key, validator in post_params.items():\n                    if key in self.request.POST:\n                        setattr(self.params, key,\n                                validator(self.request.POST[key]))\n            if file_params:\n                for key, validator in file_params.items():\n                    if key in self.request.FILES:\n                        setattr(self.params, key,\n                                validator(self.request.FILES[key]))\n\n    def _request_is_for_prefixed_path(self):\n        \"\"\"Checks if the request's path uses an optional path prefix.\"\"\"\n        if not site_settings.OPTIONAL_PATH_PREFIX:\n            return False\n        req_path = self.request.path[1:]  # drop the leading slash\n        if req_path == site_settings.OPTIONAL_PATH_PREFIX:\n            return True\n        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)\n\n    def build_absolute_path(self, path=None):\n        \"\"\"Builds an absolute path, including the path prefix if required.\n\n        Django's HttpRequest objects have a similar function, but we implement\n        our own so that we can handle path prefixes correctly when they're in\n        use.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n\n        Returns:\n            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX\n            if it was used with the original request (e.g.,\n            '/personfinder/abc?x=y'). Does not preserve query parameters from\n            the original request.\n        \"\"\"\n        if path is None:\n            # request.path will already include the path prefix if it's being\n            # used.\n            return self.request.path\n        assert path[0] == '/'\n        if self._request_is_for_prefixed_path():\n            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)\n        else:\n            return path\n\n    def build_absolute_uri(self, path=None):\n        \"\"\"Builds an absolute URI given a path.\n\n        See build_absolute_path (above) for an explanation of why we implement\n        this function ourselves.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n\n        Returns:\n            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if\n            it was used with the original request (e.g.,\n            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve\n            query parameters from the original request.\n        \"\"\"\n        return self.request.build_absolute_uri(self.build_absolute_path(path))\n\n    def render(self, template_name, status_code=200, **template_vars):\n        \"\"\"Renders a template with the given variables.\n\n        Args:\n            template_name (str): The filename of the template in app/resources.\n            **template_vars: Named variables to pass to the template.\n\n        Returns:\n            HttpResponse: An HttpResponse with the rendered template.\n        \"\"\"\n\n        def get_vars():\n            \"\"\"A function returning vars, for use by the resources module.\"\"\"\n            template_vars['env'] = self.env\n            # TODO(nworden): change templates to access config through env, which\n            # already has the config anyway\n            template_vars['config'] = self.env.config\n            template_vars['params'] = self.params\n            return template_vars\n\n        query_str = self.request.META.get('QUERY_STRING', '')\n        extra_key = (self.env.repo, self.env.charset, query_str)\n        return django.http.HttpResponse(\n            resources.get_rendered(template_name, self.env.lang, extra_key,\n                                   get_vars, 0),\n            status=status_code)\n\n    @django.utils.decorators.classonlymethod\n    def as_view(cls, **initkwargs):\n        # pylint: disable=E,W,R,C\n        # We want to have a setup() function called before dispatch() (see\n        # explanation in the comments on the setup() function), and Django 2.2\n        # has support for it built in. However, we're not on Django 2.2 yet, so\n        # we make the modification to View.as_view() ourselves to get this\n        # feature ahead of time (the code below is just a copy of the original\n        # Django 1.11 View.as_view function, with the setup() call stuck in). We\n        # can clean this up when we upgrade to Django 2.2.\n        \"\"\"Main entry point for a request-response process.\"\"\"\n        for key in initkwargs:\n            if key in cls.http_method_names:\n                raise TypeError(\"You tried to pass in the %s method name as a \"\n                                \"keyword argument to %s(). Don't do that.\" %\n                                (key, cls.__name__))\n            if not hasattr(cls, key):\n                raise TypeError(\n                    \"%s() received an invalid keyword %r. as_view \"\n                    \"only accepts arguments that are already \"\n                    \"attributes of the class.\" % (cls.__name__, key))\n\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            if hasattr(self, 'get') and not hasattr(self, 'head'):\n                self.head = self.get\n            self.request = request\n            self.args = args\n            self.kwargs = kwargs\n            self.setup(request, *args, **kwargs)\n            return self.dispatch(request, *args, **kwargs)\n\n        view.view_class = cls\n        view.view_initkwargs = initkwargs\n\n        # take name and docstring from class\n        functools.update_wrapper(view, cls, updated=())\n\n        # and possible attributes set by decorators\n        # like csrf_exempt from dispatch\n        functools.update_wrapper(view, cls.dispatch, assigned=())\n        return view\n/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Access restriction tests.\"\"\"\n\nimport django.urls\n\nimport urls\nimport views\n\nimport django_tests_base\n\n\nclass AccessRestrictionTests(django_tests_base.DjangoTestsBase):\n    \"\"\"Tests that access restrictions are enforced.\"\"\"\n\n    # Dictionary from path name to a boolean indicating whether the page should\n    # be restricted to admins.\n    IS_RESTRICTED_TO_ADMINS = {\n        'admin-statistics': True,\n    }\n\n    def test_blocked_to_non_admins(self):\n        \"\"\"Tests that admin-only pages aren't available to non-admins.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = django.urls.reverse(path_name)\n            assert self.client.get(path).status_code == 403\n            assert self.client.post(path).status_code == 403\n\n    def test_available_to_admins(self):\n        \"\"\"Tests that admin-only pages are available to admins.\n\n        This is a sort of meta-test: I'm not really concerned that we might\n        accidentally lock admins out of the admin pages, but I do want to make\n        sure that the test above actually depends on the user not being an admin\n        (as opposed to access getting denied because the tests are set up wrong\n        somehow).\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = django.urls.reverse(path_name)\n            assert self.client.get(path).status_code == 200\n            # Don't test POST requests here; they'll need an XSRF token and\n            # that'll be covered in a separate test.\n\n    def test_other_pages_unrestricted(self):\n        \"\"\"Tests that non-admins can access unrestricted pages.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: not item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = django.urls.reverse(path_name)\n            assert self.client.get(path).status_code != 403\n\n    def test_all_paths_included(self):\n        \"\"\"Tests that all (Django-served) pages are listed.\n\n        We want to make sure no one forgets to add these tests for admin pages,\n        so we require that each URL path is included in the dictionary above.\n        \"\"\"\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed:'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            assert (\n                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)\n/n/n/n", "label": 0}, {"id": "047c9683b31aef990531ccd084962ddb25e88be5", "code": "/app/urls.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"URL routing module.\"\"\"\n\nfrom django.conf import urls\n\nimport site_settings\nimport views.admin.statistics\n\n# We include an optional trailing slash in all the patterns (Django has support\n# for automatic redirection, but we don't want to send people redirect responses\n# if it's not really needed).\n_BASE_URL_PATTERNS = [(r'global/admin/statistics/?',\n                       views.admin.statistics.AdminStatisticsView.as_view)]\n\n# pylint: disable=invalid-name\n# Pylint would prefer that this name be uppercased, but Django's going to look\n# for this value in the urls module; it has to be called urlpatterns.\nurlpatterns = [\n    urls.url('^(%s)$' % path_exp, view_func())\n    for (path_exp, view_func) in _BASE_URL_PATTERNS\n]\n\nif site_settings.OPTIONAL_PATH_PREFIX:\n    urlpatterns += [\n        urls.url(\n            '^(%s)/(%s)$' % (site_settings.OPTIONAL_PATH_PREFIX, path_exp),\n            view_func()) for (path_exp, view_func) in _BASE_URL_PATTERNS\n    ]\n/n/n/n/app/views/base.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"View-related code common to the whole app.\"\"\"\n\nimport functools\nimport re\n\nimport django.http\nimport django.utils.decorators\nimport django.views\n\nimport config\nimport const\nimport resources\nimport site_settings\nimport utils\n\n\nclass BaseView(django.views.View):\n    \"\"\"Base view class shared across the app.\"\"\"\n\n    # This should be overridden by subclasses.\n    ACTION_ID = None\n\n    _GET_PARAMETERS = {\n        'lang': utils.strip,\n    }\n\n    def setup(self, request, *args, **kwargs):\n        \"\"\"Sets up the handler.\n\n        Views aren't passed any request-specific information when they're\n        initialized, so you can't really do much in __init__. However, having a\n        function that gets called before dispatch is useful for all kinds of\n        things (in particular, it's useful to have a top-down function, where\n        the parent class functions run before those of subclasses). setup() is\n        essentially a substitute for __init__().\n\n        Args:\n            request (HttpRequest): The request object.\n            *args: Unused.\n            **kwargs: Arbitrary keyword arguments. Should include repository ID\n                (under the key 'repo') if applicable.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        # TODO(nworden): don't forget to call super.setup here once we upgrade\n        # to Django 2.2.\n        del request, args  # unused\n\n        # Set up the parameters and read in the base set of parameters.\n        self.params = utils.Struct()\n        self.read_params(get_params=BaseView._GET_PARAMETERS)\n\n        # Set up env variable with data needed by the whole app.\n        self.env = utils.Struct()\n        self.env.repo = kwargs.get('repo', None)\n        self.env.action = self.ACTION_ID\n        self.env.config = config.Configuration(self.env.repo or '*')\n        # Django will make a guess about what language to use, but Django's\n        # guess should be overridden by the lang CGI param if it's set.\n        # TODO(nworden): figure out how much of the logic below we still need\n        # now that Django can do a lot of the work for us.\n        lang = self.params.get('lang') or self.request.LANGUAGE_CODE\n        lang = re.sub('[^A-Za-z0-9-]', '', lang)\n        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)\n        if lang in const.LANGUAGE_ENDONYMS.keys():\n            self.env.lang = lang\n        else:\n            self.env.lang = (self.env.config.language_menu_options[0]\n                             if self.env.config.language_menu_options else\n                             const.DEFAULT_LANGUAGE_CODE)\n        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI\n        self.env.charset = const.CHARSET_UTF8\n        # TODO(nworden): try to eliminate use of global_url. It doesn't seem\n        # great that templates are building URLs by sticking things onto this.\n        self.env.global_url = self.build_absolute_uri('/global')\n\n    def read_params(self, get_params=None, post_params=None, file_params=None):\n        \"\"\"Reads CGI parameter values into self.params.\n\n        Args:\n            get_params (dict): A dictionary from GET parameter keys to validator\n                functions.\n            post_params (dict): A dictionary from POST parameter keys to\n                validator functions.\n            file_params (dict): A dictionary from POST parameter keys for\n                uploaded files to validator functions.\n        \"\"\"\n        if self.request.method == 'GET':\n            if get_params:\n                for key, validator in get_params.items():\n                    if key in self.request.GET:\n                        setattr(self.params, key,\n                                validator(self.request.GET[key]))\n        else:\n            if post_params:\n                for key, validator in post_params.items():\n                    if key in self.request.POST:\n                        setattr(self.params, key,\n                                validator(self.request.POST[key]))\n            if file_params:\n                for key, validator in file_params.items():\n                    if key in self.request.FILES:\n                        setattr(self.params, key,\n                                validator(self.request.FILES[key]))\n\n    def _request_is_for_prefixed_path(self):\n        \"\"\"Checks if the request's path uses an optional path prefix.\"\"\"\n        if not site_settings.OPTIONAL_PATH_PREFIX:\n            return False\n        req_path = self.request.path[1:]  # drop the leading slash\n        if req_path == site_settings.OPTIONAL_PATH_PREFIX:\n            return True\n        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)\n\n    def build_absolute_path(self, path=None):\n        \"\"\"Builds an absolute path, including the path prefix if required.\n\n        Django's HttpRequest objects have a similar function, but we implement\n        our own so that we can handle path prefixes correctly when they're in\n        use.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n\n        Returns:\n            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX\n            if it was used with the original request (e.g.,\n            '/personfinder/abc?x=y'). Does not preserve query parameters from\n            the original request.\n        \"\"\"\n        if path is None:\n            # request.path will already include the path prefix if it's being\n            # used.\n            return self.request.path\n        assert path[0] == '/'\n        if self._request_is_for_prefixed_path():\n            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)\n        else:\n            return path\n\n    def build_absolute_uri(self, path=None):\n        \"\"\"Builds an absolute URI given a path.\n\n        See build_absolute_path (above) for an explanation of why we implement\n        this function ourselves.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n\n        Returns:\n            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if\n            it was used with the original request (e.g.,\n            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve\n            query parameters from the original request.\n        \"\"\"\n        return self.request.build_absolute_uri(self.build_absolute_path(path))\n\n    def render(self, template_name, **template_vars):\n        \"\"\"Renders a template with the given variables.\n\n        Args:\n            template_name (str): The filename of the template in app/resources.\n            **template_vars: Named variables to pass to the template.\n\n        Returns:\n            HttpResponse: An HttpResponse with the rendered template.\n        \"\"\"\n\n        def get_vars():\n            \"\"\"A function returning vars, for use by the resources module.\"\"\"\n            template_vars['env'] = self.env\n            # TODO(nworden): change templates to access config through env, which\n            # already has the config anyway\n            template_vars['config'] = self.env.config\n            template_vars['params'] = self.params\n            return template_vars\n\n        query_str = self.request.META.get('QUERY_STRING', '')\n        extra_key = (self.env.repo, self.env.charset, query_str)\n        return django.http.HttpResponse(\n            resources.get_rendered(template_name, self.env.lang, extra_key,\n                                   get_vars, 0))\n\n    @django.utils.decorators.classonlymethod\n    def as_view(cls, **initkwargs):\n        # pylint: disable=E,W,R,C\n        # We want to have a setup() function called before dispatch() (see\n        # explanation in the comments on the setup() function), and Django 2.2\n        # has support for it built in. However, we're not on Django 2.2 yet, so\n        # we make the modification to View.as_view() ourselves to get this\n        # feature ahead of time (the code below is just a copy of the original\n        # Django 1.11 View.as_view function, with the setup() call stuck in). We\n        # can clean this up when we upgrade to Django 2.2.\n        \"\"\"Main entry point for a request-response process.\"\"\"\n        for key in initkwargs:\n            if key in cls.http_method_names:\n                raise TypeError(\"You tried to pass in the %s method name as a \"\n                                \"keyword argument to %s(). Don't do that.\" %\n                                (key, cls.__name__))\n            if not hasattr(cls, key):\n                raise TypeError(\n                    \"%s() received an invalid keyword %r. as_view \"\n                    \"only accepts arguments that are already \"\n                    \"attributes of the class.\" % (cls.__name__, key))\n\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            if hasattr(self, 'get') and not hasattr(self, 'head'):\n                self.head = self.get\n            self.request = request\n            self.args = args\n            self.kwargs = kwargs\n            self.setup(request, *args, **kwargs)\n            return self.dispatch(request, *args, **kwargs)\n\n        view.view_class = cls\n        view.view_initkwargs = initkwargs\n\n        # take name and docstring from class\n        functools.update_wrapper(view, cls, updated=())\n\n        # and possible attributes set by decorators\n        # like csrf_exempt from dispatch\n        functools.update_wrapper(view, cls.dispatch, assigned=())\n        return view\n/n/n/n", "label": 1}, {"id": "fa58bf0d37503c857be1a8cf533e8400d5cdbb6f", "code": "app/admin_api_keys.py/n/n#!/usr/bin/python2.7\n# Copyright 2013 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport urllib\n\nfrom google.appengine.ext import db\nfrom google.appengine.api import users\n\nfrom model import Authorization, ApiKeyManagementLog\nimport utils\n\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\n\n\nAPI_KEY_LENGTH = 16\nKEYS_PER_PAGE = 50\n\nAUTHORIZATION_PARAMS_LIST = [\n    'contact_name',\n    'contact_email',\n    'organization_name',\n    'domain_write_permission',\n    'read_permission',\n    'full_read_permission',\n    'search_permission',\n    'subscribe_permission',\n    'mark_notes_reviewed',\n    'believed_dead_permission',\n    'stats_permission',\n    'is_valid',\n]\n\ndef to_authorization_params(param):\n    ret = {}\n    for param_name in AUTHORIZATION_PARAMS_LIST:\n        ret[param_name] = getattr(param, param_name)\n    return ret\n\n\nclass ListApiKeys(utils.BaseHandler):\n    \"\"\"\n    A handler for listing API keys for a particular domain.\n    TODO(ryok): implement a search/filter and pagination feature.\n    \"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        user = users.get_current_user()\n        q = Authorization.all().filter('repo =', self.repo or '*')\n        authorizations = q.fetch(KEYS_PER_PAGE)\n        nav_html = ('<a href=\"%s\">%s</a> '\n                    % (self.get_url('admin/api_keys'),\n                       escape(_('Create a new API key'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render('admin_api_keys_list.html',\n                           nav_html=nav_html,\n                           admin_api_keys_url=self.get_url('/admin/api_keys'),\n                           user=user, authorizations=authorizations,\n                           user_email_with_tags=user_email_with_tags,\n                           xsrf_token=xsrf_tool.generate_token(\n                               user.user_id(), 'admin_api_keys'))\n\n\nclass CreateOrUpdateApiKey(utils.BaseHandler):\n    \"\"\"A handler for create/update API keys.\"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    def render_form(self, authorization=None, message=''):\n        \"\"\"Display a form for create/update Authorization\"\"\"\n        user = users.get_current_user()\n        if authorization:\n            operation_name = _('Update an existing key')\n            nav_html = ('<a href=\"%s\">%s</a> '\n                        % (self.get_url('admin/api_keys'),\n                           escape(_('Create a new API key'))))\n        else:\n            authorization = Authorization.DEFAULT_SETTINGS\n            operation_name = _('Create a new API key')\n            nav_html = ''\n\n        nav_html += ('<a href=\"%s\">%s</a>'\n                     % (self.get_url('admin/api_keys/list'),\n                        escape(_('List API keys'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render(\n            'admin_api_keys.html',\n            user=user, target_key=authorization,\n            user_email_with_tags=user_email_with_tags,\n            login_url=users.create_login_url(self.request.url),\n            logout_url=users.create_logout_url(self.request.url),\n            operation_name=operation_name, message=message,\n            nav_html=nav_html,\n            xsrf_token=xsrf_tool.generate_token(\n                user.user_id(), 'admin_api_keys'),\n        )\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        \"\"\"\n        It can be called with a key of ApiKeyManagementLog entity. In\n        such a case, it will show a detailed information of the key in\n        a form for updating the key, otherwise, it will show a form\n        for creating a new API key.\n        \"\"\"\n        management_log_key = self.request.get('log_key')\n        if management_log_key:\n            management_log = db.get(management_log_key)\n            message = ''\n            if management_log.action == ApiKeyManagementLog.CREATE:\n                message = _('A new API key has been created successfully.')\n            elif management_log.action == ApiKeyManagementLog.UPDATE:\n                message = _('The API key has been updated successfully.')\n            return self.render_form(management_log.authorization, message)\n        else:\n            # display a creation form\n            return self.render_form()\n\n    @utils.require_api_key_management_permission\n    def post(self):\n        \"\"\"Handle a post request from the create/update/edit form\"\"\"\n\n        user = users.get_current_user()\n        xsrf_tool = utils.XsrfTool()\n        if not (self.params.xsrf_token and xsrf_tool.verify_token(\n                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):\n            return self.error(403)\n\n        # Handle a form submission from list page\n        if self.request.get('edit_form'):\n            authorization = db.get(self.request.get('authorization_key'))\n            if not authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            return self.render_form(authorization)\n\n        # Handle authorization form submission\n        if not (self.params.contact_name and\n                self.params.contact_email and\n                self.params.organization_name):\n            return self.error(400, _('Please fill in all the required fields.'))\n\n        original_key = self.request.get('key')\n        if original_key:\n            # just override the existing one\n            existing_authorization = db.get(original_key)\n            if not existing_authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            key_str = existing_authorization.api_key\n            action = ApiKeyManagementLog.UPDATE\n        else:\n            key_str = utils.generate_random_key(API_KEY_LENGTH)\n            action = ApiKeyManagementLog.CREATE\n        repo = self.repo or '*'\n\n        authorization = Authorization.create(\n            repo, key_str,\n            **to_authorization_params(self.params))\n        authorization.put()\n\n        management_log = ApiKeyManagementLog(repo=repo,\n                                             api_key=authorization.api_key,\n                                             action=action)\n        management_log.put()\n\n        self.redirect('/admin/api_keys?repo=%s&log_key=%s'\n                      % (self.repo, management_log.key()))\n/n/n/napp/model.py/n/n#!/usr/bin/python2.7\n# Copyright 2010 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"The Person Finder data model, based on PFIF (http://zesty.ca/pfif).\"\"\"\n\n__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'\n\nfrom datetime import timedelta\n\nfrom google.appengine.api import datastore_errors\nfrom google.appengine.api import memcache\nfrom google.appengine.ext import db\n\nimport config\nimport full_text_search\nimport indexing\nimport pfif\nimport prefix\nfrom const import HOME_DOMAIN, NOTE_STATUS_TEXT\n\n# default # of days for a record to expire.\nDEFAULT_EXPIRATION_DAYS = 40\n\n# ==== PFIF record IDs =====================================================\n\ndef is_original(repo, record_id):\n    \"\"\"Returns True if this is a record_id for a record originally created in\n    the specified repository.\"\"\"\n    try:\n        repo_id, local_id = record_id.split('/', 1)\n        return repo_id == repo + '.' + HOME_DOMAIN\n    except ValueError:\n        raise ValueError('%r is not a valid record_id' % record_id)\n\ndef is_clone(repo, record_id):\n    \"\"\"Returns True if this is a record_id for a clone record (a record created\n    in another repository and copied into the specified one).\"\"\"\n    return not is_original(repo, record_id)\n\ndef filter_by_prefix(query, key_name_prefix):\n    \"\"\"Filters a query for key_names that have the given prefix.  If root_kind\n    is specified, filters the query for children of any entities that are of\n    that kind with the given prefix; otherwise, the results are assumed to be\n    top-level entities of the kind being queried.\"\"\"\n    root_kind = query._model_class.__name__\n    min_key = db.Key.from_path(root_kind, key_name_prefix)\n    max_key = db.Key.from_path(root_kind, key_name_prefix + u'\\uffff')\n    return query.filter('__key__ >=', min_key).filter('__key__ <=', max_key)\n\ndef get_properties_as_dict(db_obj):\n    \"\"\"Returns a dictionary containing all (dynamic)* properties of db_obj.\"\"\"\n    properties = dict((k, v.__get__(db_obj, db_obj.__class__)) for\n                      k, v in db_obj.properties().iteritems() if\n                      v.__get__(db_obj, db_obj.__class__))\n    dynamic_properties = dict((prop, getattr(db_obj, prop)) for\n                              prop in db_obj.dynamic_properties())\n    properties.update(dynamic_properties)\n    return properties\n\ndef clone_to_new_type(origin, dest_class, **kwargs):\n    \"\"\"Clones the given entity to a new entity of the type \"dest_class\".\n    Optionally, pass in values to kwargs to update values during cloning.\"\"\"\n    vals = get_properties_as_dict(origin)\n    vals.update(**kwargs)\n    if hasattr(origin, 'record_id'):\n        vals.update(record_id=origin.record_id)\n    return dest_class(key_name=origin.key().name(), **vals)\n\n# ==== Model classes =======================================================\n\n# Every Person or Note entity belongs to a specific repository.  To partition\n# the datastore, key names consist of the repo name, a colon, and then the\n# record ID.  Each repository appears to be a separate instance of the app.\n\n# Note that the repository name doesn't necessarily have to match the original\n# repository domain in the record ID!  For example, a person record created at\n# foo.person-finder.appspot.com would have a key name such as:\n#\n#     foo:foo.person-finder.appspot.com/person.234\n#\n# This record would be searchable only at foo.person-finder.appspot.com --\n# each repository is independent.  Copying it to bar.person-finder.appspot.com\n# would produce a clone record with the key name:\n#\n#     bar:foo.person-finder.appspot.com/person.234\n#\n# That is, the clone has the same record ID but a different repository name.\n\nclass Repo(db.Model):\n    \"\"\"Identifier for a repository of Person and Note records.  This is a\n    top-level entity, with no parent, whose existence just indicates the\n    existence of a repository.  Key name: unique repository name.  In the UI,\n    each repository behaves like an independent instance of the application.\"\"\"\n\n    class ActivationStatus(object):\n        \"\"\"An enum for the launch/activation status of the repo.\"\"\"\n        # For use with repositories that have not yet been publicly launched.\n        # Staging repos aren't listed on the homepage or in the repository feed,\n        # but are otherwise totally usable repos for anyone who knows the URL.\n        STAGING = 0\n        # For repositories in active use. These repos are listed on the homepage\n        # and in the repository feed.\n        ACTIVE = 1\n        # For repositories that have been turned down. The repository is\n        # unavailable, through either the web interface or the API, and users\n        # will instead see a deactivation message. These repos aren't listed on\n        # the homepage or in the repository feed.\n        DEACTIVATED = 2\n\n    # TODO(nworden): actually use this field\n    activation_status = db.IntegerProperty(\n        required=False, default=ActivationStatus.STAGING)\n\n    # Whether the repository is in test mode; meant for use with evergreen\n    # repositories when they're not needed. Records for repos in test mode are\n    # automatically deleted after 24 hours.\n    test_mode = db.BooleanProperty(default=False)\n\n    # Few properties for now; the repository title and other settings are all in\n    # ConfigEntry entities (see config.py).\n\n    @classmethod\n    def list(cls):\n        \"\"\"Returns a list of all repository names.\"\"\"\n        return [repo.key().name() for repo in cls.all()]\n\n    @classmethod\n    def list_active(cls):\n        \"\"\"Returns a list of the active (non-deactivated) repository names.\"\"\"\n        return [name for name in Repo.list()\n                if not config.get_for_repo(name, 'deactivated')]\n\n    @classmethod\n    def list_launched(cls):\n        \"\"\"Returns a list of the launched (listed in menu) repository names.\"\"\"\n        return [name for name in Repo.list()\n                if config.get_for_repo(name, 'launched') and\n                        not config.get_for_repo(name, 'deactivated')]\n\n\nclass Base(db.Model):\n    \"\"\"Base class providing methods common to both Person and Note entities,\n    whose key names are partitioned using the repo name as a prefix.\"\"\"\n\n    # max records to fetch in one go.\n    FETCH_LIMIT = 200\n\n    # Even though the repo is part of the key_name, it is also stored\n    # redundantly as a separate property so it can be indexed and queried upon.\n    repo = db.StringProperty(required=True)\n\n    # We can't use an inequality filter on expiry_date (together with other\n    # inequality filters), so we use a periodic task to set the is_expired flag\n    # on expired records, and filter using the flag.  A record's life cycle is:\n    #\n    # 1. Record is created with some expiry_date.\n    # 2. expiry_date passes.\n    # 3. tasks.DeleteExpired sets is_expired to True; record vanishes from UI.\n    # 4. delete.EXPIRED_TTL_DAYS days pass.\n    # 5. tasks.DeleteExpired wipes the record.\n\n    # We set default=False to ensure all entities are indexed by is_expired.\n    # NOTE: is_expired should ONLY be modified in Person.put_expiry_flags().\n    is_expired = db.BooleanProperty(required=False, default=False)\n\n    @classmethod\n    def all(cls, keys_only=False, filter_expired=True):\n        \"\"\"Returns a query for all records of this kind; by default this\n        filters out the records marked as expired.\n\n        Args:\n          keys_only - If true, return only the keys.\n          filter_expired - If true, omit records with is_expired == True.\n        Returns:\n          query - A Query object for the results.\n        \"\"\"\n        query = super(Base, cls).all(keys_only=keys_only)\n        if filter_expired:\n            query.filter('is_expired =', False)\n        return query\n\n    @classmethod\n    def all_in_repo(cls, repo, filter_expired=True):\n        \"\"\"Gets a query for all entities in a given repository.\"\"\"\n        return cls.all(filter_expired=filter_expired).filter('repo =', repo)\n\n    def get_record_id(self):\n        \"\"\"Returns the record ID of this record.\"\"\"\n        repo, record_id = self.key().name().split(':', 1)\n        return record_id\n    record_id = property(get_record_id)\n\n    def get_original_domain(self):\n        \"\"\"Returns the domain name of this record's original repository.\"\"\"\n        return self.record_id.split('/', 1)[0]\n    original_domain = property(get_original_domain)\n\n    def is_original(self):\n        \"\"\"Returns True if this record was created in this repository.\"\"\"\n        return is_original(self.repo, self.record_id)\n\n    def is_clone(self):\n        \"\"\"Returns True if this record was copied from another repository.\"\"\"\n        return not self.is_original()\n\n    @classmethod\n    def get_key(cls, repo, record_id):\n        \"\"\"Get entity key from its record id\"\"\"\n        return db.Key.from_path(cls.kind(), repo + ':' + record_id)\n\n    @classmethod\n    def get_all(cls, repo, record_ids, limit=200):\n        \"\"\"Gets the entities with the given record_ids in a given repository.\"\"\"\n        keys = [cls.get_key(repo, id) for id in record_ids]\n        return [record for record in db.get(keys) if record is not None]\n\n    @classmethod\n    def get(cls, repo, record_id, filter_expired=True):\n        \"\"\"Gets the entity with the given record_id in a given repository.\"\"\"\n        record = cls.get_by_key_name(repo + ':' + record_id)\n        if record:\n            if not (filter_expired and record.is_expired):\n                return record\n\n    @classmethod\n    def create_original(cls, repo, **kwargs):\n        \"\"\"Creates a new original entity with the given field values.\"\"\"\n        # TODO(ryok): Consider switching to URL-like record id format,\n        # which is more consitent with repo id format.\n        record_id = '%s.%s/%s.%d' % (\n            repo, HOME_DOMAIN, cls.__name__.lower(), UniqueId.create_id())\n        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)\n\n    @classmethod\n    def create_clone(cls, repo, record_id, **kwargs):\n        \"\"\"Creates a new clone entity with the given field values.\"\"\"\n        assert is_clone(repo, record_id)\n        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)\n\n    # TODO(kpy): Rename this function (maybe to create_with_record_id?).\n    @classmethod\n    def create_original_with_record_id(cls, repo, record_id, **kwargs):\n        \"\"\"Creates an original entity with the given record_id and field\n        values, overwriting any existing entity with the same record_id.\n        This should be rarely used in practice (e.g. for an administrative\n        import into a home repository), hence the long method name.\"\"\"\n        return cls(key_name=repo + ':' + record_id, repo=repo, **kwargs)\n\n\n# All fields are either required, or have a default value.  For property\n# types that have a false value, the default is the false value.  For types\n# with no false value, the default is None.\n\nclass Person(Base):\n    \"\"\"The datastore entity kind for storing a PFIF person record.  Never call\n    Person() directly; use Person.create_clone() or Person.create_original().\n\n    Methods that start with \"get_\" return actual values or lists of values;\n    other methods return queries or generators for values.\n    \"\"\"\n    # If you add any new fields, be sure they are handled in wipe_contents().\n\n    # entry_date should update every time a record is created or re-imported.\n    entry_date = db.DateTimeProperty(required=True)\n    expiry_date = db.DateTimeProperty(required=False)\n\n    author_name = db.StringProperty(default='', multiline=True)\n    author_email = db.StringProperty(default='')\n    author_phone = db.StringProperty(default='')\n\n    # the original date we saw this record; it should not change.\n    original_creation_date = db.DateTimeProperty(auto_now_add=True)\n\n    # source_date is the date that the original repository last changed\n    # any of the fields in the pfif record.\n    source_date = db.DateTimeProperty()\n\n    source_name = db.StringProperty(default='')\n    source_url = db.StringProperty(default='')\n\n    # TODO(ryok): consider marking this required.\n    full_name = db.StringProperty(multiline=True)\n    given_name = db.StringProperty()\n    family_name = db.StringProperty()\n    alternate_names = db.StringProperty(default='', multiline=True)\n    description = db.TextProperty(default='')\n    sex = db.StringProperty(default='', choices=pfif.PERSON_SEX_VALUES)\n    date_of_birth = db.StringProperty(default='')  # YYYY, YYYY-MM, YYYY-MM-DD\n    age = db.StringProperty(default='')  # NN or NN-MM\n    home_street = db.StringProperty(default='')\n    home_neighborhood = db.StringProperty(default='')\n    home_city = db.StringProperty(default='')\n    home_state = db.StringProperty(default='')\n    home_postal_code = db.StringProperty(default='')\n    home_country = db.StringProperty(default='')\n    photo_url = db.TextProperty(default='')\n    profile_urls = db.TextProperty(default='')\n\n    # This reference points to a locally stored Photo entity.  ONLY set this\n    # property when storing a new Photo object that is owned by this Person\n    # record and can be safely deleted when the Person is deleted.\n    photo = db.ReferenceProperty(default=None)\n\n    # The following properties are not part of the PFIF data model; they are\n    # cached on the Person for efficiency.\n\n    # Value of the 'status' and 'source_date' properties on the Note\n    # with the latest source_date with the 'status' field present.\n    latest_status = db.StringProperty(default='')\n    latest_status_source_date = db.DateTimeProperty()\n    # Value of the 'author_made_contact' and 'source_date' properties on the\n    # Note with the latest source_date with the 'author_made_contact' field\n    # present.\n    latest_found = db.BooleanProperty()\n    latest_found_source_date = db.DateTimeProperty()\n\n    # Last write time of this Person or any Notes on this Person.\n    # This reflects any change to the Person page.\n    last_modified = db.DateTimeProperty(auto_now=True)\n\n    # This flag is set to true only when the record author disabled\n    # adding new notes to a record.\n    notes_disabled = db.BooleanProperty(default=False)\n\n    # attributes used by indexing.py\n    names_prefixes = db.StringListProperty()\n    # TODO(ryok): index address components.\n    _fields_to_index_properties = ['given_name', 'family_name', 'full_name']\n    _fields_to_index_by_prefix_properties = ['given_name', 'family_name',\n        'full_name']\n\n    @staticmethod\n    def past_due_records(repo):\n        \"\"\"Returns a query for all Person records with expiry_date in the past,\n        or None, regardless of their is_expired flags.\"\"\"\n        import utils\n        return Person.all(filter_expired=False).filter(\n            'expiry_date <=', utils.get_utcnow()).filter(\n            'repo =', repo)\n\n    @staticmethod\n    def potentially_expired_records(repo,\n                                    days_to_expire=DEFAULT_EXPIRATION_DAYS):\n        \"\"\"Returns a query for all Person records with source date\n        older than days_to_expire (or empty source_date), regardless of\n        is_expired flags value.\"\"\"\n        import utils\n        cutoff_date = utils.get_utcnow() - timedelta(days_to_expire)\n        return Person.all(filter_expired=False).filter(\n            'source_date <=',cutoff_date).filter(\n            'repo =', repo)\n\n    @property\n    def person_record_id(self):\n        return self.record_id\n\n    @property\n    def primary_full_name(self):\n        return self.full_name.splitlines()[0] if self.full_name else ''\n\n    @property\n    def full_name_list(self):\n        return self.full_name.splitlines() if self.full_name else []\n\n    @property\n    def alternate_names_list(self):\n        return self.alternate_names.splitlines() if self.alternate_names else []\n\n    @property\n    def fuzzified_age(self):\n        import utils\n        return utils.fuzzify_age(self.age) if self.age else None\n\n    @property\n    def profile_urls_list(self):\n        return self.profile_urls.splitlines() if self.profile_urls else []\n\n    @property\n    def photo_url_no_scheme(self):\n        import utils\n        return utils.strip_url_scheme(self.photo_url)\n\n    def get_notes(self, filter_expired=True):\n        \"\"\"Returns a list of all the Notes on this Person, omitting expired\n        Notes by default.\"\"\"\n        return Note.get_by_person_record_id(\n            self.repo, self.record_id, filter_expired=filter_expired)\n\n    def get_subscriptions(self, subscription_limit=200):\n        \"\"\"Retrieves a list of all the Subscriptions for this Person.\"\"\"\n        return Subscription.get_by_person_record_id(\n            self.repo, self.record_id, limit=subscription_limit)\n\n    def get_linked_person_ids(self, note_limit=200):\n        \"\"\"Retrieves IDs of Persons marked as duplicates of this Person.\"\"\"\n        return [note.linked_person_record_id\n                for note in self.get_notes(note_limit)\n                if note.linked_person_record_id]\n\n    def get_linked_persons(self, note_limit=200):\n        \"\"\"Retrieves Persons marked as duplicates of this Person.\"\"\"\n        return Person.get_all(self.repo,\n                              self.get_linked_person_ids(note_limit))\n\n    def get_all_linked_persons(self):\n        \"\"\"Retrieves all Persons transitively linked to this Person.\"\"\"\n        linked_person_ids = set([self.record_id])\n        linked_persons = []\n        # Maintain a list of ids of duplicate persons that have not\n        # yet been processed.\n        new_person_ids = set(self.get_linked_person_ids())\n        # Iteratively process all new_person_ids by retrieving linked\n        # duplicates and storing those not yet processed.\n        # Processed ids are stored in the linked_person_ids set, and\n        # their corresponding records are in the linked_persons list.\n        while new_person_ids:\n            linked_person_ids.update(new_person_ids)\n            new_persons = Person.get_all(self.repo, list(new_person_ids))\n            for person in new_persons:\n                new_person_ids.update(person.get_linked_person_ids())\n            linked_persons += new_persons\n            new_person_ids -= linked_person_ids\n        return linked_persons\n\n    def get_associated_emails(self):\n        \"\"\"Gets a set of all the e-mail addresses to notify when this record\n        is changed.\"\"\"\n        email_addresses = set([note.author_email for note in self.get_notes()\n                               if note.author_email])\n        if self.author_email:\n            email_addresses.add(self.author_email)\n        return email_addresses\n\n    def get_effective_expiry_date(self):\n        \"\"\"Gets the expiry_date, or if no expiry_date is present, returns the\n        source_date plus the configurable default_expiration_days interval.\n\n        If there's no source_date, we use original_creation_date.\n        Returns:\n          A datetime date (not None).\n        \"\"\"\n        if self.expiry_date:\n            return self.expiry_date\n        else:\n            expiration_days = config.get_for_repo(\n                self.repo, 'default_expiration_days') or (\n                DEFAULT_EXPIRATION_DAYS)\n            # in theory, we should always have original_creation_date, but since\n            # it was only added recently, we might have legacy\n            # records without it.\n            start_date = self.original_creation_date or utils.get_utcnow()\n            return start_date + timedelta(expiration_days)\n\n    def put_expiry_flags(self):\n        \"\"\"Updates the is_expired flags on this Person and related Notes to\n        make them consistent with the effective_expiry_date() on this Person,\n        and commits the changes to the datastore.\"\"\"\n        import utils\n        now = utils.get_utcnow()\n        expired = self.get_effective_expiry_date() <= now\n\n        if self.is_expired != expired:\n            # NOTE: This should be the ONLY code that modifies is_expired.\n            self.is_expired = expired\n\n            # if we neglected to capture the original_creation_date,\n            # make a best effort to grab it now, for posterity.\n            if not self.original_creation_date:\n                self.original_creation_date = self.source_date\n\n            # If the record is expiring (being replaced with a placeholder,\n            # see http://zesty.ca/pfif/1.3/#data-expiry) or un-expiring (being\n            # restored from deletion), we want the source_date and entry_date\n            # updated so downstream clients will see this as the newest state.\n            self.source_date = now\n            self.entry_date = now\n\n            # All the Notes on the Person also expire or unexpire, to match.\n            notes = self.get_notes(filter_expired=False)\n            for note in notes:\n                note.is_expired = expired\n\n            # Store these changes in the datastore.\n            db.put(notes + [self])\n            # TODO(lschumacher): photos don't have expiration currently.\n\n    def wipe_contents(self):\n        \"\"\"Sets all the content fields to None (leaving timestamps and the\n        expiry flag untouched), stores the empty record, and permanently\n        deletes any related Notes and Photos.  Call this method ONLY on records\n        that have already expired.\"\"\"\n        # We rely on put_expiry_flags to have properly set the source_date,\n        # entry_date, and is_expired flags on Notes, as necessary.\n        assert self.is_expired\n\n        # Permanently delete all related Photos and Notes, but not self.\n        self.delete_related_entities()\n\n        was_changed = False\n        # TODO(nworden): consider adding a is_tombstone property or something\n        # like that, so we could just check that instead of checking each\n        # property individually every time.\n        for name, property in self.properties().items():\n            # Leave the repo, is_expired flag, and timestamps untouched.\n            if name not in ['repo', 'is_expired', 'original_creation_date',\n                            'source_date', 'entry_date', 'expiry_date']:\n                if name == 'photo':\n                    # If we attempt to access this directly, Datastore will try\n                    # to fetch the actual photo, which won't go well, because we\n                    # just deleted the photo.\n                    cur_value = Person.photo.get_value_for_datastore(self)\n                else:\n                    cur_value = getattr(self, name)\n                if cur_value != property.default:\n                    setattr(self, name, property.default)\n                    was_changed = True\n        if was_changed:\n            self.put()  # Store the empty placeholder record.\n\n    def delete_related_entities(self, delete_self=False):\n        \"\"\"Permanently delete all related Photos and Notes, and also self if\n        delete_self is True.\"\"\"\n        # Delete all related Notes.\n        notes = self.get_notes(filter_expired=False)\n        # Delete the locally stored Photos.  We use get_value_for_datastore to\n        # get just the keys and prevent auto-fetching the Photo data.\n        photo = Person.photo.get_value_for_datastore(self)\n        note_photos = [Note.photo.get_value_for_datastore(n) for n in notes]\n\n        entities_to_delete = filter(None, notes + [photo] + note_photos)\n        if delete_self:\n            entities_to_delete.append(self)\n            if config.get('enable_fulltext_search'):\n                full_text_search.delete_record_from_index(self)\n        db.delete(entities_to_delete)\n\n    def update_from_note(self, note):\n        \"\"\"Updates any necessary fields on the Person to reflect a new Note.\"\"\"\n        # We want to transfer only the *non-empty, newer* values to the Person.\n        if note.author_made_contact is not None:  # for boolean, None means\n                                                  # unspecified\n            # datetime stupidly refuses to compare to None, so check for None.\n            if (self.latest_found_source_date is None or\n                note.source_date >= self.latest_found_source_date):\n                self.latest_found = note.author_made_contact\n                self.latest_found_source_date = note.source_date\n        if note.status:  # for string, '' means unspecified\n            if (self.latest_status_source_date is None or\n                note.source_date >= self.latest_status_source_date):\n                self.latest_status = note.status\n                self.latest_status_source_date = note.source_date\n\n    def update_index(self, which_indexing):\n        #setup new indexing\n        if 'new' in which_indexing:\n            indexing.update_index_properties(self)\n            if config.get('enable_fulltext_search'):\n                full_text_search.add_record_to_index(self)\n        # setup old indexing\n        if 'old' in which_indexing:\n            prefix.update_prefix_properties(self)\n\n    def update_latest_status(self, modified_note=None):\n        \"\"\"Scans all notes on this Person and fixes latest_status if needed.\"\"\"\n        status = None\n        status_source_date = None\n        for note in self.get_notes():\n            if modified_note and modified_note.note_record_id == note.record_id:\n                note = modified_note\n            if note.status and not note.hidden:\n                status = note.status\n                status_source_date = note.source_date\n        if status != self.latest_status:\n            self.latest_status = status\n            self.latest_status_source_date = status_source_date\n            self.put()\n\n    def put_new(self):\n        \"\"\"Write the new person record to datastore. Increments person_counter\n        because a new record is created. Logs user actions is updated too.\n        We should never call this method against an existing record.\"\"\"\n        db.put(self)\n        UsageCounter.increment_counter(self.repo, ['person'])\n        UserActionLog.put_new('add', self, copy_properties=False)\n\n# Old indexing\n# TODO(ryok): This is obsolete. Remove it.\nprefix.add_prefix_properties(\n    Person, 'given_name', 'family_name', 'home_street', 'home_neighborhood',\n    'home_city', 'home_state', 'home_postal_code')\n\n\nclass Note(Base):\n    \"\"\"The datastore entity kind for storing a PFIF note record.  Never call\n    Note() directly; use Note.create_clone() or Note.create_original().\"\"\"\n\n    # The entry_date should update every time a record is re-imported.\n    entry_date = db.DateTimeProperty(required=True)\n\n    person_record_id = db.StringProperty(required=True)\n\n    # Use this field to store the person_record_id of a duplicate Person entry.\n    linked_person_record_id = db.StringProperty(default='')\n\n    author_name = db.StringProperty(default='', multiline=True)\n    author_email = db.StringProperty(default='')\n    author_phone = db.StringProperty(default='')\n\n    # the original date we saw this record; it should not change.\n    original_creation_date = db.DateTimeProperty(auto_now_add=True)\n\n    # source_date is the date that the original repository last changed\n    # any of the fields in the pfif record.\n    source_date = db.DateTimeProperty()\n\n    status = db.StringProperty(default='', choices=pfif.NOTE_STATUS_VALUES)\n    author_made_contact = db.BooleanProperty()\n    email_of_found_person = db.StringProperty(default='')\n    phone_of_found_person = db.StringProperty(default='')\n    last_known_location = db.StringProperty(default='', multiline=True)\n    text = db.TextProperty(default='')\n    photo_url = db.TextProperty(default='')\n\n    # This reference points to a locally stored Photo entity.  ONLY set this\n    # property when storing a new Photo object that is owned by this Note\n    # record and can be safely deleted when the Note is deleted.\n    photo = db.ReferenceProperty(default=None)\n\n    # True if the note has been marked as spam. Will cause the note to be\n    # initially hidden from display upon loading a record page.\n    hidden = db.BooleanProperty(default=False)\n\n    # True if the note has been reviewed for spam content at /admin/review.\n    reviewed = db.BooleanProperty(default=False)\n\n    def get_note_record_id(self):\n        return self.record_id\n    note_record_id = property(get_note_record_id)\n\n    @property\n    def photo_url_no_scheme(self):\n        import utils\n        return utils.strip_url_scheme(self.photo_url)\n\n    @staticmethod\n    def get_by_person_record_id(\n        repo, person_record_id, filter_expired=True):\n        \"\"\"Gets a list of all the Notes on a Person, ordered by source_date.\"\"\"\n        return list(Note.generate_by_person_record_id(\n            repo, person_record_id, filter_expired))\n\n    @staticmethod\n    def generate_by_person_record_id(\n        repo, person_record_id, filter_expired=True):\n        \"\"\"Generates all the Notes on a Person record ordered by source_date.\"\"\"\n        query = Note.all_in_repo(repo, filter_expired=filter_expired\n            ).filter('person_record_id =', person_record_id\n            ).order('source_date')\n        notes = query.fetch(Note.FETCH_LIMIT)\n        while notes:\n            for note in notes:\n                yield note\n            query.with_cursor(query.cursor())  # Continue where fetch left off.\n            notes = query.fetch(Note.FETCH_LIMIT)\n\n    @staticmethod\n    def get_unreviewed_notes_count(repo, filter_expired=True):\n        \"\"\"Gets the number of unreviewed notes.\"\"\"\n        query = Note.all_in_repo(repo, filter_expired=filter_expired\n            ).filter('reviewed =', False).filter('hidden =', False)\n        return query.count()\n\n    def put_new(self):\n        \"\"\"Write the new note to datastore. Increments note_counter because\n        a new note is created. Also, logs user actions is updated. We should\n        never call this method against an existing record.\"\"\"\n        db.put(self)\n        UserActionLog.put_new('add', self, copy_properties=False)\n        note_status = self.status if self.status else 'unspecified'\n        UsageCounter.increment_counter(self.repo, ['note', note_status])\n\nclass NoteWithBadWords(Note):\n    # Spam score given by SpamDetector\n    spam_score = db.FloatProperty(default=0)\n    # True is the note is confirmed by its author through email\n    confirmed = db.BooleanProperty(default=False)\n    # Once the note is confirmed, this field stores the copy of\n    # this note in Note table. It will be useful if we want to\n    # delete the notes with bad words, even when they are confirmed.\n    confirmed_copy_id = db.StringProperty(default='')\n\nclass Photo(db.Model):\n    \"\"\"An uploaded image file.  Key name: repo + ':' + photo_id.\"\"\"\n\n    # Even though the repo is part of the key_name, it is also stored\n    # redundantly as a separate property so it can be indexed and queried upon.\n    repo = db.StringProperty(required=True)\n    image_data = db.BlobProperty()  # sanitized, resized image in PNG format\n    upload_date = db.DateTimeProperty(auto_now_add=True)\n    # thumbnail image in PNG format\n    thumbnail_data = db.BlobProperty(default=None)\n\n    @staticmethod\n    def create(repo, **kwargs):\n        \"\"\"Creates a Photo entity with the given field values.\"\"\"\n        id = UniqueId.create_id()\n        return Photo(key_name='%s:%s' % (repo, id), repo=repo, **kwargs)\n\n    @staticmethod\n    def get(repo, id):\n        return Photo.get_by_key_name('%s:%s' % (repo, id))\n\n\nclass Authorization(db.Model):\n    \"\"\"Authorization keys.  Key name: repo + ':' + auth_key.\"\"\"\n\n    DEFAULT_SETTINGS = dict(contact_name='', contact_email='',\n                            organization_name='', domain_write_permission='',\n                            read_permission=False, full_read_permission=False,\n                            search_permission=True, subscribe_permission=False,\n                            mark_notes_reviewed=False, is_valid=True, key='')\n\n    # Even though the repo is part of the key_name, it is also stored\n    # redundantly as a separate property so it can be indexed and queried upon.\n    repo = db.StringProperty(required=True)\n\n    def summary_str(self):\n        \"\"\"Generates a summary of the key's current state.\n\n        Meant for logging.\n        \"\"\"\n        permissions_list = []\n        for permission_field in ['read_permission',\n                                 'full_read_permission',\n                                 'search_permission',\n                                 'subscribe_permission',\n                                 'mark_notes_reviewed',\n                                 'believed_dead_permission',\n                                 'stats_permission']:\n            if getattr(self, permission_field):\n                permissions_list.append(permission_field)\n        permissions = '; '.join(permissions_list)\n        return ('repo: %(repo)s\\n'\n                'write domain: %(write_domain)s\\n'\n                'permissions: %(permissions)s\\n'\n                'valid: %(valid)s\\n'\n                'contact name: %(contact_name)s\\n'\n                'contact email: %(contact_email)s\\n'\n                'organization name: %(org_name)s') % {\n                    'repo': self.repo,\n                    'write_domain': self.domain_write_permission or 'None',\n                    'permissions': permissions,\n                    'valid': self.is_valid,\n                    'contact_name': self.contact_name,\n                    'contact_email': self.contact_email,\n                    'org_name': self.organization_name,\n                }\n\n    # If this field is non-empty, this authorization token allows the client\n    # to write records with this original domain.\n    domain_write_permission = db.StringProperty()\n\n    # If this flag is true, this authorization token allows the client to read\n    # non-sensitive fields (i.e. filtered by utils.filter_sensitive_fields).\n    read_permission = db.BooleanProperty()\n\n    # If this flag is true, this authorization token allows the client to read\n    # all fields (i.e. not filtered by utils.filter_sensitive_fields).\n    full_read_permission = db.BooleanProperty()\n\n    # If this flag is true, this authorization token allows the client to use\n    # the search API and return non-sensitive fields (i.e. filtered\n    # by utils.filter_sensitive_fields).\n    search_permission = db.BooleanProperty()\n\n    # If this flag is true, this authorization token allows the client to use\n    # the API to subscribe any e-mail address to updates on any person.\n    subscribe_permission = db.BooleanProperty()\n\n    # If this flag is true, notes written with this authorization token are\n    # marked as \"reviewed\" and won't show up in admin's review list.\n    mark_notes_reviewed = db.BooleanProperty()\n\n    # If this flag is true, notes written with this authorization token are\n    # allowed to have status == 'believed_dead'.\n    believed_dead_permission = db.BooleanProperty()\n\n    # If this flag is true, this key can be used to get overall statistics.\n    stats_permission = db.BooleanProperty()\n\n    # If this flag is False, the API access with this key won't be\n    # allowed.\n    is_valid = db.BooleanProperty(default=True)\n\n    # Bookkeeping information for humans, not used programmatically.\n    contact_name = db.StringProperty()\n    contact_email = db.StringProperty()\n    organization_name = db.StringProperty()\n\n    @property\n    def api_key(self):\n        \"\"\"Gets a key value excluding the repo part. \"\"\"\n        if self.has_key():\n            return self.key().name().split(':')[1]\n        return None\n\n    @classmethod\n    def get(cls, repo, key):\n        \"\"\"Gets the Authorization entity for a given repository and key.\"\"\"\n        return cls.get_by_key_name(repo + ':' + key)\n\n    @classmethod\n    def create(cls, repo, key, **kwargs):\n        \"\"\"Creates an Authorization entity for a given repository and key.\"\"\"\n        return cls(key_name=repo + ':' + key, repo=repo, **kwargs)\n\n\nclass ApiKeyManagementLog(db.Model):\n    \"\"\"Log management history for API keys.\"\"\"\n    CREATE = 'create'\n    UPDATE = 'update'\n    DELETE = 'delete'\n    ACTIONS = [CREATE, UPDATE, DELETE]\n\n    user = db.UserProperty(auto_current_user_add=True)\n    timestamp = db.DateTimeProperty(auto_now_add=True)\n    repo = db.StringProperty(required=True)\n    api_key = db.StringProperty(required=True)\n    action = db.StringProperty(required=True, choices=ACTIONS)\n    # The IP address of the admin making the change.\n    ip_address = db.StringProperty()\n    # A string representation of the state of the key after this action.\n    key_state = db.TextProperty()\n\n    @property\n    def authorization(self):\n        return Authorization.get(self.repo, self.api_key)\n\ndef encode_count_name(count_name):\n    \"\"\"Encode a name to printable ASCII characters so it can be safely\n    used as an attribute name for the datastore.\"\"\"\n    encoded = []\n    append = encoded.append\n    for ch in map(ord, count_name):\n        if ch == 92:\n            append('\\\\\\\\')\n        elif 33 <= ch <= 126:\n            append(chr(ch))\n        else:\n            append('\\\\u%04x' % ch)\n    return ''.join(encoded)\n\nclass ApiActionLog(db.Model):\n    \"\"\"Log of api key usage.\"\"\"\n    # actions\n    REPO = 'repo'\n    DELETE = 'delete'\n    READ = 'read'\n    SEARCH = 'search'\n    WRITE = 'write'\n    SUBSCRIBE = 'subscribe'\n    UNSUBSCRIBE = 'unsubscribe'\n    ACTIONS = [REPO, DELETE, READ, SEARCH, WRITE, SUBSCRIBE, UNSUBSCRIBE]\n\n    repo = db.StringProperty()\n    api_key = db.StringProperty()\n    action = db.StringProperty(required=True, choices=ACTIONS)\n    person_records = db.IntegerProperty()\n    note_records = db.IntegerProperty()\n    people_skipped = db.IntegerProperty() # write only\n    notes_skipped = db.IntegerProperty() # write only\n    user_agent = db.StringProperty()\n    ip_address = db.StringProperty() # client ip\n    request_url = db.StringProperty()\n    version = db.StringProperty() # pfif version.\n    timestamp = db.DateTimeProperty(auto_now=True)\n\n    @staticmethod\n    def record_action(repo, api_key, version, action, person_records,\n                      note_records, people_skipped, notes_skipped, user_agent,\n                      ip_address, request_url,\n                      timestamp=None):\n        import utils\n        try:\n            ApiActionLog(repo=repo,\n                         api_key=api_key,\n                         action=action,\n                         person_records=person_records,\n                         note_records=note_records,\n                         people_skipped=people_skipped,\n                         notes_skipped=notes_skipped,\n                         user_agent=user_agent,\n                         ip_address=ip_address,\n                         request_url=request_url,\n                         version=version,\n                         timestamp=timestamp or utils.get_utcnow()).put()\n        except Exception:\n            # swallow anything to prevent the main action from failing.\n            pass\n\nclass Counter(db.Expando):\n    \"\"\"Counters hold partial and completed results for ongoing counting tasks.\n    To see how this is used, check out tasks.py.  A single Counter object can\n    contain several named accumulators.  Typical usage is to scan for entities\n    in order by __key__, update the accumulators for each entity, and save the\n    partial counts when the time limit for a request is reached.  The last\n    scanned key is saved in last_key so the next request can pick up the scan\n    where the last one left off.  A non-empty last_key means a scan is not\n    finished; when a scan is done, last_key should be set to ''.\"\"\"\n    timestamp = db.DateTimeProperty(auto_now=True)\n    scan_name = db.StringProperty()\n    repo = db.StringProperty()\n    last_key = db.StringProperty(default='')  # if non-empty, count is partial\n\n    # Each Counter also has a dynamic property for each accumulator; all such\n    # properties are named \"count_\" followed by a count_name.  The count_name\n    # is encoded to ensure all its characters are printable ASCII.\n    def get(self, count_name):\n        \"\"\"Gets the specified accumulator from this counter object.\"\"\"\n        return getattr(self, 'count_' + encode_count_name(count_name), 0)\n\n    def increment(self, count_name):\n        \"\"\"Increments the given accumulator on this Counter object.\"\"\"\n        prop_name = 'count_' + encode_count_name(count_name)\n        setattr(self, prop_name, getattr(self, prop_name, 0) + 1)\n\n    @classmethod\n    def get_count(cls, repo, name):\n        \"\"\"Gets the latest finished count for the given repository and name.\n        'name' should be in the format scan_name + '.' + count_name.\"\"\"\n        scan_name, count_name = name.split('.')\n        count_name = encode_count_name(count_name)\n        return cls.get_all_counts(repo, scan_name).get(count_name, 0)\n\n    @classmethod\n    def get_all_counts(cls, repo, scan_name):\n        \"\"\"Gets a dictionary of all the counts for the last completed scan\n        for the given repository and scan name.\"\"\"\n        counter_key = repo + ':' + scan_name\n\n        # Get the counts from memcache, loading from datastore if necessary.\n        counter_dict = memcache.get(counter_key)\n        if not counter_dict:\n            try:\n                # Get the latest completed counter with this scan_name.\n                counter = cls.all().filter('repo =', repo\n                                  ).filter('scan_name =', scan_name\n                                  ).filter('last_key =', ''\n                                  ).order('-timestamp').get()\n            except datastore_errors.NeedIndexError:\n                # Absurdly, it can take App Engine up to an hour to build an\n                # index for a kind that has zero entities, and during that time\n                # all queries fail.  Catch this error so we don't get screwed.\n                counter = None\n\n            counter_dict = {}\n            if counter:\n                # Cache the counter's contents in memcache for one minute.\n                counter_dict = dict((name[6:], getattr(counter, name))\n                                    for name in counter.dynamic_properties()\n                                    if name.startswith('count_'))\n                memcache.set(counter_key, counter_dict, 60)\n\n        # Return the dictionary of counts for this scan.\n        return counter_dict\n\n    @classmethod\n    def all_finished_counters(cls, repo, scan_name):\n        \"\"\"Gets a query for all finished counters for the specified scan.\"\"\"\n        return cls.all().filter('repo =', repo\n                       ).filter('scan_name =', scan_name\n                       ).filter('last_key =', '')\n\n    @classmethod\n    def get_unfinished_or_create(cls, repo, scan_name):\n        \"\"\"Gets the latest unfinished Counter entity for the given repository\n        and scan_name.  If there is no unfinished Counter, create a new one.\"\"\"\n        counter = cls.all().filter('repo =', repo\n                          ).filter('scan_name =', scan_name\n                          ).order('-timestamp').get()\n        if not counter or not counter.last_key:\n            counter = Counter(repo=repo, scan_name=scan_name)\n        return counter\n\n\nclass Subscription(db.Model):\n    \"\"\"Subscription to notifications when a note is added to a person record\"\"\"\n    repo = db.StringProperty(required=True)\n    person_record_id = db.StringProperty(required=True)\n    email = db.StringProperty(required=True)\n    language = db.StringProperty(required=True)\n    timestamp = db.DateTimeProperty(auto_now_add=True)\n\n    @staticmethod\n    def create(repo, record_id, email, language):\n        \"\"\"Creates a new Subscription\"\"\"\n        key_name = '%s:%s:%s' % (repo, record_id, email)\n        return Subscription(key_name=key_name, repo=repo,\n                            person_record_id=record_id,\n                            email=email, language=language)\n\n    @staticmethod\n    def get(repo, record_id, email):\n        \"\"\"Gets the entity with the given record_id in a given repository.\"\"\"\n        key_name = '%s:%s:%s' % (repo, record_id, email)\n        return Subscription.get_by_key_name(key_name)\n\n    @staticmethod\n    def get_by_person_record_id(repo, person_record_id, limit=200):\n        \"\"\"Retrieve subscriptions for a person record.\"\"\"\n        query = Subscription.all().filter('repo =', repo)\n        query = query.filter('person_record_id =', person_record_id)\n        return query.fetch(limit)\n\n\nclass UserActionLog(db.Expando):\n    \"\"\"Logs user actions.\"\"\"\n    time = db.DateTimeProperty(required=True)\n    repo = db.StringProperty(required=True)\n    action = db.StringProperty(required=True, choices=[\n        'add', 'delete', 'extend', 'hide', 'mark_dead', 'mark_alive',\n        'restore', 'unhide', 'disable_notes', 'enable_notes'])\n    entity_kind = db.StringProperty(required=True)\n    entity_key_name = db.StringProperty(required=True)\n    detail = db.TextProperty()\n    ip_address = db.StringProperty()\n\n    @classmethod\n    def put_new(cls, action, entity, detail='', ip_address='',\n                copy_properties=True):\n        \"\"\"Adds an entry to the UserActionLog.  'action' is the action that\n        the user performed, 'entity' is the entity that was operated on, and\n        'detail' is a string containing any other details.\"\"\"\n        import utils\n        kind = entity.kind()\n        entry = cls(\n            time=utils.get_utcnow(), repo=entity.repo, action=action,\n            entity_kind=kind, entity_key_name=entity.key().name(),\n            detail=detail, ip_address=ip_address)\n        # copy the properties of the entity\n        if copy_properties:\n            for name in entity.properties():\n                value = getattr(entity, name)\n                if isinstance(value, db.Model):\n                    value = value.key()\n                setattr(entry, kind + '_' + name, value)\n        entry.put()\n\n\nclass StaticSiteMapInfo(db.Model):\n    \"\"\"Holds static sitemaps file info.\"\"\"\n    static_sitemaps = db.StringListProperty()\n    static_sitemaps_generation_time = db.DateTimeProperty(required=True)\n    shard_size_seconds = db.IntegerProperty(default=90)\n\n\nclass SiteMapPingStatus(db.Model):\n    \"\"\"Tracks the last shard index that was pinged to the search engine.\"\"\"\n    search_engine = db.StringProperty(required=True)\n    shard_index = db.IntegerProperty(default=-1)\n\n\nclass UniqueId(db.Model):\n    \"\"\"This entity is used just to generate unique numeric IDs.\"\"\"\n    @staticmethod\n    def create_id():\n        \"\"\"Gets an integer ID that is guaranteed to be different from any ID\n        previously returned by this static method.\"\"\"\n        unique_id = UniqueId()\n        unique_id.put()\n        return unique_id.key().id()\n\nclass UsageCounter(db.Expando):\n    \"\"\"Counters which count the historical statistics for each repository.\n    To see how this is used, check out admin_statistics.py.\n    Unlike the Counter class, UsageCounter object increments when\n    a new record or a new note is created, which means, the UsageCounter\n    will not decrement when a record/note is expired/deleted.\"\"\"\n\n    # repo stored as a seperate property so it can be indexed and queried.\n    repo = db.StringProperty(required=True)\n\n    @classmethod\n    def create(cls, repo):\n        \"\"\"Create a new counter\"\"\"\n        return UsageCounter(key_name=repo, repo=repo)\n\n    @classmethod\n    def get(cls, repo):\n        \"\"\"Gets the entity with a given repository.\"\"\"\n        return UsageCounter.get_by_key_name(repo)\n\n    @classmethod\n    @db.transactional\n    def increment_counter(cls, repo, counter_list, amount=1):\n        \"\"\"Increase the counter for the counter value\n        based on the given amount. Each Counter has a dynamic property\n        and is named based on a given counter_name.\"\"\"\n        counter = cls.get(repo)\n        if not counter:\n            counter = cls.create(repo)\n        for counter_name in counter_list:\n            counter_value = getattr(counter, counter_name, 0)\n            setattr(counter, counter_name, counter_value + amount)\n        counter.put()\n/n/n/napp/urls.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"URL routing module.\"\"\"\n\nfrom django.conf import urls\n\nimport site_settings\nimport tasksmodule.deletion\nimport tasksmodule.sitemap_ping\nimport views.admin.api_keys\nimport views.admin.create_repo\nimport views.admin.statistics\nimport views.meta.sitemap\n\n# We include an optional trailing slash in all the patterns (Django has support\n# for automatic redirection, but we don't want to send people redirect responses\n# if it's not really needed).\n_BASE_URL_PATTERNS = [\n    ('admin_apikeys-list', r'(?P<repo>[^\\/]+)/admin/api_keys/list/?',\n     views.admin.api_keys.ApiKeyListView.as_view),\n    ('admin_apikeys-manage', r'(?P<repo>[^\\/]+)/admin/api_keys/?',\n     views.admin.api_keys.ApiKeyManagementView.as_view),\n    ('admin_create-repo', r'global/admin/create_repo/?',\n     views.admin.create_repo.AdminCreateRepoView.as_view),\n    ('admin_statistics', r'global/admin/statistics/?',\n     views.admin.statistics.AdminStatisticsView.as_view),\n    ('meta_sitemap', r'global/sitemap/?',\n     views.meta.sitemap.SitemapView.as_view),\n    ('tasks_process-expirations',\n     r'(?P<repo>[^\\/]+)/tasks/process_expirations/?',\n     tasksmodule.deletion.ProcessExpirationsTask.as_view),\n    ('tasks_cleanup-stray-notes',\n     r'(?P<repo>[^\\/]+)/tasks/cleanup_stray_notes/?',\n     tasksmodule.deletion.CleanupStrayNotesTask.as_view),\n    ('tasks_cleanup-stray-subscriptions',\n     r'(?P<repo>[^\\/]+)/tasks/cleanup_stray_subscriptions/?',\n     tasksmodule.deletion.CleanupStraySubscriptionsTask.as_view),\n    ('tasks_sitemap-ping', r'global/tasks/sitemap_ping/?',\n     tasksmodule.sitemap_ping.SitemapPingTaskView.as_view),\n]\n\n# pylint: disable=invalid-name\n# Pylint would prefer that this name be uppercased, but Django's going to look\n# for this value in the urls module; it has to be called urlpatterns.\nurlpatterns = [\n    urls.url('^%s$' % path_exp, view_func(), name=name)\n    for (name, path_exp, view_func) in _BASE_URL_PATTERNS\n]\n\nif site_settings.OPTIONAL_PATH_PREFIX:\n    urlpatterns += [\n        urls.url(\n            '^%(prefix)s/%(path)s$' % {\n                'prefix': site_settings.OPTIONAL_PATH_PREFIX,\n                'path': path_exp\n            },\n            view_func(),\n            name='prefixed__%s' % name)\n        for (name, path_exp, view_func) in _BASE_URL_PATTERNS\n    ]\n/n/n/napp/views/admin/api_keys.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"The admin API key pages.\n\nThe way navigation is handled for these pages is a little unintuitive so let me\nexplain:\n - The main entry point to these pages is the list view, which accepts GET\n   requests and returns a view with a) a link to create a new API key (which\n   makes a GET request to the management page) and b) a list of existing pages,\n   each with an \"edit\" button.\n - The list view's \"edit\" buttons make a _POST_ request to send the user to the\n   management page for that key, with the key in a CGI parameter. I'm not\n   exactly sure why that's a POST instead of a GET request, but I would guess\n   it's to keep API keys out of URLs (which would end up in browser histories).\n - When a key is created or edited through the management page, it makes a POST\n   request to itself, which returns a redirect to itself (which becomes a GET\n   request). Consequently, the POST/GET handlers are the opposite of what you\n   might expect: the POST handler handles the initial display of the form, while\n   the GET handler handles what you see afterwards. The GET handler takes the\n   Datastore key for a log entry (via a CGI param), which it uses to get the API\n   key itself by way of the log entry.\n\"\"\"\n\nimport django.core.exceptions\nimport django.shortcuts\nimport django.utils.translation as t\nfrom google.appengine.ext import db\n\nimport model\nimport utils\nimport views.admin.base\n\n\n_API_KEY_LENGTH = 16\n\n\nclass ApiKeyListView(views.admin.base.AdminBaseView):\n    \"\"\"The admin API key list view.\"\"\"\n\n    ACTION_ID = 'admin/api_keys/list'\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"Serves a view with a list of API keys.\"\"\"\n        del request, args, kwargs  # unused\n        auths = model.Authorization.all().filter(\n            'repo = ', self.env.repo or '*')\n        return self.render(\n            'admin_api_keys_list.html',\n            admin_api_keys_url=self.build_absolute_path(\n                '/admin/api_keys', self.env.repo or 'global'),\n            user=self.env.user,\n            user_email=self.env.user.email(),\n            authorizations=auths,\n            xsrf_token=self.xsrf_tool.generate_token(\n               self.env.user.user_id(), 'admin_api_keys'))\n\n\nclass ApiKeyManagementView(views.admin.base.AdminBaseView):\n    \"\"\"The API key management view, for creating or editing keys.\"\"\"\n\n    ACTION_ID = 'admin/api_keys'\n\n    def get_params(self):\n        return views.base.read_params(\n            super(ApiKeyManagementView, self).get_params(),\n            self.request,\n            get_params={\n                'log_key': utils.strip,\n            },\n            post_params={\n                'authorization_key': utils.strip,\n                'believed_dead_permission': utils.validate_checkbox_as_bool,\n                'contact_name': utils.strip,\n                'contact_email': utils.strip,\n                'domain_write_permission': utils.strip,\n                'edit_form': utils.strip,\n                'full_read_permission': utils.validate_checkbox_as_bool,\n                'is_valid': utils.validate_checkbox_as_bool,\n                'key': utils.strip,\n                'mark_notes_reviewed': utils.validate_checkbox_as_bool,\n                'organization_name': utils.strip,\n                'read_permission': utils.validate_checkbox_as_bool,\n                'search_permission': utils.validate_checkbox_as_bool,\n                'stats_permission': utils.validate_checkbox_as_bool,\n                'subscribe_permission': utils.validate_checkbox_as_bool,\n            })\n\n    def get(self, request, *args, **kwargs):\n        if self.params.get('log_key'):\n            management_log_key = self.params.log_key\n            management_log = db.get(management_log_key)\n            message = ''\n            if management_log.action == model.ApiKeyManagementLog.CREATE:\n                message = t.ugettext(\n                    'A new API key has been created successfully.')\n            elif management_log.action == model.ApiKeyManagementLog.UPDATE:\n                message = t.ugettext(\n                    'The API key has been updated successfully.')\n            return self._render_form(management_log.authorization, message)\n        else:\n            return self._render_form()\n\n    def _make_authorization(self, repo, key_str):\n        \"\"\"Creates and stores an Authorization entity with the request's params.\n\n        Args:\n            repo (str): The ID of a repository, or '*' for a global key.\n            key_str (str): The key itself.\n\n        Returns:\n            Authorization: An Authorization entity, already put in Datastore.\n        \"\"\"\n        authorization = model.Authorization.create(\n            repo,\n            key_str,\n            contact_name=self.params.contact_name,\n            contact_email=self.params.contact_email,\n            organization_name=self.params.organization_name,\n            domain_write_permission=self.params.get('domain_write_permission'),\n            read_permission=self.params.get('read_permission'),\n            full_read_permission=self.params.get('full_read_permission'),\n            search_permission=self.params.get('search_permission'),\n            subscribe_permission=self.params.get('subscribe_permission'),\n            mark_notes_reviewed=self.params.get('mark_notes_reviewed'),\n            believed_dead_permission=self.params.get(\n                'believed_dead_permission'),\n            stats_permission=self.params.get('stats_permission'),\n            is_valid=self.params.get('is_valid'))\n        authorization.put()\n        return authorization\n\n    def post(self, request, *args, **kwargs):\n        self.enforce_xsrf('admin_api_keys')\n\n        # Navigation to an individual key's management page is handled by making\n        # a POST request to this view. When it's such a request, the edit_form\n        # param will be set.\n        if self.params.get('edit_form'):\n            authorization = db.get(self.params.get('authorization_key'))\n            if not authorization:\n                return self.error(404, t.ugettext(\n                    'No such Authorization entity.'))\n            return self._render_form(authorization)\n\n        if not (self.params.get('contact_name') and\n                self.params.get('contact_email') and\n                self.params.get('organization_name')):\n            return self.error(400, t.ugettext(\n                'Please fill in all the required fields.'))\n\n        repo = self.env.repo or '*'\n        if self.params.get('key'):\n            # Just override the existing one.\n            existing_authorization = db.get(self.params.get('key'))\n            if not existing_authorization:\n                return self.error(404, t.ugettext(\n                    'No such Authorization entity.'))\n            # This shouldn't happen unless an admin does something funny with\n            # URLs, but check just to be safe.\n            if existing_authorization.repo != repo:\n                return self.error(400, t.ugettext(\n                    'Authorization already exists for another repo! '\n                    'That\\'s not expected.'))\n            key_str = existing_authorization.api_key\n            action = model.ApiKeyManagementLog.UPDATE\n        else:\n            key_str = utils.generate_random_key(_API_KEY_LENGTH)\n            action = model.ApiKeyManagementLog.CREATE\n\n        authorization = self._make_authorization(repo, key_str)\n\n        management_log = model.ApiKeyManagementLog(\n            repo=repo,\n            api_key=authorization.api_key,\n            action=action,\n            ip_address=request.META.get('REMOTE_ADDR'),\n            key_state=authorization.summary_str())\n        management_log.put()\n\n        return django.shortcuts.redirect(\n            self.build_absolute_uri(\n                '/%s/admin/api_keys?repo=%s&log_key=%s' % (\n                    self.env.repo or 'global',\n                    self.env.repo or 'global',\n                    management_log.key())))\n\n    def _render_form(self, authorization=None, message=None):\n        \"\"\"Produces a response with the API key management form.\n\n        Args:\n            authorization (Authorization, optional): An Authorization object. If\n                present, an edit form will be produced; if None, a create form\n                will be produced.\n            message (str, optional): A message to display along with the form.\n\n        Returns:\n            HttpResponse: An HTTP response with the form.\n        \"\"\"\n        if authorization:\n            operation_type = 'update'\n        else:\n            authorization = model.Authorization.DEFAULT_SETTINGS\n            operation_type = 'create'\n        list_url = self.build_absolute_path(\n            '/%s/admin/api_keys/list' % (self.env.repo or 'global'))\n        return self.render(\n            'admin_api_keys.html',\n            user=self.env.user,\n            target_key=authorization,\n            user_email=self.env.user.email(),\n            operation_type=operation_type,\n            message=message,\n            list_url=list_url,\n            xsrf_token=self.xsrf_tool.generate_token(\n                self.env.user.user_id(), 'admin_api_keys'),\n        )\n/n/n/napp/views/admin/base.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Code shared by admin view modules.\"\"\"\n\nimport django.shortcuts\nfrom google.appengine.api import users\n\nimport model\nimport utils\nimport views.base\n\n\nclass AdminBaseView(views.base.BaseView):\n    \"\"\"Base view for admin views.\"\"\"\n\n    class Env(views.base.BaseView.Env):\n        \"\"\"Class to store environment information used by views and templates.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n\n        @property\n        def all_repo_options(self):\n            \"\"\"Gets a list of Structs with repo IDs and URLs.\n\n            Each Struct is expected to have two values:\n            - repo: the repo ID\n            - url: the URL to the repo's admin page\n            \"\"\"\n            return self._all_repo_options\n\n        @all_repo_options.setter\n        def all_repo_options(self, value):\n            self._all_repo_options = value\n\n        @property\n        def logout_url(self):\n            \"\"\"Gets a logout URL for the user.\"\"\"\n            return self._logout_url\n\n        @logout_url.setter\n        def logout_url(self, value):\n            self._logout_url = value\n\n        @property\n        def user(self):\n            \"\"\"Gets a users.User object for the current user, if any.\"\"\"\n            return self._user\n\n        @user.setter\n        def user(self, value):\n            self._user = value\n\n    def setup(self, request, *args, **kwargs):\n        \"\"\"See docs on BaseView.setup.\"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        super(AdminBaseView, self).setup(request, *args, **kwargs)\n        self.env.show_logo = True\n        self.env.enable_javascript = True\n        self.env.user = users.get_current_user()\n        self.env.logout_url = users.create_logout_url(self.build_absolute_uri())\n        self.env.all_repo_options = [\n            utils.Struct(\n                repo=repo, url=self.build_absolute_path('/%s/admin' % repo))\n            for repo in sorted(model.Repo.list())\n        ]\n        self.xsrf_tool = utils.XsrfTool()\n\n    def get_params(self):\n        return views.base.read_params(\n            super(AdminBaseView, self).get_params(),\n            self.request,\n            post_params={'xsrf_token': utils.strip})\n\n    def enforce_xsrf(self, action_id):\n        \"\"\"Verifies the request's XSRF token.\n\n        Checks the request's XSRF token and raises Django's PermissionDenied\n        exception if the request didn't have a token or the token is invalid.\n        As long as it's not caught, this will cause Django to return a 403.\n\n        Args:\n            action_id (str): The action ID used for creating the page's tokens.\n\n        Raises:\n            PermissionDenied: If the request's token is missing or invalid.\n        \"\"\"\n        if not (self.params.get('xsrf_token') and\n                self.xsrf_tool.verify_token(\n                    self.params.get('xsrf_token'),\n                    self.env.user.user_id(),\n                    action_id)):\n            raise django.core.exceptions.PermissionDenied\n\n    def dispatch(self, request, *args, **kwargs):\n        \"\"\"See docs on django.views.View.dispatch.\"\"\"\n        # All the admin pages, and only the admin pages, require the user to be\n        # logged in as an admin.\n        # If we start requiring login for other pages, we should consider\n        # refactoring this into a decorator or something like that.\n        if not self.env.user:\n            return django.shortcuts.redirect(\n                users.create_login_url(self.build_absolute_uri()))\n        if not users.is_current_user_admin():\n            logout_url = users.create_logout_url(self.build_absolute_uri())\n            return self.render(\n                'not_admin_error.html',\n                status_code=403,\n                logout_url=logout_url,\n                user=self.env.user)\n        return super(AdminBaseView, self).dispatch(request, args, kwargs)\n/n/n/napp/views/admin/create_repo.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"The admin create-repo page.\"\"\"\n\nimport django.shortcuts\n\nimport config\nimport const\nimport model\nimport utils\nimport views.admin.base\n\n\nclass AdminCreateRepoView(views.admin.base.AdminBaseView):\n    \"\"\"The admin create-repo view.\"\"\"\n\n    ACTION_ID = 'admin/create_repo'\n\n    def setup(self, request, *args, **kwargs):\n        super(AdminCreateRepoView, self).setup(request, *args, **kwargs)\n\n    def get_params(self):\n        return views.base.read_params(\n            super(AdminCreateRepoView, self).get_params(),\n            self.request,\n            post_params={'new_repo': utils.strip})\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"Serves GET requests.\n\n        Args:\n            request: Unused.\n            *args: Unused.\n            **kwargs: Unused.\n\n        Returns:\n            HttpResponse: A HTTP response with the admin create-repo page.\n        \"\"\"\n        del request, args, kwargs  # unused\n        return self.render(\n            'admin_create_repo.html',\n            xsrf_token=self.xsrf_tool.generate_token(self.env.user.user_id(),\n                                                     self.ACTION_ID))\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"Serves POST requests, creating a new repo.\n\n        Creates a new repository and sets some default values (assuming the user\n        has permission and a valid XSRF token).\n\n        Args:\n            request: Unused.\n            *args: Unused.\n            **kwargs: Unused.\n\n        Returns:\n            HttpResponse: A redirect to the new repo's admin page.\n        \"\"\"\n        del request, args, kwargs  # unused\n        self.enforce_xsrf(self.ACTION_ID)\n        new_repo = self.params.new_repo\n        model.Repo(\n            key_name=new_repo,\n            activation_status=model.Repo.ActivationStatus.STAGING,\n            test_mode=False).put()\n        # Provide some defaults.\n        config.set_for_repo(\n            new_repo,\n            language_menu_options=['en', 'fr'],\n            repo_titles={\n                'en': 'Earthquake',\n                'fr': u'S\\xe9isme'\n            },\n            keywords='person finder, people finder, person, people, ' +\n            'crisis, survivor, family',\n            use_family_name=True,\n            use_alternate_names=True,\n            use_postal_code=True,\n            allow_believed_dead_via_ui=False,\n            min_query_word_length=2,\n            show_profile_entry=False,\n            profile_websites=const.DEFAULT_PROFILE_WEBSITES,\n            map_default_zoom=6,\n            map_default_center=[0, 0],\n            map_size_pixels=[400, 280],\n            read_auth_key_required=True,\n            search_auth_key_required=True,\n            deactivated=False,\n            launched=False,\n            deactivation_message_html='',\n            start_page_custom_htmls={\n                'en': '',\n                'fr': ''\n            },\n            results_page_custom_htmls={\n                'en': '',\n                'fr': ''\n            },\n            view_page_custom_htmls={\n                'en': '',\n                'fr': ''\n            },\n            seek_query_form_custom_htmls={\n                'en': '',\n                'fr': ''\n            },\n            footer_custom_htmls={\n                'en': '',\n                'fr': ''\n            },\n            bad_words='',\n            published_date=utils.get_utcnow_timestamp(),\n            updated_date=utils.get_utcnow_timestamp(),\n            test_mode=False,\n            force_https=True,\n            zero_rating_mode=False,\n            time_zone_offset=0,\n            time_zone_abbreviation='UTC',\n        )\n        return django.shortcuts.redirect(\n            self.build_absolute_path('/%s/admin' % new_repo))\n/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"View-related code common to the whole app.\"\"\"\n\nimport functools\nimport re\n\nimport django.http\nimport django.utils.decorators\nimport django.views\n\nimport config\nimport const\nimport resources\nimport site_settings\nimport utils\n\n\nclass BaseView(django.views.View):\n    \"\"\"Base view class shared across the app.\"\"\"\n\n    # This should be overridden by subclasses.\n    ACTION_ID = None\n\n    class Env(object):\n        \"\"\"Class to store environment information used by views and templates.\n\n        Subclasses of BaseView may define their own Env class (which must be\n        subclasses of BaseView.Env); that Env class (as long as it's called\n        \"Env\") will be used automatically when the env is set up.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        # pylint: disable=too-many-instance-attributes\n\n        @property\n        def action(self):\n            \"\"\"Gets the action ID, an identifier for the page being served.\"\"\"\n            return self._action\n\n        @action.setter\n        def action(self, value):\n            self._action = value\n\n        @property\n        def charset(self):\n            \"\"\"Gets the character encoding being used to serve the page.\"\"\"\n            return self._charset\n\n        @charset.setter\n        def charset(self, value):\n            self._charset = value\n\n        @property\n        def config(self):\n            \"\"\"Gets the config, a config.Config object for the repository.\"\"\"\n            return self._config\n\n        @config.setter\n        def config(self, value):\n            self._config = value\n\n        @property\n        def enable_javascript(self):\n            \"Gets whether or not to enable JavaScript.\" \"\"\n            return self._enable_javascript\n\n        @enable_javascript.setter\n        def enable_javascript(self, value):\n            self._enable_javascript = value\n\n        @property\n        def global_url(self):\n            \"\"\"Gets the URL for the global root.\"\"\"\n            return self._global_url\n\n        @global_url.setter\n        def global_url(self, value):\n            self._global_url = value\n\n        @property\n        def lang(self):\n            \"\"\"Gets the code for the language being used (see const.py).\"\"\"\n            return self._lang\n\n        @lang.setter\n        def lang(self, value):\n            self._lang = value\n\n        @property\n        def repo(self):\n            \"\"\"Gets the repository ID, or None if it's a global page.\"\"\"\n            return self._repo\n\n        @repo.setter\n        def repo(self, value):\n            self._repo = value\n\n        @property\n        def rtl(self):\n            \"\"\"Gets whether the language is a right-to-left language.\"\"\"\n            return self._rtl\n\n        @rtl.setter\n        def rtl(self, value):\n            self._rtl = value\n\n        @property\n        def show_logo(self):\n            \"\"\"Gets whether or not to show the logo in the header.\"\"\"\n            return self._show_logo\n\n        @show_logo.setter\n        def show_logo(self, value):\n            self._show_logo = value\n\n    def setup(self, request, *args, **kwargs):\n        \"\"\"Sets up the handler.\n\n        Views aren't passed any request-specific information when they're\n        initialized, so you can't really do much in __init__. However, having a\n        function that gets called before dispatch is useful for all kinds of\n        things (in particular, it's useful to have a top-down function, where\n        the parent class functions run before those of subclasses). setup() is\n        essentially a substitute for __init__().\n\n        Args:\n            request (HttpRequest): The request object.\n            *args: Unused.\n            **kwargs: Arbitrary keyword arguments. Should include repository ID\n                (under the key 'repo') if applicable.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        # TODO(nworden): don't forget to call super.setup here once we upgrade\n        # to Django 2.2.\n        del request, args  # unused\n\n        # Set up the parameters and read in the base set of parameters.\n        self.params = self.get_params()\n\n        # Set up env variable with data needed by the whole app.\n        self.env = self.Env()\n        self.env.repo = kwargs.get('repo', None)\n        self.env.action = self.ACTION_ID\n        self.env.config = config.Configuration(self.env.repo or '*')\n        # Django will make a guess about what language to use, but Django's\n        # guess should be overridden by the lang CGI param if it's set.\n        # TODO(nworden): figure out how much of the logic below we still need\n        # now that Django can do a lot of the work for us.\n        lang = self.params.get('lang') or self.request.LANGUAGE_CODE\n        lang = re.sub('[^A-Za-z0-9-]', '', lang)\n        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)\n        if lang in const.LANGUAGE_ENDONYMS.keys():\n            self.env.lang = lang\n        else:\n            self.env.lang = (self.env.config.language_menu_options[0]\n                             if self.env.config.language_menu_options else\n                             const.DEFAULT_LANGUAGE_CODE)\n        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI\n        self.env.charset = const.CHARSET_UTF8\n        # TODO(nworden): try to eliminate use of global_url. It doesn't seem\n        # great that templates are building URLs by sticking things onto this.\n        self.env.global_url = self.build_absolute_uri('/global')\n\n    def get_params(self):\n        \"\"\"Gets parameter values out of the request.\n\n        Subclasses that need additional values should override this function,\n        with an implementation like this:\n        return views.base.read_params(\n            super(<Subclass>, self).get_params(),\n            self.request,\n            get_params={'x': validate_x, 'y': validate_y,},\n            post_params={'z': validate_z})\n\n        Returns:\n            utils.Struct: A container with the values of CGI parameters used by\n            this view.\n        \"\"\"\n        return read_params(\n            utils.Struct(), self.request, get_params={'lang': utils.strip})\n\n    def _request_is_for_prefixed_path(self):\n        \"\"\"Checks if the request's path uses an optional path prefix.\"\"\"\n        if not site_settings.OPTIONAL_PATH_PREFIX:\n            return False\n        req_path = self.request.path[1:]  # drop the leading slash\n        if req_path == site_settings.OPTIONAL_PATH_PREFIX:\n            return True\n        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)\n\n    def build_absolute_path(self, path=None, repo=None):\n        \"\"\"Builds an absolute path, including the path prefix if required.\n\n        Django's HttpRequest objects have a similar function, but we implement\n        our own so that we can handle path prefixes correctly when they're in\n        use.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n            repo (str, optional): A repo ID. If specified, the path will be\n                considered relative to the repo's route. If this is specified,\n                path must also be specified.\n\n        Returns:\n            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX\n            if it was used with the original request (e.g.,\n            '/personfinder/abc?x=y'). Does not preserve query parameters from\n            the original request.\n        \"\"\"\n        if path is None:\n            assert not repo\n            # request.path will already include the path prefix if it's being\n            # used.\n            return self.request.path\n        assert path[0] == '/'\n        if repo:\n            path = '/%s%s' % (repo, path)\n        if self._request_is_for_prefixed_path():\n            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)\n        else:\n            return path\n\n    def build_absolute_uri(self, path=None):\n        \"\"\"Builds an absolute URI given a path.\n\n        See build_absolute_path (above) for an explanation of why we implement\n        this function ourselves.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n\n        Returns:\n            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if\n            it was used with the original request (e.g.,\n            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve\n            query parameters from the original request.\n        \"\"\"\n        return self.request.build_absolute_uri(self.build_absolute_path(path))\n\n    def render(self, template_name, status_code=200, **template_vars):\n        \"\"\"Renders a template with the given variables.\n\n        Args:\n            template_name (str): The filename of the template in app/resources.\n            **template_vars: Named variables to pass to the template.\n\n        Returns:\n            HttpResponse: An HttpResponse with the rendered template.\n        \"\"\"\n\n        def get_vars():\n            \"\"\"A function returning vars, for use by the resources module.\"\"\"\n            template_vars['env'] = self.env\n            # TODO(nworden): change templates to access config through env, which\n            # already has the config anyway\n            template_vars['config'] = self.env.config\n            template_vars['params'] = self.params\n            template_vars['csp_nonce'] = self.request.csp_nonce\n            return template_vars\n\n        query_str = self.request.META.get('QUERY_STRING', '')\n        extra_key = (self.env.repo, self.env.charset, query_str)\n        return django.http.HttpResponse(\n            resources.get_rendered(template_name, self.env.lang, extra_key,\n                                   get_vars, 0),\n            status=status_code)\n\n    def error(self, status_code, message=''):\n        \"\"\"Returns an error response.\n\n        Args:\n            status_code (int): The HTTP status code to use.\n            message (str, optional): A message to display. Defaults to the empty\n                string.\n\n        Returns:\n            HttpResponse: An HTTP response with the given status code and\n            message.\n        \"\"\"\n        # pylint: disable=no-self-use\n        # Making this a method of BaseView keeps it consistent with render(),\n        # and probably other similar functions in the future.\n        return django.http.HttpResponse(\n            content=message, content_type='text/plain', status=status_code)\n\n    @django.utils.decorators.classonlymethod\n    def as_view(cls, **initkwargs):\n        # pylint: disable=E,W,R,C\n        # We want to have a setup() function called before dispatch() (see\n        # explanation in the comments on the setup() function), and Django 2.2\n        # has support for it built in. However, we're not on Django 2.2 yet, so\n        # we make the modification to View.as_view() ourselves to get this\n        # feature ahead of time (the code below is just a copy of the original\n        # Django 1.11 View.as_view function, with the setup() call stuck in). We\n        # can clean this up when we upgrade to Django 2.2.\n        \"\"\"Main entry point for a request-response process.\"\"\"\n        for key in initkwargs:\n            if key in cls.http_method_names:\n                raise TypeError(\"You tried to pass in the %s method name as a \"\n                                \"keyword argument to %s(). Don't do that.\" %\n                                (key, cls.__name__))\n            if not hasattr(cls, key):\n                raise TypeError(\n                    \"%s() received an invalid keyword %r. as_view \"\n                    \"only accepts arguments that are already \"\n                    \"attributes of the class.\" % (cls.__name__, key))\n\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            if hasattr(self, 'get') and not hasattr(self, 'head'):\n                self.head = self.get\n            self.request = request\n            self.args = args\n            self.kwargs = kwargs\n            self.setup(request, *args, **kwargs)\n            return self.dispatch(request, *args, **kwargs)\n\n        view.view_class = cls\n        view.view_initkwargs = initkwargs\n\n        # take name and docstring from class\n        functools.update_wrapper(view, cls, updated=())\n\n        # and possible attributes set by decorators\n        # like csrf_exempt from dispatch\n        functools.update_wrapper(view, cls.dispatch, assigned=())\n        return view\n\n\ndef read_params(container,\n                request,\n                get_params=None,\n                post_params=None,\n                file_params=None):\n    \"\"\"Reads CGI parameter values from the request to the container.\n\n    Args:\n        container (utils.Struct): The container to put parameter values in.\n        request (HttpRequest): The request to read from.\n        get_params (dict): A dictionary from GET parameter keys to validator\n            functions.\n        post_params (dict): A dictionary from POST parameter keys to validator\n            functions.\n        file_params (dict): A dictionary from POST parameter keys for uploaded\n            files to validator functions.\n\n    Returns:\n        utils.Struct: The container, for convenience.\n    \"\"\"\n    if request.method == 'GET':\n        if get_params:\n            for key, validator in get_params.items():\n                if key in request.GET:\n                    setattr(container, key, validator(request.GET[key]))\n    elif request.method == 'POST':\n        if post_params:\n            for key, validator in post_params.items():\n                if key in request.POST:\n                    setattr(container, key, validator(request.POST[key]))\n        if file_params:\n            for key, validator in file_params.items():\n                if key in request.FILES:\n                    setattr(container, key, validator(request.FILES[key]))\n    return container\n/n/n/ntests/server_test_cases/api_key_management_tests.py/n/n#!/usr/bin/python2.7\n# encoding: utf-8\n# Copyright 2010 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Test cases for end-to-end testing.  Run with the server_tests script.\"\"\"\n\nimport calendar\nimport datetime\nimport email\nimport email.header\nimport optparse\nimport os\nimport pytest\nimport re\nimport simplejson\nimport sys\nimport tempfile\nimport time\nimport unittest\nimport urlparse\n\nfrom google.appengine.api import images\n\nimport config\nfrom const import ROOT_URL, PERSON_STATUS_TEXT, NOTE_STATUS_TEXT\nimport download_feed\nfrom model import *\nfrom photo import MAX_IMAGE_DIMENSION\nimport remote_api\nfrom resources import Resource, ResourceBundle\nimport reveal\nimport scrape\nimport setup_pf as setup\nfrom test_pfif import text_diff\nfrom text_query import TextQuery\nimport utils\nfrom server_tests_base import ServerTestsBase\n\n\n# TODO(ryok): fix go_as_operator() and re-enable the tests.\n#class ApiKeyManagementTests(ServerTestsBase):\n#    \"\"\"Tests for API key management capabilities.\"\"\"\n#\n#    key_management_operator = \"op@example.com\"\n#    \n#    def go_as_operator(self, path, **kwargs):\n#        \"\"\"Navigates to the given path with an operator login.\"\"\"\n#        if not self.logged_in_as_operator:\n#            scrape.setcookies(self.s.cookiejar, self.hostport,\n#                              ['dev_appserver_login=%s:True:1' %\n#                                  self.key_management_operator])\n#            self.logged_in_as_operator = True\n#        return self.go(path, **kwargs)\n#\n#    def go_as_admin(self, path, **kwargs):\n#        \"\"\"Setting logged_in_as_operator to False.\"\"\"\n#        ret = ServerTestsBase.go_as_admin(self, path, **kwargs)\n#        self.logged_in_as_operator = False\n#        return ret\n#\n#    def setUp(self):\n#        ServerTestsBase.setUp(self)\n#        self.logged_in_as_operator = False\n#        config.set_for_repo(\n#            'japan',\n#            key_management_operators=[self.key_management_operator])\n#\n#    def test_toppage(self):\n#        \"\"\"Check the main page of API kay management.\"\"\"\n#        url = 'http://%s/personfinder/japan/admin/api_keys' % self.hostport\n#        doc = self.go(url, redirects=0)\n#        # check if 302\n#        assert self.s.status == 302\n#        doc = self.go_as_operator(url, redirects=0)\n#        assert self.s.status == 200\n#        assert 'API Key Management' in doc.text\n#        doc = self.go_as_admin(url, redirects=0)\n#        assert self.s.status == 200\n#        assert 'API Key Management' in doc.text\n#\n#    def test_manage_key(self):\n#        \"\"\"Check if a new API key is created/updated correctly.\"\"\"\n#        url = 'http://%s/personfinder/japan/admin/api_keys' % self.hostport\n#        doc = self.go_as_operator(url)\n#        assert self.s.status == 200\n#        assert 'API Key Management' in doc.text\n#        form = doc.cssselect_one('form#create-or-update-api-key')\n#        contact_name = 'Test User'\n#        contact_email = 'user@example.com'\n#        organization_name = 'Example, Inc.'\n#        domain_write_permission = 'example.com'\n#        doc = self.s.submit(\n#            form,\n#            contact_name=contact_name,\n#            contact_email=contact_email,\n#            organization_name=organization_name,\n#            domain_write_permission=domain_write_permission,\n#            read_permission='on',\n#            full_read_permission='on',\n#            search_permission='on',\n#            subscribe_permission='on',\n#            mark_notes_reviewed='on',\n#            is_valid='on',\n#        )\n#        assert 'A new API key has been created successfully.' in doc.text\n#        q = Authorization.all().filter('repo =', 'japan')\n#        authorizations = q.fetch(10)\n#        assert len(authorizations) == 1\n#        authorization = authorizations[0]\n#        # Check if the new key is correct.\n#        assert authorization.contact_name == contact_name\n#        assert authorization.contact_email == contact_email\n#        assert authorization.organization_name == organization_name\n#        assert authorization.domain_write_permission == domain_write_permission\n#        assert authorization.read_permission is True\n#        assert authorization.full_read_permission is True\n#        assert authorization.search_permission is True\n#        assert authorization.subscribe_permission is True\n#        assert authorization.mark_notes_reviewed is True\n#        assert authorization.is_valid is True\n#        # Check if the management self.log is created correctly.\n#        q = ApiKeyManagementLog.all().filter('repo =', 'japan')\n#        logs = q.fetch(10)\n#        assert len(logs) == 1\n#        self.log = logs[0]\n#        assert self.log.user.email() == self.key_management_operator\n#        assert self.log.authorization.key() == authorization.key()\n#        assert self.log.action == ApiKeyManagementLog.CREATE\n#\n#        # List the key and click the edit form on the list\n#        url = 'http://%s/personfinder/japan/admin/api_keys/list' % self.hostport\n#        doc = self.go_as_admin(url)\n#        assert self.s.status == 200\n#        assert 'Listing API keys for japan' in doc.text\n#        form = doc.cssselect_one('form')\n#        doc = self.s.submit(form)\n#        assert self.s.status == 200\n#        assert 'Detailed information of an API key for japan' in doc.text\n#\n#        # Update the key\n#        contact_name = 'Japanese User'\n#        contact_email = 'user@example.jp'\n#        organization_name = 'Example, Corp.'\n#\n#        form = doc.cssselect_one('form')\n#        doc = self.s.submit(\n#            form,\n#            contact_name=contact_name,\n#            contact_email=contact_email,\n#            organization_name=organization_name,\n#            domain_write_permission='',\n#            read_permission='',\n#            full_read_permission='',\n#            search_permission='',\n#            subscribe_permission='',\n#            mark_notes_reviewed='',\n#            is_valid='',\n#            key=str(authorization.key()),\n#        )\n#        assert 'The API key has been updated successfully.' in doc.text\n#        q = Authorization.all().filter('repo =', 'japan')\n#        authorizations = q.fetch(10)\n#        assert len(authorizations) == 1\n#        authorization = authorizations[0]\n#        # Check if the new key is correct.\n#        assert authorization.contact_name == contact_name\n#        assert authorization.contact_email == contact_email\n#        assert authorization.organization_name == organization_name\n#        assert authorization.domain_write_permission == ''\n#        assert authorization.read_permission is False\n#        assert authorization.full_read_permission is False\n#        assert authorization.search_permission is False\n#        assert authorization.subscribe_permission is False\n#        assert authorization.mark_notes_reviewed is False\n#        assert authorization.is_valid is False\n#        # Check if the management self.log is created correctly.\n#        q = ApiKeyManagementLog.all().filter('repo =', 'japan')\n#        logs = q.fetch(10)\n#        assert len(logs) == 2\n#        for self.log in logs:\n#            assert self.log.user.email() == self.key_management_operator\n#            assert self.log.authorization.key() == authorization.key()\n#            if self.log.action != ApiKeyManagementLog.CREATE:\n#                assert self.log.action == ApiKeyManagementLog.UPDATE\n/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Access restriction tests.\"\"\"\n\nimport os\n\nimport django.urls\n\nimport urls\nimport views\n\nimport view_tests_base\n\n\nclass AccessRestrictionTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests that access restrictions are enforced.\"\"\"\n\n    # Dictionary from path name to a boolean indicating whether the page should\n    # be restricted to admins.\n    IS_RESTRICTED_TO_ADMINS = {\n        'admin_apikeys-manage': True,\n        'admin_apikeys-list': True,\n        'admin_create-repo': True,\n        'admin_statistics': True,\n        'meta_sitemap': False,\n    }\n\n    def get_path(self, path_name):\n        # If we ever have URLs with more interesting things in the path besides\n        # repo, we'll have to rethink this.\n        try:\n            return django.urls.reverse(path_name)\n        except django.urls.NoReverseMatch:\n            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})\n\n    def test_blocked_to_non_admins(self):\n        \"\"\"Tests that admin-only pages aren't available to non-admins.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 403\n            assert self.client.post(path, secure=True).status_code == 403\n\n    def test_available_to_admins(self):\n        \"\"\"Tests that admin-only pages are available to admins.\n\n        This is a sort of meta-test: I'm not really concerned that we might\n        accidentally lock admins out of the admin pages, but I do want to make\n        sure that the test above actually depends on the user not being an admin\n        (as opposed to access getting denied because the tests are set up wrong\n        somehow).\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 200\n            # Don't test POST requests here; they'll need an XSRF token and\n            # that'll be covered in a separate test.\n\n    def test_other_pages_unrestricted(self):\n        \"\"\"Tests that non-admins can access unrestricted pages.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: not item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code != 403\n\n    def test_all_paths_included(self):\n        \"\"\"Tests that all (Django-served) pages are listed.\n\n        We want to make sure no one forgets to add these tests for admin pages,\n        so we require that each URL path is included in the dictionary above.\n        \"\"\"\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed__'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            if pattern.name.startswith('tasks_'):\n                # Skip task handlers; they'll be tested separately.\n                # TODO(nworden): test them\n                continue\n            assert (\n                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)\n/n/n/ntests/views/test_admin_api_keys.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Tests for the admin API keys pages.\"\"\"\n\nimport django.http\n\nimport model\n\nimport view_tests_base\n\n\ndef add_test_authorization():\n    authorization = model.Authorization.create(\n        'haiti',\n        'secret_key',\n        contact_name='Bob Vance',\n        contact_email='bob@fridge.com',\n        organization_name='Vance Refrigeration',\n        domain_write_permission='fridge.com',\n        read_permission=True,\n        full_read_permission=True,\n        search_permission=True,\n        subscribe_permission=False,\n        mark_notes_reviewed=False,\n        believed_dead_permission=False,\n        stats_permission=False,\n        is_valid=True)\n    authorization.put()\n    return authorization\n\n\nclass ApiKeyListViewTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests the admin API keys list view.\"\"\"\n\n    def setUp(self):\n        super(ApiKeyListViewTests, self).setUp()\n        model.Repo(key_name='haiti').put()\n        add_test_authorization()\n        self.login(is_admin=True)\n\n    def test_get(self):\n        \"\"\"Tests GET requests.\"\"\"\n        doc = self.to_doc(self.client.get(\n            '/haiti/admin/api_keys/list/', secure=True))\n        self.assertTrue('Bob Vance' in doc.text)\n        self.assertTrue('bob@fridge.com' in doc.text)\n        self.assertTrue('Vance Refrigeration' in doc.text)\n        # The first 10 elements with the \"permissions\" class are the\n        # \"Permissions\" header and the individual permissions column headers.\n        permissions_row = [el.text for el in doc.cssselect('.permission')[10:]]\n        expected_permissions = [\n            'fridge.com', 'x', 'x', 'x', None, None, None, None, 'x']\n        self.assertEqual(permissions_row, expected_permissions)\n\n\nclass ApiKeyManagementViewTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests the API key management view.\"\"\"\n\n    def init_testbed_stubs(self):\n        self.testbed.init_user_stub()\n        self.testbed.init_datastore_v3_stub()\n\n    def setUp(self):\n        super(ApiKeyManagementViewTests, self).setUp()\n        self.login(is_admin=True)\n\n    def test_get_create_form(self):\n        \"\"\"Tests GET requests with no log key (i.e., the creation form).\"\"\"\n        self.authorization = add_test_authorization()\n        res = self.client.get('/haiti/admin/api_keys/', secure=True)\n        self.assertEqual(res.context['target_key'],\n                         model.Authorization.DEFAULT_SETTINGS)\n        self.assertEqual(res.context['operation_type'], 'create')\n\n    def test_get_update_form(self):\n        \"\"\"Tests GET requests with a log key specified (i.e., an update form).\n        \"\"\"\n        self.authorization = add_test_authorization()\n        management_log = model.ApiKeyManagementLog(\n            repo='haiti',\n            api_key=self.authorization.api_key,\n            action=model.ApiKeyManagementLog.CREATE,\n            ip_address='123.45.67.89',\n            key_state=self.authorization.summary_str())\n        management_log.put()\n        res = self.client.get(\n            '/haiti/admin/api_keys/',\n            data={'log_key': management_log.key()},\n            secure=True)\n        self.assertEqual(res.context['target_key'].key(),\n                         self.authorization.key())\n        self.assertEqual(res.context['operation_type'], 'update')\n\n    def test_post_render_update_form(self):\n        \"\"\"Tests POST requests to show the update form.\"\"\"\n        self.authorization = add_test_authorization()\n        params = {\n            'edit_form': '1',\n            'authorization_key': self.authorization.key(),\n            'xsrf_token': self.xsrf_token('admin_api_keys'),\n        }\n        res = self.client.post(\n            '/haiti/admin/api_keys/', data=params, secure=True)\n        self.assertEqual(res.context['target_key'].key(),\n                         self.authorization.key())\n        self.assertEqual(res.context['operation_type'], 'update')\n\n    def test_create_key(self):\n        \"\"\"Tests POST requests to create a new key.\"\"\"\n        params = {\n            'contact_name': 'Creed Bratton',\n            'contact_email': 'creed@aol.com',\n            'organization_name': 'Creed Inc.',\n            'read_permission': 'true',\n            'search_permission': 'true',\n            'is_valid': 'true',\n            'xsrf_token': self.xsrf_token('admin_api_keys'),\n        }\n        res = self.client.post(\n            '/haiti/admin/api_keys/', data=params, secure=True,\n            REMOTE_ADDR='11.22.33.44')\n        # Check that the Authorization entity was generated correctly.\n        auths = model.Authorization.all().filter('repo =', 'haiti')\n        self.assertEqual(auths.count(), 1)\n        auth = auths[0]\n        self.assertEqual(auth.contact_name, 'Creed Bratton')\n        self.assertEqual(auth.contact_email, 'creed@aol.com')\n        self.assertEqual(auth.organization_name, 'Creed Inc.')\n        self.assertTrue(auth.read_permission)\n        self.assertTrue(auth.search_permission)\n        self.assertTrue(auth.is_valid)\n        self.assertIsNone(auth.domain_write_permission)\n        self.assertFalse(auth.full_read_permission)\n        self.assertFalse(auth.subscribe_permission)\n        self.assertFalse(auth.mark_notes_reviewed)\n        self.assertFalse(auth.believed_dead_permission)\n        self.assertFalse(auth.stats_permission)\n        self.assertIsInstance(res, django.http.HttpResponseRedirect)\n        # A management log entry should have been created.\n        management_logs = model.ApiKeyManagementLog.all()\n        self.assertEqual(1, management_logs.count())\n        management_log = management_logs[0]\n        self.assertEqual(management_log.repo, 'haiti')\n        self.assertEqual(management_log.api_key, auth.api_key)\n        self.assertEqual(\n            management_log.action, model.ApiKeyManagementLog.CREATE)\n        self.assertEqual(management_log.ip_address, '11.22.33.44')\n        self.assertTrue('Creed' in management_log.key_state)\n        # The user should be redirected to the form with the log key in a GET\n        # parameter.\n        self.assertEqual(\n            res.url,\n            'https://testserver/haiti/admin/api_keys?repo=haiti&log_key=%s' %\n            management_log.key())\n\n    def test_update_key(self):\n        \"\"\"Tests POST request to update an existing key.\"\"\"\n        self.authorization = add_test_authorization()\n        params = {\n            'key': self.authorization.key(),\n            'contact_name': 'Phyllis Vance',\n            'contact_email': 'phyllis@fridge.com',\n            'organization_name': 'Vance Refrigeration',\n            'domain_write_permission': 'fridge.com',\n            'read_permission': 'true',\n            'full_read_permission': 'true',\n            'search_permission': 'true',\n            'subscribe_permission': 'true',\n            'is_valid': 'true',\n            'xsrf_token': self.xsrf_token('admin_api_keys'),\n        }\n        res = self.client.post(\n            '/haiti/admin/api_keys/', data=params, secure=True,\n            REMOTE_ADDR='11.22.33.44')\n        # Check that the Authorization entity was updated correctly.\n        auths = model.Authorization.all().filter('repo =', 'haiti')\n        self.assertEqual(auths.count(), 1)\n        auth = auths[0]\n        self.assertEqual(auth.key(), self.authorization.key())\n        # Check that changes were made.\n        self.assertEqual(auth.contact_name, 'Phyllis Vance')\n        self.assertEqual(auth.contact_email, 'phyllis@fridge.com')\n        self.assertTrue(auth.subscribe_permission)\n        # A management log entry should have been created.\n        management_logs = model.ApiKeyManagementLog.all()\n        self.assertEqual(1, management_logs.count())\n        management_log = management_logs[0]\n        self.assertEqual(management_log.repo, 'haiti')\n        self.assertEqual(management_log.api_key, auth.api_key)\n        self.assertEqual(\n            management_log.action, model.ApiKeyManagementLog.UPDATE)\n        self.assertEqual(management_log.ip_address, '11.22.33.44')\n        self.assertTrue('Phyllis' in management_log.key_state)\n        # The user should be redirected to the form with the log key in a GET\n        # parameter.\n        self.assertEqual(\n            res.url,\n            'https://testserver/haiti/admin/api_keys?repo=haiti&log_key=%s' %\n            management_log.key())\n/n/n/ntests/views/view_tests_base.py/n/n\"\"\"Tools to help run tests against the Django app.\"\"\"\n\nimport os\nimport unittest\n\nimport django\nimport django.test\nfrom google.appengine.ext import testbed\n\nimport const\nimport utils\n\nimport scrape\n\n\nclass ViewTestsBase(unittest.TestCase):\n    \"\"\"A base class for tests for the Django app.\"\"\"\n\n    _USER_ID = 'k'\n\n    def init_testbed_stubs(self):\n        self.testbed.init_user_stub()\n\n    def setUp(self):\n        self.testbed = testbed.Testbed()\n        self.testbed.activate()\n        self.init_testbed_stubs()\n        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n        django.setup()\n        django.test.utils.setup_test_environment()\n        self.client = django.test.Client()\n        self._xsrf_tool = utils.XsrfTool()\n\n    def tearDown(self):\n        self.testbed.deactivate()\n        django.test.utils.teardown_test_environment()\n\n    def login(self, is_admin=False):\n        \"\"\"Logs in the \"user\" for making requests.\n\n        Args:\n           is_admin (bool): Whether the user should be considered an admin.\n        \"\"\"\n        self.testbed.setup_env(\n            user_email='kay@mib.gov',\n            user_id=ViewTestsBase._USER_ID,\n            user_is_admin='1' if is_admin else '0',\n            overwrite=True)\n\n    def xsrf_token(self, action_id):\n        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)\n\n    def to_doc(self, response):\n        \"\"\"Produces a scrape.Document from the Django test response.\n\n        Args:\n            response (Response): A response from a Django test client.\n\n        Returns:\n            scrape.Document: A wrapper around the response's contents to help\n                with examining it.\n        \"\"\"\n        # TODO(nworden): when everything's on Django, make some changes to\n        # scrape.py so it better fits Django's test framework.\n        return scrape.Document(\n            content_bytes=response.content,\n            # The Django test Response objects don't include the URL, but that's\n            # ok: the Document's url field is only used by scrape.Session, which\n            # we're not using with the Django tests.\n            url=None,\n            status=response.status_code,\n            # We aren't using this, at least not in the Django tests.\n            message=None,\n            # The response headers are accessed directly through the Response\n            # object.\n            headers=response,\n            charset=const.CHARSET_UTF8)\n/n/n/n", "label": 0}, {"id": "fa58bf0d37503c857be1a8cf533e8400d5cdbb6f", "code": "/app/admin_api_keys.py/n/n#!/usr/bin/python2.7\n# Copyright 2013 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport urllib\n\nfrom google.appengine.ext import db\nfrom google.appengine.api import users\n\nfrom model import Authorization, ApiKeyManagementLog\nimport utils\n\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\n\n\nAPI_KEY_LENGTH = 16\nKEYS_PER_PAGE = 50\n\nAUTHORIZATION_PARAMS_LIST = [\n    'contact_name',\n    'contact_email',\n    'organization_name',\n    'domain_write_permission',\n    'read_permission',\n    'full_read_permission',\n    'search_permission',\n    'subscribe_permission',\n    'mark_notes_reviewed',\n    'believed_dead_permission',\n    'stats_permission',\n    'is_valid',\n]\n\ndef to_authorization_params(param):\n    ret = {}\n    for param_name in AUTHORIZATION_PARAMS_LIST:\n        ret[param_name] = getattr(param, param_name)\n    return ret\n\n\nclass ListApiKeys(utils.BaseHandler):\n    \"\"\"\n    A handler for listing API keys for a particular domain.\n    TODO(ryok): implement a search/filter and pagination feature.\n    \"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        user = users.get_current_user()\n        q = Authorization.all().filter('repo =', self.repo or '*')\n        authorizations = q.fetch(KEYS_PER_PAGE)\n        nav_html = ('<a href=\"%s\">%s</a> '\n                    % (self.get_url('admin/api_keys'),\n                       escape(_('Create a new API key'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render('admin_api_keys_list.html',\n                           nav_html=nav_html,\n                           admin_api_keys_url=self.get_url('/admin/api_keys'),\n                           user=user, authorizations=authorizations,\n                           user_email_with_tags=user_email_with_tags,\n                           xsrf_token=xsrf_tool.generate_token(\n                               user.user_id(), 'admin_api_keys'))\n\n\nclass CreateOrUpdateApiKey(utils.BaseHandler):\n    \"\"\"A handler for create/update API keys.\"\"\"\n\n    https_required = True\n    ignore_deactivation = True\n    repo_required = False\n    admin_required = True\n\n    def render_form(self, authorization=None, message=''):\n        \"\"\"Display a form for create/update Authorization\"\"\"\n        user = users.get_current_user()\n        if authorization:\n            operation_name = _('Update an existing key')\n            nav_html = ('<a href=\"%s\">%s</a> '\n                        % (self.get_url('admin/api_keys'),\n                           escape(_('Create a new API key'))))\n        else:\n            authorization = Authorization.DEFAULT_SETTINGS\n            operation_name = _('Create a new API key')\n            nav_html = ''\n\n        nav_html += ('<a href=\"%s\">%s</a>'\n                     % (self.get_url('admin/api_keys/list'),\n                        escape(_('List API keys'))))\n        user_email_with_tags = ('<span class=\"email\">%s</span>'\n                % escape(user.email()))\n        xsrf_tool = utils.XsrfTool()\n        return self.render(\n            'admin_api_keys.html',\n            user=user, target_key=authorization,\n            user_email_with_tags=user_email_with_tags,\n            login_url=users.create_login_url(self.request.url),\n            logout_url=users.create_logout_url(self.request.url),\n            operation_name=operation_name, message=message,\n            nav_html=nav_html,\n            xsrf_token=xsrf_tool.generate_token(\n                user.user_id(), 'admin_api_keys'),\n        )\n\n    @utils.require_api_key_management_permission\n    def get(self):\n        \"\"\"\n        It can be called with a key of ApiKeyManagementLog entity. In\n        such a case, it will show a detailed information of the key in\n        a form for updating the key, otherwise, it will show a form\n        for creating a new API key.\n        \"\"\"\n        management_log_key = self.request.get('log_key')\n        if management_log_key:\n            management_log = db.get(management_log_key)\n            message = ''\n            if management_log.action == ApiKeyManagementLog.CREATE:\n                message = _('A new API key has been created successfully.')\n            elif management_log.action == ApiKeyManagementLog.UPDATE:\n                message = _('The API key has been updated successfully.')\n            return self.render_form(management_log.authorization, message)\n        else:\n            # display a creation form\n            return self.render_form()\n\n    @utils.require_api_key_management_permission\n    def post(self):\n        \"\"\"Handle a post request from the create/update/edit form\"\"\"\n\n        user = users.get_current_user()\n        xsrf_tool = utils.XsrfTool()\n        if not (self.params.xsrf_token and xsrf_tool.verify_token(\n                self.params.xsrf_token, user.user_id(), 'admin_api_keys')):\n            return self.error(403)\n\n        # Handle a form submission from list page\n        if self.request.get('edit_form'):\n            authorization = db.get(self.request.get('authorization_key'))\n            if not authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            return self.render_form(authorization)\n\n        # Handle authorization form submission\n        if not (self.params.contact_name and\n                self.params.contact_email and\n                self.params.organization_name):\n            return self.error(400, _('Please fill in all the required fields.'))\n\n        original_key = self.request.get('key')\n        if original_key:\n            # just override the existing one\n            existing_authorization = db.get(original_key)\n            if not existing_authorization:\n                return self.error(404, _('No such Authorization entity.'))\n            key_str = existing_authorization.api_key\n            action = ApiKeyManagementLog.UPDATE\n        else:\n            key_str = utils.generate_random_key(API_KEY_LENGTH)\n            action = ApiKeyManagementLog.CREATE\n        repo = self.repo or '*'\n\n        authorization = Authorization.create(\n            repo, key_str,\n            **to_authorization_params(self.params))\n        authorization.put()\n\n        management_log = ApiKeyManagementLog(repo=repo,\n                                             api_key=authorization.api_key,\n                                             action=action)\n        management_log.put()\n\n        self.redirect('/admin/api_keys?repo=%s&log_key=%s'\n                      % (self.repo, management_log.key()))\n/n/n/n", "label": 1}, {"id": "5bd28a262e274d24cf802ed6051e6880c7033452", "code": "app/admin_delete_record.py/n/n#!/usr/bin/python2.7\n# Copyright 2016 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom const import *\nfrom model import *\nfrom utils import *\nimport reveal\n\n\nclass Handler(BaseHandler):\n    \"\"\"An admin page to delete person records.\"\"\"\n\n    # After a repository is deactivated, we still need the admin page to be\n    # accessible so we can edit its settings.\n    ignore_deactivation = True\n\n    repo_required = False\n    admin_required = True\n\n    def get(self):\n        xsrf_tool = XsrfTool()\n        user = users.get_current_user()\n        self.render(\n            'admin_delete_record.html',\n            id=self.env.domain + '/person.',\n            xsrf_token=xsrf_tool.generate_token(\n                user.user_id(), 'admin_delete_record'))\n\n    def post(self):\n        xsrf_tool = XsrfTool()\n        user = users.get_current_user()\n        if not (self.params.xsrf_token and xsrf_tool.verify_token(\n                    self.params.xsrf_token, user.user_id(),\n                    'admin_delete_record')):\n            self.error(403)\n            return False\n        # Redirect to the deletion handler with a valid signature.\n        action = ('delete', str(self.params.id))\n        self.redirect('/delete', id=self.params.id,\n                      signature=reveal.sign(action))\n/n/n/napp/main.py/n/n#!/usr/bin/python2.7\n# Copyright 2010 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"The main request handler. All dynamic requests except for remote_api are\nhandled by this handler, which dispatches to all other dynamic handlers.\"\"\"\n\nimport django_setup  # always keep this first\n\nimport mimetypes\nimport re\nimport os\n\nimport urlparse\n\nfrom google.appengine.api import memcache\nfrom google.appengine.api import users\nfrom google.appengine.ext import webapp\n\nimport config\nimport const\nimport django.utils.html\nimport logging\nimport model\nimport pfif\nimport resources\nimport utils\nimport user_agents\nimport setup_pf\n\n\n# When no action or repo is specified, redirect to this action.\nHOME_ACTION = 'home.html'\n\n# Map of URL actions to Python module and class names.\n# TODO(kpy): Remove the need for this configuration information, either by\n# regularizing the module and class names or adding a URL attribute to handlers.\nHANDLER_CLASSES = dict((x, x.replace('/', '_') + '.Handler') for x in [\n  'start',\n  'amp_start',\n  'query',\n  'results',\n  'create',\n  'view',\n  'multiview',\n  'reveal',\n  'photo',\n  'embed',\n  'extend',\n  'gadget',\n  'delete',\n  'flag_note',\n  'restore',\n  'subscribe',\n  'unsubscribe',\n  'disable_notes',\n  'confirm_disable_notes',\n  'enable_notes',\n  'confirm_enable_notes',\n  'post_flagged_note',\n  'confirm_post_flagged_note',\n  'third_party_search',\n  'admin',\n  'admin/create_repo',\n  'admin/dashboard',\n  'admin/resources',\n  'admin/review',\n  'css',\n  'add_note',\n  'tos',\n])\n\n# Exceptional cases where the module name doesn't match the URL.\nHANDLER_CLASSES[''] = 'start.Handler'\nHANDLER_CLASSES['admin/api_keys'] = 'admin_api_keys.CreateOrUpdateApiKey'\nHANDLER_CLASSES['admin/api_keys/list'] = 'admin_api_keys.ListApiKeys'\nHANDLER_CLASSES['api/import'] = 'api.Import'\nHANDLER_CLASSES['api/import/notes'] = 'api.Import'\nHANDLER_CLASSES['api/import/persons'] = 'api.Import'\nHANDLER_CLASSES['api/read'] = 'api.Read'\nHANDLER_CLASSES['api/write'] = 'api.Write'\nHANDLER_CLASSES['api/search'] = 'api.Search'\nHANDLER_CLASSES['api/subscribe'] = 'api.Subscribe'\nHANDLER_CLASSES['api/unsubscribe'] = 'api.Unsubscribe'\nHANDLER_CLASSES['api/stats'] = 'api.Stats'\nHANDLER_CLASSES['api/handle_sms'] = 'api.HandleSMS'\nHANDLER_CLASSES['api/photo_upload'] = 'api.PhotoUpload'\nHANDLER_CLASSES['feeds/repo'] = 'feeds.Repo'\nHANDLER_CLASSES['feeds/note'] = 'feeds.Note'\nHANDLER_CLASSES['feeds/person'] = 'feeds.Person'\nHANDLER_CLASSES['tasks/count/note'] = 'tasks.CountNote'\nHANDLER_CLASSES['tasks/count/person'] = 'tasks.CountPerson'\nHANDLER_CLASSES['tasks/count/reindex'] = 'tasks.Reindex'\nHANDLER_CLASSES['tasks/count/update_dead_status'] = 'tasks.UpdateDeadStatus'\nHANDLER_CLASSES['tasks/count/update_status'] = 'tasks.UpdateStatus'\nHANDLER_CLASSES['tasks/delete_expired'] = 'tasks.DeleteExpired'\nHANDLER_CLASSES['tasks/delete_old'] = 'tasks.DeleteOld'\nHANDLER_CLASSES['tasks/dump_csv'] = 'tasks.DumpCSV'\nHANDLER_CLASSES['tasks/clean_up_in_test_mode'] = 'tasks.CleanUpInTestMode'\nHANDLER_CLASSES['tasks/notify_many_unreviewed_notes'] = 'tasks.NotifyManyUnreviewedNotes'\nHANDLER_CLASSES['tasks/thumbnail_preparer'] = 'tasks.ThumbnailPreparer'\nif config.get('enable_react_ui'):\n    HANDLER_CLASSES['d/create'] = 'frontend_api.Create'\n    HANDLER_CLASSES['d/person'] = 'frontend_api.Person'\n    HANDLER_CLASSES['d/repo'] = 'frontend_api.Repo'\n    HANDLER_CLASSES['d/results'] = 'frontend_api.Results'\n\nNON_REACT_UI_PATHS = ['api/', 'admin/', 'feeds/', 'sitemap', 'tasks/', 'd/']\n\ndef is_development_server():\n    \"\"\"Returns True if the app is running in development.\"\"\"\n    server = os.environ.get('SERVER_SOFTWARE', '')\n    return 'Development' in server\n\ndef is_cron_task(request):\n    \"\"\"Returns True if the request is from appengine cron.\"\"\"\n    return 'X-AppEngine-Cron' in request.headers\n\ndef is_task_queue_task(request):\n    \"\"\"Returns True if the request is from the appengine task queue.\"\"\"\n    return 'X-AppEngine-TaskName' in request.headers\n\ndef get_repo_and_action(request):\n    \"\"\"Determines the repo and action for a request.  The action is the part\n    of the URL path after the repo, with no leading or trailing slashes.\"\"\"\n    scheme, netloc, path, _, _ = urlparse.urlsplit(request.url)\n    parts = path.lstrip('/').split('/')\n\n    # Depending on whether we're serving from appspot directly or\n    # google.org/personfinder we could have /global or /personfinder/global\n    # as the 'global' prefix.\n    if parts[0] == 'personfinder':\n        parts.pop(0)\n    repo = parts and parts.pop(0) or None\n    action = '/'.join(parts)\n    if repo == 'global':\n        repo = None\n    return repo, action\n\ndef select_charset(request):\n    \"\"\"Given a request, chooses a charset for encoding the response.\n\n    If the selected charset is UTF-8, it always returns\n    'utf-8' (const.CHARSET_UTF8), not 'utf8', 'UTF-8', etc.\n\n    For now, we always use UTF-8, because supporting anything else with WebOB\n    1.2.3 and webapp2 is impractical. We might revisit this once we migrate to\n    Django, with which it shouldn't be so difficult to support other character\n    sets.\n    \"\"\"\n    return const.CHARSET_UTF8\n\ndef select_lang(request, config=None):\n    \"\"\"Selects the best language to use for a given request.  The 'lang' query\n    parameter has priority, then the django_language cookie, then\n    'Accept-Language' HTTP header, then the first language in the language menu,\n    then the default setting.\"\"\"\n    default_lang = (\n        (config and\n         config.language_menu_options and\n         config.language_menu_options[0]) or\n            const.DEFAULT_LANGUAGE_CODE)\n    lang = (request.get('lang') or\n            request.cookies.get('django_language', None) or\n            select_lang_from_header(request, default_lang=default_lang))\n    lang = re.sub('[^A-Za-z0-9-]', '', lang)\n    lang = const.LANGUAGE_SYNONYMS.get(lang, lang)\n    if lang in const.LANGUAGE_ENDONYMS.keys():\n        return lang\n    else:\n        return default_lang\n\ndef select_lang_from_header(request, default_lang):\n    \"\"\"Selects the best language matching 'Accept-Language' HTTP header.\"\"\"\n    # Either of the first item in the first argument or the default_match\n    # argument is used as the default depending on the situation. So we need to\n    # put the default language to both. See:\n    #   https://docs.pylonsproject.org/projects/webob/en/stable/api/webob.html#webob.acceptparse.AcceptLanguageValidHeader.best_match\n    #   https://docs.pylonsproject.org/projects/webob/en/stable/api/webob.html#webob.acceptparse.AcceptLanguageNoHeader.best_match\n    return request.accept_language.best_match(\n        [default_lang] + const.LANGUAGE_ENDONYMS.keys(),\n        default_match=default_lang)\n\ndef get_repo_options(request, lang):\n    \"\"\"Returns a list of the names and titles of the launched repositories.\"\"\"\n    options = []\n    for repo in model.Repo.list_launched():\n        titles = config.get_for_repo(repo, 'repo_titles', {})\n        default_title = (titles.values() or ['?'])[0]\n        title = titles.get(lang, titles.get('en', default_title))\n        url = utils.get_repo_url(request, repo)\n        test_mode = config.get_for_repo(repo, 'test_mode')\n        options.append(utils.Struct(repo=repo, title=title, url=url,\n                                    test_mode=test_mode))\n    return options\n\ndef get_language_options(request, config, current_lang):\n    \"\"\"Returns a list of information needed to generate the language menu.\"\"\"\n    primary_langs = (config and config.language_menu_options) or ['en']\n    all_langs = sorted(\n        const.LANGUAGE_ENDONYMS.keys(),\n        key=lambda s: const.LANGUAGE_ENDONYMS[s])\n    return {\n        'primary':\n            [get_language_option(request, lang, lang == current_lang)\n             for lang in primary_langs],\n        'all':\n            # We put both 'primary' and 'all' languages into a single <select>\n            # box (See app/resources/language-menu.html.template).\n            # If current_lang is in the primary languages, we mark the\n            # language as is_selected in 'primary', not in 'all', to make sure\n            # a single option is selected in the <select> box.\n            [get_language_option(\n                request, lang,\n                lang == current_lang and lang not in primary_langs)\n             for lang in all_langs],\n    }\n\ndef get_language_option(request, lang, is_selected):\n    return {\n        'lang': lang,\n        'endonym': const.LANGUAGE_ENDONYMS.get(lang, '?'),\n        'url': utils.set_url_param(request.url, 'lang', lang),\n        'is_selected': is_selected,\n    }\n\ndef get_localized_message(localized_messages, lang, default):\n    \"\"\"Gets the localized message for lang from a dictionary that maps language\n    codes to localized messages.  Falls back to English if language 'lang' is\n    not available, or to a default message if English is not available.\"\"\"\n    if not isinstance(localized_messages, dict):\n        return default\n    return localized_messages.get(lang, localized_messages.get('en', default))\n\ndef get_hidden_input_tags_for_preserved_query_params(request):\n    \"\"\"Gets HTML with <input type=\"hidden\"> tags to preserve query parameters\n    listed in utils.PRESERVED_QUERY_PARAM_NAMES e.g. \"ui\".\"\"\"\n    tags_str = ''\n    for name in utils.PRESERVED_QUERY_PARAM_NAMES:\n        value = request.get(name)\n        if value:\n            tags_str += '<input type=\"hidden\" name=\"%s\" value=\"%s\">\\n' % (\n                django.utils.html.escape(name),\n                django.utils.html.escape(value))\n    return tags_str\n\ndef setup_env(request):\n    \"\"\"Constructs the 'env' object, which contains various template variables\n    that are commonly used by most handlers.\"\"\"\n    env = utils.Struct()\n    env.repo, env.action = get_repo_and_action(request)\n    env.config = config.Configuration(env.repo or '*')\n\n    env.analytics_id = env.config.get('analytics_id')\n    env.amp_gtm_id = env.config.get('amp_gtm_id')\n    env.maps_api_key = env.config.get('maps_api_key')\n\n    # Internationalization-related stuff.\n    env.charset = select_charset(request)\n    env.lang = select_lang(request, env.config)\n    env.rtl = env.lang in const.LANGUAGES_BIDI\n\n    # Determine the resource bundle to use.\n    env.default_resource_bundle = env.config.get('default_resource_bundle', '1')\n    env.resource_bundle = (request.cookies.get('resource_bundle', '') or\n                           env.default_resource_bundle)\n\n    # Information about the request.\n    env.url = utils.set_url_param(request.url, 'lang', env.lang)\n    env.scheme, env.netloc, env.path, _, _ = urlparse.urlsplit(request.url)\n    env.force_https = True\n    env.domain = env.netloc.split(':')[0]\n    env.global_url = utils.get_repo_url(request, 'global')\n\n    # Commonly used information that's rendered or localized for templates.\n    env.language_options = get_language_options(request, env.config, env.lang)\n    env.repo_options = get_repo_options(request, env.lang)\n    env.expiry_options = [\n        utils.Struct(value=value, text=const.PERSON_EXPIRY_TEXT[value])\n        for value in sorted(const.PERSON_EXPIRY_TEXT.keys(), key=int)\n    ]\n    env.status_options = [\n        utils.Struct(value=value, text=const.NOTE_STATUS_TEXT[value])\n        for value in pfif.NOTE_STATUS_VALUES\n        if (value != 'believed_dead' or\n            not env.config or env.config.allow_believed_dead_via_ui)\n    ]\n    env.hidden_input_tags_for_preserved_query_params = (\n        get_hidden_input_tags_for_preserved_query_params(request))\n\n    ui_param = request.get('ui', '').strip().lower()\n\n    # Interprets \"small\" and \"style\" parameters for backward compatibility.\n    # TODO(ichikawa): Delete these in near future when we decide to drop\n    # support of these parameters.\n    small_param = request.get('small', '').strip().lower()\n    style_param = request.get('style', '').strip().lower()\n    if not ui_param and small_param == 'yes':\n        ui_param = 'small'\n    elif not ui_param and style_param:\n        ui_param = style_param\n\n    if ui_param:\n        env.ui = ui_param\n    elif user_agents.is_jp_tier2_mobile_phone(request):\n        env.ui = 'light'\n    else:\n        env.ui = 'default'\n\n    # UI configurations.\n    #\n    # Enables features which require JavaScript.\n    env.enable_javascript = True\n    # Enables operations which requires Captcha.\n    env.enable_captcha = True\n    # Enables photo upload.\n    env.enable_photo_upload = True\n    # Enables to flag/unflag notes as spam, and to reveal spam notes.\n    env.enable_spam_ops = True\n    # Enables duplicate marking mode.\n    env.enable_dup_mode = True\n    # Shows a logo on top of the page.\n    env.show_logo = True\n    # Shows language menu.\n    env.show_language_menu = True\n    # Uses short labels for buttons.\n    env.use_short_buttons = False\n    # Optional \"target\" attribute for links to non-small pages.\n    env.target_attr = ''\n    # Shows record IDs in the results page.\n    env.show_record_ids_in_results = True\n    # Shows non AMP HTML pages by default.\n    env.amp = False\n\n    if env.ui == 'small':\n        env.show_logo = False\n        env.target_attr = ' target=\"_blank\" '\n\n    elif env.ui == 'light':\n        # Disables features which requires JavaScript. Some feature phones\n        # doesn't support JavaScript.\n        env.enable_javascript = False\n        # Disables operations which requires Captcha because Captcha requires\n        # JavaScript.\n        env.enable_captcha = False\n        # Uploading is often not supported in feature phones.\n        env.enable_photo_upload = False\n        # Disables spam operations because it requires JavaScript and\n        # supporting more pages on ui=light.\n        env.enable_spam_ops = False\n        # Disables duplicate marking mode because it doesn't support\n        # small screens and it requires JavaScript.\n        env.enable_dup_mode = False\n        # Hides the logo on the top to save the space. Also, the logo links\n        # to the global page which doesn't support small screens.\n        env.show_logo = False\n        # Hides language menu because the menu in the current position is\n        # annoying in feature phones.\n        # TODO(ichikawa): Consider layout of the language menu.\n        env.show_language_menu = False\n        # Too long buttons are not fully shown in some feature phones.\n        env.use_short_buttons = True\n        # To make it simple.\n        env.show_record_ids_in_results = False\n\n    env.back_chevron = u'\\xab'\n    back_chevron_in_charset = True\n    try:\n        env.back_chevron.encode(env.charset)\n    except UnicodeEncodeError:\n        # u'\\xab' is not in the charset (e.g. Shift_JIS).\n        back_chevron_in_charset = False\n    if not back_chevron_in_charset or env.ui == 'light':\n        # Use ASCII characters on ui=light too because some feature phones\n        # support UTF-8 but don't render UTF-8 symbols such as u'\\xab'.\n        env.back_chevron = u'<<'\n\n    env.enable_maps = (\n        env.enable_javascript\n        and not env.config.zero_rating_mode\n        and env.maps_api_key)\n    env.enable_analytics = (\n        env.enable_javascript\n        and not env.config.zero_rating_mode\n        and env.analytics_id)\n    env.enable_translate = (\n        env.enable_javascript\n        and not env.config.zero_rating_mode\n        and env.config.translate_api_key)\n\n    # Repo-specific information.\n    if env.repo:\n        # repo_url is the root URL for the repository.\n        env.repo_url = utils.get_repo_url(request, env.repo)\n        # start_url is like repo_url but preserves parameters such as 'ui'.\n        env.start_url = utils.get_url(request, env.repo, '')\n        # URL of the link in the heading. The link on ui=small links to the\n        # normal UI.\n        env.repo_title_url = (\n            env.repo_url if env.ui == 'small' else env.start_url)\n        # URL to force default UI. Note that we show ui=light version in some\n        # user agents when ui parameter is not specified.\n        env.default_ui_url = utils.get_url(request, env.repo, '', ui='default')\n        env.repo_path = urlparse.urlsplit(env.repo_url)[2]\n        env.repo_title = get_localized_message(\n            env.config.repo_titles, env.lang, '?')\n        env.start_page_custom_html = get_localized_message(\n            env.config.start_page_custom_htmls, env.lang, '')\n        env.results_page_custom_html = get_localized_message(\n            env.config.results_page_custom_htmls, env.lang, '')\n        env.view_page_custom_html = get_localized_message(\n            env.config.view_page_custom_htmls, env.lang, '')\n        env.seek_query_form_custom_html = get_localized_message(\n            env.config.seek_query_form_custom_htmls, env.lang, '')\n        env.footer_custom_html = get_localized_message(\n            env.config.footer_custom_htmls, env.lang, '')\n        # If the repository is deactivated, we should not show test mode\n        # notification.\n        env.repo_test_mode = (\n            env.config.test_mode and not env.config.deactivated)\n        env.force_https = env.config.force_https\n\n        env.params_full_name = request.get('full_name', '').strip()\n        if not env.params_full_name:\n            # Preformat the name from 'given_name' and 'family_name' parameters.\n            given_name = request.get('given_name', '').strip()\n            family_name = request.get('family_name', '').strip()\n            env.params_full_name = utils.get_full_name(\n                given_name, family_name, env.config)\n\n    return env\n\ndef flush_caches(*keywords):\n    \"\"\"Flushes the specified set of caches.  Pass '*' to flush everything.\"\"\"\n    if '*' in keywords or 'resource' in keywords:\n       resources.clear_caches()\n    if '*' in keywords or 'memcache' in keywords:\n       memcache.flush_all()\n    if '*' in keywords or 'config' in keywords:\n       config.cache.flush()\n    for keyword in keywords:\n        if keyword.startswith('config/'):\n            config.cache.delete(keyword[7:])\n\n\nclass Main(webapp.RequestHandler):\n    \"\"\"The main request handler.  All dynamic requests except for remote_api are\n    handled by this handler, which dispatches to all other dynamic handlers.\"\"\"\n\n    def initialize(self, request, response):\n        webapp.RequestHandler.initialize(self, request, response)\n\n        # If requested, set the clock before doing anything clock-related.\n        # Only works on localhost for testing.  Specify ?utcnow=1293840000 to\n        # set the clock to 2011-01-01, or ?utcnow=real to revert to real time.\n        utcnow = request.get('utcnow')\n        if request.remote_addr == '127.0.0.1' and utcnow:\n            if utcnow == 'real':\n                utils.set_utcnow_for_test(None)\n            else:\n                utils.set_utcnow_for_test(float(utcnow))\n\n        # If requested, flush caches before we touch anything that uses them.\n        # This is used for certain tests.\n        if utils.is_dev_app_server():\n            flush_caches(*request.get('flush', '').split(','))\n\n        # Gather commonly used information into self.env.\n        self.env = setup_env(request)\n\n        # Force a redirect if requested, except where https is not supported:\n        # - for cron jobs\n        # - for task queue jobs\n        # - in development\n        if (self.env.force_https and self.env.scheme == 'http'\n            and not is_cron_task(self.request)\n            and not is_task_queue_task(self.request)\n            and not is_development_server()):\n            self.redirect(self.env.url.replace('http:', 'https:'))\n\n        # Activate the selected language.\n        response.headers['Content-Language'] = self.env.lang\n        response.headers['Set-Cookie'] = \\\n            'django_language=%s; path=/' % self.env.lang\n        django_setup.activate(self.env.lang)\n\n        # Activate the appropriate resource bundle.\n        resources.set_active_bundle_name(self.env.resource_bundle)\n\n    def should_serve_react_ui(self):\n        for path_prefix in NON_REACT_UI_PATHS:\n            if self.env.action.startswith(path_prefix):\n                return False\n        return True\n\n    def set_content_security_policy(self):\n        \"\"\"Sets the CSP in the headers. Returns the nonce to use for scripts.\"\"\"\n        csp_nonce = utils.generate_random_key(20)\n        csp_value = (\n            'object-src \\'none\\'; '\n            'script-src \\'nonce-%s\\' \\'unsafe-inline\\' '\n            '\\'strict-dynamic\\' https: http:; '\n            'base-uri \\'none\\';'\n        ) % csp_nonce\n        self.response.headers['Content-Security-Policy'] = csp_value\n        return csp_nonce\n\n    def serve(self):\n        request, response, env = self.request, self.response, self.env\n\n        # If the Person Finder instance has not been initialized yet,\n        # prepend to any served page a warning and a link to the admin\n        # page where the datastore can be initialized.\n        if not env.config.get('initialized'):\n            if request.get('operation') == 'setup_datastore':\n                setup_pf.setup_datastore()\n                self.redirect(env.global_url + '/')\n                return\n            else:\n                get_vars = lambda: {'env': env}\n                content = resources.get_rendered('setup_datastore.html', env.lang,\n                        (env.repo, env.charset), get_vars)\n                response.out.write(content)\n\n        if env.config.get('enable_react_ui'):\n            # TODO(nworden): serve static files from /global/static\n            if env.repo == 'static':\n                self.serve_static_content(self.env.action)\n            elif self.should_serve_react_ui():\n                csp_nonce = self.set_content_security_policy()\n                response.out.write(\n                    resources.get_rendered(\n                        'react_index.html', env.lang,\n                        get_vars=lambda: {'env': env, 'csp_nonce': csp_nonce}))\n                return\n\n        if not env.action and not env.repo:\n            # A request for the root path ('/'). Renders the home page.\n            self.serve_static_content(HOME_ACTION)\n        elif env.action in HANDLER_CLASSES:\n            # Dispatch to the handler for the specified action.\n            module_name, class_name = HANDLER_CLASSES[env.action].split('.')\n            handler = getattr(__import__(module_name), class_name)(\n                request, response, env)\n            getattr(handler, request.method.lower())()  # get() or post()\n        elif env.action.endswith('.template'):\n            # Don't serve template source code.\n            response.set_status(404)\n            response.out.write('Not found')\n        else:\n            self.serve_static_content(self.env.action)\n\n    def serve_static_content(self, resource_name):\n        \"\"\"Serve a static page or file in app/resources/static directory.\"\"\"\n        response, env = self.response, self.env\n        env.robots_ok = True\n        get_vars = lambda: {'env': env, 'config': env.config}\n        content = resources.get_rendered(\n            'static/%s' % resource_name,\n            env.lang,\n            (env.repo, env.charset),\n            get_vars)\n        if content is None:\n            response.set_status(404)\n            response.out.write('Not found')\n        else:\n            content_type, encoding = mimetypes.guess_type(resource_name)\n            response.headers['Content-Type'] = (\n                    (content_type or 'text/plain') +\n                    ('; charset=%s' % encoding if encoding else ''))\n            response.out.write(content)\n\n    def get(self):\n        self.serve()\n\n    def post(self):\n        self.serve()\n\n    def head(self):\n        self.request.method = 'GET'\n        self.serve()\n        self.response.clear()\n\nif __name__ == '__main__':\n    webapp.util.run_wsgi_app(webapp.WSGIApplication([('.*', Main)]))\n/n/n/napp/urls.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"URL routing module.\"\"\"\n\nfrom django.conf import urls\n\nimport site_settings\nimport tasksmodule.deletion\nimport tasksmodule.sitemap_ping\nimport views.admin.api_keys\nimport views.admin.create_repo\nimport views.admin.delete_record\nimport views.admin.statistics\nimport views.meta.sitemap\n\n# We include an optional trailing slash in all the patterns (Django has support\n# for automatic redirection, but we don't want to send people redirect responses\n# if it's not really needed).\n_BASE_URL_PATTERNS = [\n    ('admin_apikeys-list', r'(?P<repo>[^\\/]+)/admin/api_keys/list/?',\n     views.admin.api_keys.ApiKeyListView.as_view),\n    ('admin_apikeys-manage', r'(?P<repo>[^\\/]+)/admin/api_keys/?',\n     views.admin.api_keys.ApiKeyManagementView.as_view),\n    ('admin_create-repo', r'global/admin/create_repo/?',\n     views.admin.create_repo.AdminCreateRepoView.as_view),\n    ('admin_delete-record', r'(?P<repo>[^\\/]+)/admin/delete_record/?',\n     views.admin.delete_record.AdminDeleteRecordView.as_view),\n    ('admin_statistics', r'global/admin/statistics/?',\n     views.admin.statistics.AdminStatisticsView.as_view),\n    ('meta_sitemap', r'global/sitemap/?',\n     views.meta.sitemap.SitemapView.as_view),\n    ('tasks_process-expirations',\n     r'(?P<repo>[^\\/]+)/tasks/process_expirations/?',\n     tasksmodule.deletion.ProcessExpirationsTask.as_view),\n    ('tasks_cleanup-stray-notes',\n     r'(?P<repo>[^\\/]+)/tasks/cleanup_stray_notes/?',\n     tasksmodule.deletion.CleanupStrayNotesTask.as_view),\n    ('tasks_cleanup-stray-subscriptions',\n     r'(?P<repo>[^\\/]+)/tasks/cleanup_stray_subscriptions/?',\n     tasksmodule.deletion.CleanupStraySubscriptionsTask.as_view),\n    ('tasks_sitemap-ping', r'global/tasks/sitemap_ping/?',\n     tasksmodule.sitemap_ping.SitemapPingTaskView.as_view),\n]\n\n# pylint: disable=invalid-name\n# Pylint would prefer that this name be uppercased, but Django's going to look\n# for this value in the urls module; it has to be called urlpatterns.\nurlpatterns = [\n    urls.url('^%s$' % path_exp, view_func(), name=name)\n    for (name, path_exp, view_func) in _BASE_URL_PATTERNS\n]\n\nif site_settings.OPTIONAL_PATH_PREFIX:\n    urlpatterns += [\n        urls.url(\n            '^%(prefix)s/%(path)s$' % {\n                'prefix': site_settings.OPTIONAL_PATH_PREFIX,\n                'path': path_exp\n            },\n            view_func(),\n            name='prefixed__%s' % name)\n        for (name, path_exp, view_func) in _BASE_URL_PATTERNS\n    ]\n/n/n/napp/views/admin/delete_record.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"The admin delete-record page.\n\nNo deleting is done from this page itself; it's just a way to skip the captcha\non the user-facing deletion page.\n\"\"\"\n\nimport django.shortcuts\n\nimport const\nimport reveal\nimport utils\nimport views.admin.base\n\n\nclass AdminDeleteRecordView(views.admin.base.AdminBaseView):\n    \"\"\"The admin delete-record view.\"\"\"\n\n    ACTION_ID = 'admin/delete_record'\n\n    def setup(self, request, *args, **kwargs):\n        super(AdminDeleteRecordView, self).setup(request, *args, **kwargs)\n\n    def get_params(self):\n        return views.base.read_params(\n            super(AdminDeleteRecordView, self).get_params(),\n            self.request,\n            post_params={'id': utils.strip})\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"Serves GET requests with the deletion form.\"\"\"\n        del request, args, kwargs  # unused\n        return self.render(\n            'admin_delete_record.html',\n            id='%s/person.' % const.HOME_DOMAIN,\n            xsrf_token=self.xsrf_tool.generate_token(self.env.user.user_id(),\n                                                     self.ACTION_ID))\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"Sends the user to the deletion page with a valid signature.\"\"\"\n        del request, args, kwargs  # unused\n        self.enforce_xsrf(self.ACTION_ID)\n        action = ('delete', self.params.id)\n        path = '/delete?' + utils.urlencode(\n            {'id': self.params.id,\n             'signature': reveal.sign(action),})\n        return django.shortcuts.redirect(\n            self.build_absolute_uri(path, self.env.repo))\n/n/n/napp/views/base.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"View-related code common to the whole app.\"\"\"\n\nimport functools\nimport re\n\nimport django.http\nimport django.utils.decorators\nimport django.views\n\nimport config\nimport const\nimport resources\nimport site_settings\nimport utils\n\n\nclass BaseView(django.views.View):\n    \"\"\"Base view class shared across the app.\"\"\"\n\n    # This should be overridden by subclasses.\n    ACTION_ID = None\n\n    class Env(object):\n        \"\"\"Class to store environment information used by views and templates.\n\n        Subclasses of BaseView may define their own Env class (which must be\n        subclasses of BaseView.Env); that Env class (as long as it's called\n        \"Env\") will be used automatically when the env is set up.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        # pylint: disable=too-many-instance-attributes\n\n        @property\n        def action(self):\n            \"\"\"Gets the action ID, an identifier for the page being served.\"\"\"\n            return self._action\n\n        @action.setter\n        def action(self, value):\n            self._action = value\n\n        @property\n        def charset(self):\n            \"\"\"Gets the character encoding being used to serve the page.\"\"\"\n            return self._charset\n\n        @charset.setter\n        def charset(self, value):\n            self._charset = value\n\n        @property\n        def config(self):\n            \"\"\"Gets the config, a config.Config object for the repository.\"\"\"\n            return self._config\n\n        @config.setter\n        def config(self, value):\n            self._config = value\n\n        @property\n        def enable_javascript(self):\n            \"Gets whether or not to enable JavaScript.\" \"\"\n            return self._enable_javascript\n\n        @enable_javascript.setter\n        def enable_javascript(self, value):\n            self._enable_javascript = value\n\n        @property\n        def global_url(self):\n            \"\"\"Gets the URL for the global root.\"\"\"\n            return self._global_url\n\n        @global_url.setter\n        def global_url(self, value):\n            self._global_url = value\n\n        @property\n        def lang(self):\n            \"\"\"Gets the code for the language being used (see const.py).\"\"\"\n            return self._lang\n\n        @lang.setter\n        def lang(self, value):\n            self._lang = value\n\n        @property\n        def repo(self):\n            \"\"\"Gets the repository ID, or None if it's a global page.\"\"\"\n            return self._repo\n\n        @repo.setter\n        def repo(self, value):\n            self._repo = value\n\n        @property\n        def rtl(self):\n            \"\"\"Gets whether the language is a right-to-left language.\"\"\"\n            return self._rtl\n\n        @rtl.setter\n        def rtl(self, value):\n            self._rtl = value\n\n        @property\n        def show_logo(self):\n            \"\"\"Gets whether or not to show the logo in the header.\"\"\"\n            return self._show_logo\n\n        @show_logo.setter\n        def show_logo(self, value):\n            self._show_logo = value\n\n    def setup(self, request, *args, **kwargs):\n        \"\"\"Sets up the handler.\n\n        Views aren't passed any request-specific information when they're\n        initialized, so you can't really do much in __init__. However, having a\n        function that gets called before dispatch is useful for all kinds of\n        things (in particular, it's useful to have a top-down function, where\n        the parent class functions run before those of subclasses). setup() is\n        essentially a substitute for __init__().\n\n        Args:\n            request (HttpRequest): The request object.\n            *args: Unused.\n            **kwargs: Arbitrary keyword arguments. Should include repository ID\n                (under the key 'repo') if applicable.\n        \"\"\"\n        # pylint: disable=attribute-defined-outside-init\n        # TODO(nworden): don't forget to call super.setup here once we upgrade\n        # to Django 2.2.\n        del request, args  # unused\n\n        # Set up the parameters and read in the base set of parameters.\n        self.params = self.get_params()\n\n        # Set up env variable with data needed by the whole app.\n        self.env = self.Env()\n        self.env.repo = kwargs.get('repo', None)\n        self.env.action = self.ACTION_ID\n        self.env.config = config.Configuration(self.env.repo or '*')\n        # Django will make a guess about what language to use, but Django's\n        # guess should be overridden by the lang CGI param if it's set.\n        # TODO(nworden): figure out how much of the logic below we still need\n        # now that Django can do a lot of the work for us.\n        lang = self.params.get('lang') or self.request.LANGUAGE_CODE\n        lang = re.sub('[^A-Za-z0-9-]', '', lang)\n        lang = const.LANGUAGE_SYNONYMS.get(lang, lang)\n        if lang in const.LANGUAGE_ENDONYMS.keys():\n            self.env.lang = lang\n        else:\n            self.env.lang = (self.env.config.language_menu_options[0]\n                             if self.env.config.language_menu_options else\n                             const.DEFAULT_LANGUAGE_CODE)\n        self.env.rtl = self.env.lang in const.LANGUAGES_BIDI\n        self.env.charset = const.CHARSET_UTF8\n        # TODO(nworden): try to eliminate use of global_url. It doesn't seem\n        # great that templates are building URLs by sticking things onto this.\n        self.env.global_url = self.build_absolute_uri('/global')\n\n    def get_params(self):\n        \"\"\"Gets parameter values out of the request.\n\n        Subclasses that need additional values should override this function,\n        with an implementation like this:\n        return views.base.read_params(\n            super(<Subclass>, self).get_params(),\n            self.request,\n            get_params={'x': validate_x, 'y': validate_y,},\n            post_params={'z': validate_z})\n\n        Returns:\n            utils.Struct: A container with the values of CGI parameters used by\n            this view.\n        \"\"\"\n        return read_params(\n            utils.Struct(), self.request, get_params={'lang': utils.strip})\n\n    def _request_is_for_prefixed_path(self):\n        \"\"\"Checks if the request's path uses an optional path prefix.\"\"\"\n        if not site_settings.OPTIONAL_PATH_PREFIX:\n            return False\n        req_path = self.request.path[1:]  # drop the leading slash\n        if req_path == site_settings.OPTIONAL_PATH_PREFIX:\n            return True\n        return req_path.startswith('%s/' % site_settings.OPTIONAL_PATH_PREFIX)\n\n    def build_absolute_path(self, path=None, repo=None):\n        \"\"\"Builds an absolute path, including the path prefix if required.\n\n        Django's HttpRequest objects have a similar function, but we implement\n        our own so that we can handle path prefixes correctly when they're in\n        use.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n            repo (str, optional): A repo ID. If specified, the path will be\n                considered relative to the repo's route. If this is specified,\n                path must also be specified.\n\n        Returns:\n            str: An absolute path, including the sitewide OPTIONAL_PATH_PREFIX\n            if it was used with the original request (e.g.,\n            '/personfinder/abc?x=y'). Does not preserve query parameters from\n            the original request.\n        \"\"\"\n        if path is None:\n            assert not repo\n            # request.path will already include the path prefix if it's being\n            # used.\n            return self.request.path\n        assert path[0] == '/'\n        if repo:\n            path = '/%s%s' % (repo, path)\n        if self._request_is_for_prefixed_path():\n            return '/%s%s' % (site_settings.OPTIONAL_PATH_PREFIX, path)\n        else:\n            return path\n\n    def build_absolute_uri(self, path=None, repo=None):\n        \"\"\"Builds an absolute URI given a path.\n\n        See build_absolute_path (above) for an explanation of why we implement\n        this function ourselves.\n\n        Args:\n            path (str, optional): A path beginning with a slash (may include a\n                query string), e.g., '/abc?x=y'. If the path argument is not\n                specified or is None, the current request's path will be used.\n            repo (str, optional): A repo ID. If specified, the path will be\n                considered relative to the repo's route. If this is specified,\n                path must also be specified.\n\n        Returns:\n            str: An absolute URI, including the sitewide OPTIONAL_PATH_PREFIX if\n            it was used with the original request (e.g.,\n            'http://localhost:8000/personfinder/abc?x=y'). Does not preserve\n            query parameters from the original request.\n        \"\"\"\n        return self.request.build_absolute_uri(\n            self.build_absolute_path(path, repo))\n\n    def render(self, template_name, status_code=200, **template_vars):\n        \"\"\"Renders a template with the given variables.\n\n        Args:\n            template_name (str): The filename of the template in app/resources.\n            **template_vars: Named variables to pass to the template.\n\n        Returns:\n            HttpResponse: An HttpResponse with the rendered template.\n        \"\"\"\n\n        def get_vars():\n            \"\"\"A function returning vars, for use by the resources module.\"\"\"\n            template_vars['env'] = self.env\n            # TODO(nworden): change templates to access config through env, which\n            # already has the config anyway\n            template_vars['config'] = self.env.config\n            template_vars['params'] = self.params\n            template_vars['csp_nonce'] = self.request.csp_nonce\n            return template_vars\n\n        query_str = self.request.META.get('QUERY_STRING', '')\n        extra_key = (self.env.repo, self.env.charset, query_str)\n        return django.http.HttpResponse(\n            resources.get_rendered(template_name, self.env.lang, extra_key,\n                                   get_vars, 0),\n            status=status_code)\n\n    def error(self, status_code, message=''):\n        \"\"\"Returns an error response.\n\n        Args:\n            status_code (int): The HTTP status code to use.\n            message (str, optional): A message to display. Defaults to the empty\n                string.\n\n        Returns:\n            HttpResponse: An HTTP response with the given status code and\n            message.\n        \"\"\"\n        # pylint: disable=no-self-use\n        # Making this a method of BaseView keeps it consistent with render(),\n        # and probably other similar functions in the future.\n        return django.http.HttpResponse(\n            content=message, content_type='text/plain', status=status_code)\n\n    @django.utils.decorators.classonlymethod\n    def as_view(cls, **initkwargs):\n        # pylint: disable=E,W,R,C\n        # We want to have a setup() function called before dispatch() (see\n        # explanation in the comments on the setup() function), and Django 2.2\n        # has support for it built in. However, we're not on Django 2.2 yet, so\n        # we make the modification to View.as_view() ourselves to get this\n        # feature ahead of time (the code below is just a copy of the original\n        # Django 1.11 View.as_view function, with the setup() call stuck in). We\n        # can clean this up when we upgrade to Django 2.2.\n        \"\"\"Main entry point for a request-response process.\"\"\"\n        for key in initkwargs:\n            if key in cls.http_method_names:\n                raise TypeError(\"You tried to pass in the %s method name as a \"\n                                \"keyword argument to %s(). Don't do that.\" %\n                                (key, cls.__name__))\n            if not hasattr(cls, key):\n                raise TypeError(\n                    \"%s() received an invalid keyword %r. as_view \"\n                    \"only accepts arguments that are already \"\n                    \"attributes of the class.\" % (cls.__name__, key))\n\n        def view(request, *args, **kwargs):\n            self = cls(**initkwargs)\n            if hasattr(self, 'get') and not hasattr(self, 'head'):\n                self.head = self.get\n            self.request = request\n            self.args = args\n            self.kwargs = kwargs\n            self.setup(request, *args, **kwargs)\n            return self.dispatch(request, *args, **kwargs)\n\n        view.view_class = cls\n        view.view_initkwargs = initkwargs\n\n        # take name and docstring from class\n        functools.update_wrapper(view, cls, updated=())\n\n        # and possible attributes set by decorators\n        # like csrf_exempt from dispatch\n        functools.update_wrapper(view, cls.dispatch, assigned=())\n        return view\n\n\ndef read_params(container,\n                request,\n                get_params=None,\n                post_params=None,\n                file_params=None):\n    \"\"\"Reads CGI parameter values from the request to the container.\n\n    Args:\n        container (utils.Struct): The container to put parameter values in.\n        request (HttpRequest): The request to read from.\n        get_params (dict): A dictionary from GET parameter keys to validator\n            functions.\n        post_params (dict): A dictionary from POST parameter keys to validator\n            functions.\n        file_params (dict): A dictionary from POST parameter keys for uploaded\n            files to validator functions.\n\n    Returns:\n        utils.Struct: The container, for convenience.\n    \"\"\"\n    if request.method == 'GET':\n        if get_params:\n            for key, validator in get_params.items():\n                if key in request.GET:\n                    setattr(container, key, validator(request.GET[key]))\n    elif request.method == 'POST':\n        if post_params:\n            for key, validator in post_params.items():\n                if key in request.POST:\n                    setattr(container, key, validator(request.POST[key]))\n        if file_params:\n            for key, validator in file_params.items():\n                if key in request.FILES:\n                    setattr(container, key, validator(request.FILES[key]))\n    return container\n/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Access restriction tests.\"\"\"\n\nimport os\n\nimport django.urls\n\nimport urls\nimport views\n\nimport view_tests_base\n\n\nclass AccessRestrictionTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests that access restrictions are enforced.\"\"\"\n\n    # Dictionary from path name to a boolean indicating whether the page should\n    # be restricted to admins.\n    IS_RESTRICTED_TO_ADMINS = {\n        'admin_apikeys-manage': True,\n        'admin_apikeys-list': True,\n        'admin_create-repo': True,\n        'admin_delete-record': True,\n        'admin_statistics': True,\n        'meta_sitemap': False,\n    }\n\n    def get_path(self, path_name):\n        # If we ever have URLs with more interesting things in the path besides\n        # repo, we'll have to rethink this.\n        try:\n            return django.urls.reverse(path_name)\n        except django.urls.NoReverseMatch:\n            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})\n\n    def test_blocked_to_non_admins(self):\n        \"\"\"Tests that admin-only pages aren't available to non-admins.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 403\n            assert self.client.post(path, secure=True).status_code == 403\n\n    def test_available_to_admins(self):\n        \"\"\"Tests that admin-only pages are available to admins.\n\n        This is a sort of meta-test: I'm not really concerned that we might\n        accidentally lock admins out of the admin pages, but I do want to make\n        sure that the test above actually depends on the user not being an admin\n        (as opposed to access getting denied because the tests are set up wrong\n        somehow).\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 200\n            # Don't test POST requests here; they'll need an XSRF token and\n            # that'll be covered in a separate test.\n\n    def test_other_pages_unrestricted(self):\n        \"\"\"Tests that non-admins can access unrestricted pages.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: not item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code != 403\n\n    def test_all_paths_included(self):\n        \"\"\"Tests that all (Django-served) pages are listed.\n\n        We want to make sure no one forgets to add these tests for admin pages,\n        so we require that each URL path is included in the dictionary above.\n        \"\"\"\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed__'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            if pattern.name.startswith('tasks_'):\n                # Skip task handlers; they'll be tested separately.\n                # TODO(nworden): test them\n                continue\n            assert (\n                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)\n/n/n/ntests/views/test_admin_delete_record.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Tests for the admin delete-record page.\"\"\"\n\nimport datetime\n\nimport django\nimport django.http\nimport django.test\nimport six.moves.urllib.parse as urlparse\n\n# pylint: disable=wrong-import-order\n# pylint sometimes thinks config is a standard import that belongs before the\n# django import. It's mistaken; config is our own module (if you run\n# python -c \"import config\", it produces an error saying config doesn't exist).\n# Filed issue #626 to move us out of the global namespace someday, which would\n# prevent stuff like this.\nimport config\nimport const\nimport model\n\nimport view_tests_base\n\n\nclass AdminDeleteRecordViewTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests the admin delete-record view.\"\"\"\n\n    def setUp(self):\n        super(AdminDeleteRecordViewTests, self).setUp()\n        self.login(is_admin=True)\n        self.data_generator.repo()\n        self.person = self.data_generator.person()\n\n    def test_get(self):\n        \"\"\"Tests GET requests.\"\"\"\n        res = self.client.get('/global/admin/delete_record/', secure=True)\n        self.assertEqual(res.context['id'], '%s/person.' % const.HOME_DOMAIN)\n\n    def test_post(self):\n        \"\"\"Tests POST requests to delete a record.\"\"\"\n        get_doc = self.to_doc(self.client.get(\n            '/global/admin/delete_record/', secure=True))\n        xsrf_token = get_doc.cssselect_one('input[name=\"xsrf_token\"]').get(\n            'value')\n        post_resp = self.client.post('/haiti/admin/delete_record/', {\n            'xsrf_token': xsrf_token,\n            'id': self.person.record_id,\n        }, secure=True)\n        # Check that the user's redirected to the repo's main admin page.\n        self.assertIsInstance(post_resp, django.http.HttpResponseRedirect)\n        parse = urlparse.urlparse(post_resp.url)\n        self.assertEqual('/haiti/delete', parse.path)\n        query_params = dict(urlparse.parse_qsl(parse.query))\n        self.assertEqual(query_params['id'], self.person.record_id)\n        # Check that the signature param is present and not the empty string.\n        self.assertTrue(len(query_params['signature']) > 1)\n/n/n/n", "label": 0}, {"id": "5bd28a262e274d24cf802ed6051e6880c7033452", "code": "/app/admin_delete_record.py/n/n#!/usr/bin/python2.7\n# Copyright 2016 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nfrom const import *\nfrom model import *\nfrom utils import *\nimport reveal\n\n\nclass Handler(BaseHandler):\n    \"\"\"An admin page to delete person records.\"\"\"\n\n    # After a repository is deactivated, we still need the admin page to be\n    # accessible so we can edit its settings.\n    ignore_deactivation = True\n\n    repo_required = False\n    admin_required = True\n\n    def get(self):\n        xsrf_tool = XsrfTool()\n        user = users.get_current_user()\n        self.render(\n            'admin_delete_record.html',\n            id=self.env.domain + '/person.',\n            xsrf_token=xsrf_tool.generate_token(\n                user.user_id(), 'admin_delete_record'))\n\n    def post(self):\n        xsrf_tool = XsrfTool()\n        user = users.get_current_user()\n        if not (self.params.xsrf_token and xsrf_tool.verify_token(\n                    self.params.xsrf_token, user.user_id(),\n                    'admin_delete_record')):\n            self.error(403)\n            return False\n        # Redirect to the deletion handler with a valid signature.\n        action = ('delete', str(self.params.id))\n        self.redirect('/delete', id=self.params.id,\n                      signature=reveal.sign(action))\n/n/n/n", "label": 1}, {"id": "89bf68c6f62362e29467a2ed22eb2b477268eef8", "code": "app/utils.py/n/n#!/usr/bin/python2.7\n# Copyright 2017 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n__author__ = 'kpy@google.com (Ka-Ping Yee) and many other Googlers'\n\nimport calendar\nimport copy\nfrom datetime import datetime, timedelta\nimport hmac\nimport httplib\nimport logging\nimport os\nimport random\nimport re\nimport string\nimport sys\nimport time\nimport traceback\nimport unicodedata\nimport urllib\nimport urlparse\nimport base64\n\nfrom django.core.validators import EmailValidator, URLValidator, ValidationError\nimport django.utils.html\nfrom django.utils.translation import ugettext as _\nfrom django.template.defaulttags import register\nfrom google.appengine.api import images\nfrom google.appengine.api import taskqueue\nfrom google.appengine.api import users\nfrom google.appengine.ext import webapp\nimport google.appengine.ext.webapp.template\nimport google.appengine.ext.webapp.util\nimport recaptcha.client.captcha\nfrom babel.dates import format_date\nfrom babel.dates import format_datetime\nfrom babel.dates import format_time\nimport babel\n\nimport const\nimport config\nimport model\nimport pfif\nimport resources\n\n# The domain name from which to send e-mail.\nEMAIL_DOMAIN = 'appspotmail.com'  # All apps on appspot.com use this for mail.\n\n# Query parameters which are automatically preserved on page transition\n# if you use utils.BaseHandler.get_url() or\n# env.hidden_input_tags_for_preserved_query_params.\nPRESERVED_QUERY_PARAM_NAMES = ['ui', 'charsets', 'referrer']\n\n@register.filter\ndef get_value(dictionary, key):\n    \"\"\"Django Template filter to get dictionary value based on the given key\"\"\"\n    return dictionary.get(key)\n\n# ==== Field value text ========================================================\n\n\ndef get_person_sex_text(person):\n    \"\"\"Returns the UI text for a person's sex field.\"\"\"\n    return const.PERSON_SEX_TEXT.get(person.sex or '')\n\n\ndef get_note_status_text(note):\n    \"\"\"Returns the UI text for a note's status field.\"\"\"\n    return const.NOTE_STATUS_TEXT.get(note.status or '')\n\n\ndef get_person_status_text(person):\n    \"\"\"Returns the UI text for a person's latest_status.\"\"\"\n    return const.PERSON_STATUS_TEXT.get(person.latest_status or '')\n\n\n# Things that occur as prefixes of global paths (i.e. no repository name).\nGLOBAL_PATH_RE = re.compile(r'^/(global|personfinder)(/?|/.*)$')\n\n\n# ==== String formatting =======================================================\n\n\ndef format_boolean(value):\n    return value and 'true' or 'false'\n\n\ndef format_utc_datetime(dt):\n    if not dt:\n        return ''\n    return dt.replace(microsecond=0).isoformat() + 'Z'\n\n\ndef format_utc_timestamp(timestamp):\n    if not isinstance(timestamp, (int, float)):\n        return ''\n    return format_utc_datetime(datetime.utcfromtimestamp(timestamp))\n\n\ndef format_sitemaps_datetime(dt):\n    integer_dt = datetime(\n        dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)\n    return integer_dt.isoformat() + '+00:00'\n\n\ndef encode(string, encoding='utf-8'):\n    \"\"\"If unicode, encode to encoding; if 8-bit string, leave unchanged.\"\"\"\n    if isinstance(string, unicode):\n        string = string.encode(encoding)\n    return string\n\n\ndef urlencode(params, encoding='utf-8'):\n    \"\"\"Encode the key-value pairs in 'params' into a query string, applying\n    the specified encoding to any Unicode strings and ignoring any keys that\n    have value == None.  (urllib.urlencode doesn't support Unicode).\"\"\"\n    keys = params.keys()\n    keys.sort()  # Sort the keys to get canonical ordering\n    return urllib.urlencode([\n        (encode(key, encoding), encode(params[key], encoding))\n        for key in keys if isinstance(params[key], basestring)])\n\n\ndef set_param(params, param, value):\n    \"\"\"Take the params from a urlparse and override one of the values.\"\"\"\n    # This will strip out None-valued params and collapse repeated params.\n    params = dict(urlparse.parse_qsl(params))\n    if value is None:\n        if param in params:\n            del(params[param])\n    else:\n        params[param] = value\n    return urlencode(params)\n\n\ndef set_url_param(url, param, value):\n    \"\"\"This modifies a URL setting the given param to the specified value.  This\n    may add the param or override an existing value, or, if the value is None,\n    it will remove the param.  Note that value must be a basestring and can't be\n    an int, for example.\"\"\"\n    url_parts = list(urlparse.urlparse(url))\n    url_parts[4] = set_param(url_parts[4], param, value)\n    return urlparse.urlunparse(url_parts)\n\n\ndef anchor_start(href):\n    \"\"\"Returns the HREF escaped and embedded in an anchor tag.\"\"\"\n    return '<a href=\"%s\">' % django.utils.html.escape(href)\n\n\ndef anchor(href, body):\n    \"\"\"Returns a string anchor HTML element with the given href and body.\"\"\"\n    return anchor_start(href) + django.utils.html.escape(body) + '</a>'\n\n\n# ==== Validators ==============================================================\n\n# These validator functions are used to check and parse query parameters.\n# Each validator should return a parsed, sanitized value, or return a default\n# value, or raise ValueError to display an error message to the user.\n\n\ndef strip(string):\n    # Trailing nulls appear in some strange character encodings like Shift-JIS.\n    return string.strip().rstrip('\\0')\n\n\ndef strip_and_lower(string):\n    return strip(string).lower()\n\n\ndef validate_yes(string):\n    return (strip(string).lower() == 'yes') and 'yes' or ''\n\n\ndef validate_checkbox(string):\n    return (strip(string).lower() == 'on') and 'yes' or ''\n\n\ndef validate_checkbox_as_bool(val):\n    if val.lower() in ['on', 'yes', 'true']:\n        return True\n    return False\n\n\ndef validate_role(string):\n    return (strip(string).lower() == 'provide') and 'provide' or 'seek'\n\n\ndef validate_int(string):\n    return string and int(strip(string))\n\n\ndef validate_sex(string):\n    \"\"\"Validates the 'sex' parameter, returning a canonical value or ''.\"\"\"\n    if string:\n        string = strip(string).lower()\n    return string in pfif.PERSON_SEX_VALUES and string or ''\n\n\ndef validate_expiry(value):\n    \"\"\"Validates that the 'expiry_option' parameter is a positive integer.\n\n    Returns:\n      the int() value if it's present and parses, or the default_expiry_days\n      for the repository, if it's set, otherwise -1 which represents the\n      'unspecified' status.\n    \"\"\"\n    try:\n        value = int(value)\n    except Exception, e:\n        return None\n    return value > 0 and value or None\n\n\nAPPROXIMATE_DATE_RE = re.compile(r'^\\d{4}(-\\d\\d)?(-\\d\\d)?$')\n\n\ndef validate_approximate_date(string):\n    if string:\n        string = strip(string)\n        if APPROXIMATE_DATE_RE.match(string):\n            return string\n    return ''\n\n\nAGE_RE = re.compile(r'^(\\d+)(-(\\d+))?$')\n# Hyphen with possibly surrounding whitespaces.\nHYPHEN_RE = re.compile(\n    ur'\\s*[-\\u2010-\\u2015\\u2212\\u301c\\u30fc\\ufe58\\ufe63\\uff0d]\\s*',\n    re.UNICODE)\n\n\ndef validate_age(string):\n    \"\"\"Validates the 'age' parameter, returning a canonical value or ''.\"\"\"\n    if string:\n        string = strip(string)\n        string = unicodedata.normalize('NFKC', unicode(string))\n        string = HYPHEN_RE.sub('-', string)\n        if AGE_RE.match(string):\n            return string\n    return ''\n\n\ndef validate_status(string):\n    \"\"\"Validates an incoming status parameter, returning one of the canonical\n    status strings or ''.  Note that '' is always used as the Python value\n    to represent the 'unspecified' status.\"\"\"\n    if string:\n        string = strip(string).lower()\n    return string in pfif.NOTE_STATUS_VALUES and string or ''\n\n\nDATETIME_RE = re.compile(r'^(2\\d\\d\\d)-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d):(\\d\\d)Z$')\n\n\ndef validate_datetime(string):\n    if not string:\n        return None  # A missing value is okay.\n    match = DATETIME_RE.match(string)\n    if match:\n        return datetime(*map(int, match.groups()))\n    raise ValueError('Bad datetime: %r' % string)\n\n\ndef validate_timestamp(string):\n    try:\n        return string and datetime.utcfromtimestamp(float(strip(string)))\n    except:\n        raise ValueError('Bad timestamp: %s' % string)\n\n\ndef validate_image(bytestring):\n    try:\n        image = None\n        if bytestring:\n            image = images.Image(bytestring)\n            image.width\n        return image\n    except:\n        return False\n\n\nEMAIL_VALIDATOR = EmailValidator()\n\n\ndef validate_email(email):\n    \"\"\"Validates an email address, returning True on correct,\n    False on incorrect, None on empty string.\"\"\"\n    # Note that google.appengine.api.mail.is_email_valid() is unhelpful;\n    # it checks only for the empty string\n    if not email:\n        return None\n    try:\n        EMAIL_VALIDATOR(email)\n        return True\n    except ValidationError:\n        return False\n\n\ndef validate_version(string):\n    \"\"\"Version, if present, should be in pfif versions.\"\"\"\n    if string and strip(string) not in pfif.PFIF_VERSIONS:\n        raise ValueError('Bad pfif version: %s' % string)\n    return pfif.PFIF_VERSIONS[strip(string) or pfif.PFIF_DEFAULT_VERSION]\n\n\nREPO_RE = re.compile('^[a-z0-9-]+$')\n\n\ndef validate_repo(string):\n    string = (string or '').strip()\n    if not string:\n        return None\n    if string == 'global':\n        raise ValueError('\"global\" is an illegal repository name.')\n    if REPO_RE.match(string):\n        return string\n    raise ValueError('Repository names can only contain '\n                     'lowercase letters, digits, and hyphens.')\n\n\nRESOURCE_NAME_RE = re.compile('^[a-z0-9._-]+$')\n\n\ndef validate_resource_name(string):\n    \"\"\"A resource name or bundle label.\"\"\"\n    string = (string or '').strip().lower()\n    if not string:\n        return None\n    if RESOURCE_NAME_RE.match(string):\n        return string\n    raise ValueError('Invalid resource name or bundle name: %r' % string)\n\n\nLANG_RE = re.compile('^[A-Za-z0-9-]+$')\n\n\ndef validate_lang(string):\n    \"\"\"A BCP 47 language tag.\"\"\"\n    string = (string or '').strip().lower()\n    if not string:\n        return None\n    if LANG_RE.match(string):\n        return string\n    raise ValueError('Invalid language tag: %r' % string)\n\n\ndef validate_cache_seconds(string):\n    \"\"\"A number of seconds to cache a Resource in RAM.\"\"\"\n    string = (string or '').strip()\n    if string:\n        return float(string)\n    return 1.0\n\n\n# ==== Fuzzification functions =================================================\n\n# The range should be no more specific than a five year period.\nMIN_AGE_RANGE = 5\n\ndef fuzzify_age(value):\n    \"\"\"Fuzzifies the age value for privacy.\n\n    Args:\n        value: a PFIF-compliant age value (a number or range, e.g., 45-49).\n\n    Returns:\n        A range of at least five years that includes the given value, or None if\n        the input value is None or invalid.\n    \"\"\"\n    if not value:\n        return None\n    parse = AGE_RE.match(value)\n    if not parse:\n        return None\n    range_start = int(parse.group(1))\n    range_end = int(parse.group(3)) if parse.group(3) else None\n    if not range_end:\n        # If no range was given, use a round five years around the given age.\n        range_start -= range_start % MIN_AGE_RANGE\n        return '%d-%d' % (range_start, range_start + MIN_AGE_RANGE)\n    if (range_end - range_start) >= MIN_AGE_RANGE:\n        # If the range we were given is already acceptably wide, leave it as-is.\n        return value\n    # If we were given too specific a range, pad it out to a round five year\n    # range.\n    range_start -= range_start % MIN_AGE_RANGE\n    range_end += MIN_AGE_RANGE - ((range_end) % MIN_AGE_RANGE)\n    return '%d-%d' % (range_start, range_end)\n\n\n# ==== Other utilities =========================================================\n\n\ndef get_app_name():\n    \"\"\"Canonical name of the app, without HR s~ nonsense.  This only works in\n    the context of the appserver (eg remote_api can't use it).\"\"\"\n    from google.appengine.api import app_identity\n    return app_identity.get_application_id()\n\n\ndef sanitize_urls(record):\n    \"\"\"Clean up URLs to protect against XSS.\n\n    We check URLs submitted through Person Finder, but bad data might come in\n    through the API.\n    \"\"\"\n    url_validator = URLValidator(schemes=['http', 'https'])\n    # Single-line URLs.\n    for field in ['photo_url', 'source_url']:\n        url = getattr(record, field, None)\n        if not url:\n            continue\n        try:\n            url_validator(url)\n        except ValidationError:\n            setattr(record, field, None)\n    # Multi-line URLs.\n    for field in ['profile_urls']:\n        urls = (getattr(record, field, None) or '').splitlines()\n        sanitized_urls = []\n        for url in urls:\n            if url:\n                try:\n                    url_validator(url)\n                    sanitized_urls.append(url)\n                except ValidationError:\n                    logging.warning(\n                        'Unsanitary URL in database on %s' % record.record_id)\n        if len(urls) != len(sanitized_urls):\n            setattr(record, field, '\\n'.join(sanitized_urls))\n\n\ndef get_host(host=None):\n    host = host or os.environ['HTTP_HOST']\n    \"\"\"Return the host name, without version specific details.\"\"\"\n    parts = host.split('.')\n    if len(parts) > 3:\n        return '.'.join(parts[-3:])\n    else:\n        return host\n\n\n# List of sensitive field names in person and note records.\nSENSITIVE_FIELDS = [\n  'date_of_birth',\n  'author_email',\n  'author_phone',\n  'email_of_found_person',\n  'phone_of_found_person',\n]\n\n\ndef optionally_filter_sensitive_fields(records, auth=None):\n    \"\"\"Removes sensitive fields from a list of dictionaries, unless the client\n    has full read authorization.\n\n    Args:\n        records (list of dict): A list of dictionaries which represent either of:\n            - a person record\n            - a note record\n            - a joined record of a person and a note\n    \"\"\"\n    if not (auth and auth.full_read_permission):\n        filter_sensitive_fields(records)\n\n\ndef filter_sensitive_fields(records):\n    \"\"\"Removes sensitive fields from a list of dictionaries.\n\n    Args:\n        records (list of dict): A list of dictionaries which represent either of:\n            - a person record\n            - a note record\n            - a joined record of a person and a note\n    \"\"\"\n    for record in records:\n        for prefix in ['', 'person_', 'note_']:\n            for field in SENSITIVE_FIELDS:\n                prefixed_field = prefix + field\n                if prefixed_field in record:\n                    record[prefixed_field] = ''\n\n\ndef join_person_and_note_record(person_record, note_record):\n    \"\"\"Join a person record and a note record into a single dictionary.\n\n    The field names are prefixed with 'person_' or 'note_' to avoid name\n    collision. note_record can be None. In that case, person record field\n    names are still prefixed.\n\n    Args:\n        person_record (dict): A dictionary representation of a person record.\n            Cannot be None.\n        note_record (dict): A dictionary representation of a note record for\n            the person. Can be None.\n    \"\"\"\n    joined_record = {}\n    for name, value in person_record.iteritems():\n        new_name = get_field_name_for_joined_record(name, 'person')\n        joined_record[new_name] = value\n    if note_record:\n        assert (note_record['person_record_id'] ==\n                person_record['person_record_id'])\n        for name, value in note_record.iteritems():\n            new_name = get_field_name_for_joined_record(name, 'note')\n            joined_record[new_name] = value\n    return joined_record\n\n\ndef get_field_name_for_joined_record(original_field_name, record_type):\n    \"\"\"Converts a field name in a person/note record into a field name used in\n    a joined record of a person and a note.\n\n    See also join_person_and_note_record().\n\n    Args:\n        original_field_name (str): A field name in a person/note record.\n        record_type (str): 'person' or 'note'.\n    \"\"\"\n    if original_field_name in ('person_record_id', 'note_record_id'):\n        return original_field_name\n    else:\n        return '%s_%s' % (record_type, original_field_name)\n\n\n# The current time for testing as a datetime object, or None if using real time.\n_utcnow_for_test = None\n\n\ndef set_utcnow_for_test(now):\n    \"\"\"Sets the current time for testing purposes.  Pass in a datetime object\n    or a timestamp in epoch seconds; or pass None to revert to real time.\"\"\"\n    global _utcnow_for_test\n    if isinstance(now, (int, float)):\n        now = datetime.utcfromtimestamp(float(now))\n    _utcnow_for_test = now\n\n\ndef get_utcnow():\n    \"\"\"Returns the current UTC datetime (settable with set_utcnow_for_test).\"\"\"\n    global _utcnow_for_test\n    return (_utcnow_for_test is None) and datetime.utcnow() or _utcnow_for_test\n\n\ndef get_timestamp(dt):\n    \"\"\"Converts datetime object to a float value in epoch seconds.\"\"\"\n    return calendar.timegm(dt.utctimetuple()) + dt.microsecond * 1e-6\n\n\ndef get_utcnow_timestamp():\n    \"\"\"Returns the current time in epoch seconds (settable with\n    set_utcnow_for_test).\"\"\"\n    return get_timestamp(get_utcnow())\n\n\ndef log_api_action(handler, action, num_person_records=0, num_note_records=0,\n                   people_skipped=0, notes_skipped=0):\n    \"\"\"Log an API action.\"\"\"\n    if handler.config and handler.config.api_action_logging:\n        model.ApiActionLog.record_action(\n            handler.repo, handler.params.key,\n            handler.params.version.version, action,\n            num_person_records, num_note_records,\n            people_skipped, notes_skipped,\n            handler.request.headers.get('User-Agent'),\n            handler.request.remote_addr, handler.request.url)\n\n\ndef get_full_name(given_name, family_name, config):\n    \"\"\"Return full name string obtained by concatenating given_name and\n    family_name in the order specified by config.family_name_first, or just\n    given_name if config.use_family_name is False.\"\"\"\n    if config.use_family_name:\n        separator = (given_name and family_name) and u' ' or u''\n        if config.family_name_first:\n            return separator.join([family_name, given_name])\n        else:\n            return separator.join([given_name, family_name])\n    else:\n        return given_name\n\n\ndef send_confirmation_email_to_record_author(\n    handler, person, action, confirm_url, record_id):\n    \"\"\"Send the author an email to confirm enabling/disabling notes\n    of a record.\"\"\"\n    if not person.author_email:\n        return handler.error(\n            400, _('No author email for record %(id)s.') % {'id' : record_id})\n\n    # i18n: Subject line of an e-mail message confirming the author\n    # wants to disable notes for this record\n    if action == 'enable':\n        subject = _('[Person Finder] Enable notes on \"%(full_name)s\"?'\n                ) % {'full_name': person.primary_full_name}\n    elif action == 'disable':\n        subject = _('[Person Finder] Disable notes on \"%(full_name)s\"?'\n                ) % {'full_name': person.primary_full_name}\n    else:\n        raise ValueError('Unknown action: %s' % action)\n\n    # send e-mail to record author confirming the lock of this record.\n    template_name = '%s_notes_email.txt' % action\n    handler.send_mail(\n        subject=subject,\n        to=person.author_email,\n        body=handler.render_to_string(\n            template_name,\n            author_name=person.author_name,\n            full_name=person.primary_full_name,\n            site_url=handler.get_url('/'),\n            confirm_url=confirm_url\n        )\n    )\n\n\ndef get_repo_url(request, repo, scheme=None):\n    \"\"\"Constructs the absolute root URL for a given repository.\"\"\"\n    req_scheme, req_netloc, req_path, _, _ = urlparse.urlsplit(request.url)\n    prefix = req_path.startswith('/personfinder') and '/personfinder' or ''\n    if is_dev_app_server():\n        scheme = 'http'  # HTTPS is not available when using dev_appserver\n    return (scheme or req_scheme) + '://' + req_netloc + prefix + '/' + repo\n\n\ndef get_url(request, repo, action, charset='utf-8', scheme=None, **params):\n    \"\"\"Constructs the absolute URL for a given action and query parameters,\n    preserving the current repo and the parameters listed in\n    PRESERVED_QUERY_PARAM_NAMES.\"\"\"\n    repo_url = get_repo_url(request, repo or 'global', scheme)\n    for name in PRESERVED_QUERY_PARAM_NAMES:\n        params[name] = params.get(name, request.get(name, None))\n    query = urlencode(params, charset)\n    return repo_url + '/' + action.lstrip('/') + (query and '?' + query or '')\n\n\ndef add_profile_icon_url(website, handler):\n    website = copy.deepcopy(website)  # avoid modifying the original\n    website['icon_url'] = \\\n        handler.env.global_url + '/' + website['icon_filename']\n    return website\n\n\ndef strip_url_scheme(url):\n    if not url:\n        return url\n    _, netloc, path, query, segment = urlparse.urlsplit(url)\n    return urlparse.urlunsplit(('', netloc, path, query, segment))\n\n\ndef is_dev_app_server():\n    return os.environ['APPLICATION_ID'].startswith('dev~')\n\n# ==== Struct ==================================================================\n\nclass Struct:\n    \"\"\"A simple bag of attributes.\"\"\"\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\n    def get(self, name, default=None):\n        return self.__dict__.get(name, default)\n\n\n# ==== Key management ======================================================\n\ndef generate_random_key(length):\n    \"\"\"Generates a random key with given length.\"\"\"\n    source = ('abcdefghijklmnopqrstuvwxyz'\n              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n              '1234567890'\n              '-_')\n    rng = random.SystemRandom()\n    return ''.join(rng.choice(source) for i in range(length))\n\n\n# ==== Decorators  ============================================================\n\ndef require_api_key_management_permission(handler_method):\n    \"\"\"\n    This is a decorator for API Key management feature. The limitation\n    is that the decorator can not preserve payloads within a POST/PUT\n    request.\n\n    Usage:\n    class SomeHandler(utils.BaseHandler):\n        @utils.require_api_key_management_permission\n        def get(self):\n            # ....\n            # ....\n    \"\"\"\n    def inner(*args, **kwargs):\n        handler = args[0]\n        user = users.get_current_user()\n        if (users.is_current_user_admin() or\n            (user and handler.config.key_management_operators and\n             user.email() in handler.config.key_management_operators)):\n            return handler_method(*args, **kwargs)\n        else:\n            return handler.redirect(\n                users.create_login_url(handler.request.url))\n    return inner\n\n\n# ==== Base Handler ============================================================\n\nclass BaseHandler(webapp.RequestHandler):\n    # Handlers that don't need a repository name can set this to False.\n    repo_required = True\n\n    # Handlers that require HTTPS can set this to True.\n    https_required = True\n\n    # Set this to True to enable a handler even for deactivated repositories.\n    ignore_deactivation = False\n\n    # Handlers that require an admin permission must set this to True.\n    admin_required = False\n\n    # List all accepted query parameters here with their associated validators.\n    auto_params = {\n        'action': strip,\n        'add_note': validate_yes,\n        'age': validate_age,\n        'alternate_family_names': strip,\n        'alternate_given_names': strip,\n        'author_email': strip,\n        'author_made_contact': validate_yes,\n        'author_name': strip,\n        'author_phone': strip,\n        'your_own_email': strip,\n        'your_own_phone': strip,\n        'believed_dead_permission': validate_checkbox_as_bool,\n        'cache_seconds': validate_cache_seconds,\n        'clone': validate_yes,\n        'confirm': validate_yes,\n        'contact_email': strip,\n        'contact_name': strip,\n        'content_id': strip,\n        'context': strip,\n        'cursor': strip,\n        'date_of_birth': validate_approximate_date,\n        'description': strip,\n        'domain_write_permission': strip,\n        'dupe_notes': validate_yes,\n        'email_of_found_person': strip,\n        'error': strip,\n        'expiry_option': validate_expiry,\n        'family_name': strip,\n        'full_read_permission': validate_checkbox_as_bool,\n        'given_name': strip,\n        'home_city': strip,\n        'home_country': strip,\n        'home_neighborhood': strip,\n        'home_postal_code': strip,\n        'home_state': strip,\n        'id': strip,\n        'id1': strip,\n        'id2': strip,\n        'id3': strip,\n        'is_valid': validate_checkbox_as_bool,\n        'key': strip,\n        'lang': validate_lang,\n        'last_known_location': strip,\n        'mark_notes_reviewed': validate_checkbox_as_bool,\n        'max_results': validate_int,\n        'min_entry_date': validate_datetime,\n        'new_repo': validate_repo,\n        'note_photo': validate_image,\n        'note_photo_url': strip,\n        'omit_notes': validate_yes,\n        'operation': strip,\n        'organization_name': strip,\n        'person_record_id': strip,\n        'phone_of_found_person': strip,\n        'photo': validate_image,\n        'photo_url': strip,\n        'profile_url1': strip,\n        'profile_url2': strip,\n        'profile_url3': strip,\n        'query': strip,\n        'query_name': strip,\n        'query_location': strip,\n        'query_type': strip,\n        'read_permission': validate_checkbox_as_bool,\n        'referrer': strip,\n        'resource_bundle': validate_resource_name,\n        'resource_bundle_default': validate_resource_name,\n        'resource_bundle_original': validate_resource_name,\n        'resource_lang': validate_lang,\n        'resource_name': validate_resource_name,\n        'role': validate_role,\n        'search_engine_id': validate_int,\n        'search_permission': validate_checkbox_as_bool,\n        'sex': validate_sex,\n        'signature': strip,\n        'skip': validate_int,\n        'small': validate_yes,\n        'source': strip,\n        'source_date': strip,\n        'source_name': strip,\n        'source_url': strip,\n        'stats_permission': validate_checkbox_as_bool,\n        'status': validate_status,\n        'style': strip,\n        'subscribe': validate_checkbox,\n        'subscribe_own_info': validate_checkbox,\n        'subscribe_email': strip,\n        'subscribe_permission': validate_checkbox_as_bool,\n        'suppress_redirect': validate_yes,\n        'target': strip,\n        'text': strip,\n        'thumb': validate_checkbox_as_bool,\n        'timestamp': validate_timestamp,\n        'ui': strip_and_lower,\n        'utcnow': validate_timestamp,\n        'version': validate_version,\n        'own_info': validate_yes,\n        'xsrf_token': strip,\n    }\n\n    def redirect(self, path, repo=None, permanent=False, **params):\n        # This will prepend the repo to the path to create a working URL,\n        # unless the path has a global prefix or is an absolute URL.\n        if re.match('^[a-z]+:', path) or GLOBAL_PATH_RE.match(path):\n            if params:\n              path += '?' + urlencode(params, self.charset)\n        else:\n            path = self.get_url(path, repo, **params)\n        return webapp.RequestHandler.redirect(self, path, permanent=permanent)\n\n    def render(self, name, language_override=None, cache_seconds=0,\n               get_vars=lambda: {}, **vars):\n        \"\"\"Renders a template to the output stream, passing in the variables\n        specified in **vars as well as any additional variables returned by\n        get_vars().  Since this is intended for use by a dynamic page handler,\n        caching is off by default; if cache_seconds is positive, then\n        get_vars() will be called only when cached content is unavailable.\"\"\"\n        self.write(self.render_to_string(\n            name, language_override, cache_seconds, get_vars, **vars))\n\n    def render_to_string(self, name, language_override=None, cache_seconds=0,\n                         get_vars=lambda: {}, **vars):\n        \"\"\"Renders a template to a string, passing in the variables specified\n        in **vars as well as any additional variables returned by get_vars().\n        Since this is intended for use by a dynamic page handler, caching is\n        off by default; if cache_seconds is positive, then get_vars() will be\n        called only when cached content is unavailable.\"\"\"\n        # TODO(kpy): Make the contents of extra_key overridable by callers?\n        lang = language_override or self.env.lang\n        extra_key = (self.env.repo, self.env.charset, self.request.query_string)\n        def get_all_vars():\n            vars.update(get_vars())\n            for key in ('env', 'config', 'params'):\n                if key in vars:\n                    raise Exception(\n                        'Cannot use \"%s\" as a key in vars. It is reserved.'\n                        % key)\n            vars['env'] = self.env  # pass along application-wide context\n            vars['config'] = self.config  # pass along the configuration\n            vars['params'] = self.params  # pass along the query parameters\n            return vars\n        return resources.get_rendered(\n            name, lang, extra_key, get_all_vars, cache_seconds)\n\n    def error(self, code, message='', message_html=''):\n        self.info(code, message, message_html, style='error')\n\n    def info(self, code, message='', message_html='', style='info'):\n        \"\"\"Renders a simple page with a message.\n\n        Args:\n          code: HTTP status code.\n          message: A message in plain text.\n          message_html: A message in HTML.\n          style: 'info', 'error' or 'plain'. 'info' and 'error' differs in\n              appearance. 'plain' just renders the message without extra\n              HTML tags. Good for API response.\n        \"\"\"\n        is_error = 400 <= code < 600\n        if is_error:\n            webapp.RequestHandler.error(self, code)\n        else:\n            self.response.set_status(code)\n        if not message and not message_html:\n            message = '%d: %s' % (code, httplib.responses.get(code))\n        if style == 'plain':\n            self.__render_plain_message(message, message_html)\n        else:\n            try:\n                self.render('message.html', cls=style,\n                            message=message, message_html=message_html)\n            except:\n                self.__render_plain_message(message, message_html)\n        self.terminate_response()\n\n    def __render_plain_message(self, message, message_html):\n        self.response.out.write(\n            django.utils.html.escape(message) +\n            ('<p>' if message and message_html else '') +\n            message_html)\n\n    def terminate_response(self):\n        \"\"\"Prevents any further output from being written.\"\"\"\n        self.response.out.write = lambda *args: None\n        self.get = lambda *args: None\n        self.post = lambda *args: None\n\n    def write(self, text):\n        \"\"\"Sends text to the client using the charset from select_charset().\"\"\"\n        self.response.out.write(text.encode(self.env.charset, 'replace'))\n\n    def get_url(self, action, repo=None, scheme=None, **params):\n        \"\"\"Constructs the absolute URL for a given action and query parameters,\n        preserving the current repo and the parameters listed in\n        PRESERVED_QUERY_PARAM_NAMES.\"\"\"\n        return get_url(self.request, repo or self.env.repo, action,\n                       charset=self.env.charset, scheme=scheme, **params)\n\n    @staticmethod\n    def add_task_for_repo(repo, name, action, **kwargs):\n        \"\"\"Queues up a task for an individual repository.\"\"\"\n        task_name = '%s-%s-%s' % (repo, name, int(time.time()*1000))\n        path = '/%s/%s' % (repo, action)\n        taskqueue.add(name=task_name, method='GET', url=path, params=kwargs)\n\n    def send_mail(self, to, subject, body):\n        \"\"\"Sends e-mail using a sender address that's allowed for this app.\"\"\"\n        app_id = get_app_name()\n        sender = 'Do not reply <do-not-reply@%s.%s>' % (app_id, EMAIL_DOMAIN)\n        logging.info('Add mail task: recipient %r, subject %r' % (to, subject))\n        taskqueue.add(queue_name='send-mail', url='/global/admin/send_mail',\n                      params={'sender': sender,\n                              'to': to,\n                              'subject': subject,\n                              'body': body})\n\n    def get_captcha_html(self, error_code=None, use_ssl=False):\n        \"\"\"Generates the necessary HTML to display a CAPTCHA validation box.\"\"\"\n\n        # We use the 'custom_translations' parameter for UI messages, whereas\n        # the 'lang' parameter controls the language of the challenge itself.\n        # reCAPTCHA falls back to 'en' if this parameter isn't recognized.\n        lang = self.env.lang.split('-')[0]\n\n        return recaptcha.client.captcha.get_display_html(\n            site_key=config.get('captcha_site_key'),\n            use_ssl=use_ssl, error=error_code, lang=lang\n        )\n\n    def get_captcha_response(self):\n        \"\"\"Returns an object containing the CAPTCHA response information for the\n        given request's CAPTCHA field information.\"\"\"\n        # Allows faking the CAPTCHA response by an HTTP request parameter, but\n        # only locally, for testing purpose.\n        faked_captcha_response = self.request.get('faked_captcha_response')\n        if faked_captcha_response and self.request.remote_addr == '127.0.0.1':\n            return recaptcha.client.captcha.RecaptchaResponse(\n                is_valid=faked_captcha_response == 'success')\n\n        captcha_response = self.request.get('g-recaptcha-response')\n        return recaptcha.client.captcha.submit(captcha_response)\n\n    def handle_exception(self, exception, debug_mode):\n        logging.error(traceback.format_exc())\n        self.error(500, _(\n            'There was an error processing your request.  Sorry for the '\n            'inconvenience.  Our administrators will investigate the source '\n            'of the problem, but please check that the format of your '\n            'request is correct.'))\n\n    def __get_env_language_for_babel(self):\n        language_code = self.env.lang\n        try:\n            return babel.Locale.parse(language_code, sep='-')\n        except babel.UnknownLocaleError as e:\n            # fallback language\n            return babel.Locale('en')\n\n    def to_local_time(self, date):\n        \"\"\"Converts a datetime object to the local time configured for the\n        current repository.  For convenience, returns None if date is None.\"\"\"\n        # TODO(kpy): This only works for repositories that have a single fixed\n        # time zone offset and never use Daylight Saving Time.\n        if date:\n            if self.config.time_zone_offset:\n                return date + timedelta(0, 3600*self.config.time_zone_offset)\n            return date\n\n    def format_datetime_localized(self, dt):\n        \"\"\"Formats a datetime object to a localized human-readable string based\n        on the current locale.\"\"\"\n        return format_datetime(dt, locale=self.__get_env_language_for_babel());\n\n    def format_date_localized(self, dt):\n        \"\"\"Formats a datetime object to a localized human-readable string based\n        on the current locale containing only the date.\"\"\"\n        return format_date(dt, locale=self.__get_env_language_for_babel());\n\n    def format_time_localized(self, dt):\n        \"\"\"Formats a datetime object to a localized human-readable string based\n        on the current locale containing only the time.\"\"\"\n        return format_time(dt, locale=self.__get_env_language_for_babel());\n\n    def to_formatted_local_datetime(self, dt):\n        \"\"\"Converts a datetime object to the local datetime configured for the\n        current repository and formats to a localized human-readable string\n        based on the current locale.\"\"\"\n        dt = self.to_local_time(dt)\n        return self.format_datetime_localized(dt)\n\n    def to_formatted_local_date(self, dt):\n        \"\"\"Converts a datetime object to the local date configured for the\n        current repository and formats to a localized human-readable string\n        based on the current locale.\"\"\"\n        dt = self.to_local_time(dt)\n        return self.format_date_localized(dt)\n\n    def to_formatted_local_time(self, dt):\n        \"\"\"Converts a datetime object to the local time configured for the\n        current repository and formats to a localized human-readable string\n        based on the current locale.\"\"\"\n        dt = self.to_local_time(dt)\n        return self.format_time_localized(dt)\n\n    def maybe_redirect_for_repo_alias(self, request):\n        \"\"\"If the specified repository name is an alias, redirects to the URL\n        with the canonical repository name and returns True. Otherwise returns\n        False.\n        \"\"\"\n        # Config repo_alias is a dictionary from a repository name alias to\n        # its canonical.\n        # e.g., {'yol': '2013-yolanda', 'jam': '2014-jammu-kashmir-floods'}\n        #\n        # A repository name alias can be used instead of the canonical\n        # repository name in URLs. This is especially useful combined with\n        # the short URL. e.g., You can access\n        # https://www.google.org/personfinder/2014-jammu-kashmir-floods\n        # by https://g.co/pf/jam .\n        if not self.repo:\n            return False\n        repo_aliases = config.get('repo_aliases', default={})\n        if self.repo in repo_aliases:\n            canonical_repo = repo_aliases[self.repo]\n            params = {}\n            for name in request.arguments():\n                params[name] = request.get(name)\n            # Redirects to the same URL including the query parameters, except\n            # for the repository name.\n            self.redirect('/' + self.env.action, repo=canonical_repo, **params)\n            self.terminate_response()\n            return True\n        else:\n            return False\n\n    def should_show_inline_photo(self, photo_url):\n        \"\"\"Returns True if we should show the photo in our site directly with\n        <img> tag. Returns True only if the photo is served by our domain, to\n        avoid loading resources in other domains in Person Finder.\n        \"\"\"\n        if not photo_url:\n            return False\n        else:\n            _, our_netloc, _, _, _ = urlparse.urlsplit(self.request.url)\n            _, photo_netloc, _, _, _ = urlparse.urlsplit(photo_url)\n            return photo_netloc == our_netloc\n\n    URL_PARSE_QUERY_INDEX = 4\n\n    def get_thumbnail_url(self, photo_url):\n        \"\"\"Get a thumbnail URL for an uploaded photo's URL.\n\n        Args:\n            photo_url: a photo URL for an uploaded photo\n        \"\"\"\n        if not photo_url:\n            return None\n        parsed_url = list(urlparse.urlparse(photo_url))\n        params_dict = dict(urlparse.parse_qsl(\n            parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX]))\n        params_dict['thumb'] = 'true'\n        parsed_url[BaseHandler.URL_PARSE_QUERY_INDEX] = urllib.urlencode(\n            params_dict)\n        return urlparse.urlunparse(parsed_url)\n\n    def set_auth(self):\n        self.auth = None\n        if self.params.key:\n            if self.repo:\n                # check for domain specific one.\n                self.auth = model.Authorization.get(self.repo, self.params.key)\n            if not self.auth:\n                # perhaps this is a global key ('*' for consistency with config).\n                self.auth = model.Authorization.get('*', self.params.key)\n        if self.auth and not self.auth.is_valid:\n            self.auth = None\n\n    def __return_unimplemented_method_error(self):\n        return self.error(\n            405,\n            'HTTP method %s is not allowed for this URL.'\n                % self.request.method)\n\n    def __init__(self, request, response, env):\n        webapp.RequestHandler.__init__(self, request, response)\n        self.params = Struct()\n        self.env = env\n        self.repo = env.repo\n        self.config = env.config\n        self.charset = env.charset\n\n        # Set default Content-Type header.\n        self.response.headers['Content-Type'] = (\n            'text/html; charset=%s' % self.charset)\n        if self.admin_required:\n            self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n\n        # Validate query parameters.\n        for name, validator in self.auto_params.items():\n            try:\n                value = self.request.get(name, '')\n                setattr(self.params, name, validator(value))\n            except Exception, e:\n                setattr(self.params, name, validator(None))\n                return self.error(400, 'Invalid parameter %s: %s' % (name, e))\n\n        # Ensure referrer is in whitelist, if it exists\n        if self.params.referrer and (not self.params.referrer in\n                                     self.config.referrer_whitelist):\n            setattr(self.params, 'referrer', '')\n\n        # Check for SSL (unless running local dev app server).\n        if self.https_required and not is_dev_app_server():\n            if self.env.scheme != 'https':\n                url_parts = list(urlparse.urlparse(self.request.url))\n                url_parts[0] = 'https'  # The 0th part is the scheme.\n                webapp.RequestHandler.redirect(\n                    self, urlparse.urlunparse(url_parts))\n                self.terminate_response()\n                return\n\n        # Handles repository alias.\n        if self.maybe_redirect_for_repo_alias(request):\n            return\n\n        # Shows a custom error page here when the user is not an admin\n        # instead of \"login: admin\" in app.yaml\n        # If we use it, user can't sign out\n        # because the error page of \"login: admin\" doesn't have sign-out link.\n        if self.admin_required:\n            self.env.user = users.get_current_user()\n            if not self.env.user:\n                login_url = users.create_login_url(self.request.url)\n                webapp.RequestHandler.redirect(self, login_url)\n                self.terminate_response()\n                return\n            if not users.is_current_user_admin():\n                logout_url = users.create_logout_url(self.request.url)\n                self.render('not_admin_error.html', logout_url=logout_url, user=user)\n                self.terminate_response()\n                return\n            self.env.logout_url = users.create_logout_url(self.request.url)\n            # This is different from env.repo_options because this contains all\n            # repositories including deactivated ones.\n            self.env.all_repo_options = [\n                Struct(\n                    repo=repo,\n                    url=get_repo_url(self.request, repo) + '/admin')\n                for repo in sorted(model.Repo.list())]\n\n        # Handlers that don't need a repository configuration can skip it.\n        if not self.repo:\n            if self.repo_required:\n                return self.error(400, 'No repository specified.')\n            return\n        # Everything after this requires a repo.\n\n        # Reject requests for repositories that don't exist.\n        if not model.Repo.get_by_key_name(self.repo):\n            html = 'No such repository. '\n            if self.env.repo_options:\n                html += 'Select:<p>' + self.render_to_string('repo-menu.html')\n            return self.error(404, message_html=html)\n\n        # If this repository has been deactivated, terminate with a message.\n        # The ignore_deactivation flag is for admin pages that bypass this.\n        if self.config.deactivated and not self.ignore_deactivation:\n            self.env.language_menu = []\n            self.env.robots_ok = True\n            self.render('message.html', cls='deactivation',\n                        message_html=self.config.deactivation_message_html)\n            self.terminate_response()\n\n    def get(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def post(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def put(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def head(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def options(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def delete(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n    def trace(self, *args):\n        \"\"\"Default handler implementation which returns HTTP status 405.\"\"\"\n        return self.__return_unimplemented_method_error()\n\n\n# ==== XSRF protection =========================================================\n\nclass XsrfTool(object):\n\n    # XSRF tokens expire after 4 hours.\n    TOKEN_EXPIRATION_TIME = 60 * 60 * 4\n\n    def __init__(self):\n        configured_key = config.get('xsrf_token_key')\n        if configured_key:\n            # config.get returns unicode, but hmac is going to want a str\n            self._key = configured_key.encode('utf-8')\n        else:\n            configured_key = generate_random_key(20)\n            config.set(xsrf_token_key=configured_key)\n            self._key = configured_key\n\n    def generate_token(self, user_id, action_id):\n        action_time = get_utcnow_timestamp()\n        return '%s/%f' % (\n            self._generate_hmac_digest(user_id, action_id, action_time),\n            action_time)\n\n    def verify_token(self, token, user_id, action_id):\n        token_spl = token.split('/')\n        if len(token_spl) != 2:\n            return False\n        [hmac_digest, action_time_str] = token_spl\n        action_time = float(action_time_str)\n        if (action_time + XsrfTool.TOKEN_EXPIRATION_TIME <\n            get_utcnow_timestamp()):\n            return False\n        expected_hmac_digest = self._generate_hmac_digest(\n            user_id, action_id, action_time)\n        return hmac.compare_digest(\n            hmac_digest.encode('utf-8'), expected_hmac_digest)\n\n    def _generate_hmac_digest(self, user_id, action_id, action_time):\n        hmac_obj = hmac.new(\n            self._key, '%s/%s/%f' % (user_id, action_id, action_time))\n        return hmac_obj.hexdigest()\n/n/n/ntests/test_xsrftool.py/n/n\"\"\"Tests for the XSRF tool.\"\"\"\n\nimport datetime\nimport unittest\n\nimport config\nimport utils\n\n\nclass XsrfToolTests(unittest.TestCase):\n    \"\"\"Test cases for utils.XsrfTool.\"\"\"\n\n    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)\n\n    def setUp(self):\n        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)\n\n    def test_gen_and_verify_good_token(self):\n        \"\"\"Tests generating and verifying a good token.\"\"\"\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))\n\n    def test_rejects_invalid_tokens(self):\n        \"\"\"Tests that an invalid token is rejected.\"\"\"\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        self.assertFalse(tool.verify_token(\n            'ThisTokenDoesNotEvenHaveASlash', 12345, 'test_action'))\n        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)\n        self.assertFalse(\n            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,\n                              'test_action'))\n\n    def test_rejects_expired_token(self):\n        \"\"\"Tests that an expired token is rejected.\"\"\"\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +\n                                  datetime.timedelta(hours=4, minutes=1))\n        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))\n\n    def test_good_with_no_prior_key(self):\n        \"\"\"Tests a good token when a token key has to be autogenerated.\n\n        If the config doesn't already have an XSRF token key set, the XSRF tool\n        will generate one automatically.\n        \"\"\"\n        # config seems to be shared across tests, so we have to specifically set\n        # it to None.\n        config.set(xsrf_token_key=None)\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))\n\n    def test_bad_with_no_prior_key(self):\n        \"\"\"Tests a bad token when a token key has to be autogenerated.\n\n        If the config doesn't already have an XSRF token key set, the XSRF tool\n        will generate one automatically.\n        \"\"\"\n        # config seems to be shared across tests, so we have to specifically set\n        # it to None.\n        config.set(xsrf_token_key=None)\n        tool = utils.XsrfTool()\n        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)\n        self.assertFalse(\n            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,\n                              'test_action'))\n/n/n/ntests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Access restriction tests.\"\"\"\n\nimport os\n\nimport django.urls\n\nimport urls\nimport views\n\nimport view_tests_base\n\n\nclass AccessRestrictionTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests that access restrictions are enforced.\"\"\"\n\n    # Dictionary from path name to a boolean indicating whether the page should\n    # be restricted to admins.\n    IS_RESTRICTED_TO_ADMINS = {\n        'admin_apikeys-manage': True,\n        'admin_apikeys-list': True,\n        'admin_create-repo': True,\n        'admin_delete-record': True,\n        'admin_statistics': True,\n        'meta_sitemap': False,\n    }\n\n    def get_path(self, path_name):\n        # If we ever have URLs with more interesting things in the path besides\n        # repo, we'll have to rethink this.\n        try:\n            return django.urls.reverse(path_name)\n        except django.urls.NoReverseMatch:\n            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})\n\n    def test_blocked_to_non_admins(self):\n        \"\"\"Tests that admin-only pages aren't available to non-admins.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 403\n            assert self.client.post(path, secure=True).status_code == 403\n\n    def test_available_to_admins(self):\n        \"\"\"Tests that admin-only pages are available to admins.\n\n        This is a sort of meta-test: I'm not really concerned that we might\n        accidentally lock admins out of the admin pages, but I do want to make\n        sure that the test above actually depends on the user not being an admin\n        (as opposed to access getting denied because the tests are set up wrong\n        somehow).\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 200\n            # Don't test POST requests here; they'll need an XSRF token and\n            # that'll be covered in a separate test.\n\n    def test_other_pages_unrestricted(self):\n        \"\"\"Tests that non-admins can access unrestricted pages.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: not item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code != 403\n\n    def test_all_paths_included(self):\n        \"\"\"Tests that all (Django-served) pages are listed.\n\n        We want to make sure no one forgets to add these tests for admin pages,\n        so we require that each URL path is included in the dictionary above.\n        \"\"\"\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed__'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            if pattern.name.startswith('tasks_'):\n                # Skip task handlers; they'll be tested separately.\n                # TODO(nworden): test them\n                continue\n            assert (\n                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)\n/n/n/ntests/views/test_auto_security.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Automatic security tests.\n\nThis file isn't meant for tests specific to a particular page; they're designed\nas general-purpose tests for common security requirements. All paths must be\nincluded in the AutoSecurityTests.PATH_TEST_INFO list (this is tested to ensure\nwe can't forget these tests for a new view).\n\"\"\"\n\nimport collections\nimport copy\nimport os\n\nimport django.urls\n\nimport urls\n\nimport view_tests_base\n\n\n# A tuple containing configuration for automatic security tests for a path.\nPathTestInfo = collections.namedtuple(\n    'PathTestInfo',\n    [\n        # Whether the path is expected to accept GET requests.\n        'accepts_get',\n        # Whether the past is expected to accept POST requests.\n        'accepts_post',\n        # Whether the page is restricted to admins.\n        'restricted_to_admins',\n        # Whether POST requests should require an XSRF token.\n        'requires_xsrf',\n        # A dict with valid POST data, excluding an XSRF token (the tests will\n        # add, or omit, the XSRF tokens). Should be None if XSRF isn't used for\n        # the page.\n        'sample_post_data',\n        # The action ID used for XSRF tokens. Should be None if XSRF isn't used\n        # for the page.\n        'xsrf_action_id',\n    ])\n\n\nclass AutoSecurityTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests that access restrictions are enforced.\"\"\"\n    # pylint: disable=no-self-use\n\n    # A map from path names (defined in urls.py) to PathTestInfo tuples.\n    PATH_TEST_INFO = {\n        'admin_apikeys-list':\n        PathTestInfo(\n            accepts_get=True,\n            accepts_post=False,\n            restricted_to_admins=True,\n            requires_xsrf=False,\n            sample_post_data=None,\n            xsrf_action_id=None),\n        'admin_apikeys-manage':\n        PathTestInfo(\n            accepts_get=True,\n            accepts_post=True,\n            restricted_to_admins=True,\n            requires_xsrf=True,\n            sample_post_data={\n                'contact_name': 'Bob',\n                'contact_email': 'bob@fridge.com',\n                'organization_name': 'Vance Refrigeration',\n            },\n            xsrf_action_id='admin_api_keys'),\n        'admin_create-repo':\n        PathTestInfo(\n            accepts_get=True,\n            accepts_post=True,\n            restricted_to_admins=True,\n            requires_xsrf=True,\n            sample_post_data={\n                'new_repo': 'new-hampshire',\n            },\n            xsrf_action_id='admin/create_repo'),\n        'admin_delete-record':\n        PathTestInfo(\n            accepts_get=True,\n            accepts_post=True,\n            restricted_to_admins=True,\n            requires_xsrf=True,\n            sample_post_data={\n                'id': 'abc123',\n            },\n            xsrf_action_id='admin/delete_record'),\n        'admin_statistics':\n        PathTestInfo(\n            accepts_get=True,\n            accepts_post=False,\n            restricted_to_admins=True,\n            requires_xsrf=False,\n            sample_post_data=None,\n            xsrf_action_id=None),\n        'meta_sitemap':\n        PathTestInfo(\n            accepts_get=True,\n            accepts_post=False,\n            restricted_to_admins=False,\n            requires_xsrf=False,\n            sample_post_data=None,\n            xsrf_action_id=None),\n    }\n\n    def get_path(self, path_name):\n        \"\"\"Gets a path to use for the given path name.\n\n        Args:\n            path_name (str): The path name defined in urls.py.\n\n        This will first try to reverse the URL with no arguments, and then fall\n        back to reversing it with a \"repo\" argument. If we ever have URLs with\n        more interesting things in the path besides repo, we'll have to rethink\n        this.\n        \"\"\"\n        try:\n            return django.urls.reverse(path_name)\n        except django.urls.NoReverseMatch:\n            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})\n\n    def get_valid_post_data(self, path_info):\n        \"\"\"Gets data for a valid POST requests.\n\n        Generates and includes a valid XSRF token when needed.\n        \"\"\"\n        if path_info.requires_xsrf:\n            # Copy the data dict to avoid mutating the original.\n            data = copy.deepcopy(path_info.sample_post_data)\n            data['xsrf_token'] = self._xsrf_tool.generate_token(\n                view_tests_base.ViewTestsBase.TEST_USER_ID,\n                path_info.xsrf_action_id)\n            return data\n        return path_info.sample_post_data\n\n    def get_paths_to_test(self, filter_func):\n        \"\"\"Gets paths to test based on a filter function.\n\n        Args:\n            filter_func (function): A function that accepts a PathTestInfo tuple\n            and returns True or False to indicate if it should be included.\n\n        Returns:\n            list: A list of tuples with path names and PathTestInfo tuples.\n        \"\"\"\n        return [(path_name, path_info)\n                for (path_name,\n                     path_info) in AutoSecurityTests.PATH_TEST_INFO.items()\n                if filter_func(path_info)]\n\n    def test_blocked_to_non_admins(self):\n        \"\"\"Tests that admin-only pages aren't available to non-admins.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, path_info) in self.get_paths_to_test(\n                lambda path_info: path_info.restricted_to_admins):\n            path = self.get_path(path_name)\n            if path_info.accepts_get:\n                self.assertEqual(\n                    self.client.get(path, secure=True).status_code, 403,\n                    'Admin-only page available to non-admin: %s' % path_name)\n            if path_info.accepts_post:\n                self.assertEqual(\n                    self.client.post(\n                        path, self.get_valid_post_data(path_info),\n                        secure=True).status_code, 403,\n                    'Admin-only page available to non-admin: %s' % path_name)\n\n    def test_available_to_admins(self):\n        \"\"\"Tests that admin-only pages are available to admins.\n\n        This is a sort of meta-test: I'm not really concerned that we might\n        accidentally lock admins out of the admin pages, but I do want to make\n        sure that the test above actually depends on the user not being an admin\n        (as opposed to access getting denied because the tests are set up wrong\n        somehow).\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, path_info) in self.get_paths_to_test(\n                lambda path_info: path_info.restricted_to_admins):\n            path = self.get_path(path_name)\n            if path_info.accepts_get:\n                self.assertEqual(\n                    self.client.get(path, secure=True).status_code, 200,\n                    'GET unavailable to admins for: %s' % path_name)\n            # Some POST requests might return a redirect, so just ensure they\n            # don't get a 403 like non-admins do.\n            if path_info.accepts_post:\n                self.assertNotEqual(\n                    self.client.post(\n                        path, self.get_valid_post_data(path_info),\n                        secure=True).status_code, 403,\n                    'POST unavailable to admins for: %s' % path_name)\n\n    def test_other_pages_unrestricted(self):\n        \"\"\"Tests that non-admins can access unrestricted pages.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, path_info) in self.get_paths_to_test(\n                lambda path_info: not path_info.restricted_to_admins):\n            path = self.get_path(path_name)\n            if path_info.accepts_get:\n                self.assertEqual(\n                    self.client.get(path, secure=True).status_code, 200,\n                    'Unrestricted page blocked to non-admin: %s' % path_name)\n            if path_info.accepts_post:\n                # Redirects are fine, just check that they don't get a 403.\n                self.assertNotEqual(\n                    self.client.post(\n                        path, self.get_valid_post_data(path_info),\n                        secure=True).status_code, 403,\n                    'Unrestricted page blocked to non-admin: %s' % path_name)\n\n    def test_missing_xsrf_token(self):\n        \"\"\"Tests that, if XSRF is required, POSTs without a token are rejected.\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, path_info) in self.get_paths_to_test(\n                lambda path_info: path_info.requires_xsrf):\n            # Just in case someone accidentally included an XSRF token in the\n            # PathTestInfo tuple.\n            assert 'xsrf_token' not in path_info.sample_post_data\n            path = self.get_path(path_name)\n            self.assertEqual(\n                self.client.post(path, path_info.sample_post_data,\n                                 secure=True).status_code, 403,\n                'XSRF page accepts data missing XSRF token: %s' % path_name)\n            post_data = copy.deepcopy(path_info.sample_post_data)\n            post_data['xsrf_token'] = ''\n            self.assertEqual(\n                self.client.post(path, post_data, secure=True).status_code, 403,\n                'XSRF page accepts data empty XSRF token: %s' % path_name)\n\n    def test_invalid_xsrf_token(self):\n        \"\"\"Tests that XSRF tokens are checked for validity.\"\"\"\n        self.login(is_admin=True)\n        for (path_name, path_info) in self.get_paths_to_test(\n                lambda path_info: path_info.requires_xsrf):\n            path = self.get_path(path_name)\n            post_data = copy.deepcopy(path_info.sample_post_data)\n            post_data['xsrf_token'] = 'NotAValidToken'\n            self.assertEqual(\n                self.client.post(path, post_data, secure=True).status_code, 403,\n                'XSRF page accepts data invalid XSRF token: %s' % path_name)\n\n    def test_all_paths_included(self):\n        \"\"\"Tests that all (Django-served) pages are listed.\n\n        We want to make sure no one forgets to add these tests for admin pages,\n        so we require that each URL path is included in the dictionary above.\n        \"\"\"\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed__'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            if pattern.name.startswith('tasks_'):\n                # Skip tasks; they'll be tested separately.\n                continue\n            assert pattern.name in AutoSecurityTests.PATH_TEST_INFO\n\n    def test_gae_task_header_required(self):\n        \"\"\"Tests that tasks can only be called by App Engine.\n\n        App Engine sets a special header (and strips it out of external\n        requests); we use that to reject external requests to task handlers.\n        \"\"\"\n        # Set this to a non-dev ID, because we permit non-GAE requests in dev.\n        os.environ['APPLICATION_ID'] = 'prod-app'\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed__'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            if not pattern.name.startswith('tasks_'):\n                # Skip views that aren't task handlers; they're tested\n                # elsewhere.\n                continue\n            path = self.get_path(pattern.name)\n            assert self.client.get(path, secure=True).status_code == 403\n/n/n/ntests/views/view_tests_base.py/n/n\"\"\"Tools to help run tests against the Django app.\"\"\"\n\nimport const\nimport utils\n\nimport scrape\nimport testutils.base\n\n\nclass ViewTestsBase(testutils.base.ServerTestsBase):\n    \"\"\"A base class for tests for the Django app.\"\"\"\n\n    TEST_USER_EMAIL = 'kay@mib.gov'\n    TEST_USER_ID = 'k'\n\n    def setUp(self):\n        super(ViewTestsBase, self).setUp()\n        self._xsrf_tool = utils.XsrfTool()\n\n    def login(self, is_admin=False):\n        \"\"\"Logs in the \"user\" for making requests.\n\n        Args:\n           is_admin (bool): Whether the user should be considered an admin.\n        \"\"\"\n        self.testbed.setup_env(\n            user_email=ViewTestsBase.TEST_USER_EMAIL,\n            user_id=ViewTestsBase.TEST_USER_ID,\n            user_is_admin='1' if is_admin else '0',\n            overwrite=True)\n\n    def xsrf_token(self, action_id):\n        return self._xsrf_tool.generate_token(\n            ViewTestsBase.TEST_USER_ID, action_id)\n\n    def to_doc(self, response):\n        \"\"\"Produces a scrape.Document from the Django test response.\n\n        Args:\n            response (Response): A response from a Django test client.\n\n        Returns:\n            scrape.Document: A wrapper around the response's contents to help\n                with examining it.\n        \"\"\"\n        # TODO(nworden): when everything's on Django, make some changes to\n        # scrape.py so it better fits Django's test framework.\n        return scrape.Document(\n            content_bytes=response.content,\n            # The Django test Response objects don't include the URL, but that's\n            # ok: the Document's url field is only used by scrape.Session, which\n            # we're not using with the Django tests.\n            url=None,\n            status=response.status_code,\n            # We aren't using this, at least not in the Django tests.\n            message=None,\n            # The response headers are accessed directly through the Response\n            # object.\n            headers=response,\n            charset=const.CHARSET_UTF8)\n/n/n/n", "label": 0}, {"id": "89bf68c6f62362e29467a2ed22eb2b477268eef8", "code": "/tests/test_xsrftool.py/n/n\"\"\"Tests for the XSRF tool.\"\"\"\n\nimport datetime\nimport unittest\n\nimport config\nimport utils\n\n\nclass XsrfToolTests(unittest.TestCase):\n    \"\"\"Test cases for utils.XsrfTool.\"\"\"\n\n    TEST_NOW = datetime.datetime(2010, 1, 31, 18, 0, 0)\n\n    def setUp(self):\n        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW)\n\n    def test_gen_and_verify_good_token(self):\n        \"\"\"Tests generating and verifying a good token.\"\"\"\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))\n\n    def test_rejects_invalid_token(self):\n        \"\"\"Tests that an invalid token is rejected.\"\"\"\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)\n        self.assertFalse(\n            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,\n                              'test_action'))\n\n    def test_rejects_expired_token(self):\n        \"\"\"Tests that an expired token is rejected.\"\"\"\n        config.set(xsrf_token_key='abcdef')\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        utils.set_utcnow_for_test(XsrfToolTests.TEST_NOW +\n                                  datetime.timedelta(hours=4, minutes=1))\n        self.assertFalse(tool.verify_token(token, 12345, 'test_action'))\n\n    def test_good_with_no_prior_key(self):\n        \"\"\"Tests a good token when a token key has to be autogenerated.\n\n        If the config doesn't already have an XSRF token key set, the XSRF tool\n        will generate one automatically.\n        \"\"\"\n        # config seems to be shared across tests, so we have to specifically set\n        # it to None.\n        config.set(xsrf_token_key=None)\n        tool = utils.XsrfTool()\n        token = tool.generate_token(12345, 'test_action')\n        self.assertTrue(tool.verify_token(token, 12345, 'test_action'))\n\n    def test_bad_with_no_prior_key(self):\n        \"\"\"Tests a bad token when a token key has to be autogenerated.\n\n        If the config doesn't already have an XSRF token key set, the XSRF tool\n        will generate one automatically.\n        \"\"\"\n        # config seems to be shared across tests, so we have to specifically set\n        # it to None.\n        config.set(xsrf_token_key=None)\n        tool = utils.XsrfTool()\n        timestamp = utils.get_timestamp(XsrfToolTests.TEST_NOW)\n        self.assertFalse(\n            tool.verify_token('NotTheRightDigest/%f' % timestamp, 12345,\n                              'test_action'))\n/n/n/n/tests/views/test_access_restriction.py/n/n# Copyright 2019 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"Access restriction tests.\"\"\"\n\nimport os\n\nimport django.urls\n\nimport urls\nimport views\n\nimport view_tests_base\n\n\nclass AccessRestrictionTests(view_tests_base.ViewTestsBase):\n    \"\"\"Tests that access restrictions are enforced.\"\"\"\n\n    # Dictionary from path name to a boolean indicating whether the page should\n    # be restricted to admins.\n    IS_RESTRICTED_TO_ADMINS = {\n        'admin_apikeys-manage': True,\n        'admin_apikeys-list': True,\n        'admin_create-repo': True,\n        'admin_delete-record': True,\n        'admin_statistics': True,\n        'meta_sitemap': False,\n    }\n\n    def get_path(self, path_name):\n        # If we ever have URLs with more interesting things in the path besides\n        # repo, we'll have to rethink this.\n        try:\n            return django.urls.reverse(path_name)\n        except django.urls.NoReverseMatch:\n            return django.urls.reverse(path_name, kwargs={'repo': 'haiti'})\n\n    def test_blocked_to_non_admins(self):\n        \"\"\"Tests that admin-only pages aren't available to non-admins.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 403\n            assert self.client.post(path, secure=True).status_code == 403\n\n    def test_available_to_admins(self):\n        \"\"\"Tests that admin-only pages are available to admins.\n\n        This is a sort of meta-test: I'm not really concerned that we might\n        accidentally lock admins out of the admin pages, but I do want to make\n        sure that the test above actually depends on the user not being an admin\n        (as opposed to access getting denied because the tests are set up wrong\n        somehow).\n        \"\"\"\n        self.login(is_admin=True)\n        for (path_name, _\n            ) in filter(lambda item: item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code == 200\n            # Don't test POST requests here; they'll need an XSRF token and\n            # that'll be covered in a separate test.\n\n    def test_other_pages_unrestricted(self):\n        \"\"\"Tests that non-admins can access unrestricted pages.\"\"\"\n        self.login(is_admin=False)\n        for (path_name, _\n            ) in filter(lambda item: not item[1],\n                        AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS.items()):\n            path = self.get_path(path_name)\n            assert self.client.get(path, secure=True).status_code != 403\n\n    def test_all_paths_included(self):\n        \"\"\"Tests that all (Django-served) pages are listed.\n\n        We want to make sure no one forgets to add these tests for admin pages,\n        so we require that each URL path is included in the dictionary above.\n        \"\"\"\n        for pattern in urls.urlpatterns:\n            if pattern.name.startswith('prefixed__'):\n                # Skip these; they're the same views as the non-prefixed\n                # versions.\n                continue\n            if pattern.name.startswith('tasks_'):\n                # Skip task handlers; they'll be tested separately.\n                # TODO(nworden): test them\n                continue\n            assert (\n                pattern.name in AccessRestrictionTests.IS_RESTRICTED_TO_ADMINS)\n/n/n/n/tests/views/view_tests_base.py/n/n\"\"\"Tools to help run tests against the Django app.\"\"\"\n\nimport const\nimport utils\n\nimport scrape\nimport testutils.base\n\n\nclass ViewTestsBase(testutils.base.ServerTestsBase):\n    \"\"\"A base class for tests for the Django app.\"\"\"\n\n    _USER_ID = 'k'\n\n    def setUp(self):\n        super(ViewTestsBase, self).setUp()\n        self._xsrf_tool = utils.XsrfTool()\n\n    def login(self, is_admin=False):\n        \"\"\"Logs in the \"user\" for making requests.\n\n        Args:\n           is_admin (bool): Whether the user should be considered an admin.\n        \"\"\"\n        self.testbed.setup_env(\n            user_email='kay@mib.gov',\n            user_id=ViewTestsBase._USER_ID,\n            user_is_admin='1' if is_admin else '0',\n            overwrite=True)\n\n    def xsrf_token(self, action_id):\n        return self._xsrf_tool.generate_token(ViewTestsBase._USER_ID, action_id)\n\n    def to_doc(self, response):\n        \"\"\"Produces a scrape.Document from the Django test response.\n\n        Args:\n            response (Response): A response from a Django test client.\n\n        Returns:\n            scrape.Document: A wrapper around the response's contents to help\n                with examining it.\n        \"\"\"\n        # TODO(nworden): when everything's on Django, make some changes to\n        # scrape.py so it better fits Django's test framework.\n        return scrape.Document(\n            content_bytes=response.content,\n            # The Django test Response objects don't include the URL, but that's\n            # ok: the Document's url field is only used by scrape.Session, which\n            # we're not using with the Django tests.\n            url=None,\n            status=response.status_code,\n            # We aren't using this, at least not in the Django tests.\n            message=None,\n            # The response headers are accessed directly through the Response\n            # object.\n            headers=response,\n            charset=const.CHARSET_UTF8)\n/n/n/n", "label": 1}, {"id": "75cf3c0885faa5fa19819b7d83d5bbe120a47fe3", "code": "LikedSavedDownloaderServer.py/n/n#!/usr/bin/env python\n\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\nimport tornado.httpclient\nimport tornado.gen\n\nimport os\nimport random\nimport shutil\nimport json\nimport multiprocessing\n\nfrom utilities import sort_naturally\nimport settings\nimport redditUserImageScraper\n\n# Require a username and password in order to use the web interface. See ReadMe.org for details.\nenable_authentication = False\n#enable_authentication = True\n\nif enable_authentication:\n    import PasswordManager\n\n# List of valid user ids (used to compare user cookie)\nauthenticated_users = []\n\nvideoExtensions = ('.mp4', '.webm')\nsupportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')\n\nsavedImagesCache = []\ndef generateSavedImagesCache(outputDir):\n    global savedImagesCache\n    # Clear cache in case already created\n    savedImagesCache = []\n\n    print('Creating Liked Saved cache...')\n    \n    for root, dirs, files in os.walk(outputDir):\n        for file in files:\n            if file.endswith(supportedExtensions):\n                savedImagesCache.append(os.path.join(root, file))\n\n    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))\n\ndef outputPathToServerPath(path):\n    # This is a little weird\n    return 'output' + path.split(settings.settings['Output_dir'])[1]\n\ndef getRandomImage(filteredImagesCache=None, randomImageFilter=''):\n    if not savedImagesCache:\n        generateSavedImagesCache(settings.settings['Output_dir'])\n\n    if filteredImagesCache:\n        randomImage = random.choice(filteredImagesCache)\n    else:\n        randomImage = random.choice(savedImagesCache)\n\n    print('\\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))\n\n    serverPath = outputPathToServerPath(randomImage)\n\n    return randomImage, serverPath\n\n#\n# Tornado handlers\n#\n\n# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py\n# https://www.tornadoweb.org/en/stable/guide/security.html\n\ndef login_get_current_user(handler):\n    if enable_authentication:\n        cookie = handler.get_secure_cookie(\"user\")\n        if cookie in authenticated_users:\n            return cookie\n        else:\n            print(\"Bad/expired cookie received\")\n            return None\n    else:\n        return \"authentication_disabled\"\n\nclass AuthHandler(tornado.web.RequestHandler):\n    def get_current_user(self):\n        return login_get_current_user(self)\n    \nclass LoginHandler(AuthHandler):\n    def get(self):\n        if not enable_authentication:\n            self.redirect(\"/\")\n        else:\n            self.write('<html>'\n                       '<head>'\n\t               '<title>Liked Saved Downloader</title>'\n\t               '<link rel=\"stylesheet\" type=\"text/css\" href=\"webInterfaceNoAuth/index.css\">'\n                       '</head>'\n                       '<body><h1>Login Required</h1>'\n                       '<form action=\"/login\" method=\"post\">'\n                       'Name: <input type=\"text\" name=\"name\"><br />'\n                       'Password: <input type=\"password\" name=\"password\">'\n                       '{}'\n                       '<br /><input type=\"submit\" value=\"Sign in\">'\n                       '</form></body></html>'.format(self.xsrf_form_html()))\n\n    def post(self):\n        global authenticated_users\n        # Test password\n        if enable_authentication and PasswordManager.verify(self.get_argument(\"password\")):\n            # Generate new authenticated user session\n            randomGenerator = random.SystemRandom()\n            cookieSecret = str(randomGenerator.getrandbits(128))\n            authenticated_user = self.get_argument(\"name\") + \"_\" + cookieSecret\n            authenticated_user = authenticated_user.encode()\n            authenticated_users.append(authenticated_user)\n            \n            # Set the cookie on the user's side\n            self.set_secure_cookie(\"user\", authenticated_user)\n            \n            print(\"Authenticated user {}\".format(self.get_argument(\"name\")))\n            \n            # Let them in\n            self.redirect(\"/\")\n        else:\n            print(\"Refused user {} (password doesn't match any in database)\".format(self.get_argument(\"name\")))\n            self.redirect(\"/login\")\n            \nclass LogoutHandler(AuthHandler):\n    @tornado.web.authenticated\n    def get(self):\n        global authenticated_users\n        \n        if enable_authentication:\n            print(\"User {} logging out\".format(self.current_user))\n            if self.current_user in authenticated_users:\n                authenticated_users.remove(self.current_user)\n            self.redirect(\"/login\")\n        else:\n            self.redirect(\"/\")\n\nclass AuthedStaticHandler(tornado.web.StaticFileHandler):\n    def get_current_user(self):\n        return login_get_current_user(self)\n    \n    @tornado.web.authenticated\n    def prepare(self):\n        pass\n\nclass HomeHandler(AuthHandler):\n    @tornado.web.authenticated\n    def get(self):\n        self.render('webInterface/index.html')\n\ndef settingsToHtmlForm():\n    settingsInputs = []\n\n    for sectionSettingsPair in settings.settingsStructure:\n        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))\n\n        for sectionOption in sectionSettingsPair[1]:\n            option = None\n            optionComment = ''\n            if type(sectionOption) == tuple:\n                option = sectionOption[0]\n                optionComment = '<p class=\"optionComment\">{}</p>'.format(sectionOption[1])\n            else:\n                option = sectionOption\n                \n            if type(settings.settings[option]) == bool:\n                settingsInputs.append('''<label for=\"{option}\">{optionName}</label>\n                                     <input type=\"checkbox\" id=\"{option}\" name=\"{option}\" value=\"{optionValue}\" {checkedState} />{comment}\n                                     <br />'''\n                                      .format(option=option, optionName=option.replace('_', ' '),\n                                              comment=optionComment,\n                                              checkedState=('checked' if settings.settings[option] else ''),\n                                              optionValue=('1' if settings.settings[option] else '0')))\n                \n            elif type(settings.settings[option]) == int:\n                settingsInputs.append('''<label for=\"{option}\">{optionName}</label>\n                                     <input type=\"number\" id=\"{option}\" name=\"{option}\" value=\"{optionValue}\" />{comment}\n                                     <br />'''\n                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,\n                                              optionValue=settings.settings[option]))\n                \n            elif type(settings.settings[option]) == str:\n                settingsInputs.append('''<label for=\"{option}\">{optionName}</label>\n                                     <input type=\"{type}\" id=\"{option}\" name=\"{option}\" value=\"{optionValue}\" />{comment}\n                                     <br />'''\n                                      .format(option=option, optionName=option.replace('_', ' '),\n                                              comment=optionComment, optionValue=settings.settings[option],\n                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))\n\n    return ''.join(settingsInputs)\n\nclass SettingsHandler(AuthHandler):\n    def doSettings(self, afterSubmit):\n        htmlSettingsForm = settingsToHtmlForm()\n        settingsFilename = settings.getSettingsFilename()\n        \n        self.write('''<html>\n                            <head>\n                                  <link rel=\"stylesheet\" type=\"text/css\" href=\"webInterface/settings.css\">\n                                  <script type=\"text/javascript\" src=\"webInterface/settings.js\"></script>\n                            </head>\n                            <body>\n                                  <h1>Liked Saved Downloader Settings</h1>\n                                  <a href=\"/\">Back to Homepage</a><br /><br />\n                                  {}\n                                  <p>Settings being read from {}</p>\n                                  <form action=\"/settings\" method=\"post\">\n                                       <input type=\"submit\" value=\"Submit\">\n                                       {}\n                                       <input type=\"submit\" value=\"Submit\">\n                                       {}\n                                  </form>\n                            </body>\n                      </html>'''\n                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),\n                           settingsFilename, htmlSettingsForm, self.xsrf_form_html()))\n\n    @tornado.web.authenticated\n    def get(self):\n        self.doSettings(False)\n\n    @tornado.web.authenticated\n    def post(self):\n        currentOutputDir = settings.settings['Output_dir']\n        \n        print('Received new settings')\n        \n        for option in settings.settings:\n            newValue = self.get_argument(option, None)\n            if not newValue:\n                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes\n                # This means the user set the value to false\n                if type(settings.settings[option]) == bool:\n                    settings.settings[option] = False\n                else:\n                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'\n                          '\\n\\tIgnore this if the field is intentionally empty'.format(option))\n            else:\n                # All false bools are handed in the above if block, so we know they're true here\n                if type(settings.settings[option]) == bool:\n                    newValue = True\n                elif type(settings.settings[option]) == int:\n                    newValue = int(newValue)\n                \n                settings.settings[option] = newValue\n                # print('\\tSet {} = {}'.format(option, newValue))\n\n        # Write out the new settings\n        settings.writeServerSettings()\n        \n        # Respond with a settings page saying we've updated the settings\n        self.doSettings(True)\n\n        # Refresh the cache in case the output directory changed\n        if currentOutputDir != settings.settings['Output_dir']:\n            generateSavedImagesCache(settings.settings['Output_dir'])\n            \n\nclass RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):\n    connections = set()\n\n    def cacheFilteredImages(self):\n        # Clear the cache\n        self.filteredImagesCache = []\n\n        if not self.randomImageFilter:\n            return\n\n        randomImageFilterLower = self.randomImageFilter.lower()\n    \n        for imagePath in savedImagesCache:\n            if randomImageFilterLower in imagePath.lower():\n                self.filteredImagesCache.append(imagePath)\n\n        print('\\tFiltered images with \"{}\"; {} images matching filter'\n              .format(self.randomImageFilter, len(self.filteredImagesCache)))\n\n    def changeCurrentDirectory(self, newDirectory):\n        self.currentDirectoryPath = newDirectory\n        dirList = os.listdir(self.currentDirectoryPath)\n        \n        filteredDirList = []\n        for fileOrDir in dirList:\n            # The script spits out a lot of .json files the user probably doesn't want to see\n            if (not fileOrDir.endswith('.json')\n                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):\n                filteredDirList.append(fileOrDir)\n                \n        self.currentDirectoryCache = sorted(filteredDirList)\n\n    def open(self):\n        if not login_get_current_user(self):\n            return None\n        \n        self.connections.add(self)\n        self.randomHistory = []\n        self.randomHistoryIndex = -1\n        self.favorites = []\n        self.favoritesIndex = 0\n        self.currentImage = None\n        self.randomImageFilter = ''\n        self.filteredImagesCache = []\n        \n        self.currentDirectoryPath = ''\n        self.currentDirectoryCache = []\n        self.directoryFilter = ''\n        # Set up the directory cache with the top-level output\n        self.changeCurrentDirectory(settings.settings['Output_dir'])\n\n    def on_message(self, message):\n        if not login_get_current_user(self):\n            return None\n        \n        print('RandomImageBrowserWebSocket: Received message ', message)\n        parsedMessage = json.loads(message)\n        command = parsedMessage['command']\n        print('RandomImageBrowserWebSocket: Command ', command)\n        action = ''\n\n        \"\"\"\n         Random Image Browser\n        \"\"\"\n\n        if command == 'imageAddToFavorites':\n            if self.currentImage:\n                self.favorites.append(self.currentImage)\n                self.favoritesIndex = len(self.favorites) - 1\n\n        if command == 'nextFavorite':\n            self.favoritesIndex += 1\n            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):\n                action = 'setImage'\n                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]\n            else:\n                self.favoritesIndex = len(self.favorites) - 1\n                if len(self.favorites):\n                    action = 'setImage'\n                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]\n\n        if command == 'previousFavorite' and len(self.favorites):\n            action = 'setImage'\n\n            if self.favoritesIndex > 0:\n                self.favoritesIndex -= 1\n                \n            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]\n\n        if command == 'nextImage':\n            action = 'setImage'\n\n            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:\n                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)\n                self.randomHistory.append((fullImagePath, serverImagePath))\n                self.randomHistoryIndex = len(self.randomHistory) - 1\n            else:\n                self.randomHistoryIndex += 1\n                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]\n\n        if command == 'previousImage':\n            action = 'setImage'\n\n            if self.randomHistoryIndex > 0:\n                self.randomHistoryIndex -= 1\n                \n            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]\n\n        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):\n            fullImagePath, serverImagePath = self.currentImage\n                \n            folder = fullImagePath[:fullImagePath.rfind('/')]\n            imagesInFolder = []\n            for root, dirs, files in os.walk(folder):\n                for file in files:\n                    if file.endswith(supportedExtensions):\n                        imagesInFolder.append(os.path.join(root, file))\n            sort_naturally(imagesInFolder)\n            currentImageIndex = imagesInFolder.index(fullImagePath)\n            if currentImageIndex >= 0:\n                action = 'setImage'\n                \n                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)\n                if nextImageIndex == len(imagesInFolder):\n                    nextImageIndex = 0\n                if nextImageIndex < 0:\n                    nextImageIndex = len(imagesInFolder) - 1\n                    \n                fullImagePath = imagesInFolder[nextImageIndex]\n                serverImagePath = outputPathToServerPath(fullImagePath)\n\n        if command == 'setFilter':\n            newFilter = parsedMessage['filter']\n            if newFilter != self.randomImageFilter:\n                self.randomImageFilter = newFilter\n                self.cacheFilteredImages()\n\n        \"\"\"\n         Directory browser\n        \"\"\"\n\n        if command == 'setDirectoryFilter':\n            newFilter = parsedMessage['filter']\n            if newFilter != self.directoryFilter:\n                self.directoryFilter = newFilter\n                # Refresh cache with new filter\n                self.changeCurrentDirectory(self.currentDirectoryPath)\n                action = 'sendDirectory'\n\n        if command == 'listCurrentDirectory':\n            action = 'sendDirectory'\n\n        if command == 'changeDirectory':\n            # Reset the filter (chances are the user only wanted to filter at one level\n            self.directoryFilter = ''\n            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));\n            action = 'sendDirectory'\n\n        if command == 'directoryUp':\n            # Don't allow going higher than output dir\n            if self.currentDirectoryPath != settings.settings['Output_dir']:\n                upDirectory = (settings.settings['Output_dir']  +\n                               self.currentDirectoryPath[len(settings.settings['Output_dir'])\n                                                         : self.currentDirectoryPath.rfind('/')])\n                # Reset the filter (chances are the user only wanted to filter at one level\n                self.directoryFilter = ''\n                self.changeCurrentDirectory(upDirectory)\n                action = 'sendDirectory'\n            \n        if command == 'directoryRoot':\n            # Reset the filter (chances are the user only wanted to filter at one level\n            self.directoryFilter = ''\n            self.changeCurrentDirectory(settings.settings['Output_dir'])\n            action = 'sendDirectory'\n\n        \"\"\"\n         Actions\n        \"\"\"\n\n        # Only send a response if needed\n        if action == 'setImage':\n            # Stupid hack\n            if serverImagePath.endswith(videoExtensions):\n                action = 'setVideo'\n                \n            self.currentImage = (fullImagePath, serverImagePath)\n            responseMessage = ('{{\"responseToCommand\":\"{}\", \"action\":\"{}\", \"fullImagePath\":\"{}\", \"serverImagePath\":\"{}\"}}'\n                               .format(command, action, fullImagePath, serverImagePath))\n            self.write_message(responseMessage)\n\n        if action == 'sendDirectory':\n            directoryList = ''\n            for path in self.currentDirectoryCache:\n                isSupportedFile = path.endswith(supportedExtensions)\n                isFile = '.' in path\n                if path.endswith(videoExtensions):\n                    fileType = 'video'\n                elif isSupportedFile:\n                    fileType = 'image'\n                elif isFile:\n                    fileType = 'file'\n                else:\n                    fileType = 'dir'\n                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path\n                directoryList += '{{\"path\":\"{}\", \"type\":\"{}\", \"serverPath\":\"{}\"}},'.format(path, fileType, serverPath)\n\n            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it\n            responseMessage = ('{{\"responseToCommand\":\"{}\", \"action\":\"{}\", \"directoryList\":[{}]}}'\n                               .format(command, action, directoryList[:-1]))\n            self.write_message(responseMessage)\n            \n\n    def on_close(self):\n        self.connections.remove(self)\n\nscriptPipeConnection = None\nscriptProcess = None\n\ndef startScript():\n    global scriptPipeConnection, scriptProcess\n    \n    # Script already running\n    if scriptProcess and scriptProcess.is_alive():\n        return\n    \n    scriptPipeConnection, childConnection = multiprocessing.Pipe()\n    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,\n                                            args=(childConnection,))\n    scriptProcess.start()\n\nrunScriptWebSocketConnections = set()\nclass RunScriptWebSocket(tornado.websocket.WebSocketHandler):\n    def open(self):\n        if not login_get_current_user(self):\n            return None\n        \n        global runScriptWebSocketConnections\n        runScriptWebSocketConnections.add(self)\n\n    def on_message(self, message):\n        if not login_get_current_user(self):\n            return None\n        \n        print('RunScriptWebSocket: Received message ', message)\n\n        parsedMessage = json.loads(message)\n        command = parsedMessage['command']\n\n        print('RunScriptWebSocket: Command ', command)\n        \n        if command == 'runScript':\n            if scriptProcess and scriptProcess.is_alive():\n                print('RunScriptWebSocket: Script already running')\n                responseMessage = ('{{\"message\":\"{}\", \"action\":\"{}\"}}'\n                                   .format('Script already running\\\\n', 'printMessage'))\n                self.write_message(responseMessage)\n                \n            else:\n                print('RunScriptWebSocket: Starting script')\n\n                startScript()\n                \n                responseMessage = ('{{\"message\":\"{}\", \"action\":\"{}\"}}'\n                                   .format('Running script\\\\n', 'printMessage'))\n                self.write_message(responseMessage)\n\n    def on_close(self):\n        global runScriptWebSocketConnections\n        runScriptWebSocketConnections.remove(self)\n\ndef updateScriptStatus():\n    # If no pipe or no data to receive from pipe, we're done\n    # Poll() is non-blocking whereas recv is blocking\n    if (not runScriptWebSocketConnections\n        or not scriptPipeConnection\n        or not scriptPipeConnection.poll()):\n        return\n\n    pipeOutput = scriptPipeConnection.recv()\n    if pipeOutput:\n        responseMessage = ('{{\"message\":\"{}\", \"action\":\"{}\"}}'\n                           .format(pipeOutput.replace('\\n', '\\\\n').replace('\\t', ''),\n                                   'printMessage'))\n        \n        for client in runScriptWebSocketConnections:\n            client.write_message(responseMessage)\n\n        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:\n            # Script finished; refresh image cache\n            print('Refreshing cache due to script finishing')\n            generateSavedImagesCache(settings.settings['Output_dir'])\n            responseMessage = ('{{\"action\":\"{}\"}}'\n                               .format('scriptFinished'))\n            \n            for client in runScriptWebSocketConnections:\n                client.write_message(responseMessage)\n\n            scriptPipeConnection.close()\n\n#\n# Startup\n#\n\ndef make_app():\n    # Each time the server starts up, invalidate all cookies\n    randomGenerator = random.SystemRandom()\n    cookieSecret = str(randomGenerator.getrandbits(128))\n    \n    return tornado.web.Application([\n        # Home page\n        (r'/', HomeHandler),\n        \n        # Login\n        (r'/login', LoginHandler),\n        (r'/logout', LogoutHandler),\n\n        # Configure the script\n        (r'/settings', SettingsHandler),\n\n        # Handles messages for run script\n        (r'/runScriptWebSocket', RunScriptWebSocket),\n\n        # Handles messages for randomImageBrowser\n        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),\n\n        # Static files\n        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),\n        # Don't change this \"output\" here without changing the other places as well\n        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),\n\n        # Files served regardless of whether the user is authenticated. Only login page resources\n        # should be in this folder, because anyone can see them\n        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),\n    ],\n                                   xsrf_cookies=True,\n                                   cookie_secret=cookieSecret,\n                                   login_url=\"/login\")\n\nif __name__ == '__main__':\n    print('\\n\\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'\n          ' nor when\\n\\t connected to an insecure LAN! It is not protected against malicious use.\\n')\n    \n    print('Loading settings...')\n    settings.getSettings()\n\n    print('Liked Saved output directory: ' + settings.settings['Output_dir'])\n    if not settings.settings['Output_dir']:\n        print('WARNING: No output directory specified! This will probably break things')\n    \n    if not savedImagesCache:\n        generateSavedImagesCache(settings.settings['Output_dir'])\n    \n    port = 8888\n    print('\\nStarting LikedSavedDownloader Server on port {}...'.format(port))\n    app = make_app()\n\n    # Generating a self-signing certificate:\n    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem\n    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)\n    # I then had to tell Firefox to trust this certificate even though it is self-signing (because\n    # I want a free certificate for this non-serious project)\n    useSSL = True\n    if useSSL:\n        app.listen(port, ssl_options={\"certfile\":\"certificates/server_jupyter_based.crt.pem\",\n                                      \"keyfile\":\"certificates/server_jupyter_based.crt.key\"})\n    else:\n        # Show the warning only if SSL is not enabled\n        print('\\n\\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'\n          ' nor when\\n\\t connected to an insecure LAN! It is not protected against malicious use.\\n')\n        app.listen(port)\n        \n    ioLoop = tornado.ioloop.IOLoop.current()\n    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)\n    updateStatusCallback.start()\n    ioLoop.start()\n/n/n/n", "label": 0}, {"id": "75cf3c0885faa5fa19819b7d83d5bbe120a47fe3", "code": "/LikedSavedDownloaderServer.py/n/n#!/usr/bin/env python\n\nimport tornado.ioloop\nimport tornado.web\nimport tornado.websocket\nimport tornado.httpclient\nimport tornado.gen\n\nimport os\nimport random\nimport shutil\nimport json\nimport multiprocessing\n\nfrom utilities import sort_naturally\nimport settings\nimport redditUserImageScraper\n\n# Require a username and password in order to use the web interface. See ReadMe.org for details.\nenable_authentication = False\n#enable_authentication = True\n\nif enable_authentication:\n    import PasswordManager\n\n# List of valid user ids (used to compare user cookie)\nauthenticated_users = []\n\nvideoExtensions = ('.mp4', '.webm')\nsupportedExtensions = ('.gif', '.jpg', '.jpeg', '.png', '.mp4', '.webm')\n\nsavedImagesCache = []\ndef generateSavedImagesCache(outputDir):\n    global savedImagesCache\n    # Clear cache in case already created\n    savedImagesCache = []\n\n    print('Creating Liked Saved cache...')\n    \n    for root, dirs, files in os.walk(outputDir):\n        for file in files:\n            if file.endswith(supportedExtensions):\n                savedImagesCache.append(os.path.join(root, file))\n\n    print('Finished creating Liked Saved cache ({} images/videos)'.format(len(savedImagesCache)))\n\ndef outputPathToServerPath(path):\n    # This is a little weird\n    return 'output' + path.split(settings.settings['Output_dir'])[1]\n\ndef getRandomImage(filteredImagesCache=None, randomImageFilter=''):\n    if not savedImagesCache:\n        generateSavedImagesCache(settings.settings['Output_dir'])\n\n    if filteredImagesCache:\n        randomImage = random.choice(filteredImagesCache)\n    else:\n        randomImage = random.choice(savedImagesCache)\n\n    print('\\tgetRandomImage(): Chose random image {} (filter {})'.format(randomImage, randomImageFilter))\n\n    serverPath = outputPathToServerPath(randomImage)\n\n    return randomImage, serverPath\n\n#\n# Tornado handlers\n#\n\n# See https://github.com/tornadoweb/tornado/blob/stable/demos/blog/blog.py\n# https://www.tornadoweb.org/en/stable/guide/security.html\n\ndef login_get_current_user(handler):\n    if enable_authentication:\n        cookie = handler.get_secure_cookie(\"user\")\n        if cookie in authenticated_users:\n            return cookie\n        else:\n            print(\"Bad/expired cookie received\")\n            return None\n    else:\n        return \"authentication_disabled\"\n\nclass AuthHandler(tornado.web.RequestHandler):\n    def get_current_user(self):\n        return login_get_current_user(self)\n    \nclass LoginHandler(AuthHandler):\n    def get(self):\n        if not enable_authentication:\n            self.redirect(\"/\")\n        else:\n            self.write('<html>'\n                       '<head>'\n\t               '<title>Liked Saved Downloader</title>'\n\t               '<link rel=\"stylesheet\" type=\"text/css\" href=\"webInterfaceNoAuth/index.css\">'\n                       '</head>'\n                       '<body><h1>Login Required</h1>'\n                       '<form action=\"/login\" method=\"post\">'\n                       'Name: <input type=\"text\" name=\"name\"><br />'\n                       'Password: <input type=\"password\" name=\"password\">'\n                       '{}'\n                       '<br /><input type=\"submit\" value=\"Sign in\">'\n                       '</form></body></html>'.format(self.xsrf_form_html()))\n\n    def post(self):\n        global authenticated_users\n        # Test password\n        if enable_authentication and PasswordManager.verify(self.get_argument(\"password\")):\n            # Generate new authenticated user session\n            randomGenerator = random.SystemRandom()\n            cookieSecret = str(randomGenerator.getrandbits(128))\n            authenticated_user = self.get_argument(\"name\") + \"_\" + cookieSecret\n            authenticated_user = authenticated_user.encode()\n            authenticated_users.append(authenticated_user)\n            \n            # Set the cookie on the user's side\n            self.set_secure_cookie(\"user\", authenticated_user)\n            \n            print(\"Authenticated user {}\".format(self.get_argument(\"name\")))\n            \n            # Let them in\n            self.redirect(\"/\")\n        else:\n            print(\"Refused user {} (password doesn't match any in database)\".format(self.get_argument(\"name\")))\n            self.redirect(\"/login\")\n            \nclass LogoutHandler(AuthHandler):\n    @tornado.web.authenticated\n    def get(self):\n        global authenticated_users\n        \n        if enable_authentication:\n            print(\"User {} logging out\".format(self.current_user))\n            if self.current_user in authenticated_users:\n                authenticated_users.remove(self.current_user)\n            self.redirect(\"/login\")\n        else:\n            self.redirect(\"/\")\n\nclass AuthedStaticHandler(tornado.web.StaticFileHandler):\n    def get_current_user(self):\n        return login_get_current_user(self)\n    \n    @tornado.web.authenticated\n    def prepare(self):\n        pass\n\nclass HomeHandler(AuthHandler):\n    @tornado.web.authenticated\n    def get(self):\n        self.render('webInterface/index.html')\n\ndef settingsToHtmlForm():\n    settingsInputs = []\n\n    for sectionSettingsPair in settings.settingsStructure:\n        settingsInputs.append('<h2>{}</h2>'.format(sectionSettingsPair[0]))\n\n        for sectionOption in sectionSettingsPair[1]:\n            option = None\n            optionComment = ''\n            if type(sectionOption) == tuple:\n                option = sectionOption[0]\n                optionComment = '<p class=\"optionComment\">{}</p>'.format(sectionOption[1])\n            else:\n                option = sectionOption\n                \n            if type(settings.settings[option]) == bool:\n                settingsInputs.append('''<label for=\"{option}\">{optionName}</label>\n                                     <input type=\"checkbox\" id=\"{option}\" name=\"{option}\" value=\"{optionValue}\" {checkedState} />{comment}\n                                     <br />'''\n                                      .format(option=option, optionName=option.replace('_', ' '),\n                                              comment=optionComment,\n                                              checkedState=('checked' if settings.settings[option] else ''),\n                                              optionValue=('1' if settings.settings[option] else '0')))\n                \n            elif type(settings.settings[option]) == int:\n                settingsInputs.append('''<label for=\"{option}\">{optionName}</label>\n                                     <input type=\"number\" id=\"{option}\" name=\"{option}\" value=\"{optionValue}\" />{comment}\n                                     <br />'''\n                                      .format(option=option, optionName=option.replace('_', ' '), comment=optionComment,\n                                              optionValue=settings.settings[option]))\n                \n            elif type(settings.settings[option]) == str:\n                settingsInputs.append('''<label for=\"{option}\">{optionName}</label>\n                                     <input type=\"{type}\" id=\"{option}\" name=\"{option}\" value=\"{optionValue}\" />{comment}\n                                     <br />'''\n                                      .format(option=option, optionName=option.replace('_', ' '),\n                                              comment=optionComment, optionValue=settings.settings[option],\n                                              type=('password' if 'secret' in option.lower() or 'password' in option.lower() else 'text')))\n\n    return ''.join(settingsInputs)\n\nclass SettingsHandler(AuthHandler):\n    def doSettings(self, afterSubmit):\n        htmlSettingsForm = settingsToHtmlForm()\n        settingsFilename = settings.getSettingsFilename()\n        \n        self.write('''<html>\n                            <head>\n                                  <link rel=\"stylesheet\" type=\"text/css\" href=\"webInterface/settings.css\">\n                                  <script type=\"text/javascript\" src=\"webInterface/settings.js\"></script>\n                            </head>\n                            <body>\n                                  <h1>Liked Saved Downloader Settings</h1>\n                                  <a href=\"/\">Back to Homepage</a><br /><br />\n                                  {}\n                                  <p>Settings being read from {}</p>\n                                  <form action=\"/settings\" method=\"post\">\n                                       <input type=\"submit\" value=\"Submit\">\n                                       {}\n                                       <input type=\"submit\" value=\"Submit\">\n                                  </form>\n                            </body>\n                      </html>'''\n                   .format(('<p><b>Settings updated</b></p>' if afterSubmit else ''),\n                           settingsFilename, htmlSettingsForm))\n\n    @tornado.web.authenticated\n    def get(self):\n        self.doSettings(False)\n\n    @tornado.web.authenticated\n    def post(self):\n        currentOutputDir = settings.settings['Output_dir']\n        \n        print('Received new settings')\n        \n        for option in settings.settings:\n            newValue = self.get_argument(option, None)\n            if not newValue:\n                # It's okay if it's a boolean because POST doesn't send unchecked checkboxes\n                # This means the user set the value to false\n                if type(settings.settings[option]) == bool:\n                    settings.settings[option] = False\n                else:\n                    print('Warning: Option {} unset! The settingsStructure might be out of sync.'\n                          '\\n\\tIgnore this if the field is intentionally empty'.format(option))\n            else:\n                # All false bools are handed in the above if block, so we know they're true here\n                if type(settings.settings[option]) == bool:\n                    newValue = True\n                elif type(settings.settings[option]) == int:\n                    newValue = int(newValue)\n                \n                settings.settings[option] = newValue\n                # print('\\tSet {} = {}'.format(option, newValue))\n\n        # Write out the new settings\n        settings.writeServerSettings()\n        \n        # Respond with a settings page saying we've updated the settings\n        self.doSettings(True)\n\n        # Refresh the cache in case the output directory changed\n        if currentOutputDir != settings.settings['Output_dir']:\n            generateSavedImagesCache(settings.settings['Output_dir'])\n            \n\nclass RandomImageBrowserWebSocket(tornado.websocket.WebSocketHandler):\n    connections = set()\n\n    def cacheFilteredImages(self):\n        # Clear the cache\n        self.filteredImagesCache = []\n\n        if not self.randomImageFilter:\n            return\n\n        randomImageFilterLower = self.randomImageFilter.lower()\n    \n        for imagePath in savedImagesCache:\n            if randomImageFilterLower in imagePath.lower():\n                self.filteredImagesCache.append(imagePath)\n\n        print('\\tFiltered images with \"{}\"; {} images matching filter'\n              .format(self.randomImageFilter, len(self.filteredImagesCache)))\n\n    def changeCurrentDirectory(self, newDirectory):\n        self.currentDirectoryPath = newDirectory\n        dirList = os.listdir(self.currentDirectoryPath)\n        \n        filteredDirList = []\n        for fileOrDir in dirList:\n            # The script spits out a lot of .json files the user probably doesn't want to see\n            if (not fileOrDir.endswith('.json')\n                and (not self.directoryFilter or self.directoryFilter.lower() in fileOrDir.lower())):\n                filteredDirList.append(fileOrDir)\n                \n        self.currentDirectoryCache = sorted(filteredDirList)\n\n    def open(self):\n        if not login_get_current_user(self):\n            return None\n        \n        self.connections.add(self)\n        self.randomHistory = []\n        self.randomHistoryIndex = -1\n        self.favorites = []\n        self.favoritesIndex = 0\n        self.currentImage = None\n        self.randomImageFilter = ''\n        self.filteredImagesCache = []\n        \n        self.currentDirectoryPath = ''\n        self.currentDirectoryCache = []\n        self.directoryFilter = ''\n        # Set up the directory cache with the top-level output\n        self.changeCurrentDirectory(settings.settings['Output_dir'])\n\n    def on_message(self, message):\n        if not login_get_current_user(self):\n            return None\n        \n        print('RandomImageBrowserWebSocket: Received message ', message)\n        parsedMessage = json.loads(message)\n        command = parsedMessage['command']\n        print('RandomImageBrowserWebSocket: Command ', command)\n        action = ''\n\n        \"\"\"\n         Random Image Browser\n        \"\"\"\n\n        if command == 'imageAddToFavorites':\n            if self.currentImage:\n                self.favorites.append(self.currentImage)\n                self.favoritesIndex = len(self.favorites) - 1\n\n        if command == 'nextFavorite':\n            self.favoritesIndex += 1\n            if self.favoritesIndex >= 0 and self.favoritesIndex < len(self.favorites):\n                action = 'setImage'\n                fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]\n            else:\n                self.favoritesIndex = len(self.favorites) - 1\n                if len(self.favorites):\n                    action = 'setImage'\n                    fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]\n\n        if command == 'previousFavorite' and len(self.favorites):\n            action = 'setImage'\n\n            if self.favoritesIndex > 0:\n                self.favoritesIndex -= 1\n                \n            fullImagePath, serverImagePath = self.favorites[self.favoritesIndex]\n\n        if command == 'nextImage':\n            action = 'setImage'\n\n            if self.randomHistoryIndex == -1 or self.randomHistoryIndex >= len(self.randomHistory) - 1:\n                fullImagePath, serverImagePath = getRandomImage(self.filteredImagesCache, self.randomImageFilter)\n                self.randomHistory.append((fullImagePath, serverImagePath))\n                self.randomHistoryIndex = len(self.randomHistory) - 1\n            else:\n                self.randomHistoryIndex += 1\n                fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]\n\n        if command == 'previousImage':\n            action = 'setImage'\n\n            if self.randomHistoryIndex > 0:\n                self.randomHistoryIndex -= 1\n                \n            fullImagePath, serverImagePath = self.randomHistory[self.randomHistoryIndex]\n\n        if command in ['nextImageInFolder', 'previousImageInFolder'] and len(self.randomHistory):\n            fullImagePath, serverImagePath = self.currentImage\n                \n            folder = fullImagePath[:fullImagePath.rfind('/')]\n            imagesInFolder = []\n            for root, dirs, files in os.walk(folder):\n                for file in files:\n                    if file.endswith(supportedExtensions):\n                        imagesInFolder.append(os.path.join(root, file))\n            sort_naturally(imagesInFolder)\n            currentImageIndex = imagesInFolder.index(fullImagePath)\n            if currentImageIndex >= 0:\n                action = 'setImage'\n                \n                nextImageIndex = currentImageIndex + (1 if command == 'nextImageInFolder' else -1)\n                if nextImageIndex == len(imagesInFolder):\n                    nextImageIndex = 0\n                if nextImageIndex < 0:\n                    nextImageIndex = len(imagesInFolder) - 1\n                    \n                fullImagePath = imagesInFolder[nextImageIndex]\n                serverImagePath = outputPathToServerPath(fullImagePath)\n\n        if command == 'setFilter':\n            newFilter = parsedMessage['filter']\n            if newFilter != self.randomImageFilter:\n                self.randomImageFilter = newFilter\n                self.cacheFilteredImages()\n\n        \"\"\"\n         Directory browser\n        \"\"\"\n\n        if command == 'setDirectoryFilter':\n            newFilter = parsedMessage['filter']\n            if newFilter != self.directoryFilter:\n                self.directoryFilter = newFilter\n                # Refresh cache with new filter\n                self.changeCurrentDirectory(self.currentDirectoryPath)\n                action = 'sendDirectory'\n\n        if command == 'listCurrentDirectory':\n            action = 'sendDirectory'\n\n        if command == 'changeDirectory':\n            # Reset the filter (chances are the user only wanted to filter at one level\n            self.directoryFilter = ''\n            self.changeCurrentDirectory('{}/{}'.format(self.currentDirectoryPath, parsedMessage['path']));\n            action = 'sendDirectory'\n\n        if command == 'directoryUp':\n            # Don't allow going higher than output dir\n            if self.currentDirectoryPath != settings.settings['Output_dir']:\n                upDirectory = (settings.settings['Output_dir']  +\n                               self.currentDirectoryPath[len(settings.settings['Output_dir'])\n                                                         : self.currentDirectoryPath.rfind('/')])\n                # Reset the filter (chances are the user only wanted to filter at one level\n                self.directoryFilter = ''\n                self.changeCurrentDirectory(upDirectory)\n                action = 'sendDirectory'\n            \n        if command == 'directoryRoot':\n            # Reset the filter (chances are the user only wanted to filter at one level\n            self.directoryFilter = ''\n            self.changeCurrentDirectory(settings.settings['Output_dir'])\n            action = 'sendDirectory'\n\n        \"\"\"\n         Actions\n        \"\"\"\n\n        # Only send a response if needed\n        if action == 'setImage':\n            # Stupid hack\n            if serverImagePath.endswith(videoExtensions):\n                action = 'setVideo'\n                \n            self.currentImage = (fullImagePath, serverImagePath)\n            responseMessage = ('{{\"responseToCommand\":\"{}\", \"action\":\"{}\", \"fullImagePath\":\"{}\", \"serverImagePath\":\"{}\"}}'\n                               .format(command, action, fullImagePath, serverImagePath))\n            self.write_message(responseMessage)\n\n        if action == 'sendDirectory':\n            directoryList = ''\n            for path in self.currentDirectoryCache:\n                isSupportedFile = path.endswith(supportedExtensions)\n                isFile = '.' in path\n                if path.endswith(videoExtensions):\n                    fileType = 'video'\n                elif isSupportedFile:\n                    fileType = 'image'\n                elif isFile:\n                    fileType = 'file'\n                else:\n                    fileType = 'dir'\n                serverPath = 'output' + self.currentDirectoryPath[len(settings.settings['Output_dir']):] + '/' + path\n                directoryList += '{{\"path\":\"{}\", \"type\":\"{}\", \"serverPath\":\"{}\"}},'.format(path, fileType, serverPath)\n\n            # Do directoryList[:-1] (yuck) to trim the final trailing comma because JSON doesn't like it\n            responseMessage = ('{{\"responseToCommand\":\"{}\", \"action\":\"{}\", \"directoryList\":[{}]}}'\n                               .format(command, action, directoryList[:-1]))\n            self.write_message(responseMessage)\n            \n\n    def on_close(self):\n        self.connections.remove(self)\n\nscriptPipeConnection = None\nscriptProcess = None\n\ndef startScript():\n    global scriptPipeConnection, scriptProcess\n    \n    # Script already running\n    if scriptProcess and scriptProcess.is_alive():\n        return\n    \n    scriptPipeConnection, childConnection = multiprocessing.Pipe()\n    scriptProcess = multiprocessing.Process(target=redditUserImageScraper.runLikedSavedDownloader,\n                                            args=(childConnection,))\n    scriptProcess.start()\n\nrunScriptWebSocketConnections = set()\nclass RunScriptWebSocket(tornado.websocket.WebSocketHandler):\n    def open(self):\n        if not login_get_current_user(self):\n            return None\n        \n        global runScriptWebSocketConnections\n        runScriptWebSocketConnections.add(self)\n\n    def on_message(self, message):\n        if not login_get_current_user(self):\n            return None\n        \n        print('RunScriptWebSocket: Received message ', message)\n\n        parsedMessage = json.loads(message)\n        command = parsedMessage['command']\n\n        print('RunScriptWebSocket: Command ', command)\n        \n        if command == 'runScript':\n            if scriptProcess and scriptProcess.is_alive():\n                print('RunScriptWebSocket: Script already running')\n                responseMessage = ('{{\"message\":\"{}\", \"action\":\"{}\"}}'\n                                   .format('Script already running\\\\n', 'printMessage'))\n                self.write_message(responseMessage)\n                \n            else:\n                print('RunScriptWebSocket: Starting script')\n\n                startScript()\n                \n                responseMessage = ('{{\"message\":\"{}\", \"action\":\"{}\"}}'\n                                   .format('Running script\\\\n', 'printMessage'))\n                self.write_message(responseMessage)\n\n    def on_close(self):\n        global runScriptWebSocketConnections\n        runScriptWebSocketConnections.remove(self)\n\ndef updateScriptStatus():\n    # If no pipe or no data to receive from pipe, we're done\n    # Poll() is non-blocking whereas recv is blocking\n    if (not runScriptWebSocketConnections\n        or not scriptPipeConnection\n        or not scriptPipeConnection.poll()):\n        return\n\n    pipeOutput = scriptPipeConnection.recv()\n    if pipeOutput:\n        responseMessage = ('{{\"message\":\"{}\", \"action\":\"{}\"}}'\n                           .format(pipeOutput.replace('\\n', '\\\\n').replace('\\t', ''),\n                                   'printMessage'))\n        \n        for client in runScriptWebSocketConnections:\n            client.write_message(responseMessage)\n\n        if redditUserImageScraper.scriptFinishedSentinel in pipeOutput:\n            # Script finished; refresh image cache\n            print('Refreshing cache due to script finishing')\n            generateSavedImagesCache(settings.settings['Output_dir'])\n            responseMessage = ('{{\"action\":\"{}\"}}'\n                               .format('scriptFinished'))\n            \n            for client in runScriptWebSocketConnections:\n                client.write_message(responseMessage)\n\n            scriptPipeConnection.close()\n\n#\n# Startup\n#\n\ndef make_app():\n    # Each time the server starts up, invalidate all cookies\n    randomGenerator = random.SystemRandom()\n    cookieSecret = str(randomGenerator.getrandbits(128))\n    \n    return tornado.web.Application([\n        # Home page\n        (r'/', HomeHandler),\n        \n        # Login\n        (r'/login', LoginHandler),\n        (r'/logout', LogoutHandler),\n\n        # Configure the script\n        (r'/settings', SettingsHandler),\n\n        # Handles messages for run script\n        (r'/runScriptWebSocket', RunScriptWebSocket),\n\n        # Handles messages for randomImageBrowser\n        (r'/randomImageBrowserWebSocket', RandomImageBrowserWebSocket),\n\n        # Static files\n        (r'/webInterface/(.*)', AuthedStaticHandler, {'path' : 'webInterface'}),\n        # Don't change this \"output\" here without changing the other places as well\n        (r'/output/(.*)', AuthedStaticHandler, {'path' : settings.settings['Output_dir']}),\n\n        # Files served regardless of whether the user is authenticated. Only login page resources\n        # should be in this folder, because anyone can see them\n        (r'/webInterfaceNoAuth/(.*)', tornado.web.StaticFileHandler, {'path' : 'webInterfaceNoAuth'}),\n    ],\n                                   xsrf_cookies=True,\n                                   cookie_secret=cookieSecret,\n                                   login_url=\"/login\")\n\nif __name__ == '__main__':\n    print('\\n\\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'\n          ' nor when\\n\\t connected to an insecure LAN! It is not protected against malicious use.\\n')\n    \n    print('Loading settings...')\n    settings.getSettings()\n\n    print('Liked Saved output directory: ' + settings.settings['Output_dir'])\n    if not settings.settings['Output_dir']:\n        print('WARNING: No output directory specified! This will probably break things')\n    \n    if not savedImagesCache:\n        generateSavedImagesCache(settings.settings['Output_dir'])\n    \n    port = 8888\n    print('\\nStarting LikedSavedDownloader Server on port {}...'.format(port))\n    app = make_app()\n\n    # Generating a self-signing certificate:\n    # openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout certificates/server_jupyter_based.crt.key -out certificates/server_jupyter_based.crt.pem\n    # (from https://jupyter-notebook.readthedocs.io/en/latest/public_server.html)\n    # I then had to tell Firefox to trust this certificate even though it is self-signing (because\n    # I want a free certificate for this non-serious project)\n    useSSL = True\n    if useSSL:\n        app.listen(port, ssl_options={\"certfile\":\"certificates/server_jupyter_based.crt.pem\",\n                                      \"keyfile\":\"certificates/server_jupyter_based.crt.key\"})\n    else:\n        # Show the warning only if SSL is not enabled\n        print('\\n\\tWARNING: Do NOT run this server on the internet (e.g. port-forwarded)'\n          ' nor when\\n\\t connected to an insecure LAN! It is not protected against malicious use.\\n')\n        app.listen(port)\n        \n    ioLoop = tornado.ioloop.IOLoop.current()\n    updateStatusCallback = tornado.ioloop.PeriodicCallback(updateScriptStatus, 100)\n    updateStatusCallback.start()\n    ioLoop.start()\n/n/n/n", "label": 1}, {"id": "3fc5e147bdb8bfea24b62927f59fd09036346ef9", "code": "jupyter-5.0-default-jupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.\n\n#------------------------------------------------------------------------------\n# Application(SingletonConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## This is an application.\n\n## The date format used by logging formatters for %(asctime)s\n#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'\n\n## The Logging format template\n#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'\n\n## Set the log level by value or name.\n#c.Application.log_level = 30\n\n#------------------------------------------------------------------------------\n# JupyterApp(Application) configuration\n#------------------------------------------------------------------------------\n\n## Base class for Jupyter applications\n\n## Answer yes to any prompts.\n#c.JupyterApp.answer_yes = False\n\n## Full path of a config file.\n#c.JupyterApp.config_file = ''\n\n## Specify a config file to load.\n#c.JupyterApp.config_file_name = ''\n\n## Generate default config file.\n#c.JupyterApp.generate_config = False\n\n#------------------------------------------------------------------------------\n# NotebookApp(JupyterApp) configuration\n#------------------------------------------------------------------------------\n\n## Set the Access-Control-Allow-Credentials: true header\n#c.NotebookApp.allow_credentials = False\n\n## Set the Access-Control-Allow-Origin header\n#  \n#  Use '*' to allow any origin to access your server.\n#  \n#  Takes precedence over allow_origin_pat.\n#c.NotebookApp.allow_origin = ''\n\n## Use a regular expression for the Access-Control-Allow-Origin header\n#  \n#  Requests from an origin matching the expression will get replies with:\n#  \n#      Access-Control-Allow-Origin: origin\n#  \n#  where `origin` is the origin of the request.\n#  \n#  Ignored if allow_origin is set.\n#c.NotebookApp.allow_origin_pat = ''\n\n## Whether to allow the user to run the notebook as root.\n#c.NotebookApp.allow_root = False\n\n## DEPRECATED use base_url\n#c.NotebookApp.base_project_url = '/'\n\n## The base URL for the notebook server.\n#  \n#  Leading and trailing slashes can be omitted, and will automatically be added.\n#c.NotebookApp.base_url = '/'\n\n## Specify what command to use to invoke a web browser when opening the notebook.\n#  If not specified, the default browser will be determined by the `webbrowser`\n#  standard library module, which allows setting of the BROWSER environment\n#  variable to override it.\n#c.NotebookApp.browser = ''\n\n## The full path to an SSL/TLS certificate file.\n#c.NotebookApp.certfile = ''\n\n## The full path to a certificate authority certificate for SSL/TLS client\n#  authentication.\n#c.NotebookApp.client_ca = ''\n\n## The config manager class to use\n#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'\n\n## The notebook manager class to use.\n#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'\n\n## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's\n#  set_secure_cookie docs for details.\n#c.NotebookApp.cookie_options = {}\n\n## The random bytes used to secure cookies. By default this is a new random\n#  number every time you start the Notebook. Set it to a value in a config file\n#  to enable logins to persist across server sessions.\n#  \n#  Note: Cookie secrets should be kept private, do not share config files with\n#  cookie_secret stored in plaintext (you can read the value from a file).\n#c.NotebookApp.cookie_secret = b''\n\n## The file where the cookie secret is stored.\n#c.NotebookApp.cookie_secret_file = ''\n\n## The default URL to redirect to from `/`\n#c.NotebookApp.default_url = '/tree'\n\n## Disable cross-site-request-forgery protection\n#  \n#  Jupyter notebook 4.3.1 introduces protection from cross-site request\n#  forgeries, requiring API requests to either:\n#  \n#  - originate from pages served by this server (validated with XSRF cookie and\n#  token), or - authenticate with a token\n#  \n#  Some anonymous compute resources still desire the ability to run code,\n#  completely without authentication. These services can disable all\n#  authentication and security checks, with the full knowledge of what that\n#  implies.\n#c.NotebookApp.disable_check_xsrf = False\n\n## Whether to enable MathJax for typesetting math/TeX\n#  \n#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n#  very large, so you may want to disable it if you have a slow internet\n#  connection, or for offline use of the notebook.\n#  \n#  When disabled, equations etc. will appear as their untransformed TeX source.\n#c.NotebookApp.enable_mathjax = True\n\n## extra paths to look for Javascript notebook extensions\n#c.NotebookApp.extra_nbextensions_path = []\n\n## Extra paths to search for serving static files.\n#  \n#  This allows adding javascript/css to be available from the notebook server\n#  machine, or overriding individual files in the IPython\n#c.NotebookApp.extra_static_paths = []\n\n## Extra paths to search for serving jinja templates.\n#  \n#  Can be used to override templates from notebook.templates.\n#c.NotebookApp.extra_template_paths = []\n\n## \n#c.NotebookApp.file_to_run = ''\n\n## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS\n#  recompilation\n#c.NotebookApp.ignore_minified_js = False\n\n## (bytes/sec) Maximum rate at which messages can be sent on iopub before they\n#  are limited.\n#c.NotebookApp.iopub_data_rate_limit = 1000000\n\n## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are\n#  limited.\n#c.NotebookApp.iopub_msg_rate_limit = 1000\n\n## The IP address the notebook server will listen on.\n#c.NotebookApp.ip = 'localhost'\n\n## Supply extra arguments that will be passed to Jinja environment.\n#c.NotebookApp.jinja_environment_options = {}\n\n## Extra variables to supply to jinja templates when rendering.\n#c.NotebookApp.jinja_template_vars = {}\n\n## The kernel manager class to use.\n#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'\n\n## The kernel spec manager class to use. Should be a subclass of\n#  `jupyter_client.kernelspec.KernelSpecManager`.\n#  \n#  The Api of KernelSpecManager is provisional and might change without warning\n#  between this version of Jupyter and the next stable one.\n#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'\n\n## The full path to a private key file for usage with SSL/TLS.\n#c.NotebookApp.keyfile = ''\n\n## The login handler class to use.\n#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'\n\n## The logout handler class to use.\n#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'\n\n## The MathJax.js configuration file that is to be used.\n#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'\n\n## A custom url for MathJax.js. Should be in the form of a case-sensitive url to\n#  MathJax, for example:  /static/components/MathJax/MathJax.js\n#c.NotebookApp.mathjax_url = ''\n\n## Dict of Python modules to load as notebook server extensions.Entry values can\n#  be used to enable and disable the loading ofthe extensions. The extensions\n#  will be loaded in alphabetical order.\n#c.NotebookApp.nbserver_extensions = {}\n\n## The directory to use for notebooks and kernels.\n#c.NotebookApp.notebook_dir = ''\n\n## Whether to open in a browser after starting. The specific browser used is\n#  platform dependent and determined by the python standard library `webbrowser`\n#  module, unless it is overridden using the --browser (NotebookApp.browser)\n#  configuration option.\n#c.NotebookApp.open_browser = True\n\n## Hashed password to use for web authentication.\n#  \n#  To generate, type in a python/IPython shell:\n#  \n#    from notebook.auth import passwd; passwd()\n#  \n#  The string should be of the form type:salt:hashed-password.\n#c.NotebookApp.password = ''\n\n## Forces users to use a password for the Notebook server. This is useful in a\n#  multi user environment, for instance when everybody in the LAN can access each\n#  other's machine though ssh.\n#  \n#  In such a case, server the notebook server on localhost is not secure since\n#  any user can connect to the notebook server via ssh.\n#c.NotebookApp.password_required = False\n\n## The port the notebook server will listen on.\n#c.NotebookApp.port = 8888\n\n## The number of additional ports to try if the specified port is not available.\n#c.NotebookApp.port_retries = 50\n\n## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n#c.NotebookApp.pylab = 'disabled'\n\n## (sec) Time window used to  check the message and data rate limits.\n#c.NotebookApp.rate_limit_window = 3\n\n## Reraise exceptions encountered loading server extensions?\n#c.NotebookApp.reraise_server_extension_failures = False\n\n## DEPRECATED use the nbserver_extensions dict instead\n#c.NotebookApp.server_extensions = []\n\n## The session manager class to use.\n#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'\n\n## Supply SSL options for the tornado HTTPServer. See the tornado docs for\n#  details.\n#c.NotebookApp.ssl_options = {}\n\n## Supply overrides for terminado. Currently only supports \"shell_command\".\n#c.NotebookApp.terminado_settings = {}\n\n## Token used for authenticating first-time connections to the server.\n#  \n#  When no password is enabled, the default is to generate a new, random token.\n#  \n#  Setting to an empty string disables authentication altogether, which is NOT\n#  RECOMMENDED.\n#c.NotebookApp.token = '<generated>'\n\n## Supply overrides for the tornado.web.Application that the Jupyter notebook\n#  uses.\n#c.NotebookApp.tornado_settings = {}\n\n## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-\n#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles\n#  SSL\n#c.NotebookApp.trust_xheaders = False\n\n## DEPRECATED, use tornado_settings\n#c.NotebookApp.webapp_settings = {}\n\n## The base URL for websockets, if it differs from the HTTP server (hint: it\n#  almost certainly doesn't).\n#  \n#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n#c.NotebookApp.websocket_url = ''\n\n#------------------------------------------------------------------------------\n# ConnectionFileMixin(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for configurable classes that work with connection files\n\n## JSON file in which to store connection info [default: kernel-<pid>.json]\n#  \n#  This file will contain the IP, ports, and authentication key needed to connect\n#  clients to this kernel. By default, this file will be created in the security\n#  dir of the current profile, but can be specified by absolute path.\n#c.ConnectionFileMixin.connection_file = ''\n\n## set the control (ROUTER) port [default: random]\n#c.ConnectionFileMixin.control_port = 0\n\n## set the heartbeat port [default: random]\n#c.ConnectionFileMixin.hb_port = 0\n\n## set the iopub (PUB) port [default: random]\n#c.ConnectionFileMixin.iopub_port = 0\n\n## Set the kernel's IP address [default localhost]. If the IP address is\n#  something other than localhost, then Consoles on other machines will be able\n#  to connect to the Kernel, so be careful!\n#c.ConnectionFileMixin.ip = ''\n\n## set the shell (ROUTER) port [default: random]\n#c.ConnectionFileMixin.shell_port = 0\n\n## set the stdin (ROUTER) port [default: random]\n#c.ConnectionFileMixin.stdin_port = 0\n\n## \n#c.ConnectionFileMixin.transport = 'tcp'\n\n#------------------------------------------------------------------------------\n# KernelManager(ConnectionFileMixin) configuration\n#------------------------------------------------------------------------------\n\n## Manages a single kernel in a subprocess on this host.\n#  \n#  This version starts kernels with Popen.\n\n## Should we autorestart the kernel if it dies.\n#c.KernelManager.autorestart = True\n\n## DEPRECATED: Use kernel_name instead.\n#  \n#  The Popen Command to launch the kernel. Override this if you have a custom\n#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not\n#  pass any arguments to the kernel, because it cannot make any assumptions about\n#  the arguments that the kernel understands. In particular, this means that the\n#  kernel does not receive the option --debug if it given on the Jupyter command\n#  line.\n#c.KernelManager.kernel_cmd = []\n\n## Time to wait for a kernel to terminate before killing it, in seconds.\n#c.KernelManager.shutdown_wait_time = 5.0\n\n#------------------------------------------------------------------------------\n# Session(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Object for handling serialization and sending of messages.\n#  \n#  The Session object handles building messages and sending them with ZMQ sockets\n#  or ZMQStream objects.  Objects can communicate with each other over the\n#  network via Session objects, and only need to work with the dict-based IPython\n#  message spec. The Session will handle serialization/deserialization, security,\n#  and metadata.\n#  \n#  Sessions support configurable serialization via packer/unpacker traits, and\n#  signing with HMAC digests via the key/keyfile traits.\n#  \n#  Parameters ----------\n#  \n#  debug : bool\n#      whether to trigger extra debugging statements\n#  packer/unpacker : str : 'json', 'pickle' or import_string\n#      importstrings for methods to serialize message parts.  If just\n#      'json' or 'pickle', predefined JSON and pickle packers will be used.\n#      Otherwise, the entire importstring must be used.\n#  \n#      The functions must accept at least valid JSON input, and output *bytes*.\n#  \n#      For example, to use msgpack:\n#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'\n#  pack/unpack : callables\n#      You can also set the pack/unpack callables for serialization directly.\n#  session : bytes\n#      the ID of this Session object.  The default is to generate a new UUID.\n#  username : unicode\n#      username added to message headers.  The default is to ask the OS.\n#  key : bytes\n#      The key used to initialize an HMAC signature.  If unset, messages\n#      will not be signed or checked.\n#  keyfile : filepath\n#      The file containing a key.  If this is set, `key` will be initialized\n#      to the contents of the file.\n\n## Threshold (in bytes) beyond which an object's buffer should be extracted to\n#  avoid pickling.\n#c.Session.buffer_threshold = 1024\n\n## Whether to check PID to protect against calls after fork.\n#  \n#  This check can be disabled if fork-safety is handled elsewhere.\n#c.Session.check_pid = True\n\n## Threshold (in bytes) beyond which a buffer should be sent without copying.\n#c.Session.copy_threshold = 65536\n\n## Debug output in the Session\n#c.Session.debug = False\n\n## The maximum number of digests to remember.\n#  \n#  The digest history will be culled when it exceeds this value.\n#c.Session.digest_history_size = 65536\n\n## The maximum number of items for a container to be introspected for custom\n#  serialization. Containers larger than this are pickled outright.\n#c.Session.item_threshold = 64\n\n## execution key, for signing messages.\n#c.Session.key = b''\n\n## path to file containing execution key.\n#c.Session.keyfile = ''\n\n## Metadata dictionary, which serves as the default top-level metadata dict for\n#  each message.\n#c.Session.metadata = {}\n\n## The name of the packer for serializing messages. Should be one of 'json',\n#  'pickle', or an import name for a custom callable serializer.\n#c.Session.packer = 'json'\n\n## The UUID identifying this session.\n#c.Session.session = ''\n\n## The digest scheme used to construct the message signatures. Must have the form\n#  'hmac-HASH'.\n#c.Session.signature_scheme = 'hmac-sha256'\n\n## The name of the unpacker for unserializing messages. Only used with custom\n#  functions for `packer`.\n#c.Session.unpacker = 'json'\n\n## Username for the Session. Default is your system username.\n#c.Session.username = 'username'\n\n#------------------------------------------------------------------------------\n# MultiKernelManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for managing multiple kernels.\n\n## The name of the default kernel to start\n#c.MultiKernelManager.default_kernel_name = 'python3'\n\n## The kernel manager class.  This is configurable to allow subclassing of the\n#  KernelManager for customized behavior.\n#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'\n\n#------------------------------------------------------------------------------\n# MappingKernelManager(MultiKernelManager) configuration\n#------------------------------------------------------------------------------\n\n## A KernelManager that handles notebook mapping and HTTP error handling\n\n## \n#c.MappingKernelManager.root_dir = ''\n\n#------------------------------------------------------------------------------\n# ContentsManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Base class for serving files and directories.\n#  \n#  This serves any text or binary file, as well as directories, with special\n#  handling for JSON notebook documents.\n#  \n#  Most APIs take a path argument, which is always an API-style unicode path, and\n#  always refers to a directory.\n#  \n#  - unicode, not url-escaped\n#  - '/'-separated\n#  - leading and trailing '/' will be stripped\n#  - if unspecified, path defaults to '',\n#    indicating the root path.\n\n## \n#c.ContentsManager.checkpoints = None\n\n## \n#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'\n\n## \n#c.ContentsManager.checkpoints_kwargs = {}\n\n## Glob patterns to hide in file and directory listings.\n#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']\n\n## Python callable or importstring thereof\n#  \n#  To be called on a contents model prior to save.\n#  \n#  This can be used to process the structure, such as removing notebook outputs\n#  or other side effects that should not be saved.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(path=path, model=model, contents_manager=self)\n#  \n#  - model: the model to be saved. Includes file contents.\n#    Modifying this dict will affect the file that is stored.\n#  - path: the API path of the save destination\n#  - contents_manager: this ContentsManager instance\n#c.ContentsManager.pre_save_hook = None\n\n## \n#c.ContentsManager.root_dir = '/'\n\n## The base name used when creating untitled directories.\n#c.ContentsManager.untitled_directory = 'Untitled Folder'\n\n## The base name used when creating untitled files.\n#c.ContentsManager.untitled_file = 'untitled'\n\n## The base name used when creating untitled notebooks.\n#c.ContentsManager.untitled_notebook = 'Untitled'\n\n#------------------------------------------------------------------------------\n# FileManagerMixin(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for ContentsAPI classes that interact with the filesystem.\n#  \n#  Provides facilities for reading, writing, and copying both notebooks and\n#  generic files.\n#  \n#  Shared by FileContentsManager and FileCheckpoints.\n#  \n#  Note ---- Classes using this mixin must provide the following attributes:\n#  \n#  root_dir : unicode\n#      A directory against against which API-style paths are to be resolved.\n#  \n#  log : logging.Logger\n\n## By default notebooks are saved on disk on a temporary file and then if\n#  succefully written, it replaces the old ones. This procedure, namely\n#  'atomic_writing', causes some bugs on file system whitout operation order\n#  enforcement (like some networked fs). If set to False, the new notebook is\n#  written directly on the old one which could fail (eg: full filesystem or quota\n#  )\n#c.FileManagerMixin.use_atomic_writing = True\n\n#------------------------------------------------------------------------------\n# FileContentsManager(FileManagerMixin,ContentsManager) configuration\n#------------------------------------------------------------------------------\n\n## Python callable or importstring thereof\n#  \n#  to be called on the path of a file just saved.\n#  \n#  This can be used to process the file on disk, such as converting the notebook\n#  to a script or HTML via nbconvert.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(os_path=os_path, model=model, contents_manager=instance)\n#  \n#  - path: the filesystem path to the file just written - model: the model\n#  representing the file - contents_manager: this ContentsManager instance\n#c.FileContentsManager.post_save_hook = None\n\n## \n#c.FileContentsManager.root_dir = ''\n\n## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0\n#c.FileContentsManager.save_script = False\n\n#------------------------------------------------------------------------------\n# NotebookNotary(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for computing and verifying notebook signatures.\n\n## The hashing algorithm used to sign notebooks.\n#c.NotebookNotary.algorithm = 'sha256'\n\n## The sqlite file in which to store notebook signatures. By default, this will\n#  be in your Jupyter data directory. You can set it to ':memory:' to disable\n#  sqlite writing to the filesystem.\n#c.NotebookNotary.db_file = ''\n\n## The secret key with which notebooks are signed.\n#c.NotebookNotary.secret = b''\n\n## The file where the secret key is stored.\n#c.NotebookNotary.secret_file = ''\n\n## A callable returning the storage backend for notebook signatures. The default\n#  uses an SQLite database.\n#c.NotebookNotary.store_factory = traitlets.Undefined\n\n#------------------------------------------------------------------------------\n# KernelSpecManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## If there is no Python kernelspec registered and the IPython kernel is\n#  available, ensure it is added to the spec list.\n#c.KernelSpecManager.ensure_native_kernel = True\n\n## The kernel spec class.  This is configurable to allow subclassing of the\n#  KernelSpecManager for customized behavior.\n#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'\n\n## Whitelist of allowed kernel names.\n#  \n#  By default, all installed kernels are allowed.\n#c.KernelSpecManager.whitelist = set()\n/n/n/njupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.\n\n#------------------------------------------------------------------------------\n# Application(SingletonConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## This is an application.\n\n## The date format used by logging formatters for %(asctime)s\n#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'\n\n## The Logging format template\n#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'\n\n## Set the log level by value or name.\n#c.Application.log_level = 30\n\n#------------------------------------------------------------------------------\n# JupyterApp(Application) configuration\n#------------------------------------------------------------------------------\n\n## Base class for Jupyter applications\n\n## Answer yes to any prompts.\n#c.JupyterApp.answer_yes = False\n\n## Full path of a config file.\n#c.JupyterApp.config_file = ''\n\n## Specify a config file to load.\n#c.JupyterApp.config_file_name = ''\n\n## Generate default config file.\n#c.JupyterApp.generate_config = False\n\n#------------------------------------------------------------------------------\n# NotebookApp(JupyterApp) configuration\n#------------------------------------------------------------------------------\n\n## Set the Access-Control-Allow-Credentials: true header\n#c.NotebookApp.allow_credentials = False\n\n## Set the Access-Control-Allow-Origin header\n#  \n#  Use '*' to allow any origin to access your server.\n#  \n#  Takes precedence over allow_origin_pat.\n#c.NotebookApp.allow_origin = ''\n\n## Use a regular expression for the Access-Control-Allow-Origin header\n#  \n#  Requests from an origin matching the expression will get replies with:\n#  \n#      Access-Control-Allow-Origin: origin\n#  \n#  where `origin` is the origin of the request.\n#  \n#  Ignored if allow_origin is set.\n#c.NotebookApp.allow_origin_pat = ''\n\n## Whether to allow the user to run the notebook as root.\n#c.NotebookApp.allow_root = False\n\n## DEPRECATED use base_url\n#c.NotebookApp.base_project_url = '/'\n\n## The base URL for the notebook server.\n#  \n#  Leading and trailing slashes can be omitted, and will automatically be added.\n#c.NotebookApp.base_url = '/'\n\n## Specify what command to use to invoke a web browser when opening the notebook.\n#  If not specified, the default browser will be determined by the `webbrowser`\n#  standard library module, which allows setting of the BROWSER environment\n#  variable to override it.\n#c.NotebookApp.browser = ''\n\n## The full path to an SSL/TLS certificate file.\n#c.NotebookApp.certfile = ''\n\n## The full path to a certificate authority certificate for SSL/TLS client\n#  authentication.\n#c.NotebookApp.client_ca = ''\n\n## The config manager class to use\n#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'\n\n## The notebook manager class to use.\n#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'\n\n## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's\n#  set_secure_cookie docs for details.\n#c.NotebookApp.cookie_options = {}\n\n## The random bytes used to secure cookies. By default this is a new random\n#  number every time you start the Notebook. Set it to a value in a config file\n#  to enable logins to persist across server sessions.\n#  \n#  Note: Cookie secrets should be kept private, do not share config files with\n#  cookie_secret stored in plaintext (you can read the value from a file).\n#c.NotebookApp.cookie_secret = b''\n\n## The file where the cookie secret is stored.\n#c.NotebookApp.cookie_secret_file = ''\n\n## The default URL to redirect to from `/`\n#c.NotebookApp.default_url = '/tree'\n\n## Disable cross-site-request-forgery protection\n#  \n#  Jupyter notebook 4.3.1 introduces protection from cross-site request\n#  forgeries, requiring API requests to either:\n#  \n#  - originate from pages served by this server (validated with XSRF cookie and\n#  token), or - authenticate with a token\n#  \n#  Some anonymous compute resources still desire the ability to run code,\n#  completely without authentication. These services can disable all\n#  authentication and security checks, with the full knowledge of what that\n#  implies.\n#c.NotebookApp.disable_check_xsrf = False\n\n## Whether to enable MathJax for typesetting math/TeX\n#  \n#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n#  very large, so you may want to disable it if you have a slow internet\n#  connection, or for offline use of the notebook.\n#  \n#  When disabled, equations etc. will appear as their untransformed TeX source.\n#c.NotebookApp.enable_mathjax = True\n\n## extra paths to look for Javascript notebook extensions\n#c.NotebookApp.extra_nbextensions_path = []\n\n## Extra paths to search for serving static files.\n#  \n#  This allows adding javascript/css to be available from the notebook server\n#  machine, or overriding individual files in the IPython\n#c.NotebookApp.extra_static_paths = []\n\n## Extra paths to search for serving jinja templates.\n#  \n#  Can be used to override templates from notebook.templates.\n#c.NotebookApp.extra_template_paths = []\n\n## \n#c.NotebookApp.file_to_run = ''\n\n## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS\n#  recompilation\n#c.NotebookApp.ignore_minified_js = False\n\n## (bytes/sec) Maximum rate at which messages can be sent on iopub before they\n#  are limited.\n#c.NotebookApp.iopub_data_rate_limit = 1000000\n\n## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are\n#  limited.\n#c.NotebookApp.iopub_msg_rate_limit = 1000\n\n## The IP address the notebook server will listen on.\n#c.NotebookApp.ip = 'localhost'\n\n## Supply extra arguments that will be passed to Jinja environment.\n#c.NotebookApp.jinja_environment_options = {}\n\n## Extra variables to supply to jinja templates when rendering.\n#c.NotebookApp.jinja_template_vars = {}\n\n## The kernel manager class to use.\n#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'\n\n## The kernel spec manager class to use. Should be a subclass of\n#  `jupyter_client.kernelspec.KernelSpecManager`.\n#  \n#  The Api of KernelSpecManager is provisional and might change without warning\n#  between this version of Jupyter and the next stable one.\n#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'\n\n## The full path to a private key file for usage with SSL/TLS.\n#c.NotebookApp.keyfile = ''\n\n## The login handler class to use.\n#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'\n\n## The logout handler class to use.\n#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'\n\n## The MathJax.js configuration file that is to be used.\n#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'\n\n## A custom url for MathJax.js. Should be in the form of a case-sensitive url to\n#  MathJax, for example:  /static/components/MathJax/MathJax.js\n#c.NotebookApp.mathjax_url = ''\n\n## Dict of Python modules to load as notebook server extensions.Entry values can\n#  be used to enable and disable the loading ofthe extensions. The extensions\n#  will be loaded in alphabetical order.\n#c.NotebookApp.nbserver_extensions = {}\n\n## The directory to use for notebooks and kernels.\n#c.NotebookApp.notebook_dir = ''\n\n## Whether to open in a browser after starting. The specific browser used is\n#  platform dependent and determined by the python standard library `webbrowser`\n#  module, unless it is overridden using the --browser (NotebookApp.browser)\n#  configuration option.\n#c.NotebookApp.open_browser = True\n\n## Hashed password to use for web authentication.\n#  \n#  To generate, type in a python/IPython shell:\n#  \n#    from notebook.auth import passwd; passwd()\n#  \n#  The string should be of the form type:salt:hashed-password.\n#c.NotebookApp.password = ''\n\n## Forces users to use a password for the Notebook server. This is useful in a\n#  multi user environment, for instance when everybody in the LAN can access each\n#  other's machine though ssh.\n#  \n#  In such a case, server the notebook server on localhost is not secure since\n#  any user can connect to the notebook server via ssh.\n#c.NotebookApp.password_required = False\n\n## The port the notebook server will listen on.\n#c.NotebookApp.port = 8888\n\n## The number of additional ports to try if the specified port is not available.\n#c.NotebookApp.port_retries = 50\n\n## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n#c.NotebookApp.pylab = 'disabled'\n\n## (sec) Time window used to  check the message and data rate limits.\n#c.NotebookApp.rate_limit_window = 3\n\n## Reraise exceptions encountered loading server extensions?\n#c.NotebookApp.reraise_server_extension_failures = False\n\n## DEPRECATED use the nbserver_extensions dict instead\n#c.NotebookApp.server_extensions = []\n\n## The session manager class to use.\n#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'\n\n## Supply SSL options for the tornado HTTPServer. See the tornado docs for\n#  details.\n#c.NotebookApp.ssl_options = {}\n\n## Supply overrides for terminado. Currently only supports \"shell_command\".\n#c.NotebookApp.terminado_settings = {}\n\n## Token used for authenticating first-time connections to the server.\n#  \n#  When no password is enabled, the default is to generate a new, random token.\n#  \n#  Setting to an empty string disables authentication altogether, which is NOT\n#  RECOMMENDED.\n#c.NotebookApp.token = '<generated>'\n\n## Supply overrides for the tornado.web.Application that the Jupyter notebook\n#  uses.\n#c.NotebookApp.tornado_settings = {}\n\n## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-\n#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles\n#  SSL\n#c.NotebookApp.trust_xheaders = False\n\n## DEPRECATED, use tornado_settings\n#c.NotebookApp.webapp_settings = {}\n\n## The base URL for websockets, if it differs from the HTTP server (hint: it\n#  almost certainly doesn't).\n#  \n#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n#c.NotebookApp.websocket_url = ''\n\n#------------------------------------------------------------------------------\n# ConnectionFileMixin(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for configurable classes that work with connection files\n\n## JSON file in which to store connection info [default: kernel-<pid>.json]\n#  \n#  This file will contain the IP, ports, and authentication key needed to connect\n#  clients to this kernel. By default, this file will be created in the security\n#  dir of the current profile, but can be specified by absolute path.\n#c.ConnectionFileMixin.connection_file = ''\n\n## set the control (ROUTER) port [default: random]\n#c.ConnectionFileMixin.control_port = 0\n\n## set the heartbeat port [default: random]\n#c.ConnectionFileMixin.hb_port = 0\n\n## set the iopub (PUB) port [default: random]\n#c.ConnectionFileMixin.iopub_port = 0\n\n## Set the kernel's IP address [default localhost]. If the IP address is\n#  something other than localhost, then Consoles on other machines will be able\n#  to connect to the Kernel, so be careful!\n#c.ConnectionFileMixin.ip = ''\n\n## set the shell (ROUTER) port [default: random]\n#c.ConnectionFileMixin.shell_port = 0\n\n## set the stdin (ROUTER) port [default: random]\n#c.ConnectionFileMixin.stdin_port = 0\n\n## \n#c.ConnectionFileMixin.transport = 'tcp'\n\n#------------------------------------------------------------------------------\n# KernelManager(ConnectionFileMixin) configuration\n#------------------------------------------------------------------------------\n\n## Manages a single kernel in a subprocess on this host.\n#  \n#  This version starts kernels with Popen.\n\n## Should we autorestart the kernel if it dies.\n#c.KernelManager.autorestart = True\n\n## DEPRECATED: Use kernel_name instead.\n#  \n#  The Popen Command to launch the kernel. Override this if you have a custom\n#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not\n#  pass any arguments to the kernel, because it cannot make any assumptions about\n#  the arguments that the kernel understands. In particular, this means that the\n#  kernel does not receive the option --debug if it given on the Jupyter command\n#  line.\n#c.KernelManager.kernel_cmd = []\n\n## Time to wait for a kernel to terminate before killing it, in seconds.\n#c.KernelManager.shutdown_wait_time = 5.0\n\n#------------------------------------------------------------------------------\n# Session(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Object for handling serialization and sending of messages.\n#  \n#  The Session object handles building messages and sending them with ZMQ sockets\n#  or ZMQStream objects.  Objects can communicate with each other over the\n#  network via Session objects, and only need to work with the dict-based IPython\n#  message spec. The Session will handle serialization/deserialization, security,\n#  and metadata.\n#  \n#  Sessions support configurable serialization via packer/unpacker traits, and\n#  signing with HMAC digests via the key/keyfile traits.\n#  \n#  Parameters ----------\n#  \n#  debug : bool\n#      whether to trigger extra debugging statements\n#  packer/unpacker : str : 'json', 'pickle' or import_string\n#      importstrings for methods to serialize message parts.  If just\n#      'json' or 'pickle', predefined JSON and pickle packers will be used.\n#      Otherwise, the entire importstring must be used.\n#  \n#      The functions must accept at least valid JSON input, and output *bytes*.\n#  \n#      For example, to use msgpack:\n#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'\n#  pack/unpack : callables\n#      You can also set the pack/unpack callables for serialization directly.\n#  session : bytes\n#      the ID of this Session object.  The default is to generate a new UUID.\n#  username : unicode\n#      username added to message headers.  The default is to ask the OS.\n#  key : bytes\n#      The key used to initialize an HMAC signature.  If unset, messages\n#      will not be signed or checked.\n#  keyfile : filepath\n#      The file containing a key.  If this is set, `key` will be initialized\n#      to the contents of the file.\n\n## Threshold (in bytes) beyond which an object's buffer should be extracted to\n#  avoid pickling.\n#c.Session.buffer_threshold = 1024\n\n## Whether to check PID to protect against calls after fork.\n#  \n#  This check can be disabled if fork-safety is handled elsewhere.\n#c.Session.check_pid = True\n\n## Threshold (in bytes) beyond which a buffer should be sent without copying.\n#c.Session.copy_threshold = 65536\n\n## Debug output in the Session\n#c.Session.debug = False\n\n## The maximum number of digests to remember.\n#  \n#  The digest history will be culled when it exceeds this value.\n#c.Session.digest_history_size = 65536\n\n## The maximum number of items for a container to be introspected for custom\n#  serialization. Containers larger than this are pickled outright.\n#c.Session.item_threshold = 64\n\n## execution key, for signing messages.\n#c.Session.key = b''\n\n## path to file containing execution key.\n#c.Session.keyfile = ''\n\n## Metadata dictionary, which serves as the default top-level metadata dict for\n#  each message.\n#c.Session.metadata = {}\n\n## The name of the packer for serializing messages. Should be one of 'json',\n#  'pickle', or an import name for a custom callable serializer.\n#c.Session.packer = 'json'\n\n## The UUID identifying this session.\n#c.Session.session = ''\n\n## The digest scheme used to construct the message signatures. Must have the form\n#  'hmac-HASH'.\n#c.Session.signature_scheme = 'hmac-sha256'\n\n## The name of the unpacker for unserializing messages. Only used with custom\n#  functions for `packer`.\n#c.Session.unpacker = 'json'\n\n## Username for the Session. Default is your system username.\n#c.Session.username = 'username'\n\n#------------------------------------------------------------------------------\n# MultiKernelManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for managing multiple kernels.\n\n## The name of the default kernel to start\n#c.MultiKernelManager.default_kernel_name = 'python3'\n\n## The kernel manager class.  This is configurable to allow subclassing of the\n#  KernelManager for customized behavior.\n#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'\n\n#------------------------------------------------------------------------------\n# MappingKernelManager(MultiKernelManager) configuration\n#------------------------------------------------------------------------------\n\n## A KernelManager that handles notebook mapping and HTTP error handling\n\n## \n#c.MappingKernelManager.root_dir = ''\n\n#------------------------------------------------------------------------------\n# ContentsManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Base class for serving files and directories.\n#  \n#  This serves any text or binary file, as well as directories, with special\n#  handling for JSON notebook documents.\n#  \n#  Most APIs take a path argument, which is always an API-style unicode path, and\n#  always refers to a directory.\n#  \n#  - unicode, not url-escaped\n#  - '/'-separated\n#  - leading and trailing '/' will be stripped\n#  - if unspecified, path defaults to '',\n#    indicating the root path.\n\n## \n#c.ContentsManager.checkpoints = None\n\n## \n#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'\n\n## \n#c.ContentsManager.checkpoints_kwargs = {}\n\n## Glob patterns to hide in file and directory listings.\n#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']\n\n## Python callable or importstring thereof\n#  \n#  To be called on a contents model prior to save.\n#  \n#  This can be used to process the structure, such as removing notebook outputs\n#  or other side effects that should not be saved.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(path=path, model=model, contents_manager=self)\n#  \n#  - model: the model to be saved. Includes file contents.\n#    Modifying this dict will affect the file that is stored.\n#  - path: the API path of the save destination\n#  - contents_manager: this ContentsManager instance\n#c.ContentsManager.pre_save_hook = None\n\n## \n#c.ContentsManager.root_dir = '/'\n\n## The base name used when creating untitled directories.\n#c.ContentsManager.untitled_directory = 'Untitled Folder'\n\n## The base name used when creating untitled files.\n#c.ContentsManager.untitled_file = 'untitled'\n\n## The base name used when creating untitled notebooks.\n#c.ContentsManager.untitled_notebook = 'Untitled'\n\n#------------------------------------------------------------------------------\n# FileManagerMixin(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for ContentsAPI classes that interact with the filesystem.\n#  \n#  Provides facilities for reading, writing, and copying both notebooks and\n#  generic files.\n#  \n#  Shared by FileContentsManager and FileCheckpoints.\n#  \n#  Note ---- Classes using this mixin must provide the following attributes:\n#  \n#  root_dir : unicode\n#      A directory against against which API-style paths are to be resolved.\n#  \n#  log : logging.Logger\n\n## By default notebooks are saved on disk on a temporary file and then if\n#  succefully written, it replaces the old ones. This procedure, namely\n#  'atomic_writing', causes some bugs on file system whitout operation order\n#  enforcement (like some networked fs). If set to False, the new notebook is\n#  written directly on the old one which could fail (eg: full filesystem or quota\n#  )\n#c.FileManagerMixin.use_atomic_writing = True\n\n#------------------------------------------------------------------------------\n# FileContentsManager(FileManagerMixin,ContentsManager) configuration\n#------------------------------------------------------------------------------\n\n## Python callable or importstring thereof\n#  \n#  to be called on the path of a file just saved.\n#  \n#  This can be used to process the file on disk, such as converting the notebook\n#  to a script or HTML via nbconvert.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(os_path=os_path, model=model, contents_manager=instance)\n#  \n#  - path: the filesystem path to the file just written - model: the model\n#  representing the file - contents_manager: this ContentsManager instance\n#c.FileContentsManager.post_save_hook = None\n\n## \n#c.FileContentsManager.root_dir = ''\n\n## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0\n#c.FileContentsManager.save_script = False\n\n#------------------------------------------------------------------------------\n# NotebookNotary(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for computing and verifying notebook signatures.\n\n## The hashing algorithm used to sign notebooks.\n#c.NotebookNotary.algorithm = 'sha256'\n\n## The sqlite file in which to store notebook signatures. By default, this will\n#  be in your Jupyter data directory. You can set it to ':memory:' to disable\n#  sqlite writing to the filesystem.\n#c.NotebookNotary.db_file = ''\n\n## The secret key with which notebooks are signed.\n#c.NotebookNotary.secret = b''\n\n## The file where the secret key is stored.\n#c.NotebookNotary.secret_file = ''\n\n## A callable returning the storage backend for notebook signatures. The default\n#  uses an SQLite database.\n#c.NotebookNotary.store_factory = traitlets.Undefined\n\n#------------------------------------------------------------------------------\n# KernelSpecManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## If there is no Python kernelspec registered and the IPython kernel is\n#  available, ensure it is added to the spec list.\n#c.KernelSpecManager.ensure_native_kernel = True\n\n## The kernel spec class.  This is configurable to allow subclassing of the\n#  KernelSpecManager for customized behavior.\n#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'\n\n## Whitelist of allowed kernel names.\n#  \n#  By default, all installed kernels are allowed.\n#c.KernelSpecManager.whitelist = set()\n/n/n/n", "label": 0}, {"id": "3fc5e147bdb8bfea24b62927f59fd09036346ef9", "code": "/jupyter_notebook_config.py/n/n# Copyright (c) Jupyter Development Team.\nfrom jupyter_core.paths import jupyter_data_dir\nimport subprocess\nimport os\n\nPEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')\n\nc = get_config()\nc.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'\nc.NotebookApp.port = int(os.getenv('PORT', '') or 8888)\nc.NotebookApp.open_browser = False\n\n# Set a certificate if USE_HTTPS is set to any value\nif 'USE_HTTPS' in os.environ:\n    if not os.path.isfile(PEM_FILE):\n        # Generate a certificate if one doesn't exist on disk\n        subprocess.check_call(['openssl', 'req', '-new', \n            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',\n            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',\n            '-keyout', PEM_FILE, '-out', PEM_FILE])\n    c.NotebookApp.certfile = PEM_FILE\n\n# Set a password if PASSWORD is set\nif 'PASSWORD' in os.environ:\n    from IPython.lib import passwd\n    c.NotebookApp.password = passwd(os.environ['PASSWORD'])\n    del os.environ['PASSWORD']\n/n/n/n", "label": 1}, {"id": "3fc5e147bdb8bfea24b62927f59fd09036346ef9", "code": "jupyter-5.0-default-jupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.\n\n#------------------------------------------------------------------------------\n# Application(SingletonConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## This is an application.\n\n## The date format used by logging formatters for %(asctime)s\n#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'\n\n## The Logging format template\n#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'\n\n## Set the log level by value or name.\n#c.Application.log_level = 30\n\n#------------------------------------------------------------------------------\n# JupyterApp(Application) configuration\n#------------------------------------------------------------------------------\n\n## Base class for Jupyter applications\n\n## Answer yes to any prompts.\n#c.JupyterApp.answer_yes = False\n\n## Full path of a config file.\n#c.JupyterApp.config_file = ''\n\n## Specify a config file to load.\n#c.JupyterApp.config_file_name = ''\n\n## Generate default config file.\n#c.JupyterApp.generate_config = False\n\n#------------------------------------------------------------------------------\n# NotebookApp(JupyterApp) configuration\n#------------------------------------------------------------------------------\n\n## Set the Access-Control-Allow-Credentials: true header\n#c.NotebookApp.allow_credentials = False\n\n## Set the Access-Control-Allow-Origin header\n#  \n#  Use '*' to allow any origin to access your server.\n#  \n#  Takes precedence over allow_origin_pat.\n#c.NotebookApp.allow_origin = ''\n\n## Use a regular expression for the Access-Control-Allow-Origin header\n#  \n#  Requests from an origin matching the expression will get replies with:\n#  \n#      Access-Control-Allow-Origin: origin\n#  \n#  where `origin` is the origin of the request.\n#  \n#  Ignored if allow_origin is set.\n#c.NotebookApp.allow_origin_pat = ''\n\n## Whether to allow the user to run the notebook as root.\n#c.NotebookApp.allow_root = False\n\n## DEPRECATED use base_url\n#c.NotebookApp.base_project_url = '/'\n\n## The base URL for the notebook server.\n#  \n#  Leading and trailing slashes can be omitted, and will automatically be added.\n#c.NotebookApp.base_url = '/'\n\n## Specify what command to use to invoke a web browser when opening the notebook.\n#  If not specified, the default browser will be determined by the `webbrowser`\n#  standard library module, which allows setting of the BROWSER environment\n#  variable to override it.\n#c.NotebookApp.browser = ''\n\n## The full path to an SSL/TLS certificate file.\n#c.NotebookApp.certfile = ''\n\n## The full path to a certificate authority certificate for SSL/TLS client\n#  authentication.\n#c.NotebookApp.client_ca = ''\n\n## The config manager class to use\n#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'\n\n## The notebook manager class to use.\n#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'\n\n## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's\n#  set_secure_cookie docs for details.\n#c.NotebookApp.cookie_options = {}\n\n## The random bytes used to secure cookies. By default this is a new random\n#  number every time you start the Notebook. Set it to a value in a config file\n#  to enable logins to persist across server sessions.\n#  \n#  Note: Cookie secrets should be kept private, do not share config files with\n#  cookie_secret stored in plaintext (you can read the value from a file).\n#c.NotebookApp.cookie_secret = b''\n\n## The file where the cookie secret is stored.\n#c.NotebookApp.cookie_secret_file = ''\n\n## The default URL to redirect to from `/`\n#c.NotebookApp.default_url = '/tree'\n\n## Disable cross-site-request-forgery protection\n#  \n#  Jupyter notebook 4.3.1 introduces protection from cross-site request\n#  forgeries, requiring API requests to either:\n#  \n#  - originate from pages served by this server (validated with XSRF cookie and\n#  token), or - authenticate with a token\n#  \n#  Some anonymous compute resources still desire the ability to run code,\n#  completely without authentication. These services can disable all\n#  authentication and security checks, with the full knowledge of what that\n#  implies.\n#c.NotebookApp.disable_check_xsrf = False\n\n## Whether to enable MathJax for typesetting math/TeX\n#  \n#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n#  very large, so you may want to disable it if you have a slow internet\n#  connection, or for offline use of the notebook.\n#  \n#  When disabled, equations etc. will appear as their untransformed TeX source.\n#c.NotebookApp.enable_mathjax = True\n\n## extra paths to look for Javascript notebook extensions\n#c.NotebookApp.extra_nbextensions_path = []\n\n## Extra paths to search for serving static files.\n#  \n#  This allows adding javascript/css to be available from the notebook server\n#  machine, or overriding individual files in the IPython\n#c.NotebookApp.extra_static_paths = []\n\n## Extra paths to search for serving jinja templates.\n#  \n#  Can be used to override templates from notebook.templates.\n#c.NotebookApp.extra_template_paths = []\n\n## \n#c.NotebookApp.file_to_run = ''\n\n## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS\n#  recompilation\n#c.NotebookApp.ignore_minified_js = False\n\n## (bytes/sec) Maximum rate at which messages can be sent on iopub before they\n#  are limited.\n#c.NotebookApp.iopub_data_rate_limit = 1000000\n\n## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are\n#  limited.\n#c.NotebookApp.iopub_msg_rate_limit = 1000\n\n## The IP address the notebook server will listen on.\n#c.NotebookApp.ip = 'localhost'\n\n## Supply extra arguments that will be passed to Jinja environment.\n#c.NotebookApp.jinja_environment_options = {}\n\n## Extra variables to supply to jinja templates when rendering.\n#c.NotebookApp.jinja_template_vars = {}\n\n## The kernel manager class to use.\n#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'\n\n## The kernel spec manager class to use. Should be a subclass of\n#  `jupyter_client.kernelspec.KernelSpecManager`.\n#  \n#  The Api of KernelSpecManager is provisional and might change without warning\n#  between this version of Jupyter and the next stable one.\n#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'\n\n## The full path to a private key file for usage with SSL/TLS.\n#c.NotebookApp.keyfile = ''\n\n## The login handler class to use.\n#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'\n\n## The logout handler class to use.\n#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'\n\n## The MathJax.js configuration file that is to be used.\n#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'\n\n## A custom url for MathJax.js. Should be in the form of a case-sensitive url to\n#  MathJax, for example:  /static/components/MathJax/MathJax.js\n#c.NotebookApp.mathjax_url = ''\n\n## Dict of Python modules to load as notebook server extensions.Entry values can\n#  be used to enable and disable the loading ofthe extensions. The extensions\n#  will be loaded in alphabetical order.\n#c.NotebookApp.nbserver_extensions = {}\n\n## The directory to use for notebooks and kernels.\n#c.NotebookApp.notebook_dir = ''\n\n## Whether to open in a browser after starting. The specific browser used is\n#  platform dependent and determined by the python standard library `webbrowser`\n#  module, unless it is overridden using the --browser (NotebookApp.browser)\n#  configuration option.\n#c.NotebookApp.open_browser = True\n\n## Hashed password to use for web authentication.\n#  \n#  To generate, type in a python/IPython shell:\n#  \n#    from notebook.auth import passwd; passwd()\n#  \n#  The string should be of the form type:salt:hashed-password.\n#c.NotebookApp.password = ''\n\n## Forces users to use a password for the Notebook server. This is useful in a\n#  multi user environment, for instance when everybody in the LAN can access each\n#  other's machine though ssh.\n#  \n#  In such a case, server the notebook server on localhost is not secure since\n#  any user can connect to the notebook server via ssh.\n#c.NotebookApp.password_required = False\n\n## The port the notebook server will listen on.\n#c.NotebookApp.port = 8888\n\n## The number of additional ports to try if the specified port is not available.\n#c.NotebookApp.port_retries = 50\n\n## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n#c.NotebookApp.pylab = 'disabled'\n\n## (sec) Time window used to  check the message and data rate limits.\n#c.NotebookApp.rate_limit_window = 3\n\n## Reraise exceptions encountered loading server extensions?\n#c.NotebookApp.reraise_server_extension_failures = False\n\n## DEPRECATED use the nbserver_extensions dict instead\n#c.NotebookApp.server_extensions = []\n\n## The session manager class to use.\n#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'\n\n## Supply SSL options for the tornado HTTPServer. See the tornado docs for\n#  details.\n#c.NotebookApp.ssl_options = {}\n\n## Supply overrides for terminado. Currently only supports \"shell_command\".\n#c.NotebookApp.terminado_settings = {}\n\n## Token used for authenticating first-time connections to the server.\n#  \n#  When no password is enabled, the default is to generate a new, random token.\n#  \n#  Setting to an empty string disables authentication altogether, which is NOT\n#  RECOMMENDED.\n#c.NotebookApp.token = '<generated>'\n\n## Supply overrides for the tornado.web.Application that the Jupyter notebook\n#  uses.\n#c.NotebookApp.tornado_settings = {}\n\n## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-\n#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles\n#  SSL\n#c.NotebookApp.trust_xheaders = False\n\n## DEPRECATED, use tornado_settings\n#c.NotebookApp.webapp_settings = {}\n\n## The base URL for websockets, if it differs from the HTTP server (hint: it\n#  almost certainly doesn't).\n#  \n#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n#c.NotebookApp.websocket_url = ''\n\n#------------------------------------------------------------------------------\n# ConnectionFileMixin(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for configurable classes that work with connection files\n\n## JSON file in which to store connection info [default: kernel-<pid>.json]\n#  \n#  This file will contain the IP, ports, and authentication key needed to connect\n#  clients to this kernel. By default, this file will be created in the security\n#  dir of the current profile, but can be specified by absolute path.\n#c.ConnectionFileMixin.connection_file = ''\n\n## set the control (ROUTER) port [default: random]\n#c.ConnectionFileMixin.control_port = 0\n\n## set the heartbeat port [default: random]\n#c.ConnectionFileMixin.hb_port = 0\n\n## set the iopub (PUB) port [default: random]\n#c.ConnectionFileMixin.iopub_port = 0\n\n## Set the kernel's IP address [default localhost]. If the IP address is\n#  something other than localhost, then Consoles on other machines will be able\n#  to connect to the Kernel, so be careful!\n#c.ConnectionFileMixin.ip = ''\n\n## set the shell (ROUTER) port [default: random]\n#c.ConnectionFileMixin.shell_port = 0\n\n## set the stdin (ROUTER) port [default: random]\n#c.ConnectionFileMixin.stdin_port = 0\n\n## \n#c.ConnectionFileMixin.transport = 'tcp'\n\n#------------------------------------------------------------------------------\n# KernelManager(ConnectionFileMixin) configuration\n#------------------------------------------------------------------------------\n\n## Manages a single kernel in a subprocess on this host.\n#  \n#  This version starts kernels with Popen.\n\n## Should we autorestart the kernel if it dies.\n#c.KernelManager.autorestart = True\n\n## DEPRECATED: Use kernel_name instead.\n#  \n#  The Popen Command to launch the kernel. Override this if you have a custom\n#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not\n#  pass any arguments to the kernel, because it cannot make any assumptions about\n#  the arguments that the kernel understands. In particular, this means that the\n#  kernel does not receive the option --debug if it given on the Jupyter command\n#  line.\n#c.KernelManager.kernel_cmd = []\n\n## Time to wait for a kernel to terminate before killing it, in seconds.\n#c.KernelManager.shutdown_wait_time = 5.0\n\n#------------------------------------------------------------------------------\n# Session(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Object for handling serialization and sending of messages.\n#  \n#  The Session object handles building messages and sending them with ZMQ sockets\n#  or ZMQStream objects.  Objects can communicate with each other over the\n#  network via Session objects, and only need to work with the dict-based IPython\n#  message spec. The Session will handle serialization/deserialization, security,\n#  and metadata.\n#  \n#  Sessions support configurable serialization via packer/unpacker traits, and\n#  signing with HMAC digests via the key/keyfile traits.\n#  \n#  Parameters ----------\n#  \n#  debug : bool\n#      whether to trigger extra debugging statements\n#  packer/unpacker : str : 'json', 'pickle' or import_string\n#      importstrings for methods to serialize message parts.  If just\n#      'json' or 'pickle', predefined JSON and pickle packers will be used.\n#      Otherwise, the entire importstring must be used.\n#  \n#      The functions must accept at least valid JSON input, and output *bytes*.\n#  \n#      For example, to use msgpack:\n#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'\n#  pack/unpack : callables\n#      You can also set the pack/unpack callables for serialization directly.\n#  session : bytes\n#      the ID of this Session object.  The default is to generate a new UUID.\n#  username : unicode\n#      username added to message headers.  The default is to ask the OS.\n#  key : bytes\n#      The key used to initialize an HMAC signature.  If unset, messages\n#      will not be signed or checked.\n#  keyfile : filepath\n#      The file containing a key.  If this is set, `key` will be initialized\n#      to the contents of the file.\n\n## Threshold (in bytes) beyond which an object's buffer should be extracted to\n#  avoid pickling.\n#c.Session.buffer_threshold = 1024\n\n## Whether to check PID to protect against calls after fork.\n#  \n#  This check can be disabled if fork-safety is handled elsewhere.\n#c.Session.check_pid = True\n\n## Threshold (in bytes) beyond which a buffer should be sent without copying.\n#c.Session.copy_threshold = 65536\n\n## Debug output in the Session\n#c.Session.debug = False\n\n## The maximum number of digests to remember.\n#  \n#  The digest history will be culled when it exceeds this value.\n#c.Session.digest_history_size = 65536\n\n## The maximum number of items for a container to be introspected for custom\n#  serialization. Containers larger than this are pickled outright.\n#c.Session.item_threshold = 64\n\n## execution key, for signing messages.\n#c.Session.key = b''\n\n## path to file containing execution key.\n#c.Session.keyfile = ''\n\n## Metadata dictionary, which serves as the default top-level metadata dict for\n#  each message.\n#c.Session.metadata = {}\n\n## The name of the packer for serializing messages. Should be one of 'json',\n#  'pickle', or an import name for a custom callable serializer.\n#c.Session.packer = 'json'\n\n## The UUID identifying this session.\n#c.Session.session = ''\n\n## The digest scheme used to construct the message signatures. Must have the form\n#  'hmac-HASH'.\n#c.Session.signature_scheme = 'hmac-sha256'\n\n## The name of the unpacker for unserializing messages. Only used with custom\n#  functions for `packer`.\n#c.Session.unpacker = 'json'\n\n## Username for the Session. Default is your system username.\n#c.Session.username = 'username'\n\n#------------------------------------------------------------------------------\n# MultiKernelManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for managing multiple kernels.\n\n## The name of the default kernel to start\n#c.MultiKernelManager.default_kernel_name = 'python3'\n\n## The kernel manager class.  This is configurable to allow subclassing of the\n#  KernelManager for customized behavior.\n#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'\n\n#------------------------------------------------------------------------------\n# MappingKernelManager(MultiKernelManager) configuration\n#------------------------------------------------------------------------------\n\n## A KernelManager that handles notebook mapping and HTTP error handling\n\n## \n#c.MappingKernelManager.root_dir = ''\n\n#------------------------------------------------------------------------------\n# ContentsManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Base class for serving files and directories.\n#  \n#  This serves any text or binary file, as well as directories, with special\n#  handling for JSON notebook documents.\n#  \n#  Most APIs take a path argument, which is always an API-style unicode path, and\n#  always refers to a directory.\n#  \n#  - unicode, not url-escaped\n#  - '/'-separated\n#  - leading and trailing '/' will be stripped\n#  - if unspecified, path defaults to '',\n#    indicating the root path.\n\n## \n#c.ContentsManager.checkpoints = None\n\n## \n#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'\n\n## \n#c.ContentsManager.checkpoints_kwargs = {}\n\n## Glob patterns to hide in file and directory listings.\n#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']\n\n## Python callable or importstring thereof\n#  \n#  To be called on a contents model prior to save.\n#  \n#  This can be used to process the structure, such as removing notebook outputs\n#  or other side effects that should not be saved.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(path=path, model=model, contents_manager=self)\n#  \n#  - model: the model to be saved. Includes file contents.\n#    Modifying this dict will affect the file that is stored.\n#  - path: the API path of the save destination\n#  - contents_manager: this ContentsManager instance\n#c.ContentsManager.pre_save_hook = None\n\n## \n#c.ContentsManager.root_dir = '/'\n\n## The base name used when creating untitled directories.\n#c.ContentsManager.untitled_directory = 'Untitled Folder'\n\n## The base name used when creating untitled files.\n#c.ContentsManager.untitled_file = 'untitled'\n\n## The base name used when creating untitled notebooks.\n#c.ContentsManager.untitled_notebook = 'Untitled'\n\n#------------------------------------------------------------------------------\n# FileManagerMixin(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for ContentsAPI classes that interact with the filesystem.\n#  \n#  Provides facilities for reading, writing, and copying both notebooks and\n#  generic files.\n#  \n#  Shared by FileContentsManager and FileCheckpoints.\n#  \n#  Note ---- Classes using this mixin must provide the following attributes:\n#  \n#  root_dir : unicode\n#      A directory against against which API-style paths are to be resolved.\n#  \n#  log : logging.Logger\n\n## By default notebooks are saved on disk on a temporary file and then if\n#  succefully written, it replaces the old ones. This procedure, namely\n#  'atomic_writing', causes some bugs on file system whitout operation order\n#  enforcement (like some networked fs). If set to False, the new notebook is\n#  written directly on the old one which could fail (eg: full filesystem or quota\n#  )\n#c.FileManagerMixin.use_atomic_writing = True\n\n#------------------------------------------------------------------------------\n# FileContentsManager(FileManagerMixin,ContentsManager) configuration\n#------------------------------------------------------------------------------\n\n## Python callable or importstring thereof\n#  \n#  to be called on the path of a file just saved.\n#  \n#  This can be used to process the file on disk, such as converting the notebook\n#  to a script or HTML via nbconvert.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(os_path=os_path, model=model, contents_manager=instance)\n#  \n#  - path: the filesystem path to the file just written - model: the model\n#  representing the file - contents_manager: this ContentsManager instance\n#c.FileContentsManager.post_save_hook = None\n\n## \n#c.FileContentsManager.root_dir = ''\n\n## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0\n#c.FileContentsManager.save_script = False\n\n#------------------------------------------------------------------------------\n# NotebookNotary(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for computing and verifying notebook signatures.\n\n## The hashing algorithm used to sign notebooks.\n#c.NotebookNotary.algorithm = 'sha256'\n\n## The sqlite file in which to store notebook signatures. By default, this will\n#  be in your Jupyter data directory. You can set it to ':memory:' to disable\n#  sqlite writing to the filesystem.\n#c.NotebookNotary.db_file = ''\n\n## The secret key with which notebooks are signed.\n#c.NotebookNotary.secret = b''\n\n## The file where the secret key is stored.\n#c.NotebookNotary.secret_file = ''\n\n## A callable returning the storage backend for notebook signatures. The default\n#  uses an SQLite database.\n#c.NotebookNotary.store_factory = traitlets.Undefined\n\n#------------------------------------------------------------------------------\n# KernelSpecManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## If there is no Python kernelspec registered and the IPython kernel is\n#  available, ensure it is added to the spec list.\n#c.KernelSpecManager.ensure_native_kernel = True\n\n## The kernel spec class.  This is configurable to allow subclassing of the\n#  KernelSpecManager for customized behavior.\n#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'\n\n## Whitelist of allowed kernel names.\n#  \n#  By default, all installed kernels are allowed.\n#c.KernelSpecManager.whitelist = set()\n/n/n/njupyter_notebook_config.py/n/n# Configuration file for jupyter-notebook.\n\n#------------------------------------------------------------------------------\n# Application(SingletonConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## This is an application.\n\n## The date format used by logging formatters for %(asctime)s\n#c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'\n\n## The Logging format template\n#c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'\n\n## Set the log level by value or name.\n#c.Application.log_level = 30\n\n#------------------------------------------------------------------------------\n# JupyterApp(Application) configuration\n#------------------------------------------------------------------------------\n\n## Base class for Jupyter applications\n\n## Answer yes to any prompts.\n#c.JupyterApp.answer_yes = False\n\n## Full path of a config file.\n#c.JupyterApp.config_file = ''\n\n## Specify a config file to load.\n#c.JupyterApp.config_file_name = ''\n\n## Generate default config file.\n#c.JupyterApp.generate_config = False\n\n#------------------------------------------------------------------------------\n# NotebookApp(JupyterApp) configuration\n#------------------------------------------------------------------------------\n\n## Set the Access-Control-Allow-Credentials: true header\n#c.NotebookApp.allow_credentials = False\n\n## Set the Access-Control-Allow-Origin header\n#  \n#  Use '*' to allow any origin to access your server.\n#  \n#  Takes precedence over allow_origin_pat.\n#c.NotebookApp.allow_origin = ''\n\n## Use a regular expression for the Access-Control-Allow-Origin header\n#  \n#  Requests from an origin matching the expression will get replies with:\n#  \n#      Access-Control-Allow-Origin: origin\n#  \n#  where `origin` is the origin of the request.\n#  \n#  Ignored if allow_origin is set.\n#c.NotebookApp.allow_origin_pat = ''\n\n## Whether to allow the user to run the notebook as root.\n#c.NotebookApp.allow_root = False\n\n## DEPRECATED use base_url\n#c.NotebookApp.base_project_url = '/'\n\n## The base URL for the notebook server.\n#  \n#  Leading and trailing slashes can be omitted, and will automatically be added.\n#c.NotebookApp.base_url = '/'\n\n## Specify what command to use to invoke a web browser when opening the notebook.\n#  If not specified, the default browser will be determined by the `webbrowser`\n#  standard library module, which allows setting of the BROWSER environment\n#  variable to override it.\n#c.NotebookApp.browser = ''\n\n## The full path to an SSL/TLS certificate file.\n#c.NotebookApp.certfile = ''\n\n## The full path to a certificate authority certificate for SSL/TLS client\n#  authentication.\n#c.NotebookApp.client_ca = ''\n\n## The config manager class to use\n#c.NotebookApp.config_manager_class = 'notebook.services.config.manager.ConfigManager'\n\n## The notebook manager class to use.\n#c.NotebookApp.contents_manager_class = 'notebook.services.contents.largefilemanager.LargeFileManager'\n\n## Extra keyword arguments to pass to `set_secure_cookie`. See tornado's\n#  set_secure_cookie docs for details.\n#c.NotebookApp.cookie_options = {}\n\n## The random bytes used to secure cookies. By default this is a new random\n#  number every time you start the Notebook. Set it to a value in a config file\n#  to enable logins to persist across server sessions.\n#  \n#  Note: Cookie secrets should be kept private, do not share config files with\n#  cookie_secret stored in plaintext (you can read the value from a file).\n#c.NotebookApp.cookie_secret = b''\n\n## The file where the cookie secret is stored.\n#c.NotebookApp.cookie_secret_file = ''\n\n## The default URL to redirect to from `/`\n#c.NotebookApp.default_url = '/tree'\n\n## Disable cross-site-request-forgery protection\n#  \n#  Jupyter notebook 4.3.1 introduces protection from cross-site request\n#  forgeries, requiring API requests to either:\n#  \n#  - originate from pages served by this server (validated with XSRF cookie and\n#  token), or - authenticate with a token\n#  \n#  Some anonymous compute resources still desire the ability to run code,\n#  completely without authentication. These services can disable all\n#  authentication and security checks, with the full knowledge of what that\n#  implies.\n#c.NotebookApp.disable_check_xsrf = False\n\n## Whether to enable MathJax for typesetting math/TeX\n#  \n#  MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n#  very large, so you may want to disable it if you have a slow internet\n#  connection, or for offline use of the notebook.\n#  \n#  When disabled, equations etc. will appear as their untransformed TeX source.\n#c.NotebookApp.enable_mathjax = True\n\n## extra paths to look for Javascript notebook extensions\n#c.NotebookApp.extra_nbextensions_path = []\n\n## Extra paths to search for serving static files.\n#  \n#  This allows adding javascript/css to be available from the notebook server\n#  machine, or overriding individual files in the IPython\n#c.NotebookApp.extra_static_paths = []\n\n## Extra paths to search for serving jinja templates.\n#  \n#  Can be used to override templates from notebook.templates.\n#c.NotebookApp.extra_template_paths = []\n\n## \n#c.NotebookApp.file_to_run = ''\n\n## Deprecated: Use minified JS file or not, mainly use during dev to avoid JS\n#  recompilation\n#c.NotebookApp.ignore_minified_js = False\n\n## (bytes/sec) Maximum rate at which messages can be sent on iopub before they\n#  are limited.\n#c.NotebookApp.iopub_data_rate_limit = 1000000\n\n## (msgs/sec) Maximum rate at which messages can be sent on iopub before they are\n#  limited.\n#c.NotebookApp.iopub_msg_rate_limit = 1000\n\n## The IP address the notebook server will listen on.\n#c.NotebookApp.ip = 'localhost'\n\n## Supply extra arguments that will be passed to Jinja environment.\n#c.NotebookApp.jinja_environment_options = {}\n\n## Extra variables to supply to jinja templates when rendering.\n#c.NotebookApp.jinja_template_vars = {}\n\n## The kernel manager class to use.\n#c.NotebookApp.kernel_manager_class = 'notebook.services.kernels.kernelmanager.MappingKernelManager'\n\n## The kernel spec manager class to use. Should be a subclass of\n#  `jupyter_client.kernelspec.KernelSpecManager`.\n#  \n#  The Api of KernelSpecManager is provisional and might change without warning\n#  between this version of Jupyter and the next stable one.\n#c.NotebookApp.kernel_spec_manager_class = 'jupyter_client.kernelspec.KernelSpecManager'\n\n## The full path to a private key file for usage with SSL/TLS.\n#c.NotebookApp.keyfile = ''\n\n## The login handler class to use.\n#c.NotebookApp.login_handler_class = 'notebook.auth.login.LoginHandler'\n\n## The logout handler class to use.\n#c.NotebookApp.logout_handler_class = 'notebook.auth.logout.LogoutHandler'\n\n## The MathJax.js configuration file that is to be used.\n#c.NotebookApp.mathjax_config = 'TeX-AMS-MML_HTMLorMML-full,Safe'\n\n## A custom url for MathJax.js. Should be in the form of a case-sensitive url to\n#  MathJax, for example:  /static/components/MathJax/MathJax.js\n#c.NotebookApp.mathjax_url = ''\n\n## Dict of Python modules to load as notebook server extensions.Entry values can\n#  be used to enable and disable the loading ofthe extensions. The extensions\n#  will be loaded in alphabetical order.\n#c.NotebookApp.nbserver_extensions = {}\n\n## The directory to use for notebooks and kernels.\n#c.NotebookApp.notebook_dir = ''\n\n## Whether to open in a browser after starting. The specific browser used is\n#  platform dependent and determined by the python standard library `webbrowser`\n#  module, unless it is overridden using the --browser (NotebookApp.browser)\n#  configuration option.\n#c.NotebookApp.open_browser = True\n\n## Hashed password to use for web authentication.\n#  \n#  To generate, type in a python/IPython shell:\n#  \n#    from notebook.auth import passwd; passwd()\n#  \n#  The string should be of the form type:salt:hashed-password.\n#c.NotebookApp.password = ''\n\n## Forces users to use a password for the Notebook server. This is useful in a\n#  multi user environment, for instance when everybody in the LAN can access each\n#  other's machine though ssh.\n#  \n#  In such a case, server the notebook server on localhost is not secure since\n#  any user can connect to the notebook server via ssh.\n#c.NotebookApp.password_required = False\n\n## The port the notebook server will listen on.\n#c.NotebookApp.port = 8888\n\n## The number of additional ports to try if the specified port is not available.\n#c.NotebookApp.port_retries = 50\n\n## DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n#c.NotebookApp.pylab = 'disabled'\n\n## (sec) Time window used to  check the message and data rate limits.\n#c.NotebookApp.rate_limit_window = 3\n\n## Reraise exceptions encountered loading server extensions?\n#c.NotebookApp.reraise_server_extension_failures = False\n\n## DEPRECATED use the nbserver_extensions dict instead\n#c.NotebookApp.server_extensions = []\n\n## The session manager class to use.\n#c.NotebookApp.session_manager_class = 'notebook.services.sessions.sessionmanager.SessionManager'\n\n## Supply SSL options for the tornado HTTPServer. See the tornado docs for\n#  details.\n#c.NotebookApp.ssl_options = {}\n\n## Supply overrides for terminado. Currently only supports \"shell_command\".\n#c.NotebookApp.terminado_settings = {}\n\n## Token used for authenticating first-time connections to the server.\n#  \n#  When no password is enabled, the default is to generate a new, random token.\n#  \n#  Setting to an empty string disables authentication altogether, which is NOT\n#  RECOMMENDED.\n#c.NotebookApp.token = '<generated>'\n\n## Supply overrides for the tornado.web.Application that the Jupyter notebook\n#  uses.\n#c.NotebookApp.tornado_settings = {}\n\n## Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-\n#  For headerssent by the upstream reverse proxy. Necessary if the proxy handles\n#  SSL\n#c.NotebookApp.trust_xheaders = False\n\n## DEPRECATED, use tornado_settings\n#c.NotebookApp.webapp_settings = {}\n\n## The base URL for websockets, if it differs from the HTTP server (hint: it\n#  almost certainly doesn't).\n#  \n#  Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n#c.NotebookApp.websocket_url = ''\n\n#------------------------------------------------------------------------------\n# ConnectionFileMixin(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for configurable classes that work with connection files\n\n## JSON file in which to store connection info [default: kernel-<pid>.json]\n#  \n#  This file will contain the IP, ports, and authentication key needed to connect\n#  clients to this kernel. By default, this file will be created in the security\n#  dir of the current profile, but can be specified by absolute path.\n#c.ConnectionFileMixin.connection_file = ''\n\n## set the control (ROUTER) port [default: random]\n#c.ConnectionFileMixin.control_port = 0\n\n## set the heartbeat port [default: random]\n#c.ConnectionFileMixin.hb_port = 0\n\n## set the iopub (PUB) port [default: random]\n#c.ConnectionFileMixin.iopub_port = 0\n\n## Set the kernel's IP address [default localhost]. If the IP address is\n#  something other than localhost, then Consoles on other machines will be able\n#  to connect to the Kernel, so be careful!\n#c.ConnectionFileMixin.ip = ''\n\n## set the shell (ROUTER) port [default: random]\n#c.ConnectionFileMixin.shell_port = 0\n\n## set the stdin (ROUTER) port [default: random]\n#c.ConnectionFileMixin.stdin_port = 0\n\n## \n#c.ConnectionFileMixin.transport = 'tcp'\n\n#------------------------------------------------------------------------------\n# KernelManager(ConnectionFileMixin) configuration\n#------------------------------------------------------------------------------\n\n## Manages a single kernel in a subprocess on this host.\n#  \n#  This version starts kernels with Popen.\n\n## Should we autorestart the kernel if it dies.\n#c.KernelManager.autorestart = True\n\n## DEPRECATED: Use kernel_name instead.\n#  \n#  The Popen Command to launch the kernel. Override this if you have a custom\n#  kernel. If kernel_cmd is specified in a configuration file, Jupyter does not\n#  pass any arguments to the kernel, because it cannot make any assumptions about\n#  the arguments that the kernel understands. In particular, this means that the\n#  kernel does not receive the option --debug if it given on the Jupyter command\n#  line.\n#c.KernelManager.kernel_cmd = []\n\n## Time to wait for a kernel to terminate before killing it, in seconds.\n#c.KernelManager.shutdown_wait_time = 5.0\n\n#------------------------------------------------------------------------------\n# Session(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Object for handling serialization and sending of messages.\n#  \n#  The Session object handles building messages and sending them with ZMQ sockets\n#  or ZMQStream objects.  Objects can communicate with each other over the\n#  network via Session objects, and only need to work with the dict-based IPython\n#  message spec. The Session will handle serialization/deserialization, security,\n#  and metadata.\n#  \n#  Sessions support configurable serialization via packer/unpacker traits, and\n#  signing with HMAC digests via the key/keyfile traits.\n#  \n#  Parameters ----------\n#  \n#  debug : bool\n#      whether to trigger extra debugging statements\n#  packer/unpacker : str : 'json', 'pickle' or import_string\n#      importstrings for methods to serialize message parts.  If just\n#      'json' or 'pickle', predefined JSON and pickle packers will be used.\n#      Otherwise, the entire importstring must be used.\n#  \n#      The functions must accept at least valid JSON input, and output *bytes*.\n#  \n#      For example, to use msgpack:\n#      packer = 'msgpack.packb', unpacker='msgpack.unpackb'\n#  pack/unpack : callables\n#      You can also set the pack/unpack callables for serialization directly.\n#  session : bytes\n#      the ID of this Session object.  The default is to generate a new UUID.\n#  username : unicode\n#      username added to message headers.  The default is to ask the OS.\n#  key : bytes\n#      The key used to initialize an HMAC signature.  If unset, messages\n#      will not be signed or checked.\n#  keyfile : filepath\n#      The file containing a key.  If this is set, `key` will be initialized\n#      to the contents of the file.\n\n## Threshold (in bytes) beyond which an object's buffer should be extracted to\n#  avoid pickling.\n#c.Session.buffer_threshold = 1024\n\n## Whether to check PID to protect against calls after fork.\n#  \n#  This check can be disabled if fork-safety is handled elsewhere.\n#c.Session.check_pid = True\n\n## Threshold (in bytes) beyond which a buffer should be sent without copying.\n#c.Session.copy_threshold = 65536\n\n## Debug output in the Session\n#c.Session.debug = False\n\n## The maximum number of digests to remember.\n#  \n#  The digest history will be culled when it exceeds this value.\n#c.Session.digest_history_size = 65536\n\n## The maximum number of items for a container to be introspected for custom\n#  serialization. Containers larger than this are pickled outright.\n#c.Session.item_threshold = 64\n\n## execution key, for signing messages.\n#c.Session.key = b''\n\n## path to file containing execution key.\n#c.Session.keyfile = ''\n\n## Metadata dictionary, which serves as the default top-level metadata dict for\n#  each message.\n#c.Session.metadata = {}\n\n## The name of the packer for serializing messages. Should be one of 'json',\n#  'pickle', or an import name for a custom callable serializer.\n#c.Session.packer = 'json'\n\n## The UUID identifying this session.\n#c.Session.session = ''\n\n## The digest scheme used to construct the message signatures. Must have the form\n#  'hmac-HASH'.\n#c.Session.signature_scheme = 'hmac-sha256'\n\n## The name of the unpacker for unserializing messages. Only used with custom\n#  functions for `packer`.\n#c.Session.unpacker = 'json'\n\n## Username for the Session. Default is your system username.\n#c.Session.username = 'username'\n\n#------------------------------------------------------------------------------\n# MultiKernelManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for managing multiple kernels.\n\n## The name of the default kernel to start\n#c.MultiKernelManager.default_kernel_name = 'python3'\n\n## The kernel manager class.  This is configurable to allow subclassing of the\n#  KernelManager for customized behavior.\n#c.MultiKernelManager.kernel_manager_class = 'jupyter_client.ioloop.IOLoopKernelManager'\n\n#------------------------------------------------------------------------------\n# MappingKernelManager(MultiKernelManager) configuration\n#------------------------------------------------------------------------------\n\n## A KernelManager that handles notebook mapping and HTTP error handling\n\n## \n#c.MappingKernelManager.root_dir = ''\n\n#------------------------------------------------------------------------------\n# ContentsManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## Base class for serving files and directories.\n#  \n#  This serves any text or binary file, as well as directories, with special\n#  handling for JSON notebook documents.\n#  \n#  Most APIs take a path argument, which is always an API-style unicode path, and\n#  always refers to a directory.\n#  \n#  - unicode, not url-escaped\n#  - '/'-separated\n#  - leading and trailing '/' will be stripped\n#  - if unspecified, path defaults to '',\n#    indicating the root path.\n\n## \n#c.ContentsManager.checkpoints = None\n\n## \n#c.ContentsManager.checkpoints_class = 'notebook.services.contents.checkpoints.Checkpoints'\n\n## \n#c.ContentsManager.checkpoints_kwargs = {}\n\n## Glob patterns to hide in file and directory listings.\n#c.ContentsManager.hide_globs = ['__pycache__', '*.pyc', '*.pyo', '.DS_Store', '*.so', '*.dylib', '*~']\n\n## Python callable or importstring thereof\n#  \n#  To be called on a contents model prior to save.\n#  \n#  This can be used to process the structure, such as removing notebook outputs\n#  or other side effects that should not be saved.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(path=path, model=model, contents_manager=self)\n#  \n#  - model: the model to be saved. Includes file contents.\n#    Modifying this dict will affect the file that is stored.\n#  - path: the API path of the save destination\n#  - contents_manager: this ContentsManager instance\n#c.ContentsManager.pre_save_hook = None\n\n## \n#c.ContentsManager.root_dir = '/'\n\n## The base name used when creating untitled directories.\n#c.ContentsManager.untitled_directory = 'Untitled Folder'\n\n## The base name used when creating untitled files.\n#c.ContentsManager.untitled_file = 'untitled'\n\n## The base name used when creating untitled notebooks.\n#c.ContentsManager.untitled_notebook = 'Untitled'\n\n#------------------------------------------------------------------------------\n# FileManagerMixin(Configurable) configuration\n#------------------------------------------------------------------------------\n\n## Mixin for ContentsAPI classes that interact with the filesystem.\n#  \n#  Provides facilities for reading, writing, and copying both notebooks and\n#  generic files.\n#  \n#  Shared by FileContentsManager and FileCheckpoints.\n#  \n#  Note ---- Classes using this mixin must provide the following attributes:\n#  \n#  root_dir : unicode\n#      A directory against against which API-style paths are to be resolved.\n#  \n#  log : logging.Logger\n\n## By default notebooks are saved on disk on a temporary file and then if\n#  succefully written, it replaces the old ones. This procedure, namely\n#  'atomic_writing', causes some bugs on file system whitout operation order\n#  enforcement (like some networked fs). If set to False, the new notebook is\n#  written directly on the old one which could fail (eg: full filesystem or quota\n#  )\n#c.FileManagerMixin.use_atomic_writing = True\n\n#------------------------------------------------------------------------------\n# FileContentsManager(FileManagerMixin,ContentsManager) configuration\n#------------------------------------------------------------------------------\n\n## Python callable or importstring thereof\n#  \n#  to be called on the path of a file just saved.\n#  \n#  This can be used to process the file on disk, such as converting the notebook\n#  to a script or HTML via nbconvert.\n#  \n#  It will be called as (all arguments passed by keyword)::\n#  \n#      hook(os_path=os_path, model=model, contents_manager=instance)\n#  \n#  - path: the filesystem path to the file just written - model: the model\n#  representing the file - contents_manager: this ContentsManager instance\n#c.FileContentsManager.post_save_hook = None\n\n## \n#c.FileContentsManager.root_dir = ''\n\n## DEPRECATED, use post_save_hook. Will be removed in Notebook 5.0\n#c.FileContentsManager.save_script = False\n\n#------------------------------------------------------------------------------\n# NotebookNotary(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## A class for computing and verifying notebook signatures.\n\n## The hashing algorithm used to sign notebooks.\n#c.NotebookNotary.algorithm = 'sha256'\n\n## The sqlite file in which to store notebook signatures. By default, this will\n#  be in your Jupyter data directory. You can set it to ':memory:' to disable\n#  sqlite writing to the filesystem.\n#c.NotebookNotary.db_file = ''\n\n## The secret key with which notebooks are signed.\n#c.NotebookNotary.secret = b''\n\n## The file where the secret key is stored.\n#c.NotebookNotary.secret_file = ''\n\n## A callable returning the storage backend for notebook signatures. The default\n#  uses an SQLite database.\n#c.NotebookNotary.store_factory = traitlets.Undefined\n\n#------------------------------------------------------------------------------\n# KernelSpecManager(LoggingConfigurable) configuration\n#------------------------------------------------------------------------------\n\n## If there is no Python kernelspec registered and the IPython kernel is\n#  available, ensure it is added to the spec list.\n#c.KernelSpecManager.ensure_native_kernel = True\n\n## The kernel spec class.  This is configurable to allow subclassing of the\n#  KernelSpecManager for customized behavior.\n#c.KernelSpecManager.kernel_spec_class = 'jupyter_client.kernelspec.KernelSpec'\n\n## Whitelist of allowed kernel names.\n#  \n#  By default, all installed kernels are allowed.\n#c.KernelSpecManager.whitelist = set()\n/n/n/n", "label": 0}, {"id": "3fc5e147bdb8bfea24b62927f59fd09036346ef9", "code": "/jupyter_notebook_config.py/n/n# Copyright (c) Jupyter Development Team.\nfrom jupyter_core.paths import jupyter_data_dir\nimport subprocess\nimport os\n\nPEM_FILE = os.path.join(jupyter_data_dir(), 'notebook.pem')\n\nc = get_config()\nc.NotebookApp.ip = os.getenv('INTERFACE', '') or '*'\nc.NotebookApp.port = int(os.getenv('PORT', '') or 8888)\nc.NotebookApp.open_browser = False\n\n# Set a certificate if USE_HTTPS is set to any value\nif 'USE_HTTPS' in os.environ:\n    if not os.path.isfile(PEM_FILE):\n        # Generate a certificate if one doesn't exist on disk\n        subprocess.check_call(['openssl', 'req', '-new', \n            '-newkey', 'rsa:2048', '-days', '365', '-nodes', '-x509',\n            '-subj', '/C=XX/ST=XX/L=XX/O=generated/CN=generated',\n            '-keyout', PEM_FILE, '-out', PEM_FILE])\n    c.NotebookApp.certfile = PEM_FILE\n\n# Set a password if PASSWORD is set\nif 'PASSWORD' in os.environ:\n    from IPython.lib import passwd\n    c.NotebookApp.password = passwd(os.environ['PASSWORD'])\n    del os.environ['PASSWORD']\n/n/n/n", "label": 1}, {"id": "9d083ef1bc9cf41ff4e5a065c3196270effe3b5f", "code": "setup.py/n/nfrom setuptools import find_packages, setup\n\nsetup(\n    name='jupyter-notebook-gist',\n    version='0.4.0',\n    description='Create a gist from the Jupyter Notebook UI',\n    author='Mozilla Firefox Data Platform',\n    author_email='fx-data-platform@mozilla.com',\n    packages=find_packages(where='src'),\n    package_dir={'': 'src'},\n    include_package_data=True,\n    license='MPL2',\n    install_requires=[\n        'ipython >= 4',\n        'notebook >= 4.3.1',\n        'jupyter',\n        'requests',\n        'six',\n        'widgetsnbextension',\n    ],\n    url='https://github.com/mozilla/jupyter-notebook-gist',\n    zip_safe=False,\n)\n/n/n/n", "label": 0}, {"id": "9d083ef1bc9cf41ff4e5a065c3196270effe3b5f", "code": "/setup.py/n/nfrom setuptools import find_packages, setup\n\nsetup(\n    name='jupyter-notebook-gist',\n    version='0.4.0',\n    description='Create a gist from the Jupyter Notebook UI',\n    author='Mozilla Firefox Data Platform',\n    author_email='fx-data-platform@mozilla.com',\n    packages=find_packages(where='src'),\n    package_dir={'': 'src'},\n    include_package_data=True,\n    license='MPL2',\n    install_requires=[\n        'ipython >= 4',\n        'notebook >= 4.2',\n        'jupyter',\n        'requests',\n        'six',\n        'widgetsnbextension',\n    ],\n    url='https://github.com/mozilla/jupyter-notebook-gist',\n    zip_safe=False,\n)\n/n/n/n", "label": 1}, {"id": "e64a478b09842d55be64a7cf7badb83ac3eb6493", "code": "kijiji_repost_headless/__main__.py/n/nimport argparse\nimport os\nimport sys\nfrom time import sleep\n\nimport kijiji_api\nimport generate_inf_file as generator\n\nif sys.version_info < (3, 0):\n    raise Exception(\"This program requires Python 3.0 or greater\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Post ads on Kijiji\")\n    parser.add_argument('-u', '--username', help='username of your kijiji account')\n    parser.add_argument('-p', '--password', help='password of your kijiji account')\n\n    subparsers = parser.add_subparsers(help='sub-command help')\n\n    post_parser = subparsers.add_parser('post', help='post a new ad')\n    post_parser.add_argument('inf_file', type=str, help='.inf file containing posting details')\n    post_parser.set_defaults(function=post_ad)\n\n    folder_parser = subparsers.add_parser('folder', help='post ad from folder')\n    folder_parser.add_argument('folder_name', type=str, help='folder containing ad details')\n    folder_parser.set_defaults(function=post_folder)\n\n    repost_folder_parser = subparsers.add_parser('repost_folder', help='post ad from folder')\n    repost_folder_parser.add_argument('folder_name', type=str, help='folder containing ad details')\n    repost_folder_parser.set_defaults(function=repost_folder)\n\n    show_parser = subparsers.add_parser('show', help='show currently listed ads')\n    show_parser.set_defaults(function=show_ads)\n\n    delete_parser = subparsers.add_parser('delete', help='delete a listed ad')\n    delete_parser.add_argument('id', type=str, help='id of the ad you wish to delete')\n    delete_parser.set_defaults(function=delete_ad)\n\n    nuke_parser = subparsers.add_parser('nuke', help='delete all ads')\n    nuke_parser.set_defaults(function=nuke)\n\n    check_parser = subparsers.add_parser('check_ad', help='check if ad is active')\n    check_parser.add_argument('folder_name', type=str, help='folder containing ad details')\n    check_parser.set_defaults(function=check_ad)\n\n    repost_parser = subparsers.add_parser('repost', help='repost an existing ad')\n    repost_parser.add_argument('inf_file', type=str, help='.inf file containing posting details')\n    repost_parser.set_defaults(function=repost_ad)\n\n    build_parser = subparsers.add_parser('build_ad', help='Generates the item.inf file for a new ad')\n    build_parser.set_defaults(function=generate_inf_file)\n\n    args = parser.parse_args()\n    try:\n        args.function(args)\n    except AttributeError:\n        parser.print_help()\n\n\ndef get_folder_data(args):\n    \"\"\"\n    Set ad data inf file and extract login credentials from inf files\n    \"\"\"\n    args.inf_file = \"item.inf\"\n    cred_file = args.folder_name + \"/login.inf\"\n    creds = [line.strip() for line in open(cred_file, 'r')]\n    args.username = creds[0]\n    args.password = creds[1]\n\n\ndef get_inf_details(inf_file):\n    \"\"\"\n    Extract ad data from inf file\n    \"\"\"\n    with open(inf_file, 'rt') as infFileLines:\n        data = {key: val for line in infFileLines for (key, val) in (line.strip().split(\"=\"),)}\n    files = [open(picture, 'rb').read() for picture in data['imageCsv'].split(\",\")]\n    return [data, files]\n\n\ndef post_folder(args):\n    \"\"\"\n    Post new ad from folder\n    \"\"\"\n    get_folder_data(args)\n    os.chdir(args.folder_name)\n    post_ad(args)\n\n\ndef post_ad(args):\n    \"\"\"\n    Post new ad\n    \"\"\"\n    [data, image_files] = get_inf_details(args.inf_file)\n    attempts = 1\n    while not check_ad(args) and attempts < 5:\n        if attempts > 1:\n            print(\"Failed Attempt #{}, trying again.\".format(attempts))\n        attempts += 1\n        api = kijiji_api.KijijiApi()\n        api.login(args.username, args.password)\n        api.post_ad_using_data(data, image_files)\n    if not check_ad(args):\n        print(\"Failed Attempt #{}, giving up.\".format(attempts))\n\n\ndef show_ads(args):\n    \"\"\"\n    Print list of all ads\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    [print(\"{} '{}'\".format(ad_id, ad_name)) for ad_name, ad_id in api.get_all_ads()]\n\n\ndef delete_ad(args):\n    \"\"\"\n    Delete ad\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    api.delete_ad(args.id)\n\n\ndef delete_ad_using_title(name):\n    \"\"\"\n    Delete ad based on ad title\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.delete_ad_using_title(name)\n\n\ndef repost_ad(args):\n    \"\"\"\n    Repost ad\n\n    Try to delete ad with same title if possible before reposting new ad\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    del_ad_name = \"\"\n    for line in open(args.inf_file, 'rt'):\n        [key, val] = line.strip().rstrip(\"\\n\").split(\"=\")\n        if key == \"postAdForm.title\":\n            del_ad_name = val\n    try:\n        api.delete_ad_using_title(del_ad_name)\n        print(\"Existing ad deleted before reposting\")\n    except kijiji_api.DeleteAdException:\n        print(\"Did not find an existing ad with matching title, skipping ad deletion\")\n        pass\n    # Must wait a bit before posting the same ad even after deleting it, otherwise Kijiji will automatically remove it\n    sleep(180)\n    post_ad(args)\n\n\ndef repost_folder(args):\n    \"\"\"\n    Repost ad from folder\n    \"\"\"\n    get_folder_data(args)\n    os.chdir(args.folder_name)\n    repost_ad(args)\n\n\ndef check_ad(args):\n    \"\"\"\n    Check if ad is live\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    ad_name = \"\"\n    for line in open(args.inf_file, 'rt'):\n        [key, val] = line.strip().rstrip(\"\\n\").split(\"=\")\n        if key == \"postAdForm.title\":\n            ad_name = val\n    all_ads = api.get_all_ads()\n    return [t for t, i in all_ads if t == ad_name]\n\n\ndef nuke(args):\n    \"\"\"\n    Delete all ads\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    all_ads = api.get_all_ads()\n    [api.delete_ad(ad_id) for ad_name, ad_id in all_ads]\n\n\ndef generate_inf_file():\n    generator.run_program()\n\n\nif __name__ == \"__main__\":\n    main()\n/n/n/nkijiji_repost_headless/kijiji_api.py/n/nimport json\nimport re\nimport sys\nfrom time import strftime\n\nimport bs4\nimport requests\nimport yaml\n\nif sys.version_info < (3, 0):\n    raise Exception(\"This program requires Python 3.0 or greater\")\n\n\nclass KijijiApiException(Exception):\n    \"\"\"\n    Custom KijijiApi exception class\n    \"\"\"\n    def __init__(self, msg=\"KijijiApi exception encountered.\", dump=None):\n        self.msg = msg\n        self.dumpfilepath = \"\"\n        if dump:\n            self.dumpfilepath = \"kijijiapi_dump_{}.txt\".format(strftime(\"%Y%m%dT%H%M%S\"))\n            with open(self.dumpfilepath, 'a') as f:\n                f.write(dump)\n\n    def __str__(self):\n        if self.dumpfilepath:\n            return \"{}\\nSee {} in current directory for latest dumpfile.\".format(self.msg, self.dumpfilepath)\n        else:\n            return self.msg\n\n\ndef get_token(html, attrib_name):\n    \"\"\"\n    Return value of first match for element with name attribute\n    \"\"\"\n    soup = bs4.BeautifulSoup(html, 'html.parser')\n    res = soup.select(\"[name={}]\".format(attrib_name))\n    if not res:\n        raise KijijiApiException(\"Element with name attribute '{}' not found in html text.\".format(attrib_name), html)\n    return res[0]['value']\n\n\ndef get_kj_data(html):\n    \"\"\"\n    Return dict of Kijiji page data\n    The 'window.__data' JSON object contains many useful key/values\n    \"\"\"\n    soup = bs4.BeautifulSoup(html, 'html.parser')\n    p = re.compile('window.__data=(.*);')\n    script_list = soup.find_all(\"script\", {\"src\": False})\n    for script in script_list:\n        if script:\n            m = p.search(script.string)\n            if m:\n                return json.loads(m.group(1))\n    raise KijijiApiException(\"'__data' JSON object not found in html text.\", html)\n\n\ndef get_xsrf_token(html):\n    \"\"\"\n    Return XSRF token\n    This function is only necessary for the 'm-my-ads.html' page, as this particular page\n    does not contain the usual 'ca.kijiji.xsrf.token' hidden HTML form input element, which is easier to scrape\n    \"\"\"\n    soup = bs4.BeautifulSoup(html, 'html.parser')\n    p = re.compile('Zoop\\.init\\(.*config: ({.+?}).*\\);')\n    for script in soup.find_all(\"script\", {\"src\": False}):\n        if script:\n            m = p.search(script.string.replace(\"\\n\", \"\"))\n            if m:\n                # Using yaml to load since this is not valid JSON\n                return yaml.load(m.group(1))['token']\n    raise KijijiApiException(\"XSRF token not found in html text.\", html)\n\n\nclass KijijiApi:\n    \"\"\"\n    All functions require to be logged in to Kijiji first in order to function correctly\n    \"\"\"\n    def __init__(self):\n        config = {}\n        self.session = requests.Session()\n\n    def login(self, username, password):\n        \"\"\"\n        Login to Kijiji for the current session\n        \"\"\"\n        login_url = 'https://www.kijiji.ca/t-login.html'\n        resp = self.session.get(login_url)\n        payload = {\n            'emailOrNickname': username,\n            'password': password,\n            'rememberMe': 'true',\n            '_rememberMe': 'on',\n            'ca.kijiji.xsrf.token': get_token(resp.text, 'ca.kijiji.xsrf.token'),\n            'targetUrl': get_kj_data(resp.text)['config']['targetUrl'],\n        }\n        resp = self.session.post(login_url, data=payload)\n        if not self.is_logged_in():\n            raise KijijiApiException(\"Could not log in.\", resp.text)\n\n    def is_logged_in(self):\n        \"\"\"\n        Return true if logged into Kijiji for the current session\n        \"\"\"\n        return \"Sign Out\" in self.session.get('https://www.kijiji.ca/m-my-ads.html/').text\n\n    def logout(self):\n        \"\"\"\n        Logout of Kijiji for the current session\n        \"\"\"\n        self.session.get('https://www.kijiji.ca/m-logout.html')\n\n    def delete_ad(self, ad_id):\n        \"\"\"\n        Delete ad based on ad ID\n        \"\"\"\n        my_ads_page = self.session.get('https://www.kijiji.ca/m-my-ads.html')\n        params = {\n            'Action': 'DELETE_ADS',\n            'Mode': 'ACTIVE',\n            'needsRedirect': 'false',\n            'ads': '[{{\"adId\":\"{}\",\"reason\":\"PREFER_NOT_TO_SAY\",\"otherReason\":\"\"}}]'.format(ad_id),\n            'ca.kijiji.xsrf.token': get_xsrf_token(my_ads_page.text),\n        }\n        resp = self.session.post('https://www.kijiji.ca/j-delete-ad.json', data=params)\n        if \"OK\" not in resp.text:\n            raise KijijiApiException(\"Could not delete ad.\", resp.text)\n\n    def delete_ad_using_title(self, title):\n        \"\"\"\n        Delete ad based on ad title\n        \"\"\"\n        all_ads = self.get_all_ads()\n        [self.delete_ad(i) for t, i in all_ads if t.strip() == title.strip()]\n\n    def upload_image(self, token, image_files=[]):\n        \"\"\"\n        Upload one or more photos to Kijiji\n\n        'image_files' is a list of binary objects corresponding to images\n        \"\"\"\n        image_urls = []\n        image_upload_url = 'https://www.kijiji.ca/p-upload-image.html'\n        for img_file in image_files:\n            for i in range(0, 3):\n                r = self.session.post(image_upload_url, files={'file': img_file}, headers={\"X-Ebay-Box-Token\": token})\n                r.raise_for_status()\n                try:\n                    image_tree = json.loads(r.text)\n                    img_url = image_tree['thumbnailUrl']\n                    print(\"Image Upload success on try #{}\".format(i+1))\n                    image_urls.append(img_url)\n                    break\n                except (KeyError, ValueError):\n                    print(\"Image Upload failed on try #{}\".format(i+1))\n        return [image for image in image_urls if image is not None]\n\n    def post_ad_using_data(self, data, image_files=[]):\n        \"\"\"\n        Post new ad\n\n        'data' is a dictionary of ad data that to be posted\n        'image_files' is a list of binary objects corresponding to images to upload\n        \"\"\"\n        # Load ad posting page (arbitrary category)\n        resp = self.session.get('https://www.kijiji.ca/p-admarkt-post-ad.html?categoryId=15')\n\n        # Get token required for upload\n        m = re.search(r\"initialXsrfToken: '(\\S+)'\", resp.text)\n        if m:\n            image_upload_token = m.group(1)\n        else:\n            raise KijijiApiException(\"'initialXsrfToken' not found in html text.\", resp.text)\n\n        # Upload the images\n        image_list = self.upload_image(image_upload_token, image_files)\n        data['images'] = \",\".join(image_list)\n\n        # Retrieve XSRF tokens\n        data['ca.kijiji.xsrf.token'] = get_token(resp.text, 'ca.kijiji.xsrf.token')\n        data['postAdForm.fraudToken'] = get_token(resp.text, 'postAdForm.fraudToken')\n\n        # Format ad data and check constraints\n        data['postAdForm.description'] = data['postAdForm.description'].replace(\"\\\\n\", \"\\n\")\n        title_len = len(data.get(\"postAdForm.title\", \"\"))\n        if not title_len >= 10:\n            raise KijijiApiException(\"Your ad title is too short! (min 10 chars)\")\n        if title_len > 64:\n            raise KijijiApiException(\"Your ad title is too long! (max 64 chars)\")\n\n        # Upload the ad itself\n        new_ad_url = \"https://www.kijiji.ca/p-submit-ad.html\"\n        resp = self.session.post(new_ad_url, data=data)\n        resp.raise_for_status()\n        if \"Delete Ad?\" not in resp.text:\n            if \"There was an issue posting your ad, please contact Customer Service.\" in resp.text:\n                raise KijijiApiException(\"Could not post ad; this user is banned.\", resp.text)\n            else:\n                raise KijijiApiException(\"Could not post ad.\", resp.text)\n\n        # Extract ad ID from response set-cookie\n        ad_id = re.search('kjrva=(\\d+)', resp.headers['Set-Cookie']).group(1)\n\n        return ad_id\n\n    def get_all_ads(self):\n        \"\"\"\n        Return an iterator of tuples containing the ad title and ad ID for every ad\n        \"\"\"\n        resp = self.session.get('https://www.kijiji.ca/m-my-ads.html')\n        user_id = get_kj_data(resp.text)['config']['userId']\n        my_ads_url = 'https://www.kijiji.ca/j-get-my-ads.json?currentOffset=0&show=ACTIVE&user={}'.format(user_id)\n        my_ads_page = self.session.get(my_ads_url)\n        my_ads_tree = json.loads(my_ads_page.text)\n        ad_ids = [entry['id'] for entry in my_ads_tree['myAdEntries']]\n        ad_names = [entry['title'] for entry in my_ads_tree['myAdEntries']]\n        return zip(ad_names, ad_ids)\n/n/n/n", "label": 0}, {"id": "e64a478b09842d55be64a7cf7badb83ac3eb6493", "code": "/kijiji_repost_headless/__main__.py/n/nimport argparse\nimport os\nimport sys\nfrom time import sleep\n\nimport kijiji_api\nimport generate_inf_file as generator\n\nif sys.version_info < (3, 0):\n    raise Exception(\"This program requires Python 3.0 or greater\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Post ads on Kijiji\")\n    parser.add_argument('-u', '--username', help='username of your kijiji account')\n    parser.add_argument('-p', '--password', help='password of your kijiji account')\n\n    subparsers = parser.add_subparsers(help='sub-command help')\n\n    postParser = subparsers.add_parser('post', help='post a new ad')\n    postParser.add_argument('inf_file', type=str, help='.inf file containing posting details')\n    postParser.set_defaults(function=post_ad)\n\n    folderParser = subparsers.add_parser('folder', help='post ad from folder')\n    folderParser.add_argument('folderName', type=str, help='folder containing ad details')\n    folderParser.set_defaults(function=post_folder)\n\n    repostFolderParser = subparsers.add_parser('repost_folder', help='post ad from folder')\n    repostFolderParser.add_argument('folderName', type=str, help='folder containing ad details')\n    repostFolderParser.set_defaults(function=repost_folder)\n\n    showParser = subparsers.add_parser('show', help='show currently listed ads')\n    showParser.set_defaults(function=show_ads)\n\n    deleteParser = subparsers.add_parser('delete', help='delete a listed ad')\n    deleteParser.add_argument('id', type=str, help='id of the ad you wish to delete')\n    deleteParser.set_defaults(function=delete_ad)\n\n    nukeParser = subparsers.add_parser('nuke', help='delete all ads')\n    nukeParser.set_defaults(function=nuke)\n\n    checkParser = subparsers.add_parser('check_ad', help='check if ad is active')\n    checkParser.add_argument('folderName', type=str, help='folder containing ad details')\n    checkParser.set_defaults(function=check_ad)\n\n    repostParser = subparsers.add_parser('repost', help='repost an existing ad')\n    repostParser.add_argument('inf_file', type=str, help='.inf file containing posting details')\n    repostParser.set_defaults(function=repost_ad)\n\n    buildParser = subparsers.add_parser('build_ad', help='Generates the item.inf file for a new ad')\n    buildParser.set_defaults(function=generate_inf_file)\n\n    args = parser.parse_args()\n    try:\n        args.function(args)\n    except AttributeError:\n        parser.print_help()\n\n\ndef get_folder_data(args):\n    \"\"\"\n    Set ad data inf file and extract login credentials from inf files\n    \"\"\"\n    args.inf_file = \"item.inf\"\n    cred_file = args.folderName + \"/login.inf\"\n    creds = [line.strip() for line in open(cred_file, 'r')]\n    args.username = creds[0]\n    args.password = creds[1]\n\n\ndef get_inf_details(inf_file):\n    \"\"\"\n    Extract ad data from inf file\n    \"\"\"\n    with open(inf_file, 'rt') as infFileLines:\n        data = {key: val for line in infFileLines for (key, val) in (line.strip().split(\"=\"),)}\n    files = [open(picture, 'rb').read() for picture in data['imageCsv'].split(\",\")]\n    return [data, files]\n\n\ndef post_folder(args):\n    \"\"\"\n    Post new ad from folder\n    \"\"\"\n    get_folder_data(args)\n    os.chdir(args.folderName)\n    post_ad(args)\n\n\ndef post_ad(args):\n    \"\"\"\n    Post new ad\n    \"\"\"\n    [data, imageFiles] = get_inf_details(args.inf_file)\n    attempts = 1\n    while not check_ad(args) and attempts < 5:\n        if attempts > 1:\n            print(\"Failed Attempt #\" + str(attempts) + \", trying again.\")\n        attempts += 1\n        api = kijiji_api.KijijiApi()\n        api.login(args.username, args.password)\n        api.post_ad_using_data(data, imageFiles)\n        sleep(180)\n    if not check_ad(args):\n        print(\"Failed Attempt #\" + str(attempts) + \", giving up.\")\n\n\ndef show_ads(args):\n    \"\"\"\n    Print list of all ads\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    [print(\"{} '{}'\".format(adId, adName)) for adName, adId in api.get_all_ads()]\n\n\ndef delete_ad(args):\n    \"\"\"\n    Delete ad\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    api.delete_ad(args.id)\n\n\ndef delete_ad_using_title(name):\n    \"\"\"\n    Delete ad based on ad title\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.delete_ad_using_title(name)\n\n\ndef repost_ad(args):\n    \"\"\"\n    Repost ad\n\n    Try to delete ad with same title if possible before reposting new ad\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    delAdName = \"\"\n    for line in open(args.inf_file, 'rt'):\n        [key, val] = line.strip().rstrip(\"\\n\").split(\"=\")\n        if key == \"postAdForm.title\":\n            delAdName = val\n    try:\n        api.delete_ad_using_title(delAdName)\n        print(\"Existing ad deleted before reposting\")\n    except kijiji_api.DeleteAdException:\n        print(\"Did not find an existing ad with matching title, skipping ad deletion\")\n        pass\n    # Must wait a bit before posting the same ad even after deleting it, otherwise Kijiji will automatically remove it\n    sleep(180)\n    post_ad(args)\n\n\ndef repost_folder(args):\n    \"\"\"\n    Repost ad from folder\n    \"\"\"\n    get_folder_data(args)\n    os.chdir(args.folderName)\n    repost_ad(args)\n\n\ndef check_ad(args):\n    \"\"\"\n    Check if ad is live\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    AdName = \"\"\n    for line in open(args.inf_file, 'rt'):\n        [key, val] = line.strip().rstrip(\"\\n\").split(\"=\")\n        if key == \"postAdForm.title\":\n            AdName = val\n    allAds = api.get_all_ads()\n    return [t for t, i in allAds if t == AdName]\n\n\ndef nuke(args):\n    \"\"\"\n    Delete all ads\n    \"\"\"\n    api = kijiji_api.KijijiApi()\n    api.login(args.username, args.password)\n    allAds = api.get_all_ads()\n    [api.delete_ad(adId) for adName, adId in allAds]\n\ndef generate_inf_file(args):\n    generator.run_program()\n\nif __name__ == \"__main__\":\n    main()\n/n/n/n/kijiji_repost_headless/kijiji_api.py/n/nimport requests\nimport json\nimport bs4\nimport re\nimport sys\nfrom multiprocessing import Pool\nfrom time import strftime\n\nif sys.version_info < (3, 0):\n    raise Exception(\"This program requires Python 3.0 or greater\")\n\n\nclass KijijiApiException(Exception):\n    \"\"\"\n    Custom KijijiApi exception class\n    \"\"\"\n    def __init__(self, dump=None):\n        self.dumpfilepath = \"\"\n        if dump:\n            self.dumpfilepath = \"kijiji_dump_{}.txt\".format(strftime(\"%Y%m%dT%H%M%S\"))\n            with open(self.dumpfilepath, 'a') as f:\n                f.write(dump)\n    def __str__(self):\n        if self.dumpfilepath:\n            return \"See {} in current directory for latest dumpfile.\".format(self.dumpfilepath)\n        else:\n            return \"\"\n\nclass SignInException(KijijiApiException):\n    def __str__(self):\n        return \"Could not sign in.\\n\"+super().__str__()\n\nclass PostAdException(KijijiApiException):\n    def __str__(self):\n        return \"Could not post ad.\\n\"+super().__str__()\n\nclass BannedException(KijijiApiException):\n    def __str__(self):\n        return \"Could not post ad, this user is banned.\\n\"+super().__str__()\n\nclass DeleteAdException(KijijiApiException):\n    def __str__(self):\n        return \"Could not delete ad.\\n\"+super().__str__()\n\n\ndef get_token(html, token_name):\n    \"\"\"\n    Retrive CSRF token from webpage\n    Tokens are different every time a page is visitied\n    \"\"\"\n    soup = bs4.BeautifulSoup(html, 'html.parser')\n    res = soup.select(\"[name={}]\".format(token_name))\n    if not res:\n        print(\"Token '{}' not found in html text.\".format(token_name))\n        return \"\"\n    return res[0]['value']\n\n\nclass KijijiApi:\n    \"\"\"\n    All functions require to be logged in to Kijiji first in order to function correctly\n    \"\"\"\n    def __init__(self):\n        config = {}\n        self.session = requests.Session()\n\n    def login(self, username, password):\n        \"\"\"\n        Login to Kijiji for the current session\n        \"\"\"\n        login_url = 'https://www.kijiji.ca/t-login.html'\n        resp = self.session.get(login_url)\n        payload = {\n            'emailOrNickname': username,\n            'password': password,\n            'rememberMe': 'true',\n            '_rememberMe': 'on',\n            'ca.kijiji.xsrf.token': get_token(resp.text, 'ca.kijiji.xsrf.token'),\n            'targetUrl': 'L3QtbG9naW4uaHRtbD90YXJnZXRVcmw9TDNRdGJHOW5hVzR1YUhSdGJEOTBZWEpuWlhSVmNtdzlUREpuZEZwWFVuUmlNalV3WWpJMGRGbFlTbXhaVXpoNFRucEJkMDFxUVhsWWJVMTZZbFZLU1dGVmJHdGtiVTVzVlcxa1VWSkZPV0ZVUmtWNlUyMWpPVkJSTFMxZVRITTBVMk5wVW5wbVRHRlFRVUZwTDNKSGNtVk9kejA5XnpvMnFzNmc2NWZlOWF1T1BKMmRybEE9PQ--'\n            }\n        resp = self.session.post(login_url, data=payload)\n        if not self.is_logged_in():\n            raise SignInException(resp.text)\n\n    def is_logged_in(self):\n        \"\"\"\n        Return true if logged into Kijiji for the current session\n        \"\"\"\n        index_page_text = self.session.get('https://www.kijiji.ca/m-my-ads.html/').text\n        return \"Sign Out\" in index_page_text\n\n    def logout(self):\n        \"\"\"\n        Logout of Kijiji for the current session\n        \"\"\"\n        self.session.get('https://www.kijiji.ca/m-logout.html')\n\n    def delete_ad(self, ad_id):\n        \"\"\"\n        Delete ad based on ad ID\n        \"\"\"\n        my_ads_page = self.session.get('https://www.kijiji.ca/m-my-ads.html')\n        params = {\n            'Action': 'DELETE_ADS',\n            'Mode': 'ACTIVE',\n            'needsRedirect': 'false',\n            'ads': '[{{\"adId\":\"{}\",\"reason\":\"PREFER_NOT_TO_SAY\",\"otherReason\":\"\"}}]'.format(ad_id),\n            'ca.kijiji.xsrf.token': get_token(my_ads_page.text, 'ca.kijiji.xsrf.token')\n            }\n        resp = self.session.post('https://www.kijiji.ca/j-delete-ad.json', data=params)\n        if (\"OK\" not in resp.text):\n            raise DeleteAdException(resp.text)\n\n    def delete_ad_using_title(self, title):\n        \"\"\"\n        Delete ad based on ad title\n        \"\"\"\n        allAds = self.get_all_ads()\n        [self.delete_ad(i) for t, i in allAds if t.strip() == title.strip()]\n\n    def upload_image(self, token, image_files=[]):\n        \"\"\"\n        Upload one or more photos to Kijiji concurrently using Pool\n\n        'image_files' is a list of binary objects corresponding to images\n        \"\"\"\n        image_urls = []\n        image_upload_url = 'https://www.kijiji.ca/p-upload-image.html'\n        for img_file in image_files:\n            for i in range(0, 3):\n                files = {'file': img_file}\n                r = self.session.post(image_upload_url, files=files, headers={\"x-ebay-box-token\": token})\n                if (r.status_code != 200):\n                    print(r.status_code)\n                try:\n                    image_tree = json.loads(r.text)\n                    img_url = image_tree['thumbnailUrl']\n                    print(\"Image Upload success on try #{}\".format(i+1))\n                    image_urls.append(img_url)\n                    break\n                except (KeyError, ValueError) as e:\n                    print(\"Image Upload failed on try #{}\".format(i+1))\n        return [image for image in image_urls if image is not None]\n\n    def post_ad_using_data(self, data, image_files=[]):\n        \"\"\"\n        Post new ad\n\n        'data' is a dictionary of ad data that to be posted\n        'image_files' is a list of binary objects corresponding to images to upload\n        \"\"\"\n        # Load ad posting page\n        resp = self.session.get('https://www.kijiji.ca/p-admarkt-post-ad.html?categoryId=773')\n\n        #Get tokens required for upload\n        token_regex = r\"initialXsrfToken: '\\S+'\"\n        image_upload_token = re.findall(token_regex, resp.text)[0].strip(\"initialXsrfToken: '\").strip(\"'\")\n\n        # Upload the images\n        imageList = self.upload_image(image_upload_token, image_files)\n        data['images'] = \",\".join(imageList)\n\n        # Retrive tokens for website\n        data['ca.kijiji.xsrf.token'] = get_token(resp.text, 'ca.kijiji.xsrf.token')\n        data['postAdForm.fraudToken'] = get_token(resp.text, 'postAdForm.fraudToken')\n        data['postAdForm.description'] = data['postAdForm.description'].replace(\"\\\\n\", \"\\n\")\n\n        # Upload the ad itself\n        new_ad_url = \"https://www.kijiji.ca/p-submit-ad.html\"\n        resp = self.session.post(new_ad_url, data=data)\n        if not len(data.get(\"postAdForm.title\", \"\")) >= 10:\n            raise AssertionError(\"Your title is too short!\")\n        if (int(resp.status_code) != 200 or \\\n                \"Delete Ad?\" not in resp.text):\n            if \"There was an issue posting your ad, please contact Customer Service.\" in resp.text:\n                raise BannedException(resp.text)\n            else:\n                raise PostAdException(resp.text)\n\n        # Get adId and return it\n        new_cookie_with_ad_id = resp.headers['Set-Cookie']\n        ad_id = re.search('\\d+', new_cookie_with_ad_id).group()\n        return ad_id\n\n    def get_all_ads(self):\n        \"\"\"\n        Return an iterator of tuples containing the ad title and ad ID for every ad\n        \"\"\"\n        resp = self.session.get('https://www.kijiji.ca/m-my-ads.html')\n        user_id=get_token(resp.text, 'userId')\n        my_ads_url = 'https://www.kijiji.ca/j-get-my-ads.json?_=1&currentOffset=0&isPromoting=false&show=ACTIVE&user={}'.format(user_id)\n        my_ads_page = self.session.get(my_ads_url)\n        my_ads_tree = json.loads(my_ads_page.text)\n        ad_ids = [entry['id'] for entry in my_ads_tree['myAdEntries']]\n        ad_names = [entry['title'] for entry in my_ads_tree['myAdEntries']]\n        return zip(ad_names, ad_ids)\n/n/n/n", "label": 1}, {"id": "9573bdca55ddc5488066d3af525e41ed1d872ea6", "code": "service/pixelated/resources/__init__.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport json\n\nfrom twisted.web.http import UNAUTHORIZED\nfrom twisted.web.resource import Resource\n\n# from pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.session import IPixelatedSession\nfrom pixelated.support import log_time\n\n\nclass SetEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, set):\n            return list(obj)\n        return super(SetEncoder, self).default(obj)\n\n\ndef respond_json(entity, request, status_code=200):\n    json_response = json.dumps(entity, cls=SetEncoder)\n    request.responseHeaders.addRawHeader(b\"content-type\", b\"application/json\")\n    request.code = status_code\n    return json_response\n\n\n@log_time\ndef respond_json_deferred(entity, request, status_code=200):\n    json_response = json.dumps(entity, cls=SetEncoder)\n    request.responseHeaders.addRawHeader(b\"content-type\", b\"application/json\")\n    request.code = status_code\n    request.write(json_response)\n    request.finish()\n\n\nclass BaseResource(Resource):\n\n    def __init__(self, services_factory):\n        Resource.__init__(self)\n        self._services_factory = services_factory\n\n    def _get_user_id_from_request(self, request):\n        if self._services_factory.mode.is_single_user:\n            return None  # it doesn't matter\n        session = self.get_session(request)\n        if session.is_logged_in():\n            return session.user_uuid\n        raise ValueError('Not logged in')\n\n    def is_logged_in(self, request):\n        session = self.get_session(request)\n        return session.is_logged_in() and self._services_factory.is_logged_in(session.user_uuid)\n\n    def get_session(self, request):\n        return IPixelatedSession(request.getSession())\n\n    def _services(self, request):\n        user_id = self._get_user_id_from_request(request)\n        return self._services_factory.services(user_id)\n\n    def _service(self, request, attribute):\n        return getattr(self._services(request), attribute)\n\n    def keymanager(self, request):\n        return self._service(request, 'keymanager')\n\n    def mail_service(self, request):\n        return self._service(request, 'mail_service')\n\n    def search_engine(self, request):\n        return self._service(request, 'search_engine')\n\n    def draft_service(self, request):\n        return self._service(request, 'draft_service')\n\n    def feedback_service(self, request):\n        return self._service(request, 'feedback_service')\n\n\nclass UnAuthorizedResource(Resource):\n\n    def __init__(self):\n        Resource.__init__(self)\n\n    def render_GET(self, request):\n        request.setResponseCode(UNAUTHORIZED)\n        return \"Unauthorized!\"\n\n    def render_POST(self, request):\n        request.setResponseCode(UNAUTHORIZED)\n        return \"Unauthorized!\"\n/n/n/nservice/pixelated/resources/login_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nimport os\nfrom xml.sax import SAXParseException\n\nfrom twisted.cred import credentials\nfrom twisted.internet import defer\nfrom twisted.python.filepath import FilePath\nfrom twisted.web import util\nfrom twisted.web.http import UNAUTHORIZED, OK\nfrom twisted.web.resource import IResource, NoResource\nfrom twisted.web.server import NOT_DONE_YET\nfrom twisted.web.static import File\nfrom twisted.web.template import Element, XMLFile, renderElement, renderer\n\nfrom pixelated.adapter.welcome_mail import add_welcome_mail\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession\n\nlog = logging.getLogger(__name__)\n\n\ndef _get_startup_folder():\n    path = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(path, '..', 'assets')\n\n\ndef _get_static_folder():\n    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    # this is a workaround for packaging\n    if not os.path.exists(static_folder):\n        static_folder = os.path.abspath(\n            os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    if not os.path.exists(static_folder):\n        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n    return static_folder\n\n\nclass DisclaimerElement(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))\n\n    def __init__(self, banner):\n        super(DisclaimerElement, self).__init__()\n        self._set_loader(banner)\n        self._banner_filename = banner or \"_login_disclaimer_banner.html\"\n\n    def _set_loader(self, banner):\n        if banner:\n            current_path = os.path.dirname(os.path.abspath(__file__))\n            banner_file_path = os.path.join(current_path, \"..\", \"..\", \"..\", banner)\n            self.loader = XMLFile(FilePath(banner_file_path))\n\n    def render(self, request):\n        try:\n            return super(DisclaimerElement, self).render(request)\n        except SAXParseException:\n            return [\"Invalid XML template format for %s.\" % self._banner_filename]\n        except IOError:\n            return [\"Disclaimer banner file %s could not be read or does not exit.\" % self._banner_filename]\n\n\nclass LoginWebSite(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))\n\n    def __init__(self, error_msg=None, disclaimer_banner_file=None):\n        super(LoginWebSite, self).__init__()\n        self._error_msg = error_msg\n        self.disclaimer_banner_file = disclaimer_banner_file\n\n    @renderer\n    def error_msg(self, request, tag):\n        if self._error_msg is not None:\n            return tag(self._error_msg)\n        return tag('')\n\n    @renderer\n    def disclaimer(self, request, tag):\n        return DisclaimerElement(self.disclaimer_banner_file).render(request)\n\n\nclass LoginResource(BaseResource):\n    BASE_URL = 'login'\n\n    def __init__(self, services_factory, portal=None, disclaimer_banner=None):\n        BaseResource.__init__(self, services_factory)\n        self._static_folder = _get_static_folder()\n        self._startup_folder = _get_startup_folder()\n        self._portal = portal\n        self._disclaimer_banner = disclaimer_banner\n        self.putChild('startup-assets', File(self._startup_folder))\n\n    def set_portal(self, portal):\n        self._portal = portal\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if path == 'login':\n            return self\n        if not self.is_logged_in(request):\n            return UnAuthorizedResource()\n        return NoResource()\n\n    def render_GET(self, request):\n        request.setResponseCode(OK)\n        return self._render_template(request)\n\n    def _render_template(self, request, error_msg=None):\n        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)\n        return renderElement(request, site)\n\n    def render_POST(self, request):\n        if self.is_logged_in(request):\n            return util.redirectTo(\"/\", request)\n\n        def render_response(leap_session):\n            request.setResponseCode(OK)\n            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())\n            request.finish()\n            self._setup_user_services(leap_session, request)\n\n        def render_error(error):\n            log.info('Login Error for %s' % request.args['username'][0])\n            log.info('%s' % error)\n            request.setResponseCode(UNAUTHORIZED)\n            return self._render_template(request, 'Invalid credentials')\n\n        d = self._handle_login(request)\n        d.addCallbacks(render_response, render_error)\n\n        return NOT_DONE_YET\n\n    @defer.inlineCallbacks\n    def _handle_login(self, request):\n        self.creds = self._get_creds_from(request)\n        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)\n        defer.returnValue(leap_session)\n\n    def _get_creds_from(self, request):\n        username = request.args['username'][0]\n        password = request.args['password'][0]\n        return credentials.UsernamePassword(username, password)\n\n    @defer.inlineCallbacks\n    def _setup_user_services(self, leap_session, request):\n        user_id = leap_session.user_auth.uuid\n        if not self._services_factory.is_logged_in(user_id):\n            yield self._services_factory.create_services_from(leap_session)\n        self._init_http_session(request, user_id)\n\n    @defer.inlineCallbacks\n    def _initialize_services(self, leap_session):\n        yield self._services_factory.create_services_from(leap_session)\n\n        if leap_session.fresh_account:\n            yield add_welcome_mail(leap_session.mail_store)\n\n    def _init_http_session(self, request, user_id):\n        session = IPixelatedSession(request.getSession())\n        session.user_uuid = user_id\n/n/n/nservice/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport hashlib\nimport json\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource, UnAuthorizedResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.static import File\n\nCSRF_TOKEN_LENGTH = 32\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self.child_resources = ChildResourcesMap()\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if self._is_xsrf_valid(request):\n            return self.child_resources.get(path)\n        return UnAuthorizedResource()\n\n    def _is_xsrf_valid(self, request):\n        xsrf_token = request.getCookie('XSRF-TOKEN')\n\n        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')\n        if ajax_request:\n            xsrf_header = request.getHeader('x-xsrf-token')\n            return xsrf_header and xsrf_header == xsrf_token\n\n        get_request = (request.method == 'GET')\n        if get_request:\n            return True\n\n        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]\n        return csrf_input and csrf_input == xsrf_token\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self.child_resources.add('assets', File(self._static_folder))\n        self.child_resources.add('keys', KeysResource(self._services_factory))\n        self.child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self.child_resources.add('contacts', ContactsResource(self._services_factory))\n        self.child_resources.add('features', FeaturesResource(portal))\n        self.child_resources.add('tags', TagsResource(self._services_factory))\n        self.child_resources.add('mails', MailsResource(self._services_factory))\n        self.child_resources.add('mail', MailResource(self._services_factory))\n        self.child_resources.add('feedback', FeedbackResource(self._services_factory))\n        self.child_resources.add('user-settings', UserSettingsResource(self._services_factory))\n        self.child_resources.add(LoginResource.BASE_URL,\n                                 LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self.child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def _add_csrf_cookie(self, request):\n        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()\n        request.addCookie('XSRF-TOKEN', csrf_token)\n\n    def render_GET(self, request):\n        self._add_csrf_cookie(request)\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n\n\nclass ChildResourcesMap(object):\n    def __init__(self):\n        self._registry = {}\n\n    def add(self, path, resource):\n        self._registry[path] = resource\n\n    def get(self, path):\n        return self._registry.get(path)\n/n/n/nservice/test/integration/test_retrieve_attachment.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport base64\nimport json\nfrom email import encoders\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nfrom poster.encode import multipart_encode, MultipartParam\nfrom twisted.internet import defer\n\nfrom test.support.integration.soledad_test_base import SoledadTestBase\n\n\nclass RetrieveAttachmentTest(SoledadTestBase):\n    @defer.inlineCallbacks\n    def test_attachment_content_is_retrieved(self):\n        attachment_id, input_mail = self._create_mail_with_attachment()\n        yield self.mail_store.add_mail('INBOX', input_mail.as_string())\n\n        requested_filename = \"file name with space\"\n        expected_content_type = 'text/plain'\n        expected_content_disposition = 'attachment; filename=\"file name with space\"'\n\n        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename, content_type=expected_content_type)\n\n        self.assertEqual(200, req.code)\n        self.assertEquals('pretend to be binary attachment data', attachment)\n        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])\n        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])\n\n    @defer.inlineCallbacks\n    def test_should_retrieve_attachment_even_if_xsrf_token_not_passed(self):\n        attachment_id, input_mail = self._create_mail_with_attachment()\n        yield self.mail_store.add_mail('INBOX', input_mail.as_string())\n\n        requested_filename = \"file name with space\"\n        expected_content_type = 'text/plain'\n        expected_content_disposition = 'attachment; filename=\"file name with space\"'\n\n        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename,\n                                                    content_type=expected_content_type, ajax=False, csrf='mismatched token')\n\n        self.assertEqual(200, req.code)\n        self.assertEquals('pretend to be binary attachment data', attachment)\n        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])\n        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])\n\n    def _create_mail_with_attachment(self):\n        input_mail = MIMEMultipart()\n        input_mail.attach(MIMEText(u'a utf8 message', _charset='utf-8'))\n        attachment = MIMEApplication('pretend to be binary attachment data')\n        attachment.add_header('Content-Disposition', 'attachment', filename='file name.txt')\n        attachment.add_header('Content-Type', 'text/plain')\n        input_mail.attach(attachment)\n        attachment_id = 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A'\n        return attachment_id, input_mail\n\n    @defer.inlineCallbacks\n    def test_attachment_error_returned_if_id_not_found(self):\n        attachment, req = yield self.get_attachment('invalid attachment id', 'base64')\n\n        self.assertEqual(404, req.code)\n        self.assertIsNone(attachment)\n\n    @defer.inlineCallbacks\n    def test_post_new_attachment(self):\n        content_type = 'text/plain'\n        filename = 'filename.txt'\n        data = 'pretend to be binary attachment data'\n        file = MultipartParam('attachment', value=data, filename=filename, filetype=content_type)\n        datagen, headers = multipart_encode([file])\n        post_data = \"\".join(datagen)\n\n        _, req = yield self.post_attachment(post_data, headers)\n\n        self.assertEqual(201, req.code)\n        self.assertEqual('/attachment/B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A', req.headers['Location'])\n        response_json = {'ident': 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A',\n                         'content-type': content_type,\n                         'name': filename,\n                         'size': len(data),\n                         'encoding': 'base64'}\n        self.assertEqual(response_json, json.loads(req.written[0]))\n/n/n/nservice/test/support/integration/app_test_client.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport json\nimport multiprocessing\nfrom leap.mail.adaptors.soledad import SoledadMailAdaptor\nfrom leap.srp_session import SRPSession\nfrom mockito import mock\nimport os\nimport shutil\nimport time\nimport uuid\nimport random\n\n\nfrom leap.mail.imap.account import IMAPAccount\nfrom leap.soledad.client import Soledad\nfrom mock import Mock\nfrom twisted.internet import reactor, defer\nfrom twisted.internet.defer import succeed\nfrom twisted.web.resource import getChildForRequest\n# from twisted.web.server import Site as PixelatedSite\nfrom zope.interface import implementer\nfrom twisted.cred import checkers, credentials\nfrom pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore\nfrom pixelated.adapter.services.feedback_service import FeedbackService\nfrom pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources\nfrom pixelated.bitmask_libraries.config import LeapConfig\nfrom pixelated.bitmask_libraries.session import LeapSession\nfrom pixelated.config.services import Services\nfrom pixelated.config.site import PixelatedSite\n\nfrom pixelated.adapter.mailstore import LeapMailStore\nfrom pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore\n\nfrom pixelated.adapter.search import SearchEngine\nfrom pixelated.adapter.services.draft_service import DraftService\nfrom pixelated.adapter.services.mail_service import MailService\nfrom pixelated.resources.root_resource import RootResource\nfrom test.support.integration.model import MailBuilder\nfrom test.support.test_helper import request_mock\nfrom test.support.integration.model import ResponseMail\nfrom tempdir import TempDir\n\n\nclass AppTestAccount(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n\n    def __init__(self, user_id, leap_home):\n        self._user_id = user_id\n        self._leap_home = leap_home\n        self._uuid = str(uuid.uuid4())\n        self._mail_address = '%s@pixelated.org' % user_id\n        self._soledad = None\n        self._services = None\n\n    @defer.inlineCallbacks\n    def start(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)\n        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)\n        self.keymanager = mock()\n        self.mail_sender = self._create_mail_sender()\n        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)\n        self.attachment_store = LeapAttachmentStore(self.soledad)\n\n        yield self._initialize_imap_account()\n\n        self.draft_service = DraftService(self.mail_store)\n        self.leap_session = mock()\n        self.feedback_service = FeedbackService(self.leap_session)\n\n        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)\n\n        mails = yield self.mail_service.all_mails()\n        if len(mails) > 0:\n            raise Exception('What? Where did these come from?')\n        self.search_engine.index_mails(mails)\n\n    @property\n    def services(self):\n        if self._services is None:\n            services = mock(Services)\n            services.keymanager = self.keymanager\n            services.mail_service = self.mail_service\n            services.draft_service = self.draft_service\n            services.search_engine = self.search_engine\n            services.feedback_service = self.feedback_service\n            services._leap_session = self.leap_session\n\n            self._services = services\n            self.leap_session.close = lambda: 'mocked'\n\n        return self._services\n\n    def cleanup(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        shutil.rmtree(soledad_test_folder)\n\n    def _initialize_imap_account(self):\n        account_ready_cb = defer.Deferred()\n        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)\n        return account_ready_cb\n\n    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):\n        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n\n@implementer(checkers.ICredentialsChecker)\nclass StubSRPChecker(object):\n    credentialInterfaces = (\n        credentials.IUsernamePassword,\n    )\n\n    def __init__(self, leap_provider, credentials={}):\n        self._leap_provider = leap_provider\n        self._credentials = credentials.copy()\n\n    def add_user(self, username, password):\n        self._credentials[username] = password\n\n    def requestAvatarId(self, credentials):\n        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())\n        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))\n\n\nclass StubServicesFactory(ServicesFactory):\n\n    def __init__(self, accounts, mode):\n        super(StubServicesFactory, self).__init__(mode=mode)\n        self._accounts = accounts\n\n    @defer.inlineCallbacks\n    def create_services_from(self, leap_session):\n        account = self._accounts[leap_session.user_auth.username]\n        self._services_by_user[leap_session.user_auth.uuid] = account.services\n        yield defer.succeed(None)\n\n\nclass AppTestClient(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n    ACCOUNT = 'test'\n    MAIL_ADDRESS = 'test@pixelated.org'\n\n    def _initialize(self):\n        self._tmp_dir = TempDir()\n        self.accounts = {}\n\n    @defer.inlineCallbacks\n    def start_client(self, mode=UserAgentMode(is_single_user=True)):\n        self._initialize()\n        self._mode = mode\n        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)\n\n        yield self._test_account.start()\n\n        self.cleanup = lambda: self._tmp_dir.dissolve()\n\n        # copy fields for single user tests\n        self.soledad = self._test_account.soledad\n        self.search_engine = self._test_account.search_engine\n        self.keymanager = self._test_account.keymanager\n        self.mail_sender = self._test_account.mail_sender\n        self.mail_store = self._test_account.mail_store\n        self.attachment_store = self._test_account.attachment_store\n        self.draft_service = self._test_account.draft_service\n        self.leap_session = self._test_account.leap_session\n        self.feedback_service = self._test_account.feedback_service\n        self.mail_service = self._test_account.mail_service\n        self.account = self._test_account.account\n\n        if mode.is_single_user:\n            self.service_factory = SingleUserServicesFactory(mode)\n            services = self._test_account.services\n            self.service_factory.add_session('someuserid', services)\n\n            self.resource = RootResource(self.service_factory)\n            self.resource.initialize()\n        else:\n            self.service_factory = StubServicesFactory(self.accounts, mode)\n            provider = mock()\n            provider.config = LeapConfig(self._tmp_dir.name)\n\n            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))\n\n    @defer.inlineCallbacks\n    def create_user(self, account_name):\n        if self._mode.is_single_user:\n            raise Exception('Not supported in single user mode')\n\n        account = AppTestAccount(account_name, self._tmp_dir.name)\n        yield account.start()\n\n        self.accounts[account_name] = account\n\n    def _render(self, request, as_json=True):\n        def get_str(_str):\n            return json.loads(_str) if as_json else _str\n\n        def get_request_written_data(_=None):\n            written_data = request.getWrittenData()\n            if written_data:\n                return get_str(written_data)\n\n        resource = getChildForRequest(self.resource, request)\n        result = resource.render(request)\n\n        if isinstance(result, basestring):\n            return get_str(result), request\n\n        # result is NOT_DONE_YET\n        d = succeed(request) if request.finished else request.notifyFinish()\n        d.addCallback(get_request_written_data)\n        return d, request\n\n    def listenTCP(self, port=4567, host='127.0.0.1'):\n        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)\n\n    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):\n        def _start():\n            self.listenTCP(port, host)\n            reactor.run()\n        process = multiprocessing.Process(target=_start)\n        process.start()\n        time.sleep(1)\n        return lambda: process.terminate()\n\n    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):\n        request = request_mock(path, ajax=ajax, csrf=csrf)\n        request.args = get_args\n        return self._render(request, as_json)\n\n    def post(self, path, body='', headers=None, ajax=True, csrf='token'):\n        headers = headers or {'Content-Type': 'application/json'}\n        request = request_mock(path=path, method=\"POST\", body=body, headers=headers, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def put(self, path, body, ajax=True, csrf='token'):\n        request = request_mock(path=path, method=\"PUT\", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def delete(self, path, body=\"\", ajax=True, csrf='token'):\n        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=\"DELETE\", ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    @defer.inlineCallbacks\n    def add_mail_to_inbox(self, input_mail):\n        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)\n        defer.returnValue(mail)\n\n    def account_for(self, username):\n        return self.accounts[username]\n\n    def add_mail_to_user_inbox(self, input_mail, username):\n        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)\n\n    @defer.inlineCallbacks\n    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):\n        mails = []\n        yield self.mail_store.add_mailbox(mailbox)\n        for _ in range(num):\n            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)\n            builder.with_body(str(random.random()))\n            input_mail = builder.build_input_mail()\n            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)\n            if tags:\n                mail.tags |= set(tags)\n            if flags:\n                for flag in flags:\n                    mail.flags.add(flag)\n            if tags or flags:\n                yield self.mail_store.update_mail(mail)\n            mails.append(mail)\n\n        defer.returnValue(mails)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):\n        return os.path.join(soledad_test_folder, str(uuid.uuid4()))\n\n    def get_mails_by_tag(self, tag, page=1, window=100):\n        tags = 'tag:%s' % tag\n        return self.search(tags, page, window)\n\n    @defer.inlineCallbacks\n    def search(self, query, page=1, window=100):\n        res, _ = self.get(\"/mails\", {\n            'q': [query],\n            'w': [str(window)],\n            'p': [str(page)]\n        })\n        res = yield res\n        defer.returnValue([ResponseMail(m) for m in res['mails']])\n\n    @defer.inlineCallbacks\n    def get_mails_by_mailbox_name(self, mbox_name):\n        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)\n        mails = yield self.mail_store.get_mails(mail_ids)\n        defer.returnValue(mails)\n\n    @defer.inlineCallbacks\n    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):\n        params = {'encoding': [encoding]}\n        if filename:\n            params['filename'] = [filename]\n        if content_type:\n            params['content_type'] = [content_type]\n        deferred_result, req = self.get(\"/attachment/%s\" % ident, params, as_json=False, ajax=ajax, csrf=csrf)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    @defer.inlineCallbacks\n    def post_attachment(self, data, headers):\n        deferred_result, req = self.post('/attachment', body=data, headers=headers)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    def put_mail(self, data):\n        res, req = self.put('/mails', data)\n        return res, req\n\n    def post_tags(self, mail_ident, tags_json):\n        res, req = self.post(\"/mail/%s/tags\" % mail_ident, tags_json)\n        return res\n\n    def get_tags(self, **kwargs):\n        res, req = self.get('/tags', kwargs)\n        return res\n\n    def get_mail(self, mail_ident):\n        res, req = self.get('/mail/%s' % mail_ident)\n        return res\n\n    def delete_mail(self, mail_ident):\n        res, req = self.delete(\"/mail/%s\" % mail_ident)\n        return res\n\n    def delete_mails(self, idents):\n        res, req = self.post(\"/mails/delete\", json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_unread(self, idents):\n        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_read(self, idents):\n        res, req = self.post('/mails/read', json.dumps({'idents': idents}))\n        return res\n\n    def get_contacts(self, query):\n        res, req = self.get('/contacts', get_args={'q': query})\n        return res\n\n\n@defer.inlineCallbacks\ndef initialize_soledad(tempdir, uuid):\n    if os.path.isdir(tempdir):\n        shutil.rmtree(tempdir)\n\n    passphrase = u\"verysecretpassphrase\"\n    secret_path = os.path.join(tempdir, \"secret.gpg\")\n    local_db_path = os.path.join(tempdir, \"soledad.u1db\")\n    server_url = \"http://provider\"\n    cert_file = \"\"\n\n    class MockSharedDB(object):\n        get_doc = Mock(return_value=None)\n        put_doc = Mock()\n        lock = Mock(return_value=('atoken', 300))\n        unlock = Mock(return_value=True)\n        close = Mock()\n\n        def __call__(self):\n            return self\n\n    Soledad._shared_db = MockSharedDB()\n\n    _soledad = Soledad(\n        uuid,\n        passphrase,\n        secret_path,\n        local_db_path,\n        server_url,\n        cert_file,\n        defer_encryption=False,\n        syncable=False)\n\n    yield SoledadMailAdaptor().initialize_store(_soledad)\n\n    defer.returnValue(_soledad)\n/n/n/nservice/test/support/test_helper.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nfrom datetime import datetime\nimport io\nfrom twisted.web.test.test_web import DummyRequest\n\nfrom pixelated.adapter.model.mail import InputMail\n\n\nLEAP_FLAGS = ['\\\\Seen',\n              '\\\\Answered',\n              '\\\\Flagged',\n              '\\\\Deleted',\n              '\\\\Draft',\n              '\\\\Recent',\n              'List']\n\nDEFAULT_HEADERS = {'date': str(datetime.now())}\n\n\ndef mail_dict():\n    return {\n        'header': {\n            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],\n            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],\n            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],\n            'subject': 'Subject'\n        },\n        'body': 'Body',\n        'ident': '',\n        'tags': []\n    }\n\n\nclass TestDoc(object):\n    def __init__(self, content):\n        self.content = content\n\n    def __getitem__(self, key):\n        return self.content[key]\n\n\ndef leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',\n              chash='chash'):\n    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})\n\n    if headers is None:\n        headers = {}\n    if not (headers.get('received') or headers.get('date')):\n        headers.update(DEFAULT_HEADERS)\n    headers['headers'] = extra_headers\n    hdoc = TestDoc(headers)\n\n    bdoc = TestDoc({'raw': body, 'type': 'cnt'})\n\n    return (fdoc, hdoc, bdoc)\n\n\ndef input_mail():\n    mail = InputMail()\n    mail.fdoc = TestDoc({})\n    mail._chash = \"123\"\n    mail.as_dict = lambda: None\n    return mail\n\n\nclass TestRequest:\n\n    def __init__(self, json):\n        self.json = json\n\n\nclass PixRequestMock(DummyRequest):\n    def __init__(self, path):\n        DummyRequest.__init__(self, path)\n        self.content = None\n        self.code = None\n        self.cookies = {}\n\n    def getWrittenData(self):\n        if len(self.written):\n            return self.written[0]\n\n    def redirect(self, url):\n        self.setResponseCode(302)\n        self.setHeader(b\"location\", url)\n\n    def addCookie(self, key, value):\n        self.cookies[key] = value\n\n    def getCookie(self, key):\n        return self.cookies.get(key)\n\n\ndef request_mock(path='', method='GET', body='', headers={}, ajax=True, csrf='token'):\n    dummy = PixRequestMock(path.split('/'))\n    for name, val in headers.iteritems():\n        dummy.headers[name.lower()] = val\n    dummy.method = method\n    if isinstance(body, str):\n        dummy.content = io.BytesIO(body)\n    else:\n        for key, val in body.items():\n            dummy.addArg(key, val)\n    if ajax:\n        dummy.headers['x-requested-with'] = 'XMLHttpRequest'\n        dummy.headers['x-xsrf-token'] = csrf\n        dummy.addCookie('XSRF-TOKEN', csrf)\n\n    return dummy\n/n/n/nservice/test/unit/resources/test_root_resource.py/n/nimport unittest\nimport re\n\nfrom mock import MagicMock, patch\nfrom mockito import mock, when, any as ANY\n\nfrom pixelated.application import UserAgentMode\nfrom test.unit.resources import DummySite\nfrom twisted.web.test.requesthelper import DummyRequest\nfrom pixelated.resources.root_resource import RootResource, MODE_STARTUP, MODE_RUNNING\n\n\nclass TestRootResource(unittest.TestCase):\n    MAIL_ADDRESS = 'test_user@pixelated-project.org'\n\n    def setUp(self):\n        self.mail_service = mock()\n        self.services_factory = mock()\n        self.services_factory.mode = UserAgentMode(is_single_user=True)\n        self.services = mock()\n        self.services.mail_service = self.mail_service\n        self.services_factory._services_by_user = {'someuserid': self.mail_service}\n        when(self.services_factory).services(ANY()).thenReturn(self.services)\n        self.mail_service.account_email = self.MAIL_ADDRESS\n\n        root_resource = RootResource(self.services_factory)\n        root_resource._html_template = \"<html><head><title>$account_email</title></head></html>\"\n        root_resource._mode = root_resource\n        self.web = DummySite(root_resource)\n        self.root_resource = root_resource\n\n    def test_render_GET_should_template_account_email(self):\n        request = DummyRequest([''])\n        request.addCookie = lambda key, value: 'stubbed'\n\n        d = self.web.get(request)\n\n        def assert_response(_):\n            expected = \"<title>{0}</title>\".format(self.MAIL_ADDRESS)\n            matches = re.findall(expected, request.written[0])\n            self.assertEquals(len(matches), 1)\n\n        d.addCallback(assert_response)\n        return d\n\n    def _test_should_renew_xsrf_cookie(self):\n        request = DummyRequest([''])\n        request.addCookie = MagicMock()\n        generated_csrf_token = 'csrf_token'\n        mock_sha = MagicMock()\n        mock_sha.hexdigest = MagicMock(return_value=generated_csrf_token)\n\n        with patch('hashlib.sha256', return_value=mock_sha):\n            d = self.web.get(request)\n\n        def assert_csrf_cookie(_):\n            request.addCookie.assert_called_once_with('XSRF-TOKEN', generated_csrf_token)\n\n        d.addCallback(assert_csrf_cookie)\n        return d\n\n    def test_should_renew_xsrf_cookie_on_startup_mode(self):\n        self.root_resource._mode = MODE_STARTUP\n        self._test_should_renew_xsrf_cookie()\n\n    def test_should_renew_xsrf_cookie_on_running_mode(self):\n        self.root_resource._mode = MODE_RUNNING\n        self._test_should_renew_xsrf_cookie()\n\n    def _mock_ajax_csrf(self, request, csrf_token):\n        request.headers['x-requested-with'] = 'XMLHttpRequest'\n        request.headers['x-xsrf-token'] = csrf_token\n\n    def test_should_unauthorize_child_resource_ajax_requests_when_csrf_mismatch(self):\n        request = DummyRequest(['/child'])\n        self._mock_ajax_csrf(request, 'stubbed csrf token')\n\n        request.getCookie = MagicMock(return_value='mismatched csrf token')\n\n        d = self.web.get(request)\n\n        def assert_unauthorized(_):\n            self.assertEqual(401, request.responseCode)\n            self.assertEqual(\"Unauthorized!\", request.written[0])\n\n        d.addCallback(assert_unauthorized)\n        return d\n\n    def test_should_authorize_child_resource_non_ajax_GET_requests(self):\n        request = DummyRequest(['features'])\n\n        request.getCookie = MagicMock(return_value='irrelevant -- stubbed')\n        self.root_resource.initialize()\n\n        d = self.web.get(request)\n\n        def assert_unauthorized(_):\n            self.assertEqual(200, request.code)\n\n        d.addCallback(assert_unauthorized)\n        return d\n\n    def test_should_unauthorize_child_resource_non_ajax_POST_requests_when_csrf_input_mismatch(self):\n        request = DummyRequest(['mails'])\n        request.method = 'POST'\n        request.addArg('csrftoken', 'some csrf token')\n        mock_content = MagicMock()\n        mock_content.read = MagicMock(return_value={})\n        request.content = mock_content\n\n        request.getCookie = MagicMock(return_value='mismatched csrf token')\n\n        d = self.web.get(request)\n\n        def assert_unauthorized(_):\n            self.assertEqual(401, request.responseCode)\n            self.assertEqual(\"Unauthorized!\", request.written[0])\n\n        d.addCallback(assert_unauthorized)\n        return d\n/n/n/n", "label": 0}, {"id": "9573bdca55ddc5488066d3af525e41ed1d872ea6", "code": "/service/pixelated/resources/login_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nimport os\nfrom xml.sax import SAXParseException\n\nfrom twisted.cred import credentials\nfrom twisted.internet import defer\nfrom twisted.web import util\nfrom twisted.web.error import FlattenerError\nfrom twisted.web.http import UNAUTHORIZED, OK\nfrom twisted.web.resource import IResource, NoResource\nfrom twisted.web.server import NOT_DONE_YET\nfrom twisted.web.static import File\nfrom twisted.web.template import Element, XMLFile, renderElement, renderer\nfrom twisted.python.filepath import FilePath\n\nfrom pixelated.adapter.welcome_mail import add_welcome_mail\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession\n\nlog = logging.getLogger(__name__)\n\n\ndef _get_startup_folder():\n    path = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(path, '..', 'assets')\n\n\ndef _get_static_folder():\n    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    # this is a workaround for packaging\n    if not os.path.exists(static_folder):\n        static_folder = os.path.abspath(\n            os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    if not os.path.exists(static_folder):\n        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n    return static_folder\n\n\nclass DisclaimerElement(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))\n\n    def __init__(self, banner):\n        super(DisclaimerElement, self).__init__()\n        self._set_loader(banner)\n        self._banner_filename = banner or \"_login_disclaimer_banner.html\"\n\n    def _set_loader(self, banner):\n        if banner:\n            current_path = os.path.dirname(os.path.abspath(__file__))\n            banner_file_path = os.path.join(current_path, \"..\", \"..\", \"..\", banner)\n            self.loader = XMLFile(FilePath(banner_file_path))\n\n    def render(self, request):\n        try:\n            return super(DisclaimerElement, self).render(request)\n        except SAXParseException:\n            return [\"Invalid XML template format for %s.\" % self._banner_filename]\n        except IOError:\n            return [\"Disclaimer banner file %s could not be read or does not exit.\" % self._banner_filename]\n\n\nclass LoginWebSite(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))\n\n    def __init__(self, error_msg=None, disclaimer_banner_file=None):\n        super(LoginWebSite, self).__init__()\n        self._error_msg = error_msg\n        self.disclaimer_banner_file = disclaimer_banner_file\n\n    @renderer\n    def error_msg(self, request, tag):\n        if self._error_msg is not None:\n            return tag(self._error_msg)\n        return tag('')\n\n    @renderer\n    def disclaimer(self, request, tag):\n        return DisclaimerElement(self.disclaimer_banner_file).render(request)\n\n\nclass LoginResource(BaseResource):\n    BASE_URL = 'login'\n\n    def __init__(self, services_factory, portal=None, disclaimer_banner=None):\n        BaseResource.__init__(self, services_factory)\n        self._static_folder = _get_static_folder()\n        self._startup_folder = _get_startup_folder()\n        self._portal = portal\n        self._disclaimer_banner = disclaimer_banner\n        self.putChild('startup-assets', File(self._startup_folder))\n\n    def set_portal(self, portal):\n        self._portal = portal\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if path == 'login':\n            return self\n        if not self.is_logged_in(request):\n            return UnAuthorizedResource()\n        return NoResource()\n\n    def render_GET(self, request):\n        request.setResponseCode(OK)\n        return self._render_template(request)\n\n    def _render_template(self, request, error_msg=None):\n        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)\n        return renderElement(request, site)\n\n    def render_POST(self, request):\n        if self.is_logged_in(request):\n            return util.redirectTo(\"/\", request)\n\n        def render_response(leap_session):\n            request.setResponseCode(OK)\n            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())\n            request.finish()\n            self._setup_user_services(leap_session, request)\n\n        def render_error(error):\n            log.info('Login Error for %s' % request.args['username'][0])\n            log.info('%s' % error)\n            request.setResponseCode(UNAUTHORIZED)\n            return self._render_template(request, 'Invalid credentials')\n\n        d = self._handle_login(request)\n        d.addCallbacks(render_response, render_error)\n\n        return NOT_DONE_YET\n\n    @defer.inlineCallbacks\n    def _handle_login(self, request):\n        self.creds = self._get_creds_from(request)\n        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)\n        defer.returnValue(leap_session)\n\n    def _get_creds_from(self, request):\n        username = request.args['username'][0]\n        password = request.args['password'][0]\n        return credentials.UsernamePassword(username, password)\n\n    @defer.inlineCallbacks\n    def _setup_user_services(self, leap_session, request):\n        user_id = leap_session.user_auth.uuid\n        if not self._services_factory.is_logged_in(user_id):\n            yield self._services_factory.create_services_from(leap_session)\n        self._init_http_session(request, user_id)\n\n    @defer.inlineCallbacks\n    def _initialize_services(self, leap_session):\n        yield self._services_factory.create_services_from(leap_session)\n\n        if leap_session.fresh_account:\n            yield add_welcome_mail(leap_session.mail_store)\n\n    def _init_http_session(self, request, user_id):\n        session = IPixelatedSession(request.getSession())\n        session.user_uuid = user_id\n/n/n/n/service/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.resource import Resource\nfrom twisted.web.static import File\n\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        return Resource.getChild(self, path, request)\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self.putChild('assets', File(self._static_folder))\n        self.putChild('keys', KeysResource(self._services_factory))\n        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self.putChild('contacts', ContactsResource(self._services_factory))\n        self.putChild('features', FeaturesResource(portal))\n        self.putChild('tags', TagsResource(self._services_factory))\n        self.putChild('mails', MailsResource(self._services_factory))\n        self.putChild('mail', MailResource(self._services_factory))\n        self.putChild('feedback', FeedbackResource(self._services_factory))\n        self.putChild('user-settings', UserSettingsResource(self._services_factory))\n        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def render_GET(self, request):\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n/n/n/n/service/test/support/integration/app_test_client.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport json\nimport multiprocessing\nfrom leap.mail.adaptors.soledad import SoledadMailAdaptor\nfrom leap.srp_session import SRPSession\nfrom mockito import mock\nimport os\nimport shutil\nimport time\nimport uuid\nimport random\n\n\nfrom leap.mail.imap.account import IMAPAccount\nfrom leap.soledad.client import Soledad\nfrom mock import Mock\nfrom twisted.internet import reactor, defer\nfrom twisted.internet.defer import succeed\nfrom twisted.web.resource import getChildForRequest\n# from twisted.web.server import Site as PixelatedSite\nfrom zope.interface import implementer\nfrom twisted.cred import checkers, credentials\nfrom pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore\nfrom pixelated.adapter.services.feedback_service import FeedbackService\nfrom pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources\nfrom pixelated.bitmask_libraries.config import LeapConfig\nfrom pixelated.bitmask_libraries.session import LeapSession\nfrom pixelated.config.services import Services\nfrom pixelated.config.site import PixelatedSite\n\nfrom pixelated.adapter.mailstore import LeapMailStore\nfrom pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore\n\nfrom pixelated.adapter.search import SearchEngine\nfrom pixelated.adapter.services.draft_service import DraftService\nfrom pixelated.adapter.services.mail_service import MailService\nfrom pixelated.resources.root_resource import RootResource\nfrom test.support.integration.model import MailBuilder\nfrom test.support.test_helper import request_mock\nfrom test.support.integration.model import ResponseMail\nfrom tempdir import TempDir\n\n\nclass AppTestAccount(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n\n    def __init__(self, user_id, leap_home):\n        self._user_id = user_id\n        self._leap_home = leap_home\n        self._uuid = str(uuid.uuid4())\n        self._mail_address = '%s@pixelated.org' % user_id\n        self._soledad = None\n        self._services = None\n\n    @defer.inlineCallbacks\n    def start(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)\n        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)\n        self.keymanager = mock()\n        self.mail_sender = self._create_mail_sender()\n        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)\n        self.attachment_store = LeapAttachmentStore(self.soledad)\n\n        yield self._initialize_imap_account()\n\n        self.draft_service = DraftService(self.mail_store)\n        self.leap_session = mock()\n        self.feedback_service = FeedbackService(self.leap_session)\n\n        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)\n\n        mails = yield self.mail_service.all_mails()\n        if len(mails) > 0:\n            raise Exception('What? Where did these come from?')\n        self.search_engine.index_mails(mails)\n\n    @property\n    def services(self):\n        if self._services is None:\n            services = mock(Services)\n            services.keymanager = self.keymanager\n            services.mail_service = self.mail_service\n            services.draft_service = self.draft_service\n            services.search_engine = self.search_engine\n            services.feedback_service = self.feedback_service\n            services._leap_session = self.leap_session\n\n            self._services = services\n            self.leap_session.close = lambda: 'mocked'\n\n        return self._services\n\n    def cleanup(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        shutil.rmtree(soledad_test_folder)\n\n    def _initialize_imap_account(self):\n        account_ready_cb = defer.Deferred()\n        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)\n        return account_ready_cb\n\n    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):\n        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n\n@implementer(checkers.ICredentialsChecker)\nclass StubSRPChecker(object):\n    credentialInterfaces = (\n        credentials.IUsernamePassword,\n    )\n\n    def __init__(self, leap_provider, credentials={}):\n        self._leap_provider = leap_provider\n        self._credentials = credentials.copy()\n\n    def add_user(self, username, password):\n        self._credentials[username] = password\n\n    def requestAvatarId(self, credentials):\n        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())\n        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))\n\n\nclass StubServicesFactory(ServicesFactory):\n\n    def __init__(self, accounts, mode):\n        super(StubServicesFactory, self).__init__(mode=mode)\n        self._accounts = accounts\n\n    @defer.inlineCallbacks\n    def create_services_from(self, leap_session):\n        account = self._accounts[leap_session.user_auth.username]\n        self._services_by_user[leap_session.user_auth.uuid] = account.services\n        yield defer.succeed(None)\n\n\nclass AppTestClient(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n    ACCOUNT = 'test'\n    MAIL_ADDRESS = 'test@pixelated.org'\n\n    def _initialize(self):\n        self._tmp_dir = TempDir()\n        self.accounts = {}\n\n    @defer.inlineCallbacks\n    def start_client(self, mode=UserAgentMode(is_single_user=True)):\n        self._initialize()\n        self._mode = mode\n        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)\n\n        yield self._test_account.start()\n\n        self.cleanup = lambda: self._tmp_dir.dissolve()\n\n        # copy fields for single user tests\n        self.soledad = self._test_account.soledad\n        self.search_engine = self._test_account.search_engine\n        self.keymanager = self._test_account.keymanager\n        self.mail_sender = self._test_account.mail_sender\n        self.mail_store = self._test_account.mail_store\n        self.attachment_store = self._test_account.attachment_store\n        self.draft_service = self._test_account.draft_service\n        self.leap_session = self._test_account.leap_session\n        self.feedback_service = self._test_account.feedback_service\n        self.mail_service = self._test_account.mail_service\n        self.account = self._test_account.account\n\n        if mode.is_single_user:\n            self.service_factory = SingleUserServicesFactory(mode)\n            services = self._test_account.services\n            self.service_factory.add_session('someuserid', services)\n\n            self.resource = RootResource(self.service_factory)\n            self.resource.initialize()\n        else:\n            self.service_factory = StubServicesFactory(self.accounts, mode)\n            provider = mock()\n            provider.config = LeapConfig(self._tmp_dir.name)\n\n            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))\n\n    @defer.inlineCallbacks\n    def create_user(self, account_name):\n        if self._mode.is_single_user:\n            raise Exception('Not supported in single user mode')\n\n        account = AppTestAccount(account_name, self._tmp_dir.name)\n        yield account.start()\n\n        self.accounts[account_name] = account\n\n    def _render(self, request, as_json=True):\n        def get_str(_str):\n            return json.loads(_str) if as_json else _str\n\n        def get_request_written_data(_=None):\n            written_data = request.getWrittenData()\n            if written_data:\n                return get_str(written_data)\n\n        resource = getChildForRequest(self.resource, request)\n        result = resource.render(request)\n\n        if isinstance(result, basestring):\n            return get_str(result), request\n\n        # result is NOT_DONE_YET\n        d = succeed(request) if request.finished else request.notifyFinish()\n        d.addCallback(get_request_written_data)\n        return d, request\n\n    def listenTCP(self, port=4567, host='127.0.0.1'):\n        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)\n\n    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):\n        def _start():\n            self.listenTCP(port, host)\n            reactor.run()\n        process = multiprocessing.Process(target=_start)\n        process.start()\n        time.sleep(1)\n        return lambda: process.terminate()\n\n    def get(self, path, get_args='', as_json=True):\n        request = request_mock(path)\n        request.args = get_args\n        return self._render(request, as_json)\n\n    def post(self, path, body='', headers=None):\n        headers = headers or {'Content-Type': 'application/json'}\n        request = request_mock(path=path, method=\"POST\", body=body, headers=headers)\n        return self._render(request)\n\n    def put(self, path, body):\n        request = request_mock(path=path, method=\"PUT\", body=body, headers={'Content-Type': ['application/json']})\n        return self._render(request)\n\n    def delete(self, path, body=\"\"):\n        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=\"DELETE\")\n        return self._render(request)\n\n    @defer.inlineCallbacks\n    def add_mail_to_inbox(self, input_mail):\n        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)\n        defer.returnValue(mail)\n\n    def account_for(self, username):\n        return self.accounts[username]\n\n    def add_mail_to_user_inbox(self, input_mail, username):\n        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)\n\n    @defer.inlineCallbacks\n    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):\n        mails = []\n        yield self.mail_store.add_mailbox(mailbox)\n        for _ in range(num):\n            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)\n            builder.with_body(str(random.random()))\n            input_mail = builder.build_input_mail()\n            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)\n            if tags:\n                mail.tags |= set(tags)\n            if flags:\n                for flag in flags:\n                    mail.flags.add(flag)\n            if tags or flags:\n                yield self.mail_store.update_mail(mail)\n            mails.append(mail)\n\n        defer.returnValue(mails)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):\n        return os.path.join(soledad_test_folder, str(uuid.uuid4()))\n\n    def get_mails_by_tag(self, tag, page=1, window=100):\n        tags = 'tag:%s' % tag\n        return self.search(tags, page, window)\n\n    @defer.inlineCallbacks\n    def search(self, query, page=1, window=100):\n        res, _ = self.get(\"/mails\", {\n            'q': [query],\n            'w': [str(window)],\n            'p': [str(page)]\n        })\n        res = yield res\n        defer.returnValue([ResponseMail(m) for m in res['mails']])\n\n    @defer.inlineCallbacks\n    def get_mails_by_mailbox_name(self, mbox_name):\n        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)\n        mails = yield self.mail_store.get_mails(mail_ids)\n        defer.returnValue(mails)\n\n    @defer.inlineCallbacks\n    def get_attachment(self, ident, encoding, filename=None, content_type=None):\n        params = {'encoding': [encoding]}\n        if filename:\n            params['filename'] = [filename]\n        if content_type:\n            params['content_type'] = [content_type]\n        deferred_result, req = self.get(\"/attachment/%s\" % ident, params, as_json=False)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    @defer.inlineCallbacks\n    def post_attachment(self, data, headers):\n        deferred_result, req = self.post('/attachment', body=data, headers=headers)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    def put_mail(self, data):\n        res, req = self.put('/mails', data)\n        return res, req\n\n    def post_tags(self, mail_ident, tags_json):\n        res, req = self.post(\"/mail/%s/tags\" % mail_ident, tags_json)\n        return res\n\n    def get_tags(self, **kwargs):\n        res, req = self.get('/tags', kwargs)\n        return res\n\n    def get_mail(self, mail_ident):\n        res, req = self.get('/mail/%s' % mail_ident)\n        return res\n\n    def delete_mail(self, mail_ident):\n        res, req = self.delete(\"/mail/%s\" % mail_ident)\n        return res\n\n    def delete_mails(self, idents):\n        res, req = self.post(\"/mails/delete\", json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_unread(self, idents):\n        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_read(self, idents):\n        res, req = self.post('/mails/read', json.dumps({'idents': idents}))\n        return res\n\n    def get_contacts(self, query):\n        res, req = self.get('/contacts', get_args={'q': query})\n        return res\n\n\n@defer.inlineCallbacks\ndef initialize_soledad(tempdir, uuid):\n    if os.path.isdir(tempdir):\n        shutil.rmtree(tempdir)\n\n    passphrase = u\"verysecretpassphrase\"\n    secret_path = os.path.join(tempdir, \"secret.gpg\")\n    local_db_path = os.path.join(tempdir, \"soledad.u1db\")\n    server_url = \"http://provider\"\n    cert_file = \"\"\n\n    class MockSharedDB(object):\n        get_doc = Mock(return_value=None)\n        put_doc = Mock()\n        lock = Mock(return_value=('atoken', 300))\n        unlock = Mock(return_value=True)\n        close = Mock()\n\n        def __call__(self):\n            return self\n\n    Soledad._shared_db = MockSharedDB()\n\n    _soledad = Soledad(\n        uuid,\n        passphrase,\n        secret_path,\n        local_db_path,\n        server_url,\n        cert_file,\n        defer_encryption=False,\n        syncable=False)\n\n    yield SoledadMailAdaptor().initialize_store(_soledad)\n\n    defer.returnValue(_soledad)\n/n/n/n/service/test/support/test_helper.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nfrom datetime import datetime\nimport io\nfrom twisted.web.test.test_web import DummyRequest\n\nfrom pixelated.adapter.model.mail import InputMail\n\n\nLEAP_FLAGS = ['\\\\Seen',\n              '\\\\Answered',\n              '\\\\Flagged',\n              '\\\\Deleted',\n              '\\\\Draft',\n              '\\\\Recent',\n              'List']\n\nDEFAULT_HEADERS = {'date': str(datetime.now())}\n\n\ndef mail_dict():\n    return {\n        'header': {\n            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],\n            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],\n            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],\n            'subject': 'Subject'\n        },\n        'body': 'Body',\n        'ident': '',\n        'tags': []\n    }\n\n\nclass TestDoc(object):\n    def __init__(self, content):\n        self.content = content\n\n    def __getitem__(self, key):\n        return self.content[key]\n\n\ndef leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',\n              chash='chash'):\n    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})\n\n    if headers is None:\n        headers = {}\n    if not (headers.get('received') or headers.get('date')):\n        headers.update(DEFAULT_HEADERS)\n    headers['headers'] = extra_headers\n    hdoc = TestDoc(headers)\n\n    bdoc = TestDoc({'raw': body, 'type': 'cnt'})\n\n    return (fdoc, hdoc, bdoc)\n\n\ndef input_mail():\n    mail = InputMail()\n    mail.fdoc = TestDoc({})\n    mail._chash = \"123\"\n    mail.as_dict = lambda: None\n    return mail\n\n\nclass TestRequest:\n\n    def __init__(self, json):\n        self.json = json\n\n\nclass PixRequestMock(DummyRequest):\n    def __init__(self, path):\n        DummyRequest.__init__(self, path)\n        self.content = None\n        self.code = None\n\n    def getWrittenData(self):\n        if len(self.written):\n            return self.written[0]\n\n    def redirect(self, url):\n        self.setResponseCode(302)\n        self.setHeader(b\"location\", url)\n\n\ndef request_mock(path='', method='GET', body='', headers={}):\n    dummy = PixRequestMock(path.split('/'))\n    for name, val in headers.iteritems():\n        dummy.headers[name.lower()] = val\n    dummy.method = method\n    if isinstance(body, str):\n        dummy.content = io.BytesIO(body)\n    else:\n        for key, val in body.items():\n            dummy.addArg(key, val)\n\n    return dummy\n/n/n/n/service/test/unit/resources/test_root_resource.py/n/nimport unittest\nimport re\nfrom mockito import mock, when, any as ANY\n\nfrom pixelated.application import UserAgentMode\nfrom test.unit.resources import DummySite\nfrom twisted.web.test.requesthelper import DummyRequest\nfrom pixelated.resources.root_resource import RootResource\n\n\nclass TestRootResource(unittest.TestCase):\n    MAIL_ADDRESS = 'test_user@pixelated-project.org'\n\n    def setUp(self):\n        self.mail_service = mock()\n        self.services_factory = mock()\n        self.services_factory.mode = UserAgentMode(is_single_user=True)\n        self.services = mock()\n        self.services.mail_service = self.mail_service\n        self.services_factory._services_by_user = {'someuserid': self.mail_service}\n        when(self.services_factory).services(ANY()).thenReturn(self.services)\n        self.mail_service.account_email = self.MAIL_ADDRESS\n\n        root_resource = RootResource(self.services_factory)\n        root_resource._html_template = \"<html><head><title>$account_email</title></head></html>\"\n        root_resource._mode = root_resource\n        self.web = DummySite(root_resource)\n\n    def test_render_GET_should_template_account_email(self):\n        request = DummyRequest([''])\n\n        d = self.web.get(request)\n\n        def assert_response(_):\n            expected = \"<title>{0}</title>\".format(self.MAIL_ADDRESS)\n            matches = re.findall(expected, request.written[0])\n            self.assertEquals(len(matches), 1)\n\n        d.addCallback(assert_response)\n        return d\n/n/n/n", "label": 1}, {"id": "dbb434b56e6b161a3b851ae6a81f96dff14a29da", "code": "service/test/functional/features/environment.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport logging\nimport uuid\n\nfrom crochet import setup, wait_for\nfrom leap.common.events.server import ensure_server\nfrom twisted.internet import defer\n\nfrom pixelated.application import UserAgentMode\nfrom pixelated.config.site import PixelatedSite\nfrom test.support.dispatcher.proxy import Proxy\nfrom test.support.integration import AppTestClient\nfrom selenium import webdriver\n\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom steps.common import *\nimport os\n\nsetup()\n\n\n@wait_for(timeout=5.0)\ndef start_app_test_client(client, mode):\n    return client.start_client(mode=mode)\n\n\ndef before_all(context):\n    ensure_server()\n    logging.disable('INFO')\n    PixelatedSite.disable_csp_requests()\n    client = AppTestClient()\n    start_app_test_client(client, UserAgentMode(is_single_user=True))\n    client.listenTCP(port=8889)\n    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')\n    context.client = client\n\n    multi_user_client = AppTestClient()\n    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))\n    multi_user_client.listenTCP(port=MULTI_USER_PORT)\n    context.multi_user_client = multi_user_client\n\n\ndef after_all(context):\n    context.client.stop()\n\n\ndef before_feature(context, feature):\n    # context.browser = webdriver.Chrome()\n    # context.browser = webdriver.Firefox()\n    context.browser = webdriver.PhantomJS()\n    context.browser.set_window_size(1280, 1024)\n    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)\n    context.browser.set_page_load_timeout(60)  # wait for data\n    context.browser.get(HOMEPAGE_URL)\n\n\ndef after_step(context, step):\n    if step.status == 'failed':\n        id = str(uuid.uuid4())\n        os.chdir(\"screenshots\")\n        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + \".png\")\n        save_source(context, 'failed ' + str(step.name) + '_' + id + \".html\")\n        os.chdir(\"../\")\n\n\ndef after_feature(context, feature):\n    context.browser.quit()\n\n    cleanup_all_mails(context)\n    context.last_mail = None\n\n\n@wait_for(timeout=10.0)\ndef cleanup_all_mails(context):\n    @defer.inlineCallbacks\n    def _delete_all_mails():\n        mails = yield context.client.mail_store.all_mails()\n        for mail in mails:\n            yield context.client.mail_store.delete_mail(mail.ident)\n\n    return _delete_all_mails()\n\n\ndef save_source(context, filename='/tmp/source.html'):\n    with open(filename, 'w') as out:\n        out.write(context.browser.page_source.encode('utf8'))\n/n/n/nservice/test/support/integration/app_test_client.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport json\nimport multiprocessing\nfrom leap.mail.adaptors.soledad import SoledadMailAdaptor\nfrom leap.srp_session import SRPSession\nfrom mockito import mock\nimport os\nimport shutil\nimport time\nimport uuid\nimport random\n\n\nfrom leap.mail.imap.account import IMAPAccount\nfrom leap.soledad.client import Soledad\nfrom mock import Mock\nfrom twisted.internet import reactor, defer\nfrom twisted.internet.defer import succeed\nfrom twisted.web.resource import getChildForRequest\n# from twisted.web.server import Site as PixelatedSite\nfrom zope.interface import implementer\nfrom twisted.cred import checkers, credentials\nfrom pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore\nfrom pixelated.adapter.services.feedback_service import FeedbackService\nfrom pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources\nfrom pixelated.bitmask_libraries.config import LeapConfig\nfrom pixelated.bitmask_libraries.session import LeapSession\nfrom pixelated.config.services import Services\nfrom pixelated.config.site import PixelatedSite\n\nfrom pixelated.adapter.mailstore import LeapMailStore\nfrom pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore\n\nfrom pixelated.adapter.search import SearchEngine\nfrom pixelated.adapter.services.draft_service import DraftService\nfrom pixelated.adapter.services.mail_service import MailService\nfrom pixelated.resources.root_resource import RootResource\nfrom test.support.integration.model import MailBuilder\nfrom test.support.test_helper import request_mock\nfrom test.support.integration.model import ResponseMail\nfrom tempdir import TempDir\n\n\nclass AppTestAccount(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n\n    def __init__(self, user_id, leap_home):\n        self._user_id = user_id\n        self._leap_home = leap_home\n        self._uuid = str(uuid.uuid4())\n        self._mail_address = '%s@pixelated.org' % user_id\n        self._soledad = None\n        self._services = None\n\n    @defer.inlineCallbacks\n    def start(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)\n        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)\n        self.keymanager = mock()\n        self.mail_sender = self._create_mail_sender()\n        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)\n        self.attachment_store = LeapAttachmentStore(self.soledad)\n\n        yield self._initialize_imap_account()\n\n        self.draft_service = DraftService(self.mail_store)\n        self.leap_session = mock()\n        self.feedback_service = FeedbackService(self.leap_session)\n\n        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)\n\n        mails = yield self.mail_service.all_mails()\n        if len(mails) > 0:\n            raise Exception('What? Where did these come from?')\n        self.search_engine.index_mails(mails)\n\n    @property\n    def services(self):\n        if self._services is None:\n            services = mock(Services)\n            services.keymanager = self.keymanager\n            services.mail_service = self.mail_service\n            services.draft_service = self.draft_service\n            services.search_engine = self.search_engine\n            services.feedback_service = self.feedback_service\n            services._leap_session = self.leap_session\n\n            self._services = services\n            self.leap_session.close = lambda: 'mocked'\n\n        return self._services\n\n    def cleanup(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        shutil.rmtree(soledad_test_folder)\n\n    def _initialize_imap_account(self):\n        account_ready_cb = defer.Deferred()\n        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)\n        return account_ready_cb\n\n    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):\n        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n\n@implementer(checkers.ICredentialsChecker)\nclass StubSRPChecker(object):\n    credentialInterfaces = (\n        credentials.IUsernamePassword,\n    )\n\n    def __init__(self, leap_provider, credentials={}):\n        self._leap_provider = leap_provider\n        self._credentials = credentials.copy()\n\n    def add_user(self, username, password):\n        self._credentials[username] = password\n\n    def requestAvatarId(self, credentials):\n        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())\n        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))\n\n\nclass StubServicesFactory(ServicesFactory):\n\n    def __init__(self, accounts, mode):\n        super(StubServicesFactory, self).__init__(mode=mode)\n        self._accounts = accounts\n\n    @defer.inlineCallbacks\n    def create_services_from(self, leap_session):\n        account = self._accounts[leap_session.user_auth.username]\n        self._services_by_user[leap_session.user_auth.uuid] = account.services\n        yield defer.succeed(None)\n\n\nclass AppTestClient(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n    ACCOUNT = 'test'\n    MAIL_ADDRESS = 'test@pixelated.org'\n\n    def _initialize(self):\n        self._tmp_dir = TempDir()\n        self.accounts = {}\n\n    @defer.inlineCallbacks\n    def start_client(self, mode=UserAgentMode(is_single_user=True)):\n        self._initialize()\n        self._mode = mode\n        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)\n\n        yield self._test_account.start()\n\n        self.cleanup = lambda: self._tmp_dir.dissolve()\n\n        # copy fields for single user tests\n        self.soledad = self._test_account.soledad\n        self.search_engine = self._test_account.search_engine\n        self.keymanager = self._test_account.keymanager\n        self.mail_sender = self._test_account.mail_sender\n        self.mail_store = self._test_account.mail_store\n        self.attachment_store = self._test_account.attachment_store\n        self.draft_service = self._test_account.draft_service\n        self.leap_session = self._test_account.leap_session\n        self.feedback_service = self._test_account.feedback_service\n        self.mail_service = self._test_account.mail_service\n        self.account = self._test_account.account\n\n        if mode.is_single_user:\n            self.service_factory = SingleUserServicesFactory(mode)\n            services = self._test_account.services\n            self.service_factory.add_session('someuserid', services)\n\n            self.resource = RootResource(self.service_factory)\n            self.resource.initialize()\n        else:\n            self.service_factory = StubServicesFactory(self.accounts, mode)\n            provider = mock()\n            provider.config = LeapConfig(self._tmp_dir.name)\n\n            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))\n\n    @defer.inlineCallbacks\n    def create_user(self, account_name):\n        if self._mode.is_single_user:\n            raise Exception('Not supported in single user mode')\n\n        account = AppTestAccount(account_name, self._tmp_dir.name)\n        yield account.start()\n\n        self.accounts[account_name] = account\n\n    def _render(self, request, as_json=True):\n        def get_str(_str):\n            return json.loads(_str) if as_json else _str\n\n        def get_request_written_data(_=None):\n            written_data = request.getWrittenData()\n            if written_data:\n                return get_str(written_data)\n\n        resource = getChildForRequest(self.resource, request)\n        result = resource.render(request)\n\n        if isinstance(result, basestring):\n            return get_str(result), request\n\n        # result is NOT_DONE_YET\n        d = succeed(request) if request.finished else request.notifyFinish()\n        d.addCallback(get_request_written_data)\n        return d, request\n\n    def listenTCP(self, port=4567, host='127.0.0.1'):\n        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)\n\n    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):\n        def _start():\n            self.listenTCP(port, host)\n            reactor.run()\n        process = multiprocessing.Process(target=_start)\n        process.start()\n        time.sleep(1)\n        return lambda: process.terminate()\n\n    def stop(self):\n        reactor.stop()\n\n    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):\n        request = request_mock(path, ajax=ajax, csrf=csrf)\n        request.args = get_args\n        return self._render(request, as_json)\n\n    def post(self, path, body='', headers=None, ajax=True, csrf='token'):\n        headers = headers or {'Content-Type': 'application/json'}\n        request = request_mock(path=path, method=\"POST\", body=body, headers=headers, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def put(self, path, body, ajax=True, csrf='token'):\n        request = request_mock(path=path, method=\"PUT\", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def delete(self, path, body=\"\", ajax=True, csrf='token'):\n        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=\"DELETE\", ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    @defer.inlineCallbacks\n    def add_mail_to_inbox(self, input_mail):\n        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)\n        defer.returnValue(mail)\n\n    def account_for(self, username):\n        return self.accounts[username]\n\n    def add_mail_to_user_inbox(self, input_mail, username):\n        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)\n\n    @defer.inlineCallbacks\n    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):\n        mails = []\n        yield self.mail_store.add_mailbox(mailbox)\n        for _ in range(num):\n            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)\n            builder.with_body(str(random.random()))\n            input_mail = builder.build_input_mail()\n            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)\n            if tags:\n                mail.tags |= set(tags)\n            if flags:\n                for flag in flags:\n                    mail.flags.add(flag)\n            if tags or flags:\n                yield self.mail_store.update_mail(mail)\n            mails.append(mail)\n\n        defer.returnValue(mails)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):\n        return os.path.join(soledad_test_folder, str(uuid.uuid4()))\n\n    def get_mails_by_tag(self, tag, page=1, window=100):\n        tags = 'tag:%s' % tag\n        return self.search(tags, page, window)\n\n    @defer.inlineCallbacks\n    def search(self, query, page=1, window=100):\n        res, _ = self.get(\"/mails\", {\n            'q': [query],\n            'w': [str(window)],\n            'p': [str(page)]\n        })\n        res = yield res\n        defer.returnValue([ResponseMail(m) for m in res['mails']])\n\n    @defer.inlineCallbacks\n    def get_mails_by_mailbox_name(self, mbox_name):\n        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)\n        mails = yield self.mail_store.get_mails(mail_ids)\n        defer.returnValue(mails)\n\n    @defer.inlineCallbacks\n    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):\n        params = {'encoding': [encoding]}\n        if filename:\n            params['filename'] = [filename]\n        if content_type:\n            params['content_type'] = [content_type]\n        deferred_result, req = self.get(\"/attachment/%s\" % ident, params, as_json=False, ajax=ajax, csrf=csrf)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    @defer.inlineCallbacks\n    def post_attachment(self, data, headers):\n        deferred_result, req = self.post('/attachment', body=data, headers=headers)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    def put_mail(self, data):\n        res, req = self.put('/mails', data)\n        return res, req\n\n    def post_tags(self, mail_ident, tags_json):\n        res, req = self.post(\"/mail/%s/tags\" % mail_ident, tags_json)\n        return res\n\n    def get_tags(self, **kwargs):\n        res, req = self.get('/tags', kwargs)\n        return res\n\n    def get_mail(self, mail_ident):\n        res, req = self.get('/mail/%s' % mail_ident)\n        return res\n\n    def delete_mail(self, mail_ident):\n        res, req = self.delete(\"/mail/%s\" % mail_ident)\n        return res\n\n    def delete_mails(self, idents):\n        res, req = self.post(\"/mails/delete\", json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_unread(self, idents):\n        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_read(self, idents):\n        res, req = self.post('/mails/read', json.dumps({'idents': idents}))\n        return res\n\n    def get_contacts(self, query):\n        res, req = self.get('/contacts', get_args={'q': query})\n        return res\n\n\n@defer.inlineCallbacks\ndef initialize_soledad(tempdir, uuid):\n    if os.path.isdir(tempdir):\n        shutil.rmtree(tempdir)\n\n    passphrase = u\"verysecretpassphrase\"\n    secret_path = os.path.join(tempdir, \"secret.gpg\")\n    local_db_path = os.path.join(tempdir, \"soledad.u1db\")\n    server_url = \"http://provider\"\n    cert_file = \"\"\n\n    class MockSharedDB(object):\n        get_doc = Mock(return_value=None)\n        put_doc = Mock()\n        lock = Mock(return_value=('atoken', 300))\n        unlock = Mock(return_value=True)\n        close = Mock()\n\n        def __call__(self):\n            return self\n\n    Soledad._shared_db = MockSharedDB()\n\n    _soledad = Soledad(\n        uuid,\n        passphrase,\n        secret_path,\n        local_db_path,\n        server_url,\n        cert_file,\n        defer_encryption=False,\n        syncable=False)\n\n    yield SoledadMailAdaptor().initialize_store(_soledad)\n\n    defer.returnValue(_soledad)\n/n/n/n", "label": 0}, {"id": "dbb434b56e6b161a3b851ae6a81f96dff14a29da", "code": "/service/test/functional/features/environment.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport logging\nimport uuid\n\nfrom crochet import setup, wait_for\nfrom leap.common.events.server import ensure_server\nfrom twisted.internet import defer\n\nfrom pixelated.application import UserAgentMode\nfrom pixelated.config.site import PixelatedSite\nfrom test.support.dispatcher.proxy import Proxy\nfrom test.support.integration import AppTestClient\nfrom selenium import webdriver\n\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom steps.common import *\nimport os\n\nsetup()\n\n\n@wait_for(timeout=5.0)\ndef start_app_test_client(client, mode):\n    return client.start_client(mode=mode)\n\n\ndef before_all(context):\n    ensure_server()\n    logging.disable('INFO')\n    PixelatedSite.disable_csp_requests()\n    client = AppTestClient()\n    start_app_test_client(client, UserAgentMode(is_single_user=True))\n    client.listenTCP()\n    proxy = Proxy(proxy_port='8889', app_port='4567')\n    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')\n    context.client = client\n    context.call_to_terminate_proxy = proxy.run_on_a_thread()\n\n    multi_user_client = AppTestClient()\n    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))\n    multi_user_client.listenTCP(port=MULTI_USER_PORT)\n    context.multi_user_client = multi_user_client\n\n\ndef after_all(context):\n    context.call_to_terminate_proxy()\n\n\ndef before_feature(context, feature):\n    # context.browser = webdriver.Chrome()\n    # context.browser = webdriver.Firefox()\n    context.browser = webdriver.PhantomJS()\n    context.browser.set_window_size(1280, 1024)\n    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)\n    context.browser.set_page_load_timeout(60)  # wait for data\n    context.browser.get(HOMEPAGE_URL)\n\n\ndef after_step(context, step):\n    if step.status == 'failed':\n        id = str(uuid.uuid4())\n        os.chdir(\"screenshots\")\n        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + \".png\")\n        save_source(context, 'failed ' + str(step.name) + '_' + id + \".html\")\n        os.chdir(\"../\")\n\n\ndef after_feature(context, feature):\n    context.browser.quit()\n\n    cleanup_all_mails(context)\n    context.last_mail = None\n\n\n@wait_for(timeout=10.0)\ndef cleanup_all_mails(context):\n    @defer.inlineCallbacks\n    def _delete_all_mails():\n        mails = yield context.client.mail_store.all_mails()\n        for mail in mails:\n            yield context.client.mail_store.delete_mail(mail.ident)\n\n    return _delete_all_mails()\n\n\ndef save_source(context, filename='/tmp/source.html'):\n    with open(filename, 'w') as out:\n        out.write(context.browser.page_source.encode('utf8'))\n/n/n/n", "label": 1}, {"id": "85094ff8caac585cbff260fe89a6f21df241fd47", "code": "service/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport hashlib\nimport json\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.sandbox_resource import SandboxResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.static import File\n\nfrom pixelated.resources.users import UsersResource\n\nCSRF_TOKEN_LENGTH = 32\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self._child_resources = ChildResourcesMap()\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if self._is_xsrf_valid(request):\n            if self._mode == MODE_RUNNING:\n                return self._child_resources.get(path)\n            else:\n                return UnavailableResource()\n        return UnAuthorizedResource()\n\n    def _is_xsrf_valid(self, request):\n        xsrf_token = request.getCookie('XSRF-TOKEN')\n\n        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')\n        if ajax_request:\n            xsrf_header = xsrf_token or request.getHeader('x-xsrf-token')\n            return xsrf_header and xsrf_header == xsrf_token\n\n        get_request = (request.method == 'GET')\n        if get_request:\n            return True\n\n        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]\n        return csrf_input and csrf_input == xsrf_token\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self._child_resources.add('sandbox', SandboxResource(self._static_folder))\n        self._child_resources.add('assets', File(self._static_folder))\n        self._child_resources.add('keys', KeysResource(self._services_factory))\n        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self._child_resources.add('contacts', ContactsResource(self._services_factory))\n        self._child_resources.add('features', FeaturesResource(portal))\n        self._child_resources.add('tags', TagsResource(self._services_factory))\n        self._child_resources.add('mails', MailsResource(self._services_factory))\n        self._child_resources.add('mail', MailResource(self._services_factory))\n        self._child_resources.add('feedback', FeedbackResource(self._services_factory))\n        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))\n        self._child_resources.add('users', UsersResource(self._services_factory))\n        self._child_resources.add(LoginResource.BASE_URL,\n                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def _add_csrf_cookie(self, request):\n        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()\n        request.addCookie('XSRF-TOKEN', csrf_token)\n\n    def render_GET(self, request):\n        self._add_csrf_cookie(request)\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n\n\nclass ChildResourcesMap(object):\n    def __init__(self):\n        self._registry = {}\n\n    def add(self, path, resource):\n        self._registry[path] = resource\n\n    def get(self, path):\n        return self._registry.get(path)\n/n/n/n", "label": 0}, {"id": "85094ff8caac585cbff260fe89a6f21df241fd47", "code": "/service/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport hashlib\nimport json\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.sandbox_resource import SandboxResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.static import File\n\nfrom pixelated.resources.users import UsersResource\n\nCSRF_TOKEN_LENGTH = 32\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self._child_resources = ChildResourcesMap()\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if self._is_xsrf_valid(request):\n            if self._mode == MODE_RUNNING:\n                return self._child_resources.get(path)\n            else:\n                return UnavailableResource()\n        return UnAuthorizedResource()\n\n    def _is_xsrf_valid(self, request):\n        xsrf_token = request.getCookie('XSRF-TOKEN')\n\n        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')\n        if ajax_request:\n            xsrf_header = request.getHeader('x-xsrf-token')\n            return xsrf_header and xsrf_header == xsrf_token\n\n        get_request = (request.method == 'GET')\n        if get_request:\n            return True\n\n        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]\n        return csrf_input and csrf_input == xsrf_token\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self._child_resources.add('sandbox', SandboxResource(self._static_folder))\n        self._child_resources.add('assets', File(self._static_folder))\n        self._child_resources.add('keys', KeysResource(self._services_factory))\n        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self._child_resources.add('contacts', ContactsResource(self._services_factory))\n        self._child_resources.add('features', FeaturesResource(portal))\n        self._child_resources.add('tags', TagsResource(self._services_factory))\n        self._child_resources.add('mails', MailsResource(self._services_factory))\n        self._child_resources.add('mail', MailResource(self._services_factory))\n        self._child_resources.add('feedback', FeedbackResource(self._services_factory))\n        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))\n        self._child_resources.add('users', UsersResource(self._services_factory))\n        self._child_resources.add(LoginResource.BASE_URL,\n                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def _add_csrf_cookie(self, request):\n        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()\n        request.addCookie('XSRF-TOKEN', csrf_token)\n\n    def render_GET(self, request):\n        self._add_csrf_cookie(request)\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n\n\nclass ChildResourcesMap(object):\n    def __init__(self):\n        self._registry = {}\n\n    def add(self, path, resource):\n        self._registry[path] = resource\n\n    def get(self, path):\n        return self._registry.get(path)\n/n/n/n", "label": 1}, {"id": "9573bdca55ddc5488066d3af525e41ed1d872ea6", "code": "service/pixelated/resources/__init__.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport json\n\nfrom twisted.web.http import UNAUTHORIZED\nfrom twisted.web.resource import Resource\n\n# from pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.session import IPixelatedSession\nfrom pixelated.support import log_time\n\n\nclass SetEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, set):\n            return list(obj)\n        return super(SetEncoder, self).default(obj)\n\n\ndef respond_json(entity, request, status_code=200):\n    json_response = json.dumps(entity, cls=SetEncoder)\n    request.responseHeaders.addRawHeader(b\"content-type\", b\"application/json\")\n    request.code = status_code\n    return json_response\n\n\n@log_time\ndef respond_json_deferred(entity, request, status_code=200):\n    json_response = json.dumps(entity, cls=SetEncoder)\n    request.responseHeaders.addRawHeader(b\"content-type\", b\"application/json\")\n    request.code = status_code\n    request.write(json_response)\n    request.finish()\n\n\nclass BaseResource(Resource):\n\n    def __init__(self, services_factory):\n        Resource.__init__(self)\n        self._services_factory = services_factory\n\n    def _get_user_id_from_request(self, request):\n        if self._services_factory.mode.is_single_user:\n            return None  # it doesn't matter\n        session = self.get_session(request)\n        if session.is_logged_in():\n            return session.user_uuid\n        raise ValueError('Not logged in')\n\n    def is_logged_in(self, request):\n        session = self.get_session(request)\n        return session.is_logged_in() and self._services_factory.is_logged_in(session.user_uuid)\n\n    def get_session(self, request):\n        return IPixelatedSession(request.getSession())\n\n    def _services(self, request):\n        user_id = self._get_user_id_from_request(request)\n        return self._services_factory.services(user_id)\n\n    def _service(self, request, attribute):\n        return getattr(self._services(request), attribute)\n\n    def keymanager(self, request):\n        return self._service(request, 'keymanager')\n\n    def mail_service(self, request):\n        return self._service(request, 'mail_service')\n\n    def search_engine(self, request):\n        return self._service(request, 'search_engine')\n\n    def draft_service(self, request):\n        return self._service(request, 'draft_service')\n\n    def feedback_service(self, request):\n        return self._service(request, 'feedback_service')\n\n\nclass UnAuthorizedResource(Resource):\n\n    def __init__(self):\n        Resource.__init__(self)\n\n    def render_GET(self, request):\n        request.setResponseCode(UNAUTHORIZED)\n        return \"Unauthorized!\"\n\n    def render_POST(self, request):\n        request.setResponseCode(UNAUTHORIZED)\n        return \"Unauthorized!\"\n/n/n/nservice/pixelated/resources/login_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nimport os\nfrom xml.sax import SAXParseException\n\nfrom twisted.cred import credentials\nfrom twisted.internet import defer\nfrom twisted.python.filepath import FilePath\nfrom twisted.web import util\nfrom twisted.web.http import UNAUTHORIZED, OK\nfrom twisted.web.resource import IResource, NoResource\nfrom twisted.web.server import NOT_DONE_YET\nfrom twisted.web.static import File\nfrom twisted.web.template import Element, XMLFile, renderElement, renderer\n\nfrom pixelated.adapter.welcome_mail import add_welcome_mail\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession\n\nlog = logging.getLogger(__name__)\n\n\ndef _get_startup_folder():\n    path = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(path, '..', 'assets')\n\n\ndef _get_static_folder():\n    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    # this is a workaround for packaging\n    if not os.path.exists(static_folder):\n        static_folder = os.path.abspath(\n            os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    if not os.path.exists(static_folder):\n        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n    return static_folder\n\n\nclass DisclaimerElement(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))\n\n    def __init__(self, banner):\n        super(DisclaimerElement, self).__init__()\n        self._set_loader(banner)\n        self._banner_filename = banner or \"_login_disclaimer_banner.html\"\n\n    def _set_loader(self, banner):\n        if banner:\n            current_path = os.path.dirname(os.path.abspath(__file__))\n            banner_file_path = os.path.join(current_path, \"..\", \"..\", \"..\", banner)\n            self.loader = XMLFile(FilePath(banner_file_path))\n\n    def render(self, request):\n        try:\n            return super(DisclaimerElement, self).render(request)\n        except SAXParseException:\n            return [\"Invalid XML template format for %s.\" % self._banner_filename]\n        except IOError:\n            return [\"Disclaimer banner file %s could not be read or does not exit.\" % self._banner_filename]\n\n\nclass LoginWebSite(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))\n\n    def __init__(self, error_msg=None, disclaimer_banner_file=None):\n        super(LoginWebSite, self).__init__()\n        self._error_msg = error_msg\n        self.disclaimer_banner_file = disclaimer_banner_file\n\n    @renderer\n    def error_msg(self, request, tag):\n        if self._error_msg is not None:\n            return tag(self._error_msg)\n        return tag('')\n\n    @renderer\n    def disclaimer(self, request, tag):\n        return DisclaimerElement(self.disclaimer_banner_file).render(request)\n\n\nclass LoginResource(BaseResource):\n    BASE_URL = 'login'\n\n    def __init__(self, services_factory, portal=None, disclaimer_banner=None):\n        BaseResource.__init__(self, services_factory)\n        self._static_folder = _get_static_folder()\n        self._startup_folder = _get_startup_folder()\n        self._portal = portal\n        self._disclaimer_banner = disclaimer_banner\n        self.putChild('startup-assets', File(self._startup_folder))\n\n    def set_portal(self, portal):\n        self._portal = portal\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if path == 'login':\n            return self\n        if not self.is_logged_in(request):\n            return UnAuthorizedResource()\n        return NoResource()\n\n    def render_GET(self, request):\n        request.setResponseCode(OK)\n        return self._render_template(request)\n\n    def _render_template(self, request, error_msg=None):\n        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)\n        return renderElement(request, site)\n\n    def render_POST(self, request):\n        if self.is_logged_in(request):\n            return util.redirectTo(\"/\", request)\n\n        def render_response(leap_session):\n            request.setResponseCode(OK)\n            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())\n            request.finish()\n            self._setup_user_services(leap_session, request)\n\n        def render_error(error):\n            log.info('Login Error for %s' % request.args['username'][0])\n            log.info('%s' % error)\n            request.setResponseCode(UNAUTHORIZED)\n            return self._render_template(request, 'Invalid credentials')\n\n        d = self._handle_login(request)\n        d.addCallbacks(render_response, render_error)\n\n        return NOT_DONE_YET\n\n    @defer.inlineCallbacks\n    def _handle_login(self, request):\n        self.creds = self._get_creds_from(request)\n        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)\n        defer.returnValue(leap_session)\n\n    def _get_creds_from(self, request):\n        username = request.args['username'][0]\n        password = request.args['password'][0]\n        return credentials.UsernamePassword(username, password)\n\n    @defer.inlineCallbacks\n    def _setup_user_services(self, leap_session, request):\n        user_id = leap_session.user_auth.uuid\n        if not self._services_factory.is_logged_in(user_id):\n            yield self._services_factory.create_services_from(leap_session)\n        self._init_http_session(request, user_id)\n\n    @defer.inlineCallbacks\n    def _initialize_services(self, leap_session):\n        yield self._services_factory.create_services_from(leap_session)\n\n        if leap_session.fresh_account:\n            yield add_welcome_mail(leap_session.mail_store)\n\n    def _init_http_session(self, request, user_id):\n        session = IPixelatedSession(request.getSession())\n        session.user_uuid = user_id\n/n/n/nservice/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport hashlib\nimport json\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource, UnAuthorizedResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.static import File\n\nCSRF_TOKEN_LENGTH = 32\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self.child_resources = ChildResourcesMap()\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if self._is_xsrf_valid(request):\n            return self.child_resources.get(path)\n        return UnAuthorizedResource()\n\n    def _is_xsrf_valid(self, request):\n        xsrf_token = request.getCookie('XSRF-TOKEN')\n\n        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')\n        if ajax_request:\n            xsrf_header = request.getHeader('x-xsrf-token')\n            return xsrf_header and xsrf_header == xsrf_token\n\n        get_request = (request.method == 'GET')\n        if get_request:\n            return True\n\n        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]\n        return csrf_input and csrf_input == xsrf_token\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self.child_resources.add('assets', File(self._static_folder))\n        self.child_resources.add('keys', KeysResource(self._services_factory))\n        self.child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self.child_resources.add('contacts', ContactsResource(self._services_factory))\n        self.child_resources.add('features', FeaturesResource(portal))\n        self.child_resources.add('tags', TagsResource(self._services_factory))\n        self.child_resources.add('mails', MailsResource(self._services_factory))\n        self.child_resources.add('mail', MailResource(self._services_factory))\n        self.child_resources.add('feedback', FeedbackResource(self._services_factory))\n        self.child_resources.add('user-settings', UserSettingsResource(self._services_factory))\n        self.child_resources.add(LoginResource.BASE_URL,\n                                 LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self.child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def _add_csrf_cookie(self, request):\n        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()\n        request.addCookie('XSRF-TOKEN', csrf_token)\n\n    def render_GET(self, request):\n        self._add_csrf_cookie(request)\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n\n\nclass ChildResourcesMap(object):\n    def __init__(self):\n        self._registry = {}\n\n    def add(self, path, resource):\n        self._registry[path] = resource\n\n    def get(self, path):\n        return self._registry.get(path)\n/n/n/nservice/test/integration/test_retrieve_attachment.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport base64\nimport json\nfrom email import encoders\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nfrom poster.encode import multipart_encode, MultipartParam\nfrom twisted.internet import defer\n\nfrom test.support.integration.soledad_test_base import SoledadTestBase\n\n\nclass RetrieveAttachmentTest(SoledadTestBase):\n    @defer.inlineCallbacks\n    def test_attachment_content_is_retrieved(self):\n        attachment_id, input_mail = self._create_mail_with_attachment()\n        yield self.mail_store.add_mail('INBOX', input_mail.as_string())\n\n        requested_filename = \"file name with space\"\n        expected_content_type = 'text/plain'\n        expected_content_disposition = 'attachment; filename=\"file name with space\"'\n\n        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename, content_type=expected_content_type)\n\n        self.assertEqual(200, req.code)\n        self.assertEquals('pretend to be binary attachment data', attachment)\n        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])\n        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])\n\n    @defer.inlineCallbacks\n    def test_should_retrieve_attachment_even_if_xsrf_token_not_passed(self):\n        attachment_id, input_mail = self._create_mail_with_attachment()\n        yield self.mail_store.add_mail('INBOX', input_mail.as_string())\n\n        requested_filename = \"file name with space\"\n        expected_content_type = 'text/plain'\n        expected_content_disposition = 'attachment; filename=\"file name with space\"'\n\n        attachment, req = yield self.get_attachment(attachment_id, 'base64', filename=requested_filename,\n                                                    content_type=expected_content_type, ajax=False, csrf='mismatched token')\n\n        self.assertEqual(200, req.code)\n        self.assertEquals('pretend to be binary attachment data', attachment)\n        self.assertEquals(expected_content_disposition, req.outgoingHeaders['content-disposition'])\n        self.assertEquals(expected_content_type, req.outgoingHeaders['content-type'])\n\n    def _create_mail_with_attachment(self):\n        input_mail = MIMEMultipart()\n        input_mail.attach(MIMEText(u'a utf8 message', _charset='utf-8'))\n        attachment = MIMEApplication('pretend to be binary attachment data')\n        attachment.add_header('Content-Disposition', 'attachment', filename='file name.txt')\n        attachment.add_header('Content-Type', 'text/plain')\n        input_mail.attach(attachment)\n        attachment_id = 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A'\n        return attachment_id, input_mail\n\n    @defer.inlineCallbacks\n    def test_attachment_error_returned_if_id_not_found(self):\n        attachment, req = yield self.get_attachment('invalid attachment id', 'base64')\n\n        self.assertEqual(404, req.code)\n        self.assertIsNone(attachment)\n\n    @defer.inlineCallbacks\n    def test_post_new_attachment(self):\n        content_type = 'text/plain'\n        filename = 'filename.txt'\n        data = 'pretend to be binary attachment data'\n        file = MultipartParam('attachment', value=data, filename=filename, filetype=content_type)\n        datagen, headers = multipart_encode([file])\n        post_data = \"\".join(datagen)\n\n        _, req = yield self.post_attachment(post_data, headers)\n\n        self.assertEqual(201, req.code)\n        self.assertEqual('/attachment/B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A', req.headers['Location'])\n        response_json = {'ident': 'B5B4ED80AC3B894523D72E375DACAA2FC6606C18EDF680FE95903086C8B5E14A',\n                         'content-type': content_type,\n                         'name': filename,\n                         'size': len(data),\n                         'encoding': 'base64'}\n        self.assertEqual(response_json, json.loads(req.written[0]))\n/n/n/nservice/test/support/integration/app_test_client.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport json\nimport multiprocessing\nfrom leap.mail.adaptors.soledad import SoledadMailAdaptor\nfrom leap.srp_session import SRPSession\nfrom mockito import mock\nimport os\nimport shutil\nimport time\nimport uuid\nimport random\n\n\nfrom leap.mail.imap.account import IMAPAccount\nfrom leap.soledad.client import Soledad\nfrom mock import Mock\nfrom twisted.internet import reactor, defer\nfrom twisted.internet.defer import succeed\nfrom twisted.web.resource import getChildForRequest\n# from twisted.web.server import Site as PixelatedSite\nfrom zope.interface import implementer\nfrom twisted.cred import checkers, credentials\nfrom pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore\nfrom pixelated.adapter.services.feedback_service import FeedbackService\nfrom pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources\nfrom pixelated.bitmask_libraries.config import LeapConfig\nfrom pixelated.bitmask_libraries.session import LeapSession\nfrom pixelated.config.services import Services\nfrom pixelated.config.site import PixelatedSite\n\nfrom pixelated.adapter.mailstore import LeapMailStore\nfrom pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore\n\nfrom pixelated.adapter.search import SearchEngine\nfrom pixelated.adapter.services.draft_service import DraftService\nfrom pixelated.adapter.services.mail_service import MailService\nfrom pixelated.resources.root_resource import RootResource\nfrom test.support.integration.model import MailBuilder\nfrom test.support.test_helper import request_mock\nfrom test.support.integration.model import ResponseMail\nfrom tempdir import TempDir\n\n\nclass AppTestAccount(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n\n    def __init__(self, user_id, leap_home):\n        self._user_id = user_id\n        self._leap_home = leap_home\n        self._uuid = str(uuid.uuid4())\n        self._mail_address = '%s@pixelated.org' % user_id\n        self._soledad = None\n        self._services = None\n\n    @defer.inlineCallbacks\n    def start(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)\n        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)\n        self.keymanager = mock()\n        self.mail_sender = self._create_mail_sender()\n        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)\n        self.attachment_store = LeapAttachmentStore(self.soledad)\n\n        yield self._initialize_imap_account()\n\n        self.draft_service = DraftService(self.mail_store)\n        self.leap_session = mock()\n        self.feedback_service = FeedbackService(self.leap_session)\n\n        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)\n\n        mails = yield self.mail_service.all_mails()\n        if len(mails) > 0:\n            raise Exception('What? Where did these come from?')\n        self.search_engine.index_mails(mails)\n\n    @property\n    def services(self):\n        if self._services is None:\n            services = mock(Services)\n            services.keymanager = self.keymanager\n            services.mail_service = self.mail_service\n            services.draft_service = self.draft_service\n            services.search_engine = self.search_engine\n            services.feedback_service = self.feedback_service\n            services._leap_session = self.leap_session\n\n            self._services = services\n            self.leap_session.close = lambda: 'mocked'\n\n        return self._services\n\n    def cleanup(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        shutil.rmtree(soledad_test_folder)\n\n    def _initialize_imap_account(self):\n        account_ready_cb = defer.Deferred()\n        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)\n        return account_ready_cb\n\n    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):\n        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n\n@implementer(checkers.ICredentialsChecker)\nclass StubSRPChecker(object):\n    credentialInterfaces = (\n        credentials.IUsernamePassword,\n    )\n\n    def __init__(self, leap_provider, credentials={}):\n        self._leap_provider = leap_provider\n        self._credentials = credentials.copy()\n\n    def add_user(self, username, password):\n        self._credentials[username] = password\n\n    def requestAvatarId(self, credentials):\n        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())\n        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))\n\n\nclass StubServicesFactory(ServicesFactory):\n\n    def __init__(self, accounts, mode):\n        super(StubServicesFactory, self).__init__(mode=mode)\n        self._accounts = accounts\n\n    @defer.inlineCallbacks\n    def create_services_from(self, leap_session):\n        account = self._accounts[leap_session.user_auth.username]\n        self._services_by_user[leap_session.user_auth.uuid] = account.services\n        yield defer.succeed(None)\n\n\nclass AppTestClient(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n    ACCOUNT = 'test'\n    MAIL_ADDRESS = 'test@pixelated.org'\n\n    def _initialize(self):\n        self._tmp_dir = TempDir()\n        self.accounts = {}\n\n    @defer.inlineCallbacks\n    def start_client(self, mode=UserAgentMode(is_single_user=True)):\n        self._initialize()\n        self._mode = mode\n        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)\n\n        yield self._test_account.start()\n\n        self.cleanup = lambda: self._tmp_dir.dissolve()\n\n        # copy fields for single user tests\n        self.soledad = self._test_account.soledad\n        self.search_engine = self._test_account.search_engine\n        self.keymanager = self._test_account.keymanager\n        self.mail_sender = self._test_account.mail_sender\n        self.mail_store = self._test_account.mail_store\n        self.attachment_store = self._test_account.attachment_store\n        self.draft_service = self._test_account.draft_service\n        self.leap_session = self._test_account.leap_session\n        self.feedback_service = self._test_account.feedback_service\n        self.mail_service = self._test_account.mail_service\n        self.account = self._test_account.account\n\n        if mode.is_single_user:\n            self.service_factory = SingleUserServicesFactory(mode)\n            services = self._test_account.services\n            self.service_factory.add_session('someuserid', services)\n\n            self.resource = RootResource(self.service_factory)\n            self.resource.initialize()\n        else:\n            self.service_factory = StubServicesFactory(self.accounts, mode)\n            provider = mock()\n            provider.config = LeapConfig(self._tmp_dir.name)\n\n            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))\n\n    @defer.inlineCallbacks\n    def create_user(self, account_name):\n        if self._mode.is_single_user:\n            raise Exception('Not supported in single user mode')\n\n        account = AppTestAccount(account_name, self._tmp_dir.name)\n        yield account.start()\n\n        self.accounts[account_name] = account\n\n    def _render(self, request, as_json=True):\n        def get_str(_str):\n            return json.loads(_str) if as_json else _str\n\n        def get_request_written_data(_=None):\n            written_data = request.getWrittenData()\n            if written_data:\n                return get_str(written_data)\n\n        resource = getChildForRequest(self.resource, request)\n        result = resource.render(request)\n\n        if isinstance(result, basestring):\n            return get_str(result), request\n\n        # result is NOT_DONE_YET\n        d = succeed(request) if request.finished else request.notifyFinish()\n        d.addCallback(get_request_written_data)\n        return d, request\n\n    def listenTCP(self, port=4567, host='127.0.0.1'):\n        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)\n\n    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):\n        def _start():\n            self.listenTCP(port, host)\n            reactor.run()\n        process = multiprocessing.Process(target=_start)\n        process.start()\n        time.sleep(1)\n        return lambda: process.terminate()\n\n    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):\n        request = request_mock(path, ajax=ajax, csrf=csrf)\n        request.args = get_args\n        return self._render(request, as_json)\n\n    def post(self, path, body='', headers=None, ajax=True, csrf='token'):\n        headers = headers or {'Content-Type': 'application/json'}\n        request = request_mock(path=path, method=\"POST\", body=body, headers=headers, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def put(self, path, body, ajax=True, csrf='token'):\n        request = request_mock(path=path, method=\"PUT\", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def delete(self, path, body=\"\", ajax=True, csrf='token'):\n        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=\"DELETE\", ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    @defer.inlineCallbacks\n    def add_mail_to_inbox(self, input_mail):\n        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)\n        defer.returnValue(mail)\n\n    def account_for(self, username):\n        return self.accounts[username]\n\n    def add_mail_to_user_inbox(self, input_mail, username):\n        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)\n\n    @defer.inlineCallbacks\n    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):\n        mails = []\n        yield self.mail_store.add_mailbox(mailbox)\n        for _ in range(num):\n            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)\n            builder.with_body(str(random.random()))\n            input_mail = builder.build_input_mail()\n            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)\n            if tags:\n                mail.tags |= set(tags)\n            if flags:\n                for flag in flags:\n                    mail.flags.add(flag)\n            if tags or flags:\n                yield self.mail_store.update_mail(mail)\n            mails.append(mail)\n\n        defer.returnValue(mails)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):\n        return os.path.join(soledad_test_folder, str(uuid.uuid4()))\n\n    def get_mails_by_tag(self, tag, page=1, window=100):\n        tags = 'tag:%s' % tag\n        return self.search(tags, page, window)\n\n    @defer.inlineCallbacks\n    def search(self, query, page=1, window=100):\n        res, _ = self.get(\"/mails\", {\n            'q': [query],\n            'w': [str(window)],\n            'p': [str(page)]\n        })\n        res = yield res\n        defer.returnValue([ResponseMail(m) for m in res['mails']])\n\n    @defer.inlineCallbacks\n    def get_mails_by_mailbox_name(self, mbox_name):\n        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)\n        mails = yield self.mail_store.get_mails(mail_ids)\n        defer.returnValue(mails)\n\n    @defer.inlineCallbacks\n    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):\n        params = {'encoding': [encoding]}\n        if filename:\n            params['filename'] = [filename]\n        if content_type:\n            params['content_type'] = [content_type]\n        deferred_result, req = self.get(\"/attachment/%s\" % ident, params, as_json=False, ajax=ajax, csrf=csrf)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    @defer.inlineCallbacks\n    def post_attachment(self, data, headers):\n        deferred_result, req = self.post('/attachment', body=data, headers=headers)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    def put_mail(self, data):\n        res, req = self.put('/mails', data)\n        return res, req\n\n    def post_tags(self, mail_ident, tags_json):\n        res, req = self.post(\"/mail/%s/tags\" % mail_ident, tags_json)\n        return res\n\n    def get_tags(self, **kwargs):\n        res, req = self.get('/tags', kwargs)\n        return res\n\n    def get_mail(self, mail_ident):\n        res, req = self.get('/mail/%s' % mail_ident)\n        return res\n\n    def delete_mail(self, mail_ident):\n        res, req = self.delete(\"/mail/%s\" % mail_ident)\n        return res\n\n    def delete_mails(self, idents):\n        res, req = self.post(\"/mails/delete\", json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_unread(self, idents):\n        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_read(self, idents):\n        res, req = self.post('/mails/read', json.dumps({'idents': idents}))\n        return res\n\n    def get_contacts(self, query):\n        res, req = self.get('/contacts', get_args={'q': query})\n        return res\n\n\n@defer.inlineCallbacks\ndef initialize_soledad(tempdir, uuid):\n    if os.path.isdir(tempdir):\n        shutil.rmtree(tempdir)\n\n    passphrase = u\"verysecretpassphrase\"\n    secret_path = os.path.join(tempdir, \"secret.gpg\")\n    local_db_path = os.path.join(tempdir, \"soledad.u1db\")\n    server_url = \"http://provider\"\n    cert_file = \"\"\n\n    class MockSharedDB(object):\n        get_doc = Mock(return_value=None)\n        put_doc = Mock()\n        lock = Mock(return_value=('atoken', 300))\n        unlock = Mock(return_value=True)\n        close = Mock()\n\n        def __call__(self):\n            return self\n\n    Soledad._shared_db = MockSharedDB()\n\n    _soledad = Soledad(\n        uuid,\n        passphrase,\n        secret_path,\n        local_db_path,\n        server_url,\n        cert_file,\n        defer_encryption=False,\n        syncable=False)\n\n    yield SoledadMailAdaptor().initialize_store(_soledad)\n\n    defer.returnValue(_soledad)\n/n/n/nservice/test/support/test_helper.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nfrom datetime import datetime\nimport io\nfrom twisted.web.test.test_web import DummyRequest\n\nfrom pixelated.adapter.model.mail import InputMail\n\n\nLEAP_FLAGS = ['\\\\Seen',\n              '\\\\Answered',\n              '\\\\Flagged',\n              '\\\\Deleted',\n              '\\\\Draft',\n              '\\\\Recent',\n              'List']\n\nDEFAULT_HEADERS = {'date': str(datetime.now())}\n\n\ndef mail_dict():\n    return {\n        'header': {\n            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],\n            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],\n            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],\n            'subject': 'Subject'\n        },\n        'body': 'Body',\n        'ident': '',\n        'tags': []\n    }\n\n\nclass TestDoc(object):\n    def __init__(self, content):\n        self.content = content\n\n    def __getitem__(self, key):\n        return self.content[key]\n\n\ndef leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',\n              chash='chash'):\n    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})\n\n    if headers is None:\n        headers = {}\n    if not (headers.get('received') or headers.get('date')):\n        headers.update(DEFAULT_HEADERS)\n    headers['headers'] = extra_headers\n    hdoc = TestDoc(headers)\n\n    bdoc = TestDoc({'raw': body, 'type': 'cnt'})\n\n    return (fdoc, hdoc, bdoc)\n\n\ndef input_mail():\n    mail = InputMail()\n    mail.fdoc = TestDoc({})\n    mail._chash = \"123\"\n    mail.as_dict = lambda: None\n    return mail\n\n\nclass TestRequest:\n\n    def __init__(self, json):\n        self.json = json\n\n\nclass PixRequestMock(DummyRequest):\n    def __init__(self, path):\n        DummyRequest.__init__(self, path)\n        self.content = None\n        self.code = None\n        self.cookies = {}\n\n    def getWrittenData(self):\n        if len(self.written):\n            return self.written[0]\n\n    def redirect(self, url):\n        self.setResponseCode(302)\n        self.setHeader(b\"location\", url)\n\n    def addCookie(self, key, value):\n        self.cookies[key] = value\n\n    def getCookie(self, key):\n        return self.cookies.get(key)\n\n\ndef request_mock(path='', method='GET', body='', headers={}, ajax=True, csrf='token'):\n    dummy = PixRequestMock(path.split('/'))\n    for name, val in headers.iteritems():\n        dummy.headers[name.lower()] = val\n    dummy.method = method\n    if isinstance(body, str):\n        dummy.content = io.BytesIO(body)\n    else:\n        for key, val in body.items():\n            dummy.addArg(key, val)\n    if ajax:\n        dummy.headers['x-requested-with'] = 'XMLHttpRequest'\n        dummy.headers['x-xsrf-token'] = csrf\n        dummy.addCookie('XSRF-TOKEN', csrf)\n\n    return dummy\n/n/n/nservice/test/unit/resources/test_root_resource.py/n/nimport unittest\nimport re\n\nfrom mock import MagicMock, patch\nfrom mockito import mock, when, any as ANY\n\nfrom pixelated.application import UserAgentMode\nfrom test.unit.resources import DummySite\nfrom twisted.web.test.requesthelper import DummyRequest\nfrom pixelated.resources.root_resource import RootResource, MODE_STARTUP, MODE_RUNNING\n\n\nclass TestRootResource(unittest.TestCase):\n    MAIL_ADDRESS = 'test_user@pixelated-project.org'\n\n    def setUp(self):\n        self.mail_service = mock()\n        self.services_factory = mock()\n        self.services_factory.mode = UserAgentMode(is_single_user=True)\n        self.services = mock()\n        self.services.mail_service = self.mail_service\n        self.services_factory._services_by_user = {'someuserid': self.mail_service}\n        when(self.services_factory).services(ANY()).thenReturn(self.services)\n        self.mail_service.account_email = self.MAIL_ADDRESS\n\n        root_resource = RootResource(self.services_factory)\n        root_resource._html_template = \"<html><head><title>$account_email</title></head></html>\"\n        root_resource._mode = root_resource\n        self.web = DummySite(root_resource)\n        self.root_resource = root_resource\n\n    def test_render_GET_should_template_account_email(self):\n        request = DummyRequest([''])\n        request.addCookie = lambda key, value: 'stubbed'\n\n        d = self.web.get(request)\n\n        def assert_response(_):\n            expected = \"<title>{0}</title>\".format(self.MAIL_ADDRESS)\n            matches = re.findall(expected, request.written[0])\n            self.assertEquals(len(matches), 1)\n\n        d.addCallback(assert_response)\n        return d\n\n    def _test_should_renew_xsrf_cookie(self):\n        request = DummyRequest([''])\n        request.addCookie = MagicMock()\n        generated_csrf_token = 'csrf_token'\n        mock_sha = MagicMock()\n        mock_sha.hexdigest = MagicMock(return_value=generated_csrf_token)\n\n        with patch('hashlib.sha256', return_value=mock_sha):\n            d = self.web.get(request)\n\n        def assert_csrf_cookie(_):\n            request.addCookie.assert_called_once_with('XSRF-TOKEN', generated_csrf_token)\n\n        d.addCallback(assert_csrf_cookie)\n        return d\n\n    def test_should_renew_xsrf_cookie_on_startup_mode(self):\n        self.root_resource._mode = MODE_STARTUP\n        self._test_should_renew_xsrf_cookie()\n\n    def test_should_renew_xsrf_cookie_on_running_mode(self):\n        self.root_resource._mode = MODE_RUNNING\n        self._test_should_renew_xsrf_cookie()\n\n    def _mock_ajax_csrf(self, request, csrf_token):\n        request.headers['x-requested-with'] = 'XMLHttpRequest'\n        request.headers['x-xsrf-token'] = csrf_token\n\n    def test_should_unauthorize_child_resource_ajax_requests_when_csrf_mismatch(self):\n        request = DummyRequest(['/child'])\n        self._mock_ajax_csrf(request, 'stubbed csrf token')\n\n        request.getCookie = MagicMock(return_value='mismatched csrf token')\n\n        d = self.web.get(request)\n\n        def assert_unauthorized(_):\n            self.assertEqual(401, request.responseCode)\n            self.assertEqual(\"Unauthorized!\", request.written[0])\n\n        d.addCallback(assert_unauthorized)\n        return d\n\n    def test_should_authorize_child_resource_non_ajax_GET_requests(self):\n        request = DummyRequest(['features'])\n\n        request.getCookie = MagicMock(return_value='irrelevant -- stubbed')\n        self.root_resource.initialize()\n\n        d = self.web.get(request)\n\n        def assert_unauthorized(_):\n            self.assertEqual(200, request.code)\n\n        d.addCallback(assert_unauthorized)\n        return d\n\n    def test_should_unauthorize_child_resource_non_ajax_POST_requests_when_csrf_input_mismatch(self):\n        request = DummyRequest(['mails'])\n        request.method = 'POST'\n        request.addArg('csrftoken', 'some csrf token')\n        mock_content = MagicMock()\n        mock_content.read = MagicMock(return_value={})\n        request.content = mock_content\n\n        request.getCookie = MagicMock(return_value='mismatched csrf token')\n\n        d = self.web.get(request)\n\n        def assert_unauthorized(_):\n            self.assertEqual(401, request.responseCode)\n            self.assertEqual(\"Unauthorized!\", request.written[0])\n\n        d.addCallback(assert_unauthorized)\n        return d\n/n/n/n", "label": 0}, {"id": "9573bdca55ddc5488066d3af525e41ed1d872ea6", "code": "/service/pixelated/resources/login_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport logging\nimport os\nfrom xml.sax import SAXParseException\n\nfrom twisted.cred import credentials\nfrom twisted.internet import defer\nfrom twisted.web import util\nfrom twisted.web.error import FlattenerError\nfrom twisted.web.http import UNAUTHORIZED, OK\nfrom twisted.web.resource import IResource, NoResource\nfrom twisted.web.server import NOT_DONE_YET\nfrom twisted.web.static import File\nfrom twisted.web.template import Element, XMLFile, renderElement, renderer\nfrom twisted.python.filepath import FilePath\n\nfrom pixelated.adapter.welcome_mail import add_welcome_mail\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, IPixelatedSession\n\nlog = logging.getLogger(__name__)\n\n\ndef _get_startup_folder():\n    path = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(path, '..', 'assets')\n\n\ndef _get_static_folder():\n    static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    # this is a workaround for packaging\n    if not os.path.exists(static_folder):\n        static_folder = os.path.abspath(\n            os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n    if not os.path.exists(static_folder):\n        static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n    return static_folder\n\n\nclass DisclaimerElement(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), '_login_disclaimer_banner.html')))\n\n    def __init__(self, banner):\n        super(DisclaimerElement, self).__init__()\n        self._set_loader(banner)\n        self._banner_filename = banner or \"_login_disclaimer_banner.html\"\n\n    def _set_loader(self, banner):\n        if banner:\n            current_path = os.path.dirname(os.path.abspath(__file__))\n            banner_file_path = os.path.join(current_path, \"..\", \"..\", \"..\", banner)\n            self.loader = XMLFile(FilePath(banner_file_path))\n\n    def render(self, request):\n        try:\n            return super(DisclaimerElement, self).render(request)\n        except SAXParseException:\n            return [\"Invalid XML template format for %s.\" % self._banner_filename]\n        except IOError:\n            return [\"Disclaimer banner file %s could not be read or does not exit.\" % self._banner_filename]\n\n\nclass LoginWebSite(Element):\n    loader = XMLFile(FilePath(os.path.join(_get_startup_folder(), 'login.html')))\n\n    def __init__(self, error_msg=None, disclaimer_banner_file=None):\n        super(LoginWebSite, self).__init__()\n        self._error_msg = error_msg\n        self.disclaimer_banner_file = disclaimer_banner_file\n\n    @renderer\n    def error_msg(self, request, tag):\n        if self._error_msg is not None:\n            return tag(self._error_msg)\n        return tag('')\n\n    @renderer\n    def disclaimer(self, request, tag):\n        return DisclaimerElement(self.disclaimer_banner_file).render(request)\n\n\nclass LoginResource(BaseResource):\n    BASE_URL = 'login'\n\n    def __init__(self, services_factory, portal=None, disclaimer_banner=None):\n        BaseResource.__init__(self, services_factory)\n        self._static_folder = _get_static_folder()\n        self._startup_folder = _get_startup_folder()\n        self._portal = portal\n        self._disclaimer_banner = disclaimer_banner\n        self.putChild('startup-assets', File(self._startup_folder))\n\n    def set_portal(self, portal):\n        self._portal = portal\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if path == 'login':\n            return self\n        if not self.is_logged_in(request):\n            return UnAuthorizedResource()\n        return NoResource()\n\n    def render_GET(self, request):\n        request.setResponseCode(OK)\n        return self._render_template(request)\n\n    def _render_template(self, request, error_msg=None):\n        site = LoginWebSite(error_msg=error_msg, disclaimer_banner_file=self._disclaimer_banner)\n        return renderElement(request, site)\n\n    def render_POST(self, request):\n        if self.is_logged_in(request):\n            return util.redirectTo(\"/\", request)\n\n        def render_response(leap_session):\n            request.setResponseCode(OK)\n            request.write(open(os.path.join(self._startup_folder, 'Interstitial.html')).read())\n            request.finish()\n            self._setup_user_services(leap_session, request)\n\n        def render_error(error):\n            log.info('Login Error for %s' % request.args['username'][0])\n            log.info('%s' % error)\n            request.setResponseCode(UNAUTHORIZED)\n            return self._render_template(request, 'Invalid credentials')\n\n        d = self._handle_login(request)\n        d.addCallbacks(render_response, render_error)\n\n        return NOT_DONE_YET\n\n    @defer.inlineCallbacks\n    def _handle_login(self, request):\n        self.creds = self._get_creds_from(request)\n        iface, leap_session, logout = yield self._portal.login(self.creds, None, IResource)\n        defer.returnValue(leap_session)\n\n    def _get_creds_from(self, request):\n        username = request.args['username'][0]\n        password = request.args['password'][0]\n        return credentials.UsernamePassword(username, password)\n\n    @defer.inlineCallbacks\n    def _setup_user_services(self, leap_session, request):\n        user_id = leap_session.user_auth.uuid\n        if not self._services_factory.is_logged_in(user_id):\n            yield self._services_factory.create_services_from(leap_session)\n        self._init_http_session(request, user_id)\n\n    @defer.inlineCallbacks\n    def _initialize_services(self, leap_session):\n        yield self._services_factory.create_services_from(leap_session)\n\n        if leap_session.fresh_account:\n            yield add_welcome_mail(leap_session.mail_store)\n\n    def _init_http_session(self, request, user_id):\n        session = IPixelatedSession(request.getSession())\n        session.user_uuid = user_id\n/n/n/n/service/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.resource import Resource\nfrom twisted.web.static import File\n\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        return Resource.getChild(self, path, request)\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self.putChild('assets', File(self._static_folder))\n        self.putChild('keys', KeysResource(self._services_factory))\n        self.putChild(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self.putChild('contacts', ContactsResource(self._services_factory))\n        self.putChild('features', FeaturesResource(portal))\n        self.putChild('tags', TagsResource(self._services_factory))\n        self.putChild('mails', MailsResource(self._services_factory))\n        self.putChild('mail', MailResource(self._services_factory))\n        self.putChild('feedback', FeedbackResource(self._services_factory))\n        self.putChild('user-settings', UserSettingsResource(self._services_factory))\n        self.putChild(LoginResource.BASE_URL, LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self.putChild(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def render_GET(self, request):\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n/n/n/n/service/test/support/integration/app_test_client.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport json\nimport multiprocessing\nfrom leap.mail.adaptors.soledad import SoledadMailAdaptor\nfrom leap.srp_session import SRPSession\nfrom mockito import mock\nimport os\nimport shutil\nimport time\nimport uuid\nimport random\n\n\nfrom leap.mail.imap.account import IMAPAccount\nfrom leap.soledad.client import Soledad\nfrom mock import Mock\nfrom twisted.internet import reactor, defer\nfrom twisted.internet.defer import succeed\nfrom twisted.web.resource import getChildForRequest\n# from twisted.web.server import Site as PixelatedSite\nfrom zope.interface import implementer\nfrom twisted.cred import checkers, credentials\nfrom pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore\nfrom pixelated.adapter.services.feedback_service import FeedbackService\nfrom pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources\nfrom pixelated.bitmask_libraries.config import LeapConfig\nfrom pixelated.bitmask_libraries.session import LeapSession\nfrom pixelated.config.services import Services\nfrom pixelated.config.site import PixelatedSite\n\nfrom pixelated.adapter.mailstore import LeapMailStore\nfrom pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore\n\nfrom pixelated.adapter.search import SearchEngine\nfrom pixelated.adapter.services.draft_service import DraftService\nfrom pixelated.adapter.services.mail_service import MailService\nfrom pixelated.resources.root_resource import RootResource\nfrom test.support.integration.model import MailBuilder\nfrom test.support.test_helper import request_mock\nfrom test.support.integration.model import ResponseMail\nfrom tempdir import TempDir\n\n\nclass AppTestAccount(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n\n    def __init__(self, user_id, leap_home):\n        self._user_id = user_id\n        self._leap_home = leap_home\n        self._uuid = str(uuid.uuid4())\n        self._mail_address = '%s@pixelated.org' % user_id\n        self._soledad = None\n        self._services = None\n\n    @defer.inlineCallbacks\n    def start(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)\n        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)\n        self.keymanager = mock()\n        self.mail_sender = self._create_mail_sender()\n        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)\n        self.attachment_store = LeapAttachmentStore(self.soledad)\n\n        yield self._initialize_imap_account()\n\n        self.draft_service = DraftService(self.mail_store)\n        self.leap_session = mock()\n        self.feedback_service = FeedbackService(self.leap_session)\n\n        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)\n\n        mails = yield self.mail_service.all_mails()\n        if len(mails) > 0:\n            raise Exception('What? Where did these come from?')\n        self.search_engine.index_mails(mails)\n\n    @property\n    def services(self):\n        if self._services is None:\n            services = mock(Services)\n            services.keymanager = self.keymanager\n            services.mail_service = self.mail_service\n            services.draft_service = self.draft_service\n            services.search_engine = self.search_engine\n            services.feedback_service = self.feedback_service\n            services._leap_session = self.leap_session\n\n            self._services = services\n            self.leap_session.close = lambda: 'mocked'\n\n        return self._services\n\n    def cleanup(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        shutil.rmtree(soledad_test_folder)\n\n    def _initialize_imap_account(self):\n        account_ready_cb = defer.Deferred()\n        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)\n        return account_ready_cb\n\n    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):\n        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n\n@implementer(checkers.ICredentialsChecker)\nclass StubSRPChecker(object):\n    credentialInterfaces = (\n        credentials.IUsernamePassword,\n    )\n\n    def __init__(self, leap_provider, credentials={}):\n        self._leap_provider = leap_provider\n        self._credentials = credentials.copy()\n\n    def add_user(self, username, password):\n        self._credentials[username] = password\n\n    def requestAvatarId(self, credentials):\n        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())\n        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))\n\n\nclass StubServicesFactory(ServicesFactory):\n\n    def __init__(self, accounts, mode):\n        super(StubServicesFactory, self).__init__(mode=mode)\n        self._accounts = accounts\n\n    @defer.inlineCallbacks\n    def create_services_from(self, leap_session):\n        account = self._accounts[leap_session.user_auth.username]\n        self._services_by_user[leap_session.user_auth.uuid] = account.services\n        yield defer.succeed(None)\n\n\nclass AppTestClient(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n    ACCOUNT = 'test'\n    MAIL_ADDRESS = 'test@pixelated.org'\n\n    def _initialize(self):\n        self._tmp_dir = TempDir()\n        self.accounts = {}\n\n    @defer.inlineCallbacks\n    def start_client(self, mode=UserAgentMode(is_single_user=True)):\n        self._initialize()\n        self._mode = mode\n        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)\n\n        yield self._test_account.start()\n\n        self.cleanup = lambda: self._tmp_dir.dissolve()\n\n        # copy fields for single user tests\n        self.soledad = self._test_account.soledad\n        self.search_engine = self._test_account.search_engine\n        self.keymanager = self._test_account.keymanager\n        self.mail_sender = self._test_account.mail_sender\n        self.mail_store = self._test_account.mail_store\n        self.attachment_store = self._test_account.attachment_store\n        self.draft_service = self._test_account.draft_service\n        self.leap_session = self._test_account.leap_session\n        self.feedback_service = self._test_account.feedback_service\n        self.mail_service = self._test_account.mail_service\n        self.account = self._test_account.account\n\n        if mode.is_single_user:\n            self.service_factory = SingleUserServicesFactory(mode)\n            services = self._test_account.services\n            self.service_factory.add_session('someuserid', services)\n\n            self.resource = RootResource(self.service_factory)\n            self.resource.initialize()\n        else:\n            self.service_factory = StubServicesFactory(self.accounts, mode)\n            provider = mock()\n            provider.config = LeapConfig(self._tmp_dir.name)\n\n            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))\n\n    @defer.inlineCallbacks\n    def create_user(self, account_name):\n        if self._mode.is_single_user:\n            raise Exception('Not supported in single user mode')\n\n        account = AppTestAccount(account_name, self._tmp_dir.name)\n        yield account.start()\n\n        self.accounts[account_name] = account\n\n    def _render(self, request, as_json=True):\n        def get_str(_str):\n            return json.loads(_str) if as_json else _str\n\n        def get_request_written_data(_=None):\n            written_data = request.getWrittenData()\n            if written_data:\n                return get_str(written_data)\n\n        resource = getChildForRequest(self.resource, request)\n        result = resource.render(request)\n\n        if isinstance(result, basestring):\n            return get_str(result), request\n\n        # result is NOT_DONE_YET\n        d = succeed(request) if request.finished else request.notifyFinish()\n        d.addCallback(get_request_written_data)\n        return d, request\n\n    def listenTCP(self, port=4567, host='127.0.0.1'):\n        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)\n\n    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):\n        def _start():\n            self.listenTCP(port, host)\n            reactor.run()\n        process = multiprocessing.Process(target=_start)\n        process.start()\n        time.sleep(1)\n        return lambda: process.terminate()\n\n    def get(self, path, get_args='', as_json=True):\n        request = request_mock(path)\n        request.args = get_args\n        return self._render(request, as_json)\n\n    def post(self, path, body='', headers=None):\n        headers = headers or {'Content-Type': 'application/json'}\n        request = request_mock(path=path, method=\"POST\", body=body, headers=headers)\n        return self._render(request)\n\n    def put(self, path, body):\n        request = request_mock(path=path, method=\"PUT\", body=body, headers={'Content-Type': ['application/json']})\n        return self._render(request)\n\n    def delete(self, path, body=\"\"):\n        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=\"DELETE\")\n        return self._render(request)\n\n    @defer.inlineCallbacks\n    def add_mail_to_inbox(self, input_mail):\n        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)\n        defer.returnValue(mail)\n\n    def account_for(self, username):\n        return self.accounts[username]\n\n    def add_mail_to_user_inbox(self, input_mail, username):\n        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)\n\n    @defer.inlineCallbacks\n    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):\n        mails = []\n        yield self.mail_store.add_mailbox(mailbox)\n        for _ in range(num):\n            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)\n            builder.with_body(str(random.random()))\n            input_mail = builder.build_input_mail()\n            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)\n            if tags:\n                mail.tags |= set(tags)\n            if flags:\n                for flag in flags:\n                    mail.flags.add(flag)\n            if tags or flags:\n                yield self.mail_store.update_mail(mail)\n            mails.append(mail)\n\n        defer.returnValue(mails)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):\n        return os.path.join(soledad_test_folder, str(uuid.uuid4()))\n\n    def get_mails_by_tag(self, tag, page=1, window=100):\n        tags = 'tag:%s' % tag\n        return self.search(tags, page, window)\n\n    @defer.inlineCallbacks\n    def search(self, query, page=1, window=100):\n        res, _ = self.get(\"/mails\", {\n            'q': [query],\n            'w': [str(window)],\n            'p': [str(page)]\n        })\n        res = yield res\n        defer.returnValue([ResponseMail(m) for m in res['mails']])\n\n    @defer.inlineCallbacks\n    def get_mails_by_mailbox_name(self, mbox_name):\n        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)\n        mails = yield self.mail_store.get_mails(mail_ids)\n        defer.returnValue(mails)\n\n    @defer.inlineCallbacks\n    def get_attachment(self, ident, encoding, filename=None, content_type=None):\n        params = {'encoding': [encoding]}\n        if filename:\n            params['filename'] = [filename]\n        if content_type:\n            params['content_type'] = [content_type]\n        deferred_result, req = self.get(\"/attachment/%s\" % ident, params, as_json=False)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    @defer.inlineCallbacks\n    def post_attachment(self, data, headers):\n        deferred_result, req = self.post('/attachment', body=data, headers=headers)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    def put_mail(self, data):\n        res, req = self.put('/mails', data)\n        return res, req\n\n    def post_tags(self, mail_ident, tags_json):\n        res, req = self.post(\"/mail/%s/tags\" % mail_ident, tags_json)\n        return res\n\n    def get_tags(self, **kwargs):\n        res, req = self.get('/tags', kwargs)\n        return res\n\n    def get_mail(self, mail_ident):\n        res, req = self.get('/mail/%s' % mail_ident)\n        return res\n\n    def delete_mail(self, mail_ident):\n        res, req = self.delete(\"/mail/%s\" % mail_ident)\n        return res\n\n    def delete_mails(self, idents):\n        res, req = self.post(\"/mails/delete\", json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_unread(self, idents):\n        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_read(self, idents):\n        res, req = self.post('/mails/read', json.dumps({'idents': idents}))\n        return res\n\n    def get_contacts(self, query):\n        res, req = self.get('/contacts', get_args={'q': query})\n        return res\n\n\n@defer.inlineCallbacks\ndef initialize_soledad(tempdir, uuid):\n    if os.path.isdir(tempdir):\n        shutil.rmtree(tempdir)\n\n    passphrase = u\"verysecretpassphrase\"\n    secret_path = os.path.join(tempdir, \"secret.gpg\")\n    local_db_path = os.path.join(tempdir, \"soledad.u1db\")\n    server_url = \"http://provider\"\n    cert_file = \"\"\n\n    class MockSharedDB(object):\n        get_doc = Mock(return_value=None)\n        put_doc = Mock()\n        lock = Mock(return_value=('atoken', 300))\n        unlock = Mock(return_value=True)\n        close = Mock()\n\n        def __call__(self):\n            return self\n\n    Soledad._shared_db = MockSharedDB()\n\n    _soledad = Soledad(\n        uuid,\n        passphrase,\n        secret_path,\n        local_db_path,\n        server_url,\n        cert_file,\n        defer_encryption=False,\n        syncable=False)\n\n    yield SoledadMailAdaptor().initialize_store(_soledad)\n\n    defer.returnValue(_soledad)\n/n/n/n/service/test/support/test_helper.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nfrom datetime import datetime\nimport io\nfrom twisted.web.test.test_web import DummyRequest\n\nfrom pixelated.adapter.model.mail import InputMail\n\n\nLEAP_FLAGS = ['\\\\Seen',\n              '\\\\Answered',\n              '\\\\Flagged',\n              '\\\\Deleted',\n              '\\\\Draft',\n              '\\\\Recent',\n              'List']\n\nDEFAULT_HEADERS = {'date': str(datetime.now())}\n\n\ndef mail_dict():\n    return {\n        'header': {\n            'to': ['to@pixelated.org', 'anotherto@pixelated.org'],\n            'cc': ['cc@pixelated.org', 'anothercc@pixelated.org'],\n            'bcc': ['bcc@pixelated.org', 'anotherbcc@pixelated.org'],\n            'subject': 'Subject'\n        },\n        'body': 'Body',\n        'ident': '',\n        'tags': []\n    }\n\n\nclass TestDoc(object):\n    def __init__(self, content):\n        self.content = content\n\n    def __getitem__(self, key):\n        return self.content[key]\n\n\ndef leap_mail(uid=0, flags=LEAP_FLAGS, headers=None, extra_headers={}, mbox_uuid='INBOX', body='body',\n              chash='chash'):\n    fdoc = TestDoc({'flags': flags, 'mbox_uuid': mbox_uuid, 'type': 'flags', 'uid': uid, 'chash': chash})\n\n    if headers is None:\n        headers = {}\n    if not (headers.get('received') or headers.get('date')):\n        headers.update(DEFAULT_HEADERS)\n    headers['headers'] = extra_headers\n    hdoc = TestDoc(headers)\n\n    bdoc = TestDoc({'raw': body, 'type': 'cnt'})\n\n    return (fdoc, hdoc, bdoc)\n\n\ndef input_mail():\n    mail = InputMail()\n    mail.fdoc = TestDoc({})\n    mail._chash = \"123\"\n    mail.as_dict = lambda: None\n    return mail\n\n\nclass TestRequest:\n\n    def __init__(self, json):\n        self.json = json\n\n\nclass PixRequestMock(DummyRequest):\n    def __init__(self, path):\n        DummyRequest.__init__(self, path)\n        self.content = None\n        self.code = None\n\n    def getWrittenData(self):\n        if len(self.written):\n            return self.written[0]\n\n    def redirect(self, url):\n        self.setResponseCode(302)\n        self.setHeader(b\"location\", url)\n\n\ndef request_mock(path='', method='GET', body='', headers={}):\n    dummy = PixRequestMock(path.split('/'))\n    for name, val in headers.iteritems():\n        dummy.headers[name.lower()] = val\n    dummy.method = method\n    if isinstance(body, str):\n        dummy.content = io.BytesIO(body)\n    else:\n        for key, val in body.items():\n            dummy.addArg(key, val)\n\n    return dummy\n/n/n/n/service/test/unit/resources/test_root_resource.py/n/nimport unittest\nimport re\nfrom mockito import mock, when, any as ANY\n\nfrom pixelated.application import UserAgentMode\nfrom test.unit.resources import DummySite\nfrom twisted.web.test.requesthelper import DummyRequest\nfrom pixelated.resources.root_resource import RootResource\n\n\nclass TestRootResource(unittest.TestCase):\n    MAIL_ADDRESS = 'test_user@pixelated-project.org'\n\n    def setUp(self):\n        self.mail_service = mock()\n        self.services_factory = mock()\n        self.services_factory.mode = UserAgentMode(is_single_user=True)\n        self.services = mock()\n        self.services.mail_service = self.mail_service\n        self.services_factory._services_by_user = {'someuserid': self.mail_service}\n        when(self.services_factory).services(ANY()).thenReturn(self.services)\n        self.mail_service.account_email = self.MAIL_ADDRESS\n\n        root_resource = RootResource(self.services_factory)\n        root_resource._html_template = \"<html><head><title>$account_email</title></head></html>\"\n        root_resource._mode = root_resource\n        self.web = DummySite(root_resource)\n\n    def test_render_GET_should_template_account_email(self):\n        request = DummyRequest([''])\n\n        d = self.web.get(request)\n\n        def assert_response(_):\n            expected = \"<title>{0}</title>\".format(self.MAIL_ADDRESS)\n            matches = re.findall(expected, request.written[0])\n            self.assertEquals(len(matches), 1)\n\n        d.addCallback(assert_response)\n        return d\n/n/n/n", "label": 1}, {"id": "dbb434b56e6b161a3b851ae6a81f96dff14a29da", "code": "service/test/functional/features/environment.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport logging\nimport uuid\n\nfrom crochet import setup, wait_for\nfrom leap.common.events.server import ensure_server\nfrom twisted.internet import defer\n\nfrom pixelated.application import UserAgentMode\nfrom pixelated.config.site import PixelatedSite\nfrom test.support.dispatcher.proxy import Proxy\nfrom test.support.integration import AppTestClient\nfrom selenium import webdriver\n\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom steps.common import *\nimport os\n\nsetup()\n\n\n@wait_for(timeout=5.0)\ndef start_app_test_client(client, mode):\n    return client.start_client(mode=mode)\n\n\ndef before_all(context):\n    ensure_server()\n    logging.disable('INFO')\n    PixelatedSite.disable_csp_requests()\n    client = AppTestClient()\n    start_app_test_client(client, UserAgentMode(is_single_user=True))\n    client.listenTCP(port=8889)\n    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')\n    context.client = client\n\n    multi_user_client = AppTestClient()\n    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))\n    multi_user_client.listenTCP(port=MULTI_USER_PORT)\n    context.multi_user_client = multi_user_client\n\n\ndef after_all(context):\n    context.client.stop()\n\n\ndef before_feature(context, feature):\n    # context.browser = webdriver.Chrome()\n    # context.browser = webdriver.Firefox()\n    context.browser = webdriver.PhantomJS()\n    context.browser.set_window_size(1280, 1024)\n    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)\n    context.browser.set_page_load_timeout(60)  # wait for data\n    context.browser.get(HOMEPAGE_URL)\n\n\ndef after_step(context, step):\n    if step.status == 'failed':\n        id = str(uuid.uuid4())\n        os.chdir(\"screenshots\")\n        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + \".png\")\n        save_source(context, 'failed ' + str(step.name) + '_' + id + \".html\")\n        os.chdir(\"../\")\n\n\ndef after_feature(context, feature):\n    context.browser.quit()\n\n    cleanup_all_mails(context)\n    context.last_mail = None\n\n\n@wait_for(timeout=10.0)\ndef cleanup_all_mails(context):\n    @defer.inlineCallbacks\n    def _delete_all_mails():\n        mails = yield context.client.mail_store.all_mails()\n        for mail in mails:\n            yield context.client.mail_store.delete_mail(mail.ident)\n\n    return _delete_all_mails()\n\n\ndef save_source(context, filename='/tmp/source.html'):\n    with open(filename, 'w') as out:\n        out.write(context.browser.page_source.encode('utf8'))\n/n/n/nservice/test/support/integration/app_test_client.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport json\nimport multiprocessing\nfrom leap.mail.adaptors.soledad import SoledadMailAdaptor\nfrom leap.srp_session import SRPSession\nfrom mockito import mock\nimport os\nimport shutil\nimport time\nimport uuid\nimport random\n\n\nfrom leap.mail.imap.account import IMAPAccount\nfrom leap.soledad.client import Soledad\nfrom mock import Mock\nfrom twisted.internet import reactor, defer\nfrom twisted.internet.defer import succeed\nfrom twisted.web.resource import getChildForRequest\n# from twisted.web.server import Site as PixelatedSite\nfrom zope.interface import implementer\nfrom twisted.cred import checkers, credentials\nfrom pixelated.adapter.mailstore.leap_attachment_store import LeapAttachmentStore\nfrom pixelated.adapter.services.feedback_service import FeedbackService\nfrom pixelated.application import ServicesFactory, UserAgentMode, SingleUserServicesFactory, set_up_protected_resources\nfrom pixelated.bitmask_libraries.config import LeapConfig\nfrom pixelated.bitmask_libraries.session import LeapSession\nfrom pixelated.config.services import Services\nfrom pixelated.config.site import PixelatedSite\n\nfrom pixelated.adapter.mailstore import LeapMailStore\nfrom pixelated.adapter.mailstore.searchable_mailstore import SearchableMailStore\n\nfrom pixelated.adapter.search import SearchEngine\nfrom pixelated.adapter.services.draft_service import DraftService\nfrom pixelated.adapter.services.mail_service import MailService\nfrom pixelated.resources.root_resource import RootResource\nfrom test.support.integration.model import MailBuilder\nfrom test.support.test_helper import request_mock\nfrom test.support.integration.model import ResponseMail\nfrom tempdir import TempDir\n\n\nclass AppTestAccount(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n\n    def __init__(self, user_id, leap_home):\n        self._user_id = user_id\n        self._leap_home = leap_home\n        self._uuid = str(uuid.uuid4())\n        self._mail_address = '%s@pixelated.org' % user_id\n        self._soledad = None\n        self._services = None\n\n    @defer.inlineCallbacks\n    def start(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        self.soledad = yield initialize_soledad(tempdir=soledad_test_folder, uuid=self._uuid)\n        self.search_engine = SearchEngine(self.INDEX_KEY, user_home=soledad_test_folder)\n        self.keymanager = mock()\n        self.mail_sender = self._create_mail_sender()\n        self.mail_store = SearchableMailStore(LeapMailStore(self.soledad), self.search_engine)\n        self.attachment_store = LeapAttachmentStore(self.soledad)\n\n        yield self._initialize_imap_account()\n\n        self.draft_service = DraftService(self.mail_store)\n        self.leap_session = mock()\n        self.feedback_service = FeedbackService(self.leap_session)\n\n        self.mail_service = self._create_mail_service(self.mail_sender, self.mail_store, self.search_engine, self.attachment_store)\n\n        mails = yield self.mail_service.all_mails()\n        if len(mails) > 0:\n            raise Exception('What? Where did these come from?')\n        self.search_engine.index_mails(mails)\n\n    @property\n    def services(self):\n        if self._services is None:\n            services = mock(Services)\n            services.keymanager = self.keymanager\n            services.mail_service = self.mail_service\n            services.draft_service = self.draft_service\n            services.search_engine = self.search_engine\n            services.feedback_service = self.feedback_service\n            services._leap_session = self.leap_session\n\n            self._services = services\n            self.leap_session.close = lambda: 'mocked'\n\n        return self._services\n\n    def cleanup(self):\n        soledad_test_folder = os.path.join(self._leap_home, self._uuid)\n        shutil.rmtree(soledad_test_folder)\n\n    def _initialize_imap_account(self):\n        account_ready_cb = defer.Deferred()\n        self.account = IMAPAccount(self._user_id, self.soledad, account_ready_cb)\n        return account_ready_cb\n\n    def _create_mail_service(self, mail_sender, mail_store, search_engine, attachment_store):\n        return MailService(mail_sender, mail_store, search_engine, self._mail_address, attachment_store)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n\n@implementer(checkers.ICredentialsChecker)\nclass StubSRPChecker(object):\n    credentialInterfaces = (\n        credentials.IUsernamePassword,\n    )\n\n    def __init__(self, leap_provider, credentials={}):\n        self._leap_provider = leap_provider\n        self._credentials = credentials.copy()\n\n    def add_user(self, username, password):\n        self._credentials[username] = password\n\n    def requestAvatarId(self, credentials):\n        leap_auth = SRPSession(credentials.username, uuid.uuid4(), uuid.uuid4(), uuid.uuid4())\n        return defer.succeed(LeapSession(self._leap_provider, leap_auth, None, None, None, None))\n\n\nclass StubServicesFactory(ServicesFactory):\n\n    def __init__(self, accounts, mode):\n        super(StubServicesFactory, self).__init__(mode=mode)\n        self._accounts = accounts\n\n    @defer.inlineCallbacks\n    def create_services_from(self, leap_session):\n        account = self._accounts[leap_session.user_auth.username]\n        self._services_by_user[leap_session.user_auth.uuid] = account.services\n        yield defer.succeed(None)\n\n\nclass AppTestClient(object):\n    INDEX_KEY = '\\xde3?\\x87\\xff\\xd9\\xd3\\x14\\xf0\\xa7>\\x1f%C{\\x16.\\\\\\xae\\x8c\\x13\\xa7\\xfb\\x04\\xd4]+\\x8d_\\xed\\xd1\\x8d\\x0bI' \\\n                '\\x8a\\x0e\\xa4tm\\xab\\xbf\\xb4\\xa5\\x99\\x00d\\xd5w\\x9f\\x18\\xbc\\x1d\\xd4_W\\xd2\\xb6\\xe8H\\x83\\x1b\\xd8\\x9d\\xad'\n    ACCOUNT = 'test'\n    MAIL_ADDRESS = 'test@pixelated.org'\n\n    def _initialize(self):\n        self._tmp_dir = TempDir()\n        self.accounts = {}\n\n    @defer.inlineCallbacks\n    def start_client(self, mode=UserAgentMode(is_single_user=True)):\n        self._initialize()\n        self._mode = mode\n        self._test_account = AppTestAccount(self.ACCOUNT, self._tmp_dir.name)\n\n        yield self._test_account.start()\n\n        self.cleanup = lambda: self._tmp_dir.dissolve()\n\n        # copy fields for single user tests\n        self.soledad = self._test_account.soledad\n        self.search_engine = self._test_account.search_engine\n        self.keymanager = self._test_account.keymanager\n        self.mail_sender = self._test_account.mail_sender\n        self.mail_store = self._test_account.mail_store\n        self.attachment_store = self._test_account.attachment_store\n        self.draft_service = self._test_account.draft_service\n        self.leap_session = self._test_account.leap_session\n        self.feedback_service = self._test_account.feedback_service\n        self.mail_service = self._test_account.mail_service\n        self.account = self._test_account.account\n\n        if mode.is_single_user:\n            self.service_factory = SingleUserServicesFactory(mode)\n            services = self._test_account.services\n            self.service_factory.add_session('someuserid', services)\n\n            self.resource = RootResource(self.service_factory)\n            self.resource.initialize()\n        else:\n            self.service_factory = StubServicesFactory(self.accounts, mode)\n            provider = mock()\n            provider.config = LeapConfig(self._tmp_dir.name)\n\n            self.resource = set_up_protected_resources(RootResource(self.service_factory), provider, self.service_factory, checker=StubSRPChecker(provider))\n\n    @defer.inlineCallbacks\n    def create_user(self, account_name):\n        if self._mode.is_single_user:\n            raise Exception('Not supported in single user mode')\n\n        account = AppTestAccount(account_name, self._tmp_dir.name)\n        yield account.start()\n\n        self.accounts[account_name] = account\n\n    def _render(self, request, as_json=True):\n        def get_str(_str):\n            return json.loads(_str) if as_json else _str\n\n        def get_request_written_data(_=None):\n            written_data = request.getWrittenData()\n            if written_data:\n                return get_str(written_data)\n\n        resource = getChildForRequest(self.resource, request)\n        result = resource.render(request)\n\n        if isinstance(result, basestring):\n            return get_str(result), request\n\n        # result is NOT_DONE_YET\n        d = succeed(request) if request.finished else request.notifyFinish()\n        d.addCallback(get_request_written_data)\n        return d, request\n\n    def listenTCP(self, port=4567, host='127.0.0.1'):\n        reactor.listenTCP(port, PixelatedSite(self.resource), interface=host)\n\n    def run_on_a_thread(self, logfile='/tmp/app_test_client.log', port=4567, host='127.0.0.1'):\n        def _start():\n            self.listenTCP(port, host)\n            reactor.run()\n        process = multiprocessing.Process(target=_start)\n        process.start()\n        time.sleep(1)\n        return lambda: process.terminate()\n\n    def stop(self):\n        reactor.stop()\n\n    def get(self, path, get_args='', as_json=True, ajax=True, csrf='token'):\n        request = request_mock(path, ajax=ajax, csrf=csrf)\n        request.args = get_args\n        return self._render(request, as_json)\n\n    def post(self, path, body='', headers=None, ajax=True, csrf='token'):\n        headers = headers or {'Content-Type': 'application/json'}\n        request = request_mock(path=path, method=\"POST\", body=body, headers=headers, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def put(self, path, body, ajax=True, csrf='token'):\n        request = request_mock(path=path, method=\"PUT\", body=body, headers={'Content-Type': ['application/json']}, ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    def delete(self, path, body=\"\", ajax=True, csrf='token'):\n        request = request_mock(path=path, body=body, headers={'Content-Type': ['application/json']}, method=\"DELETE\", ajax=ajax, csrf=csrf)\n        return self._render(request)\n\n    @defer.inlineCallbacks\n    def add_mail_to_inbox(self, input_mail):\n        mail = yield self.mail_store.add_mail('INBOX', input_mail.raw)\n        defer.returnValue(mail)\n\n    def account_for(self, username):\n        return self.accounts[username]\n\n    def add_mail_to_user_inbox(self, input_mail, username):\n        return self.account_for(username).mail_store.add_mail('INBOX', input_mail.raw)\n\n    @defer.inlineCallbacks\n    def add_multiple_to_mailbox(self, num, mailbox='', flags=[], tags=[], to='recipient@to.com', cc='recipient@cc.com', bcc='recipient@bcc.com'):\n        mails = []\n        yield self.mail_store.add_mailbox(mailbox)\n        for _ in range(num):\n            builder = MailBuilder().with_status(flags).with_tags(tags).with_to(to).with_cc(cc).with_bcc(bcc)\n            builder.with_body(str(random.random()))\n            input_mail = builder.build_input_mail()\n            mail = yield self.mail_store.add_mail(mailbox, input_mail.raw)\n            if tags:\n                mail.tags |= set(tags)\n            if flags:\n                for flag in flags:\n                    mail.flags.add(flag)\n            if tags or flags:\n                yield self.mail_store.update_mail(mail)\n            mails.append(mail)\n\n        defer.returnValue(mails)\n\n    def _create_mail_sender(self):\n        mail_sender = Mock()\n        mail_sender.sendmail.side_effect = lambda mail: succeed(mail)\n        return mail_sender\n\n    def _generate_soledad_test_folder_name(self, soledad_test_folder='/tmp/soledad-test/test'):\n        return os.path.join(soledad_test_folder, str(uuid.uuid4()))\n\n    def get_mails_by_tag(self, tag, page=1, window=100):\n        tags = 'tag:%s' % tag\n        return self.search(tags, page, window)\n\n    @defer.inlineCallbacks\n    def search(self, query, page=1, window=100):\n        res, _ = self.get(\"/mails\", {\n            'q': [query],\n            'w': [str(window)],\n            'p': [str(page)]\n        })\n        res = yield res\n        defer.returnValue([ResponseMail(m) for m in res['mails']])\n\n    @defer.inlineCallbacks\n    def get_mails_by_mailbox_name(self, mbox_name):\n        mail_ids = yield self.mail_store.get_mailbox_mail_ids(mbox_name)\n        mails = yield self.mail_store.get_mails(mail_ids)\n        defer.returnValue(mails)\n\n    @defer.inlineCallbacks\n    def get_attachment(self, ident, encoding, filename=None, content_type=None, ajax=True, csrf='token'):\n        params = {'encoding': [encoding]}\n        if filename:\n            params['filename'] = [filename]\n        if content_type:\n            params['content_type'] = [content_type]\n        deferred_result, req = self.get(\"/attachment/%s\" % ident, params, as_json=False, ajax=ajax, csrf=csrf)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    @defer.inlineCallbacks\n    def post_attachment(self, data, headers):\n        deferred_result, req = self.post('/attachment', body=data, headers=headers)\n        res = yield deferred_result\n        defer.returnValue((res, req))\n\n    def put_mail(self, data):\n        res, req = self.put('/mails', data)\n        return res, req\n\n    def post_tags(self, mail_ident, tags_json):\n        res, req = self.post(\"/mail/%s/tags\" % mail_ident, tags_json)\n        return res\n\n    def get_tags(self, **kwargs):\n        res, req = self.get('/tags', kwargs)\n        return res\n\n    def get_mail(self, mail_ident):\n        res, req = self.get('/mail/%s' % mail_ident)\n        return res\n\n    def delete_mail(self, mail_ident):\n        res, req = self.delete(\"/mail/%s\" % mail_ident)\n        return res\n\n    def delete_mails(self, idents):\n        res, req = self.post(\"/mails/delete\", json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_unread(self, idents):\n        res, req = self.post('/mails/unread', json.dumps({'idents': idents}))\n        return res\n\n    def mark_many_as_read(self, idents):\n        res, req = self.post('/mails/read', json.dumps({'idents': idents}))\n        return res\n\n    def get_contacts(self, query):\n        res, req = self.get('/contacts', get_args={'q': query})\n        return res\n\n\n@defer.inlineCallbacks\ndef initialize_soledad(tempdir, uuid):\n    if os.path.isdir(tempdir):\n        shutil.rmtree(tempdir)\n\n    passphrase = u\"verysecretpassphrase\"\n    secret_path = os.path.join(tempdir, \"secret.gpg\")\n    local_db_path = os.path.join(tempdir, \"soledad.u1db\")\n    server_url = \"http://provider\"\n    cert_file = \"\"\n\n    class MockSharedDB(object):\n        get_doc = Mock(return_value=None)\n        put_doc = Mock()\n        lock = Mock(return_value=('atoken', 300))\n        unlock = Mock(return_value=True)\n        close = Mock()\n\n        def __call__(self):\n            return self\n\n    Soledad._shared_db = MockSharedDB()\n\n    _soledad = Soledad(\n        uuid,\n        passphrase,\n        secret_path,\n        local_db_path,\n        server_url,\n        cert_file,\n        defer_encryption=False,\n        syncable=False)\n\n    yield SoledadMailAdaptor().initialize_store(_soledad)\n\n    defer.returnValue(_soledad)\n/n/n/n", "label": 0}, {"id": "dbb434b56e6b161a3b851ae6a81f96dff14a29da", "code": "/service/test/functional/features/environment.py/n/n#\n# Copyright (c) 2014 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport logging\nimport uuid\n\nfrom crochet import setup, wait_for\nfrom leap.common.events.server import ensure_server\nfrom twisted.internet import defer\n\nfrom pixelated.application import UserAgentMode\nfrom pixelated.config.site import PixelatedSite\nfrom test.support.dispatcher.proxy import Proxy\nfrom test.support.integration import AppTestClient\nfrom selenium import webdriver\n\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom steps.common import *\nimport os\n\nsetup()\n\n\n@wait_for(timeout=5.0)\ndef start_app_test_client(client, mode):\n    return client.start_client(mode=mode)\n\n\ndef before_all(context):\n    ensure_server()\n    logging.disable('INFO')\n    PixelatedSite.disable_csp_requests()\n    client = AppTestClient()\n    start_app_test_client(client, UserAgentMode(is_single_user=True))\n    client.listenTCP()\n    proxy = Proxy(proxy_port='8889', app_port='4567')\n    FeaturesResource.DISABLED_FEATURES.append('autoRefresh')\n    context.client = client\n    context.call_to_terminate_proxy = proxy.run_on_a_thread()\n\n    multi_user_client = AppTestClient()\n    start_app_test_client(multi_user_client, UserAgentMode(is_single_user=False))\n    multi_user_client.listenTCP(port=MULTI_USER_PORT)\n    context.multi_user_client = multi_user_client\n\n\ndef after_all(context):\n    context.call_to_terminate_proxy()\n\n\ndef before_feature(context, feature):\n    # context.browser = webdriver.Chrome()\n    # context.browser = webdriver.Firefox()\n    context.browser = webdriver.PhantomJS()\n    context.browser.set_window_size(1280, 1024)\n    context.browser.implicitly_wait(DEFAULT_IMPLICIT_WAIT_TIMEOUT_IN_S)\n    context.browser.set_page_load_timeout(60)  # wait for data\n    context.browser.get(HOMEPAGE_URL)\n\n\ndef after_step(context, step):\n    if step.status == 'failed':\n        id = str(uuid.uuid4())\n        os.chdir(\"screenshots\")\n        context.browser.save_screenshot('failed ' + str(step.name) + '_' + id + \".png\")\n        save_source(context, 'failed ' + str(step.name) + '_' + id + \".html\")\n        os.chdir(\"../\")\n\n\ndef after_feature(context, feature):\n    context.browser.quit()\n\n    cleanup_all_mails(context)\n    context.last_mail = None\n\n\n@wait_for(timeout=10.0)\ndef cleanup_all_mails(context):\n    @defer.inlineCallbacks\n    def _delete_all_mails():\n        mails = yield context.client.mail_store.all_mails()\n        for mail in mails:\n            yield context.client.mail_store.delete_mail(mail.ident)\n\n    return _delete_all_mails()\n\n\ndef save_source(context, filename='/tmp/source.html'):\n    with open(filename, 'w') as out:\n        out.write(context.browser.page_source.encode('utf8'))\n/n/n/n", "label": 1}, {"id": "85094ff8caac585cbff260fe89a6f21df241fd47", "code": "service/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport hashlib\nimport json\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.sandbox_resource import SandboxResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.static import File\n\nfrom pixelated.resources.users import UsersResource\n\nCSRF_TOKEN_LENGTH = 32\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self._child_resources = ChildResourcesMap()\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if self._is_xsrf_valid(request):\n            if self._mode == MODE_RUNNING:\n                return self._child_resources.get(path)\n            else:\n                return UnavailableResource()\n        return UnAuthorizedResource()\n\n    def _is_xsrf_valid(self, request):\n        xsrf_token = request.getCookie('XSRF-TOKEN')\n\n        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')\n        if ajax_request:\n            xsrf_header = xsrf_token or request.getHeader('x-xsrf-token')\n            return xsrf_header and xsrf_header == xsrf_token\n\n        get_request = (request.method == 'GET')\n        if get_request:\n            return True\n\n        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]\n        return csrf_input and csrf_input == xsrf_token\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self._child_resources.add('sandbox', SandboxResource(self._static_folder))\n        self._child_resources.add('assets', File(self._static_folder))\n        self._child_resources.add('keys', KeysResource(self._services_factory))\n        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self._child_resources.add('contacts', ContactsResource(self._services_factory))\n        self._child_resources.add('features', FeaturesResource(portal))\n        self._child_resources.add('tags', TagsResource(self._services_factory))\n        self._child_resources.add('mails', MailsResource(self._services_factory))\n        self._child_resources.add('mail', MailResource(self._services_factory))\n        self._child_resources.add('feedback', FeedbackResource(self._services_factory))\n        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))\n        self._child_resources.add('users', UsersResource(self._services_factory))\n        self._child_resources.add(LoginResource.BASE_URL,\n                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def _add_csrf_cookie(self, request):\n        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()\n        request.addCookie('XSRF-TOKEN', csrf_token)\n\n    def render_GET(self, request):\n        self._add_csrf_cookie(request)\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n\n\nclass ChildResourcesMap(object):\n    def __init__(self):\n        self._registry = {}\n\n    def add(self, path, resource):\n        self._registry[path] = resource\n\n    def get(self, path):\n        return self._registry.get(path)\n/n/n/n", "label": 0}, {"id": "85094ff8caac585cbff260fe89a6f21df241fd47", "code": "/service/pixelated/resources/root_resource.py/n/n#\n# Copyright (c) 2016 ThoughtWorks, Inc.\n#\n# Pixelated is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Pixelated is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with Pixelated. If not, see <http://www.gnu.org/licenses/>.\nimport hashlib\nimport json\nimport os\nfrom string import Template\n\nfrom pixelated.resources import BaseResource, UnAuthorizedResource, UnavailableResource\nfrom pixelated.resources.attachments_resource import AttachmentsResource\nfrom pixelated.resources.sandbox_resource import SandboxResource\nfrom pixelated.resources.contacts_resource import ContactsResource\nfrom pixelated.resources.features_resource import FeaturesResource\nfrom pixelated.resources.feedback_resource import FeedbackResource\nfrom pixelated.resources.login_resource import LoginResource\nfrom pixelated.resources.logout_resource import LogoutResource\nfrom pixelated.resources.user_settings_resource import UserSettingsResource\nfrom pixelated.resources.mail_resource import MailResource\nfrom pixelated.resources.mails_resource import MailsResource\nfrom pixelated.resources.tags_resource import TagsResource\nfrom pixelated.resources.keys_resource import KeysResource\nfrom twisted.web.static import File\n\nfrom pixelated.resources.users import UsersResource\n\nCSRF_TOKEN_LENGTH = 32\n\nMODE_STARTUP = 1\nMODE_RUNNING = 2\n\n\nclass RootResource(BaseResource):\n    def __init__(self, services_factory):\n        BaseResource.__init__(self, services_factory)\n        self._startup_assets_folder = self._get_startup_folder()\n        self._static_folder = self._get_static_folder()\n        self._html_template = open(os.path.join(self._static_folder, 'index.html')).read()\n        self._services_factory = services_factory\n        self._child_resources = ChildResourcesMap()\n        self._startup_mode()\n\n    def _startup_mode(self):\n        self.putChild('startup-assets', File(self._startup_assets_folder))\n        self._mode = MODE_STARTUP\n\n    def getChild(self, path, request):\n        if path == '':\n            return self\n        if self._is_xsrf_valid(request):\n            if self._mode == MODE_RUNNING:\n                return self._child_resources.get(path)\n            else:\n                return UnavailableResource()\n        return UnAuthorizedResource()\n\n    def _is_xsrf_valid(self, request):\n        xsrf_token = request.getCookie('XSRF-TOKEN')\n\n        ajax_request = (request.getHeader('x-requested-with') == 'XMLHttpRequest')\n        if ajax_request:\n            xsrf_header = request.getHeader('x-xsrf-token')\n            return xsrf_header and xsrf_header == xsrf_token\n\n        get_request = (request.method == 'GET')\n        if get_request:\n            return True\n\n        csrf_input = request.args.get('csrftoken', [None])[0] or json.loads(request.content.read()).get('csrftoken', [None])[0]\n        return csrf_input and csrf_input == xsrf_token\n\n    def initialize(self, portal=None, disclaimer_banner=None):\n        self._child_resources.add('sandbox', SandboxResource(self._static_folder))\n        self._child_resources.add('assets', File(self._static_folder))\n        self._child_resources.add('keys', KeysResource(self._services_factory))\n        self._child_resources.add(AttachmentsResource.BASE_URL, AttachmentsResource(self._services_factory))\n        self._child_resources.add('contacts', ContactsResource(self._services_factory))\n        self._child_resources.add('features', FeaturesResource(portal))\n        self._child_resources.add('tags', TagsResource(self._services_factory))\n        self._child_resources.add('mails', MailsResource(self._services_factory))\n        self._child_resources.add('mail', MailResource(self._services_factory))\n        self._child_resources.add('feedback', FeedbackResource(self._services_factory))\n        self._child_resources.add('user-settings', UserSettingsResource(self._services_factory))\n        self._child_resources.add('users', UsersResource(self._services_factory))\n        self._child_resources.add(LoginResource.BASE_URL,\n                                  LoginResource(self._services_factory, portal, disclaimer_banner=disclaimer_banner))\n        self._child_resources.add(LogoutResource.BASE_URL, LogoutResource(self._services_factory))\n\n        self._mode = MODE_RUNNING\n\n    def _get_startup_folder(self):\n        path = os.path.dirname(os.path.abspath(__file__))\n        return os.path.join(path, '..', 'assets')\n\n    def _get_static_folder(self):\n        static_folder = os.path.abspath(os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        # this is a workaround for packaging\n        if not os.path.exists(static_folder):\n            static_folder = os.path.abspath(\n                os.path.join(os.path.abspath(__file__), \"..\", \"..\", \"..\", \"..\", \"web-ui\", \"app\"))\n        if not os.path.exists(static_folder):\n            static_folder = os.path.join('/', 'usr', 'share', 'pixelated-user-agent')\n        return static_folder\n\n    def _is_starting(self):\n        return self._mode == MODE_STARTUP\n\n    def _add_csrf_cookie(self, request):\n        csrf_token = hashlib.sha256(os.urandom(CSRF_TOKEN_LENGTH)).hexdigest()\n        request.addCookie('XSRF-TOKEN', csrf_token)\n\n    def render_GET(self, request):\n        self._add_csrf_cookie(request)\n        if self._is_starting():\n            return open(os.path.join(self._startup_assets_folder, 'Interstitial.html')).read()\n        else:\n            account_email = self.mail_service(request).account_email\n            response = Template(self._html_template).safe_substitute(account_email=account_email)\n            return str(response)\n\n\nclass ChildResourcesMap(object):\n    def __init__(self):\n        self._registry = {}\n\n    def add(self, path, resource):\n        self._registry[path] = resource\n\n    def get(self, path):\n        return self._registry.get(path)\n/n/n/n", "label": 1}, {"id": "a1548fa1586bce586c9cf06bf8dd7bf26cc6c212", "code": "cornice/tests/test_validation.py/n/n# ***** BEGIN LICENSE BLOCK *****\n# Version: MPL 1.1/GPL 2.0/LGPL 2.1\n#\n# The contents of this file are subject to the Mozilla Public License Version\n# 1.1 (the \"License\"); you may not use this file except in compliance with\n# the License. You may obtain a copy of the License at\n# http://www.mozilla.org/MPL/\n#\n# Software distributed under the License is distributed on an \"AS IS\" basis,\n# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n# for the specific language governing rights and limitations under the\n# License.\n#\n# The Original Code is Cornice (Sagrada)\n#\n# The Initial Developer of the Original Code is the Mozilla Foundation.\n# Portions created by the Initial Developer are Copyright (C) 2011\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Tarek Ziade (tarek@mozilla.com)\n#   Alexis Metaireau (alexis@mozilla.com)\n#\n# Alternatively, the contents of this file may be used under the terms of\n# either the GNU General Public License Version 2 or later (the \"GPL\"), or\n# the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n# in which case the provisions of the GPL or the LGPL are applicable instead\n# of those above. If you wish to allow use of your version of this file only\n# under the terms of either the GPL or the LGPL, and not to allow others to\n# use your version of this file under the terms of the MPL, indicate your\n# decision by deleting the provisions above and replace them with the notice\n# and other provisions required by the GPL or the LGPL. If you do not delete\n# the provisions above, a recipient may use your version of this file under\n# the terms of any one of the MPL, the GPL or the LGPL.\n#\n# ***** END LICENSE BLOCK *****\nimport unittest\nimport simplejson as json\n\nfrom webtest import TestApp\nfrom pyramid.response import Response\n\nfrom cornice.tests.validationapp import main, _json\nfrom cornice.tests.support import LoggingCatcher\nfrom cornice.schemas import Errors\nfrom cornice.validators import filter_json_xsrf\n\n\nclass TestServiceDefinition(LoggingCatcher, unittest.TestCase):\n\n    def test_validation(self):\n        app = TestApp(main({}))\n        app.get('/service', status=400)\n\n        res = app.post('/service', params='buh', status=400)\n        self.assertTrue('Not a json body' in res.body)\n\n        res = app.post('/service', params=json.dumps('buh'))\n\n        self.assertEqual(res.body, json.dumps({'body': '\"buh\"'}))\n\n        app.get('/service?paid=yup')\n\n        # valid = foo is one\n        res = app.get('/service?foo=1&paid=yup')\n        self.assertEqual(res.json['foo'], 1)\n\n        # invalid value for foo\n        res = app.get('/service?foo=buh&paid=yup', status=400)\n\n        # check that json is returned\n        errors = Errors.from_json(res.body)\n        self.assertEqual(len(errors), 1)\n\n        # the \"apidocs\" registry entry contains all the needed information\n        # to build up documentation\n        # in this case, this means the function is registered and the argument\n        # of the service are defined (e.g \"validator\" is set)\n        apidocs = app.app.registry.settings['apidocs']\n\n        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])\n\n    def test_accept(self):\n        # tests that the accept headers are handled the proper way\n        app = TestApp(main({}))\n\n        # requesting the wrong accept header should return a 406 ...\n        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)\n\n        # ... with the list of accepted content-types\n        self.assertTrue('application/json' in res.json)\n        self.assertTrue('text/json' in res.json)\n\n        app.get('/service2', headers={'Accept': 'application/*'}, status=200)\n\n        # it should also work with multiple Accept headers\n        app.get('/service2', headers={'Accept': 'audio/*, application/*'},\n                status=200)\n\n        # test that using a callable to define what's accepted works as well\n        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)\n        self.assertTrue('text/json' in res.json)\n\n        app.get('/service3', headers={'Accept': 'text/*'}, status=200)\n\n        # if we are not asking for a particular content-type, everything\n        # should work just fine\n        app.get('/service2', status=200)\n\n    def test_filters(self):\n        app = TestApp(main({}))\n\n        # filters can be applied to all the methods of a service\n        self.assertTrue(\"filtered response\" in app.get('/filtered').body)\n        self.assertTrue(\"unfiltered\" in app.post('/filtered').body)\n\n    def test_json_xsrf(self):\n        # a view returning a json list should issue a warning\n        resp = Response(json.dumps(('value1', 'value2')))\n        resp.status = 200\n        resp.content_type = 'application/json'\n        filter_json_xsrf(resp)\n        self.assertEquals(len(self.get_logs()), 1)\n/n/n/ncornice/validators.py/n/nimport logging\nimport re\n\nlog = logging.getLogger('cornice')\n\n\ndef filter_json_xsrf(response):\n    \"\"\"drops a warning if a service is returning a json array.\n\n    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info\n    on this\n    \"\"\"\n    if response.content_type in ('application/json', 'text/json'):\n        if re.match(r'[\\(\\[).*[\\)\\]]', response.body):\n            log.warn(\"returning a json array is a potential security whole, \"\n                     \"please ensure you really want to do this. See \"\n                     \"http://wiki.pylonshq.com/display/pylonsfaq/Warnings \"\n                     \"for more info\")\n    return response\n\n\nDEFAULT_VALIDATORS = []\nDEFAULT_FILTERS = [filter_json_xsrf, ]\n/n/n/n", "label": 0}, {"id": "a1548fa1586bce586c9cf06bf8dd7bf26cc6c212", "code": "/cornice/tests/test_validation.py/n/n# ***** BEGIN LICENSE BLOCK *****\n# Version: MPL 1.1/GPL 2.0/LGPL 2.1\n#\n# The contents of this file are subject to the Mozilla Public License Version\n# 1.1 (the \"License\"); you may not use this file except in compliance with\n# the License. You may obtain a copy of the License at\n# http://www.mozilla.org/MPL/\n#\n# Software distributed under the License is distributed on an \"AS IS\" basis,\n# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n# for the specific language governing rights and limitations under the\n# License.\n#\n# The Original Code is Cornice (Sagrada)\n#\n# The Initial Developer of the Original Code is the Mozilla Foundation.\n# Portions created by the Initial Developer are Copyright (C) 2011\n# the Initial Developer. All Rights Reserved.\n#\n# Contributor(s):\n#   Tarek Ziade (tarek@mozilla.com)\n#   Alexis Metaireau (alexis@mozilla.com)\n#\n# Alternatively, the contents of this file may be used under the terms of\n# either the GNU General Public License Version 2 or later (the \"GPL\"), or\n# the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n# in which case the provisions of the GPL or the LGPL are applicable instead\n# of those above. If you wish to allow use of your version of this file only\n# under the terms of either the GPL or the LGPL, and not to allow others to\n# use your version of this file under the terms of the MPL, indicate your\n# decision by deleting the provisions above and replace them with the notice\n# and other provisions required by the GPL or the LGPL. If you do not delete\n# the provisions above, a recipient may use your version of this file under\n# the terms of any one of the MPL, the GPL or the LGPL.\n#\n# ***** END LICENSE BLOCK *****\nimport unittest\nimport simplejson as json\n\nfrom webtest import TestApp\nfrom cornice.tests.validationapp import main, _json\nfrom cornice.schemas import Errors\n\n\nclass TestServiceDefinition(unittest.TestCase):\n\n    def test_validation(self):\n        app = TestApp(main({}))\n        app.get('/service', status=400)\n\n        res = app.post('/service', params='buh', status=400)\n        self.assertTrue('Not a json body' in res.body)\n\n        res = app.post('/service', params=json.dumps('buh'))\n\n        self.assertEqual(res.body, json.dumps({'body': '\"buh\"'}))\n\n        app.get('/service?paid=yup')\n\n        # valid = foo is one\n        res = app.get('/service?foo=1&paid=yup')\n        self.assertEqual(res.json['foo'], 1)\n\n        # invalid value for foo\n        res = app.get('/service?foo=buh&paid=yup', status=400)\n\n        # check that json is returned\n        errors = Errors.from_json(res.body)\n        self.assertEqual(len(errors), 1)\n\n        # the \"apidocs\" registry entry contains all the needed information\n        # to build up documentation\n        # in this case, this means the function is registered and the argument\n        # of the service are defined (e.g \"validator\" is set)\n        apidocs = app.app.registry.settings['apidocs']\n\n        self.assertTrue(_json in apidocs[('/service', 'POST')]['validators'])\n\n    def test_accept(self):\n        # tests that the accept headers are handled the proper way\n        app = TestApp(main({}))\n\n        # requesting the wrong accept header should return a 406 ...\n        res = app.get('/service2', headers={'Accept': 'audio/*'}, status=406)\n\n        # ... with the list of accepted content-types\n        self.assertTrue('application/json' in res.json)\n        self.assertTrue('text/json' in res.json)\n\n        app.get('/service2', headers={'Accept': 'application/*'}, status=200)\n\n        # it should also work with multiple Accept headers\n        app.get('/service2', headers={'Accept': 'audio/*, application/*'},\n                status=200)\n\n        # test that using a callable to define what's accepted works as well\n        res = app.get('/service3', headers={'Accept': 'audio/*'}, status=406)\n        self.assertTrue('text/json' in res.json)\n\n        app.get('/service3', headers={'Accept': 'text/*'}, status=200)\n\n        # if we are not asking for a particular content-type, everything\n        # should work just fine\n        app.get('/service2', status=200)\n\n    def test_filters(self):\n        app = TestApp(main({}))\n\n        # filters can be applied to all the methods of a service\n        self.assertTrue(\"filtered response\" in app.get('/filtered').body)\n        self.assertTrue(\"unfiltered\" in app.post('/filtered').body)\n/n/n/n/cornice/validators.py/n/nimport json\nimport logging\n\nlog = logging.getLogger(__name__)\n\n\ndef filter_json_xsrf(response):\n    \"\"\"drops a warning if a service is returning a json array.\n\n    See http://wiki.pylonshq.com/display/pylonsfaq/Warnings for more info\n    on this\n    \"\"\"\n    if response.content_type in ('application/json', 'text/json'):\n        try:\n            content = json.loads(response.body)\n            if isinstance(content, (list, tuple)):\n                log.warn(\"returning a json array is a potential security whole, \"\n                         \"please ensure you really want to do this. See \"\n                         \"http://wiki.pylonshq.com/display/pylonsfaq/Warnings \"\n                         \"for more info\")\n        except:\n            pass\n    return response\n\n\nDEFAULT_VALIDATORS = []\nDEFAULT_FILTERS = [filter_json_xsrf, ]\n/n/n/n", "label": 1}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "notebook/auth/login.py/n/n\"\"\"Tornado handlers for logging into the notebook.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\n\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\nimport uuid\n\nfrom tornado.escape import url_escape\n\nfrom ..auth.security import passwd_check\n\nfrom ..base.handlers import IPythonHandler\n\n\nclass LoginHandler(IPythonHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        if not url.startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if '://' in url:\n                # if full URL, run our cross-origin check:\n                parsed = urlparse(url.lower())\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        if self.get_login_available(self.settings):\n            if passwd_check(self.hashed_password, typed_password):\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid password'})\n                return\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n        \n        Origin check should be skipped for token-authenticated requests.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n    \n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Check if the handler has been authenticated by a token.\n        \n        This is used to signal certain things, such as:\n        \n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            user_id = handler.get_secure_cookie(handler.cookie_name)\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that we've been authenticated with a token.\n            # Used in should_check_origin above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # prevent extra Invalid cookie sig warnings:\n            handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        one_time_token = handler.one_time_token\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n        elif one_time_token and user_token == one_time_token:\n            # one-time-token-authenticated, only allow this token once\n            handler.settings.pop('one_time_token', None)\n            handler.log.info(\"Accepting one-time-token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the notebook application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The notebook server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n/n/n/nnotebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 0}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def check_xsrf_cookie(self):\n        \"\"\"Check non-empty body on POST for XSRF\n\n        instead of checking the cookie for forms.\n        \"\"\"\n        if self.request.method.upper() == 'POST' and not self.request.body:\n            # Require non-empty POST body for XSRF\n            raise web.HTTPError(400, \"POST requests must have a JSON body. If no content is needed, use '{}'.\")\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8\n\"\"\"A tornado based Jupyter notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport binascii\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport mimetypes\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport sys\nimport threading\nimport warnings\nimport webbrowser\n\ntry: #PY3\n    from base64 import encodebytes\nexcept ImportError: #PY2\n    from base64 import encodestring as encodebytes\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The Jupyter Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.httputil import url_concat\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\n\n# py23 compatibility\ntry:\n    raw_input = raw_input\nexcept NameError:\n    raw_input = input\n\nfrom .base.handlers import Template404, RedirectWithParams\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type, Float, observe, default, validate\n)\nfrom ipython_genutils import py3compat\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid, url_escape\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\njupyter notebook                       # start the notebook\njupyter notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\nDEV_NOTE_NPM = \"\"\"It looks like you're running the notebook from source.\nIf you're working on the Javascript of the notebook, try running\n\n    npm run build:watch\n\nin another terminal window to have the system incrementally\nwatch and build the notebook's JavaScript for you, as you make changes.\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, jupyter_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        # If the user is running the notebook in a git directory, make the assumption\n        # that this is a dev install and suggest to the developer `npm run build:watch`.\n        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))\n        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))\n        if dev_mode:\n            log.info(DEV_NOTE_NPM)\n\n        settings = self.init_settings(\n            jupyter_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, jupyter_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            jupyter_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        if jupyter_app.ignore_minified_js:\n            log.warning(\"\"\"The `ignore_minified_js` flag is deprecated and no \n                longer works.  Alternatively use `npm run build:watch` when\n                working on the notebook's Javascript and LESS\"\"\")\n            warnings.warn(\"The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0\", DeprecationWarning)\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=jupyter_app.static_file_path,\n            static_custom_path=jupyter_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=jupyter_app.ignore_minified_js,\n            \n            # rate limits\n            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,\n            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,\n            rate_limit_window=jupyter_app.rate_limit_window,\n            \n            # authentication\n            cookie_secret=jupyter_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=jupyter_app.login_handler_class,\n            logout_handler_class=jupyter_app.logout_handler_class,\n            password=jupyter_app.password,\n            xsrf_cookies=True,\n            disable_check_xsrf=ipython_app.disable_check_xsrf,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=jupyter_app.jinja_template_vars,\n            nbextensions_path=jupyter_app.nbextensions_path,\n            websocket_url=jupyter_app.websocket_url,\n            mathjax_url=jupyter_app.mathjax_url,\n            mathjax_config=jupyter_app.mathjax_config,\n            config=jupyter_app.config,\n            config_dir=jupyter_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('bundler.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        # TODO: Remove on notebook 5.0\n        widgets = None\n        try:\n            import widgetsnbextension\n        except:\n            try:\n                import ipywidgets as widgets\n                handlers.append(\n                    (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                        'path': widgets.find_static_assets(),\n                        'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                    }),\n                )\n            except:\n                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', RedirectWithParams, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                url = serverinfo['url']\n                if serverinfo.get('token'):\n                    url = url + '?token=%s' % serverinfo['token']\n                print(url, \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\nflags['allow-root']=(\n    {'NotebookApp' : {'allow_root' : True}},\n    \"Allow the notebook to be run from root user.\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'client-ca': 'NotebookApp.client_ca',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    @default('log_level')\n    def _default_log_level(self):\n        return logging.INFO\n\n    @default('log_datefmt')\n    def _default_log_datefmt(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    @default('log_format')\n    def _default_log_format(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    allow_root = Bool(False, config=True, \n        help=\"Whether to allow the user to run the notebook as root.\"\n    )\n\n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n\n    @default('ip')\n    def _default_ip(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warning(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    @validate('ip')\n    def _valdate_ip(self, proposal):\n        value = proposal['value']\n        if value == u'*':\n            value = u''\n        return value\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    client_ca = Unicode(u'', config=True,\n        help=\"\"\"The full path to a certificate authority certificate for SSL/TLS client authentication.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n\n    @default('cookie_secret_file')\n    def _default_cookie_secret_file(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    \n    @default('cookie_secret')\n    def _default_cookie_secret(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = encodebytes(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warning(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    token = Unicode('<generated>',\n        help=\"\"\"Token used for authenticating first-time connections to the server.\n\n        When no password is enabled,\n        the default is to generate a new, random token.\n\n        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.\n        \"\"\"\n    ).tag(config=True)\n\n    one_time_token = Unicode(\n        help=\"\"\"One-time token used for opening a browser.\n\n        Once used, this token cannot be used again.\n        \"\"\"\n    )\n\n    _token_generated = True\n\n    @default('token')\n    def _token_default(self):\n        if self.password:\n            # no token if password is enabled\n            self._token_generated = False\n            return u''\n        else:\n            self._token_generated = True\n            return binascii.hexlify(os.urandom(24)).decode('ascii')\n\n    @observe('token')\n    def _token_changed(self, change):\n        self._token_generated = False\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    password_required = Bool(False, config=True,\n                      help=\"\"\"Forces users to use a password for the Notebook server.\n                      This is useful in a multi user environment, for instance when\n                      everybody in the LAN can access each other's machine though ssh.\n\n                      In such a case, server the notebook server on localhost is not secure\n                      since any user can connect to the notebook server via ssh.\n\n                      \"\"\"\n\n    disable_check_xsrf = Bool(False, config=True,\n        help=\"\"\"Disable cross-site-request-forgery protection\n\n        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,\n        requiring API requests to either:\n\n        - originate from the (validated with XSRF cookie and token), or\n        - authenticate with a token\n\n        Some anonymous compute resources still desire the ability to run code,\n        completely without authentication.\n        These services can disable all authentication and security checks,\n        with the full knowledge of what that implies.\n        \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n\n    @observe('webapp_settings') \n    def _update_webapp_settings(self, change):\n        self.log.warning(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = change['new']\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    terminado_settings = Dict(config=True,\n            help='Supply overrides for terminado. Currently only supports \"shell_command\".')\n\n    cookie_options = Dict(config=True,\n        help=\"Extra keyword arguments to pass to `set_secure_cookie`.\"\n             \" See tornado's set_secure_cookie docs for details.\"\n    )\n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n\n    @observe('enable_mathjax')\n    def _update_enable_mathjax(self, change):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not change['new']:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n\n    @validate('base_url')\n    def _update_base_url(self, proposal):\n        value = proposal['value']\n        if not value.startswith('/'):\n            value = '/' + value\n        elif not value.endswith('/'):\n            value = value + '/'\n        return value\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n\n    @observe('base_project_url')\n    def _update_base_project_url(self, change):\n        self.log.warning(\"base_project_url is deprecated, use base_url\")\n        self.base_url = change['new']\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n\n    @default('static_custom_path')\n    def _default_static_custom_path(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path after a migration period\n        try:\n            from IPython.paths import get_ipython_dir\n        except ImportError:\n            pass\n        else:\n            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"A custom url for MathJax.js.\n        Should be in the form of a case-sensitive url to MathJax,\n        for example:  /static/components/MathJax/MathJax.js\n        \"\"\"\n    )\n\n    @default('mathjax_url')\n    def _default_mathjax_url(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\", \"static\")\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    @observe('mathjax_url')\n    def _update_mathjax_url(self, change):\n        new = change['new']\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    mathjax_config = Unicode(\"TeX-AMS-MML_HTMLorMML-full,Safe\", config=True,\n        help=\"\"\"The MathJax.js configuration file that is to be used.\"\"\"\n    )\n\n    @observe('mathjax_config')\n    def _update_mathjax_config(self, change):\n        self.log.info(\"Using MathJax configuration file: %s\", change['new'])\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    @default('info_file')\n    def _default_info_file(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n\n    @observe('pylab')\n    def _update_pylab(self, change):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if change['new'] != 'warn':\n            backend = ' %s' % change['new']\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    @default('notebook_dir')\n    def _default_notebook_dir(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    @validate('notebook_dir')\n    def _notebook_dir_validate(self, proposal):\n        value = proposal['value']\n        # Strip any trailing slashes\n        # *except* if it's root\n        _, path = os.path.splitdrive(value)\n        if path == os.sep:\n            return value\n        value = value.rstrip(os.sep)\n        if not os.path.isabs(value):\n            # If we receive a non-absolute path, make it absolute.\n            value = os.path.abspath(value)\n        if not os.path.isdir(value):\n            raise TraitError(\"No such notebook dir: %r\" % value)\n        return value\n\n    @observe('notebook_dir')\n    def _update_notebook_dir(self, change):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        new = change['new']\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    # TODO: Remove me in notebook 5.0\n    server_extensions = List(Unicode(), config=True,\n        help=(\"DEPRECATED use the nbserver_extensions dict instead\")\n    )\n    \n    @observe('server_extensions')\n    def _update_server_extensions(self, change):\n        self.log.warning(\"server_extensions is deprecated, use nbserver_extensions\")\n        self.server_extensions = change['new']\n        \n    nbserver_extensions = Dict({}, config=True,\n        help=(\"Dict of Python modules to load as notebook server extensions.\"\n              \"Entry values can be used to enable and disable the loading of\"\n              \"the extensions. The extensions will be loaded in alphabetical \"\n              \"order.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    iopub_msg_rate_limit = Float(1000, config=True, help=\"\"\"(msgs/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    iopub_data_rate_limit = Float(1000000, config=True, help=\"\"\"(bytes/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    rate_limit_window = Float(3, config=True, help=\"\"\"(sec) Time window used to \n        check the message and data rate limits.\"\"\")\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n\n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the config dirs.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        self.tornado_settings['cookie_options'] = self.cookie_options\n        self.tornado_settings['token'] = self.token\n        if (self.open_browser or self.file_to_run) and not self.password:\n            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')\n            self.tornado_settings['one_time_token'] = self.one_time_token\n\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n\n        if self.password_required and (not self.password):\n            self.log.critical(\"Notebook servers are configured to only be run with a password.\")\n            self.log.critical(\"Hint: run the following command to set a password\")\n            self.log.critical(\"\\t$ python -m notebook.auth password\")\n            sys.exit(1)\n\n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if self.client_ca:\n            ssl_options['ca_certs'] = self.client_ca\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # SSL may be missing, so only import it if it's to be used\n            import ssl\n            # Disable SSLv3 by default, since its use is discouraged.\n            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)\n            if ssl_options.get('ca_certs', False):\n                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)\n        \n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warning(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        url = self._url(ip)\n        if self.token:\n            # Don't log full token if it came from config\n            token = self.token if self._token_generated else '...'\n            url = url_concat(url, {'token': token})\n        return url\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warning\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        \n        # TODO: Remove me in notebook 5.0\n        for modulename in self.server_extensions:\n            # Don't override disable state of the extension if it already exist\n            # in the new traitlet\n            if not modulename in self.nbserver_extensions:\n                self.nbserver_extensions[modulename] = True\n        \n        for modulename in sorted(self.nbserver_extensions):\n            if self.nbserver_extensions[modulename]:\n                try:\n                    mod = importlib.import_module(modulename)\n                    func = getattr(mod, 'load_jupyter_server_extension', None)\n                    if func is not None:\n                        func(self)\n                except Exception:\n                    if self.reraise_server_extension_failures:\n                        raise\n                    self.log.warning(\"Error loading server extension %s\", modulename,\n                                  exc_info=True)\n\n    def init_mime_overrides(self):\n        # On some Windows machines, an application has registered an incorrect\n        # mimetype for CSS in the registry. Tornado uses this when serving\n        # .css files, causing browsers to reject the stylesheet. We know the\n        # mimetype always needs to be text/css, so we override it here.\n        mimetypes.add_type('text/css', '.css')\n\n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n        self.init_mime_overrides()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'token': self.token,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'password': bool(self.password),\n                'pid': os.getpid(),\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2, sort_keys=True)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n\n        if not self.allow_root:\n            # check if we are running as root, and abort if it's not allowed\n            try:\n                uid = os.geteuid()\n            except AttributeError:\n                uid = -1 # anything nonzero here, since we can't check UID assume non-root\n            if uid == 0:\n                self.log.critical(\"Running as root is not recommended. Use --allow-root to bypass.\")\n                self.exit(1)\n\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warning('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))\n            else:\n                # default_url contains base_url, but so does connection_url\n                uri = self.default_url[len(self.base_url):]\n            if self.one_time_token:\n                uri = url_concat(uri, {'token': self.one_time_token})\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n\n        if self.token and self._token_generated:\n            # log full URL with generated token, so there's a copy/pasteable link\n            # with auth info.\n            self.log.critical('\\n'.join([\n                '\\n',\n                'Copy/paste this URL into your browser when you connect for the first time,',\n                'to login with a token:',\n                '    %s' % url_concat(self.connection_url, {'token': self.token}),\n            ]))\n\n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.remove_server_info_file()\n            self.cleanup_kernels()\n\n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a runtime directory, find nbserver-* files in the security directory,\n    and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(os.path.join(runtime_dir, file))\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n/n/n/n", "label": 0}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "1c2a256addf7a5273a40963f92a6351e5d053ae0", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook._tz import utcnow\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        if user is None:\n            raise web.HTTPError(403)\n        return user\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if self._track_activity and self.get_current_user():\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers',\n                        'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n    \n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n]\n/n/n/n", "label": 0}, {"id": "1c2a256addf7a5273a40963f92a6351e5d053ae0", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook._tz import utcnow\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        if user is None:\n            raise web.HTTPError(403)\n        return user\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if self._track_activity and self.get_current_user():\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n    \n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n]\n/n/n/n", "label": 1}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "notebook/auth/login.py/n/n\"\"\"Tornado handlers for logging into the notebook.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\n\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\nimport uuid\n\nfrom tornado.escape import url_escape\n\nfrom ..auth.security import passwd_check\n\nfrom ..base.handlers import IPythonHandler\n\n\nclass LoginHandler(IPythonHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        if not url.startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if '://' in url:\n                # if full URL, run our cross-origin check:\n                parsed = urlparse(url.lower())\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        if self.get_login_available(self.settings):\n            if passwd_check(self.hashed_password, typed_password):\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid password'})\n                return\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n        \n        Origin check should be skipped for token-authenticated requests.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n    \n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Check if the handler has been authenticated by a token.\n        \n        This is used to signal certain things, such as:\n        \n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            user_id = handler.get_secure_cookie(handler.cookie_name)\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that we've been authenticated with a token.\n            # Used in should_check_origin above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # prevent extra Invalid cookie sig warnings:\n            handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        one_time_token = handler.one_time_token\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n        elif one_time_token and user_token == one_time_token:\n            # one-time-token-authenticated, only allow this token once\n            handler.settings.pop('one_time_token', None)\n            handler.log.info(\"Accepting one-time-token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the notebook application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The notebook server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n/n/n/nnotebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 0}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def check_xsrf_cookie(self):\n        \"\"\"Check non-empty body on POST for XSRF\n\n        instead of checking the cookie for forms.\n        \"\"\"\n        if self.request.method.upper() == 'POST' and not self.request.body:\n            # Require non-empty POST body for XSRF\n            raise web.HTTPError(400, \"POST requests must have a JSON body. If no content is needed, use '{}'.\")\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8\n\"\"\"A tornado based Jupyter notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport binascii\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport mimetypes\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport sys\nimport threading\nimport warnings\nimport webbrowser\n\ntry: #PY3\n    from base64 import encodebytes\nexcept ImportError: #PY2\n    from base64 import encodestring as encodebytes\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The Jupyter Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.httputil import url_concat\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\n\n# py23 compatibility\ntry:\n    raw_input = raw_input\nexcept NameError:\n    raw_input = input\n\nfrom .base.handlers import Template404, RedirectWithParams\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type, Float, observe, default, validate\n)\nfrom ipython_genutils import py3compat\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid, url_escape\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\njupyter notebook                       # start the notebook\njupyter notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\nDEV_NOTE_NPM = \"\"\"It looks like you're running the notebook from source.\nIf you're working on the Javascript of the notebook, try running\n\n    npm run build:watch\n\nin another terminal window to have the system incrementally\nwatch and build the notebook's JavaScript for you, as you make changes.\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, jupyter_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        # If the user is running the notebook in a git directory, make the assumption\n        # that this is a dev install and suggest to the developer `npm run build:watch`.\n        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))\n        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))\n        if dev_mode:\n            log.info(DEV_NOTE_NPM)\n\n        settings = self.init_settings(\n            jupyter_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, jupyter_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            jupyter_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        if jupyter_app.ignore_minified_js:\n            log.warning(\"\"\"The `ignore_minified_js` flag is deprecated and no \n                longer works.  Alternatively use `npm run build:watch` when\n                working on the notebook's Javascript and LESS\"\"\")\n            warnings.warn(\"The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0\", DeprecationWarning)\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=jupyter_app.static_file_path,\n            static_custom_path=jupyter_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=jupyter_app.ignore_minified_js,\n            \n            # rate limits\n            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,\n            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,\n            rate_limit_window=jupyter_app.rate_limit_window,\n            \n            # authentication\n            cookie_secret=jupyter_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=jupyter_app.login_handler_class,\n            logout_handler_class=jupyter_app.logout_handler_class,\n            password=jupyter_app.password,\n            xsrf_cookies=True,\n            disable_check_xsrf=ipython_app.disable_check_xsrf,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=jupyter_app.jinja_template_vars,\n            nbextensions_path=jupyter_app.nbextensions_path,\n            websocket_url=jupyter_app.websocket_url,\n            mathjax_url=jupyter_app.mathjax_url,\n            mathjax_config=jupyter_app.mathjax_config,\n            config=jupyter_app.config,\n            config_dir=jupyter_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('bundler.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        # TODO: Remove on notebook 5.0\n        widgets = None\n        try:\n            import widgetsnbextension\n        except:\n            try:\n                import ipywidgets as widgets\n                handlers.append(\n                    (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                        'path': widgets.find_static_assets(),\n                        'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                    }),\n                )\n            except:\n                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', RedirectWithParams, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                url = serverinfo['url']\n                if serverinfo.get('token'):\n                    url = url + '?token=%s' % serverinfo['token']\n                print(url, \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\nflags['allow-root']=(\n    {'NotebookApp' : {'allow_root' : True}},\n    \"Allow the notebook to be run from root user.\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'client-ca': 'NotebookApp.client_ca',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    @default('log_level')\n    def _default_log_level(self):\n        return logging.INFO\n\n    @default('log_datefmt')\n    def _default_log_datefmt(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    @default('log_format')\n    def _default_log_format(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    allow_root = Bool(False, config=True, \n        help=\"Whether to allow the user to run the notebook as root.\"\n    )\n\n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n\n    @default('ip')\n    def _default_ip(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warning(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    @validate('ip')\n    def _valdate_ip(self, proposal):\n        value = proposal['value']\n        if value == u'*':\n            value = u''\n        return value\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    client_ca = Unicode(u'', config=True,\n        help=\"\"\"The full path to a certificate authority certificate for SSL/TLS client authentication.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n\n    @default('cookie_secret_file')\n    def _default_cookie_secret_file(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    \n    @default('cookie_secret')\n    def _default_cookie_secret(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = encodebytes(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warning(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    token = Unicode('<generated>',\n        help=\"\"\"Token used for authenticating first-time connections to the server.\n\n        When no password is enabled,\n        the default is to generate a new, random token.\n\n        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.\n        \"\"\"\n    ).tag(config=True)\n\n    one_time_token = Unicode(\n        help=\"\"\"One-time token used for opening a browser.\n\n        Once used, this token cannot be used again.\n        \"\"\"\n    )\n\n    _token_generated = True\n\n    @default('token')\n    def _token_default(self):\n        if self.password:\n            # no token if password is enabled\n            self._token_generated = False\n            return u''\n        else:\n            self._token_generated = True\n            return binascii.hexlify(os.urandom(24)).decode('ascii')\n\n    @observe('token')\n    def _token_changed(self, change):\n        self._token_generated = False\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    password_required = Bool(False, config=True,\n                      help=\"\"\"Forces users to use a password for the Notebook server.\n                      This is useful in a multi user environment, for instance when\n                      everybody in the LAN can access each other's machine though ssh.\n\n                      In such a case, server the notebook server on localhost is not secure\n                      since any user can connect to the notebook server via ssh.\n\n                      \"\"\"\n\n    disable_check_xsrf = Bool(False, config=True,\n        help=\"\"\"Disable cross-site-request-forgery protection\n\n        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,\n        requiring API requests to either:\n\n        - originate from the (validated with XSRF cookie and token), or\n        - authenticate with a token\n\n        Some anonymous compute resources still desire the ability to run code,\n        completely without authentication.\n        These services can disable all authentication and security checks,\n        with the full knowledge of what that implies.\n        \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n\n    @observe('webapp_settings') \n    def _update_webapp_settings(self, change):\n        self.log.warning(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = change['new']\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    terminado_settings = Dict(config=True,\n            help='Supply overrides for terminado. Currently only supports \"shell_command\".')\n\n    cookie_options = Dict(config=True,\n        help=\"Extra keyword arguments to pass to `set_secure_cookie`.\"\n             \" See tornado's set_secure_cookie docs for details.\"\n    )\n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n\n    @observe('enable_mathjax')\n    def _update_enable_mathjax(self, change):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not change['new']:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n\n    @validate('base_url')\n    def _update_base_url(self, proposal):\n        value = proposal['value']\n        if not value.startswith('/'):\n            value = '/' + value\n        elif not value.endswith('/'):\n            value = value + '/'\n        return value\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n\n    @observe('base_project_url')\n    def _update_base_project_url(self, change):\n        self.log.warning(\"base_project_url is deprecated, use base_url\")\n        self.base_url = change['new']\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n\n    @default('static_custom_path')\n    def _default_static_custom_path(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path after a migration period\n        try:\n            from IPython.paths import get_ipython_dir\n        except ImportError:\n            pass\n        else:\n            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"A custom url for MathJax.js.\n        Should be in the form of a case-sensitive url to MathJax,\n        for example:  /static/components/MathJax/MathJax.js\n        \"\"\"\n    )\n\n    @default('mathjax_url')\n    def _default_mathjax_url(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\", \"static\")\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    @observe('mathjax_url')\n    def _update_mathjax_url(self, change):\n        new = change['new']\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    mathjax_config = Unicode(\"TeX-AMS-MML_HTMLorMML-full,Safe\", config=True,\n        help=\"\"\"The MathJax.js configuration file that is to be used.\"\"\"\n    )\n\n    @observe('mathjax_config')\n    def _update_mathjax_config(self, change):\n        self.log.info(\"Using MathJax configuration file: %s\", change['new'])\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    @default('info_file')\n    def _default_info_file(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n\n    @observe('pylab')\n    def _update_pylab(self, change):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if change['new'] != 'warn':\n            backend = ' %s' % change['new']\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    @default('notebook_dir')\n    def _default_notebook_dir(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    @validate('notebook_dir')\n    def _notebook_dir_validate(self, proposal):\n        value = proposal['value']\n        # Strip any trailing slashes\n        # *except* if it's root\n        _, path = os.path.splitdrive(value)\n        if path == os.sep:\n            return value\n        value = value.rstrip(os.sep)\n        if not os.path.isabs(value):\n            # If we receive a non-absolute path, make it absolute.\n            value = os.path.abspath(value)\n        if not os.path.isdir(value):\n            raise TraitError(\"No such notebook dir: %r\" % value)\n        return value\n\n    @observe('notebook_dir')\n    def _update_notebook_dir(self, change):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        new = change['new']\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    # TODO: Remove me in notebook 5.0\n    server_extensions = List(Unicode(), config=True,\n        help=(\"DEPRECATED use the nbserver_extensions dict instead\")\n    )\n    \n    @observe('server_extensions')\n    def _update_server_extensions(self, change):\n        self.log.warning(\"server_extensions is deprecated, use nbserver_extensions\")\n        self.server_extensions = change['new']\n        \n    nbserver_extensions = Dict({}, config=True,\n        help=(\"Dict of Python modules to load as notebook server extensions.\"\n              \"Entry values can be used to enable and disable the loading of\"\n              \"the extensions. The extensions will be loaded in alphabetical \"\n              \"order.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    iopub_msg_rate_limit = Float(1000, config=True, help=\"\"\"(msgs/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    iopub_data_rate_limit = Float(1000000, config=True, help=\"\"\"(bytes/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    rate_limit_window = Float(3, config=True, help=\"\"\"(sec) Time window used to \n        check the message and data rate limits.\"\"\")\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n\n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the config dirs.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        self.tornado_settings['cookie_options'] = self.cookie_options\n        self.tornado_settings['token'] = self.token\n        if (self.open_browser or self.file_to_run) and not self.password:\n            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')\n            self.tornado_settings['one_time_token'] = self.one_time_token\n\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n\n        if self.password_required and (not self.password):\n            self.log.critical(\"Notebook servers are configured to only be run with a password.\")\n            self.log.critical(\"Hint: run the following command to set a password\")\n            self.log.critical(\"\\t$ python -m notebook.auth password\")\n            sys.exit(1)\n\n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if self.client_ca:\n            ssl_options['ca_certs'] = self.client_ca\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # SSL may be missing, so only import it if it's to be used\n            import ssl\n            # Disable SSLv3 by default, since its use is discouraged.\n            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)\n            if ssl_options.get('ca_certs', False):\n                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)\n        \n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warning(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        url = self._url(ip)\n        if self.token:\n            # Don't log full token if it came from config\n            token = self.token if self._token_generated else '...'\n            url = url_concat(url, {'token': token})\n        return url\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warning\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        \n        # TODO: Remove me in notebook 5.0\n        for modulename in self.server_extensions:\n            # Don't override disable state of the extension if it already exist\n            # in the new traitlet\n            if not modulename in self.nbserver_extensions:\n                self.nbserver_extensions[modulename] = True\n        \n        for modulename in sorted(self.nbserver_extensions):\n            if self.nbserver_extensions[modulename]:\n                try:\n                    mod = importlib.import_module(modulename)\n                    func = getattr(mod, 'load_jupyter_server_extension', None)\n                    if func is not None:\n                        func(self)\n                except Exception:\n                    if self.reraise_server_extension_failures:\n                        raise\n                    self.log.warning(\"Error loading server extension %s\", modulename,\n                                  exc_info=True)\n\n    def init_mime_overrides(self):\n        # On some Windows machines, an application has registered an incorrect\n        # mimetype for CSS in the registry. Tornado uses this when serving\n        # .css files, causing browsers to reject the stylesheet. We know the\n        # mimetype always needs to be text/css, so we override it here.\n        mimetypes.add_type('text/css', '.css')\n\n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n        self.init_mime_overrides()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'token': self.token,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'password': bool(self.password),\n                'pid': os.getpid(),\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2, sort_keys=True)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n\n        if not self.allow_root:\n            # check if we are running as root, and abort if it's not allowed\n            try:\n                uid = os.geteuid()\n            except AttributeError:\n                uid = -1 # anything nonzero here, since we can't check UID assume non-root\n            if uid == 0:\n                self.log.critical(\"Running as root is not recommended. Use --allow-root to bypass.\")\n                self.exit(1)\n\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warning('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))\n            else:\n                # default_url contains base_url, but so does connection_url\n                uri = self.default_url[len(self.base_url):]\n            if self.one_time_token:\n                uri = url_concat(uri, {'token': self.one_time_token})\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n\n        if self.token and self._token_generated:\n            # log full URL with generated token, so there's a copy/pasteable link\n            # with auth info.\n            self.log.critical('\\n'.join([\n                '\\n',\n                'Copy/paste this URL into your browser when you connect for the first time,',\n                'to login with a token:',\n                '    %s' % url_concat(self.connection_url, {'token': self.token}),\n            ]))\n\n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.remove_server_info_file()\n            self.cleanup_kernels()\n\n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a runtime directory, find nbserver-* files in the security directory,\n    and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(os.path.join(runtime_dir, file))\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n/n/n/n", "label": 0}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "1c2a256addf7a5273a40963f92a6351e5d053ae0", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook._tz import utcnow\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        if user is None:\n            raise web.HTTPError(403)\n        return user\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if self._track_activity and self.get_current_user():\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers',\n                        'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n    \n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n]\n/n/n/n", "label": 0}, {"id": "1c2a256addf7a5273a40963f92a6351e5d053ae0", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook._tz import utcnow\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        if user is None:\n            raise web.HTTPError(403)\n        return user\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if self._track_activity and self.get_current_user():\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n    \n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n]\n/n/n/n", "label": 1}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "notebook/auth/login.py/n/n\"\"\"Tornado handlers for logging into the notebook.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\n\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\nimport uuid\n\nfrom tornado.escape import url_escape\n\nfrom ..auth.security import passwd_check\n\nfrom ..base.handlers import IPythonHandler\n\n\nclass LoginHandler(IPythonHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        if not url.startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if '://' in url:\n                # if full URL, run our cross-origin check:\n                parsed = urlparse(url.lower())\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        if self.get_login_available(self.settings):\n            if passwd_check(self.hashed_password, typed_password):\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid password'})\n                return\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n        \n        Origin check should be skipped for token-authenticated requests.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n    \n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Check if the handler has been authenticated by a token.\n        \n        This is used to signal certain things, such as:\n        \n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            user_id = handler.get_secure_cookie(handler.cookie_name)\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that we've been authenticated with a token.\n            # Used in should_check_origin above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # prevent extra Invalid cookie sig warnings:\n            handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        one_time_token = handler.one_time_token\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n        elif one_time_token and user_token == one_time_token:\n            # one-time-token-authenticated, only allow this token once\n            handler.settings.pop('one_time_token', None)\n            handler.log.info(\"Accepting one-time-token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the notebook application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The notebook server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n/n/n/nnotebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 0}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def check_xsrf_cookie(self):\n        \"\"\"Check non-empty body on POST for XSRF\n\n        instead of checking the cookie for forms.\n        \"\"\"\n        if self.request.method.upper() == 'POST' and not self.request.body:\n            # Require non-empty POST body for XSRF\n            raise web.HTTPError(400, \"POST requests must have a JSON body. If no content is needed, use '{}'.\")\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8\n\"\"\"A tornado based Jupyter notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport binascii\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport mimetypes\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport sys\nimport threading\nimport warnings\nimport webbrowser\n\ntry: #PY3\n    from base64 import encodebytes\nexcept ImportError: #PY2\n    from base64 import encodestring as encodebytes\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The Jupyter Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.httputil import url_concat\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\n\n# py23 compatibility\ntry:\n    raw_input = raw_input\nexcept NameError:\n    raw_input = input\n\nfrom .base.handlers import Template404, RedirectWithParams\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type, Float, observe, default, validate\n)\nfrom ipython_genutils import py3compat\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid, url_escape\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\njupyter notebook                       # start the notebook\njupyter notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\nDEV_NOTE_NPM = \"\"\"It looks like you're running the notebook from source.\nIf you're working on the Javascript of the notebook, try running\n\n    npm run build:watch\n\nin another terminal window to have the system incrementally\nwatch and build the notebook's JavaScript for you, as you make changes.\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, jupyter_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        # If the user is running the notebook in a git directory, make the assumption\n        # that this is a dev install and suggest to the developer `npm run build:watch`.\n        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))\n        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))\n        if dev_mode:\n            log.info(DEV_NOTE_NPM)\n\n        settings = self.init_settings(\n            jupyter_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, jupyter_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            jupyter_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        if jupyter_app.ignore_minified_js:\n            log.warning(\"\"\"The `ignore_minified_js` flag is deprecated and no \n                longer works.  Alternatively use `npm run build:watch` when\n                working on the notebook's Javascript and LESS\"\"\")\n            warnings.warn(\"The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0\", DeprecationWarning)\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=jupyter_app.static_file_path,\n            static_custom_path=jupyter_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=jupyter_app.ignore_minified_js,\n            \n            # rate limits\n            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,\n            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,\n            rate_limit_window=jupyter_app.rate_limit_window,\n            \n            # authentication\n            cookie_secret=jupyter_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=jupyter_app.login_handler_class,\n            logout_handler_class=jupyter_app.logout_handler_class,\n            password=jupyter_app.password,\n            xsrf_cookies=True,\n            disable_check_xsrf=ipython_app.disable_check_xsrf,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=jupyter_app.jinja_template_vars,\n            nbextensions_path=jupyter_app.nbextensions_path,\n            websocket_url=jupyter_app.websocket_url,\n            mathjax_url=jupyter_app.mathjax_url,\n            mathjax_config=jupyter_app.mathjax_config,\n            config=jupyter_app.config,\n            config_dir=jupyter_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('bundler.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        # TODO: Remove on notebook 5.0\n        widgets = None\n        try:\n            import widgetsnbextension\n        except:\n            try:\n                import ipywidgets as widgets\n                handlers.append(\n                    (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                        'path': widgets.find_static_assets(),\n                        'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                    }),\n                )\n            except:\n                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', RedirectWithParams, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                url = serverinfo['url']\n                if serverinfo.get('token'):\n                    url = url + '?token=%s' % serverinfo['token']\n                print(url, \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\nflags['allow-root']=(\n    {'NotebookApp' : {'allow_root' : True}},\n    \"Allow the notebook to be run from root user.\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'client-ca': 'NotebookApp.client_ca',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    @default('log_level')\n    def _default_log_level(self):\n        return logging.INFO\n\n    @default('log_datefmt')\n    def _default_log_datefmt(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    @default('log_format')\n    def _default_log_format(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    allow_root = Bool(False, config=True, \n        help=\"Whether to allow the user to run the notebook as root.\"\n    )\n\n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n\n    @default('ip')\n    def _default_ip(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warning(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    @validate('ip')\n    def _valdate_ip(self, proposal):\n        value = proposal['value']\n        if value == u'*':\n            value = u''\n        return value\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    client_ca = Unicode(u'', config=True,\n        help=\"\"\"The full path to a certificate authority certificate for SSL/TLS client authentication.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n\n    @default('cookie_secret_file')\n    def _default_cookie_secret_file(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    \n    @default('cookie_secret')\n    def _default_cookie_secret(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = encodebytes(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warning(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    token = Unicode('<generated>',\n        help=\"\"\"Token used for authenticating first-time connections to the server.\n\n        When no password is enabled,\n        the default is to generate a new, random token.\n\n        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.\n        \"\"\"\n    ).tag(config=True)\n\n    one_time_token = Unicode(\n        help=\"\"\"One-time token used for opening a browser.\n\n        Once used, this token cannot be used again.\n        \"\"\"\n    )\n\n    _token_generated = True\n\n    @default('token')\n    def _token_default(self):\n        if self.password:\n            # no token if password is enabled\n            self._token_generated = False\n            return u''\n        else:\n            self._token_generated = True\n            return binascii.hexlify(os.urandom(24)).decode('ascii')\n\n    @observe('token')\n    def _token_changed(self, change):\n        self._token_generated = False\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    password_required = Bool(False, config=True,\n                      help=\"\"\"Forces users to use a password for the Notebook server.\n                      This is useful in a multi user environment, for instance when\n                      everybody in the LAN can access each other's machine though ssh.\n\n                      In such a case, server the notebook server on localhost is not secure\n                      since any user can connect to the notebook server via ssh.\n\n                      \"\"\"\n\n    disable_check_xsrf = Bool(False, config=True,\n        help=\"\"\"Disable cross-site-request-forgery protection\n\n        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,\n        requiring API requests to either:\n\n        - originate from the (validated with XSRF cookie and token), or\n        - authenticate with a token\n\n        Some anonymous compute resources still desire the ability to run code,\n        completely without authentication.\n        These services can disable all authentication and security checks,\n        with the full knowledge of what that implies.\n        \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n\n    @observe('webapp_settings') \n    def _update_webapp_settings(self, change):\n        self.log.warning(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = change['new']\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    terminado_settings = Dict(config=True,\n            help='Supply overrides for terminado. Currently only supports \"shell_command\".')\n\n    cookie_options = Dict(config=True,\n        help=\"Extra keyword arguments to pass to `set_secure_cookie`.\"\n             \" See tornado's set_secure_cookie docs for details.\"\n    )\n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n\n    @observe('enable_mathjax')\n    def _update_enable_mathjax(self, change):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not change['new']:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n\n    @validate('base_url')\n    def _update_base_url(self, proposal):\n        value = proposal['value']\n        if not value.startswith('/'):\n            value = '/' + value\n        elif not value.endswith('/'):\n            value = value + '/'\n        return value\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n\n    @observe('base_project_url')\n    def _update_base_project_url(self, change):\n        self.log.warning(\"base_project_url is deprecated, use base_url\")\n        self.base_url = change['new']\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n\n    @default('static_custom_path')\n    def _default_static_custom_path(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path after a migration period\n        try:\n            from IPython.paths import get_ipython_dir\n        except ImportError:\n            pass\n        else:\n            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"A custom url for MathJax.js.\n        Should be in the form of a case-sensitive url to MathJax,\n        for example:  /static/components/MathJax/MathJax.js\n        \"\"\"\n    )\n\n    @default('mathjax_url')\n    def _default_mathjax_url(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\", \"static\")\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    @observe('mathjax_url')\n    def _update_mathjax_url(self, change):\n        new = change['new']\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    mathjax_config = Unicode(\"TeX-AMS-MML_HTMLorMML-full,Safe\", config=True,\n        help=\"\"\"The MathJax.js configuration file that is to be used.\"\"\"\n    )\n\n    @observe('mathjax_config')\n    def _update_mathjax_config(self, change):\n        self.log.info(\"Using MathJax configuration file: %s\", change['new'])\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    @default('info_file')\n    def _default_info_file(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n\n    @observe('pylab')\n    def _update_pylab(self, change):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if change['new'] != 'warn':\n            backend = ' %s' % change['new']\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    @default('notebook_dir')\n    def _default_notebook_dir(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    @validate('notebook_dir')\n    def _notebook_dir_validate(self, proposal):\n        value = proposal['value']\n        # Strip any trailing slashes\n        # *except* if it's root\n        _, path = os.path.splitdrive(value)\n        if path == os.sep:\n            return value\n        value = value.rstrip(os.sep)\n        if not os.path.isabs(value):\n            # If we receive a non-absolute path, make it absolute.\n            value = os.path.abspath(value)\n        if not os.path.isdir(value):\n            raise TraitError(\"No such notebook dir: %r\" % value)\n        return value\n\n    @observe('notebook_dir')\n    def _update_notebook_dir(self, change):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        new = change['new']\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    # TODO: Remove me in notebook 5.0\n    server_extensions = List(Unicode(), config=True,\n        help=(\"DEPRECATED use the nbserver_extensions dict instead\")\n    )\n    \n    @observe('server_extensions')\n    def _update_server_extensions(self, change):\n        self.log.warning(\"server_extensions is deprecated, use nbserver_extensions\")\n        self.server_extensions = change['new']\n        \n    nbserver_extensions = Dict({}, config=True,\n        help=(\"Dict of Python modules to load as notebook server extensions.\"\n              \"Entry values can be used to enable and disable the loading of\"\n              \"the extensions. The extensions will be loaded in alphabetical \"\n              \"order.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    iopub_msg_rate_limit = Float(1000, config=True, help=\"\"\"(msgs/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    iopub_data_rate_limit = Float(1000000, config=True, help=\"\"\"(bytes/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    rate_limit_window = Float(3, config=True, help=\"\"\"(sec) Time window used to \n        check the message and data rate limits.\"\"\")\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n\n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the config dirs.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        self.tornado_settings['cookie_options'] = self.cookie_options\n        self.tornado_settings['token'] = self.token\n        if (self.open_browser or self.file_to_run) and not self.password:\n            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')\n            self.tornado_settings['one_time_token'] = self.one_time_token\n\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n\n        if self.password_required and (not self.password):\n            self.log.critical(\"Notebook servers are configured to only be run with a password.\")\n            self.log.critical(\"Hint: run the following command to set a password\")\n            self.log.critical(\"\\t$ python -m notebook.auth password\")\n            sys.exit(1)\n\n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if self.client_ca:\n            ssl_options['ca_certs'] = self.client_ca\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # SSL may be missing, so only import it if it's to be used\n            import ssl\n            # Disable SSLv3 by default, since its use is discouraged.\n            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)\n            if ssl_options.get('ca_certs', False):\n                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)\n        \n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warning(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        url = self._url(ip)\n        if self.token:\n            # Don't log full token if it came from config\n            token = self.token if self._token_generated else '...'\n            url = url_concat(url, {'token': token})\n        return url\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warning\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        \n        # TODO: Remove me in notebook 5.0\n        for modulename in self.server_extensions:\n            # Don't override disable state of the extension if it already exist\n            # in the new traitlet\n            if not modulename in self.nbserver_extensions:\n                self.nbserver_extensions[modulename] = True\n        \n        for modulename in sorted(self.nbserver_extensions):\n            if self.nbserver_extensions[modulename]:\n                try:\n                    mod = importlib.import_module(modulename)\n                    func = getattr(mod, 'load_jupyter_server_extension', None)\n                    if func is not None:\n                        func(self)\n                except Exception:\n                    if self.reraise_server_extension_failures:\n                        raise\n                    self.log.warning(\"Error loading server extension %s\", modulename,\n                                  exc_info=True)\n\n    def init_mime_overrides(self):\n        # On some Windows machines, an application has registered an incorrect\n        # mimetype for CSS in the registry. Tornado uses this when serving\n        # .css files, causing browsers to reject the stylesheet. We know the\n        # mimetype always needs to be text/css, so we override it here.\n        mimetypes.add_type('text/css', '.css')\n\n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n        self.init_mime_overrides()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'token': self.token,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'password': bool(self.password),\n                'pid': os.getpid(),\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2, sort_keys=True)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n\n        if not self.allow_root:\n            # check if we are running as root, and abort if it's not allowed\n            try:\n                uid = os.geteuid()\n            except AttributeError:\n                uid = -1 # anything nonzero here, since we can't check UID assume non-root\n            if uid == 0:\n                self.log.critical(\"Running as root is not recommended. Use --allow-root to bypass.\")\n                self.exit(1)\n\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warning('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))\n            else:\n                # default_url contains base_url, but so does connection_url\n                uri = self.default_url[len(self.base_url):]\n            if self.one_time_token:\n                uri = url_concat(uri, {'token': self.one_time_token})\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n\n        if self.token and self._token_generated:\n            # log full URL with generated token, so there's a copy/pasteable link\n            # with auth info.\n            self.log.critical('\\n'.join([\n                '\\n',\n                'Copy/paste this URL into your browser when you connect for the first time,',\n                'to login with a token:',\n                '    %s' % url_concat(self.connection_url, {'token': self.token}),\n            ]))\n\n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.remove_server_info_file()\n            self.cleanup_kernels()\n\n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a runtime directory, find nbserver-* files in the security directory,\n    and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(os.path.join(runtime_dir, file))\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n/n/n/n", "label": 0}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "notebook/auth/login.py/n/n\"\"\"Tornado handlers for logging into the notebook.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport re\n\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\nimport uuid\n\nfrom tornado.escape import url_escape\n\nfrom ..auth.security import passwd_check\n\nfrom ..base.handlers import IPythonHandler\n\n\nclass LoginHandler(IPythonHandler):\n    \"\"\"The basic tornado login handler\n\n    authenticates with a hashed password from the configuration.\n    \"\"\"\n    def _render(self, message=None):\n        self.write(self.render_template('login.html',\n                next=url_escape(self.get_argument('next', default=self.base_url)),\n                message=message,\n        ))\n\n    def _redirect_safe(self, url, default=None):\n        \"\"\"Redirect if url is on our PATH\n\n        Full-domain redirects are allowed if they pass our CORS origin checks.\n\n        Otherwise use default (self.base_url if unspecified).\n        \"\"\"\n        if default is None:\n            default = self.base_url\n        if not url.startswith(self.base_url):\n            # require that next_url be absolute path within our path\n            allow = False\n            # OR pass our cross-origin check\n            if '://' in url:\n                # if full URL, run our cross-origin check:\n                parsed = urlparse(url.lower())\n                origin = '%s://%s' % (parsed.scheme, parsed.netloc)\n                if self.allow_origin:\n                    allow = self.allow_origin == origin\n                elif self.allow_origin_pat:\n                    allow = bool(self.allow_origin_pat.match(origin))\n            if not allow:\n                # not allowed, use default\n                self.log.warning(\"Not allowing login redirect to %r\" % url)\n                url = default\n        self.redirect(url)\n\n    def get(self):\n        if self.current_user:\n            next_url = self.get_argument('next', default=self.base_url)\n            self._redirect_safe(next_url)\n        else:\n            self._render()\n\n    @property\n    def hashed_password(self):\n        return self.password_from_settings(self.settings)\n\n    def post(self):\n        typed_password = self.get_argument('password', default=u'')\n        if self.get_login_available(self.settings):\n            if passwd_check(self.hashed_password, typed_password):\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            elif self.token and self.token == typed_password:\n                self.set_login_cookie(self, uuid.uuid4().hex)\n            else:\n                self.set_status(401)\n                self._render(message={'error': 'Invalid password'})\n                return\n\n        next_url = self.get_argument('next', default=self.base_url)\n        self._redirect_safe(next_url)\n\n    @classmethod\n    def set_login_cookie(cls, handler, user_id=None):\n        \"\"\"Call this on handlers to set the login cookie for success\"\"\"\n        cookie_options = handler.settings.get('cookie_options', {})\n        cookie_options.setdefault('httponly', True)\n        # tornado <4.2 has a bug that considers secure==True as soon as\n        # 'secure' kwarg is passed to set_secure_cookie\n        if handler.settings.get('secure_cookie', handler.request.protocol == 'https'):\n            cookie_options.setdefault('secure', True)\n        handler.set_secure_cookie(handler.cookie_name, user_id, **cookie_options)\n        return user_id\n\n    auth_header_pat = re.compile('token\\s+(.+)', re.IGNORECASE)\n\n    @classmethod\n    def get_token(cls, handler):\n        \"\"\"Get the user token from a request\n\n        Default:\n\n        - in URL parameters: ?token=<token>\n        - in header: Authorization: token <token>\n        \"\"\"\n\n        user_token = handler.get_argument('token', '')\n        if not user_token:\n            # get it from Authorization header\n            m = cls.auth_header_pat.match(handler.request.headers.get('Authorization', ''))\n            if m:\n                user_token = m.group(1)\n        return user_token\n\n    @classmethod\n    def should_check_origin(cls, handler):\n        \"\"\"Should the Handler check for CORS origin validation?\n        \n        Origin check should be skipped for token-authenticated requests.\n        \"\"\"\n        return not cls.is_token_authenticated(handler)\n    \n    @classmethod\n    def is_token_authenticated(cls, handler):\n        \"\"\"Check if the handler has been authenticated by a token.\n        \n        This is used to signal certain things, such as:\n        \n        - permit access to REST API\n        - xsrf protection\n        - skip origin-checks for scripts\n        \"\"\"\n        if getattr(handler, '_user_id', None) is None:\n            # ensure get_user has been called, so we know if we're token-authenticated\n            handler.get_current_user()\n        return getattr(handler, '_token_authenticated', False)\n\n    @classmethod\n    def get_user(cls, handler):\n        \"\"\"Called by handlers.get_current_user for identifying the current user.\n\n        See tornado.web.RequestHandler.get_current_user for details.\n        \"\"\"\n        # Can't call this get_current_user because it will collide when\n        # called on LoginHandler itself.\n        if getattr(handler, '_user_id', None):\n            return handler._user_id\n        user_id = cls.get_user_token(handler)\n        if user_id is None:\n            user_id = handler.get_secure_cookie(handler.cookie_name)\n        else:\n            cls.set_login_cookie(handler, user_id)\n            # Record that we've been authenticated with a token.\n            # Used in should_check_origin above.\n            handler._token_authenticated = True\n        if user_id is None:\n            # prevent extra Invalid cookie sig warnings:\n            handler.clear_login_cookie()\n            if not handler.login_available:\n                # Completely insecure! No authentication at all.\n                # No need to warn here, though; validate_security will have already done that.\n                user_id = 'anonymous'\n\n        # cache value for future retrievals on the same request\n        handler._user_id = user_id\n        return user_id\n\n    @classmethod\n    def get_user_token(cls, handler):\n        \"\"\"Identify the user based on a token in the URL or Authorization header\"\"\"\n        token = handler.token\n        if not token:\n            return\n        # check login token from URL argument or Authorization header\n        user_token = cls.get_token(handler)\n        one_time_token = handler.one_time_token\n        authenticated = False\n        if user_token == token:\n            # token-authenticated, set the login cookie\n            handler.log.debug(\"Accepting token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n        elif one_time_token and user_token == one_time_token:\n            # one-time-token-authenticated, only allow this token once\n            handler.settings.pop('one_time_token', None)\n            handler.log.info(\"Accepting one-time-token-authenticated connection from %s\", handler.request.remote_ip)\n            authenticated = True\n\n        if authenticated:\n            return uuid.uuid4().hex\n        else:\n            return None\n\n\n    @classmethod\n    def validate_security(cls, app, ssl_options=None):\n        \"\"\"Check the notebook application's security.\n\n        Show messages, or abort if necessary, based on the security configuration.\n        \"\"\"\n        if not app.ip:\n            warning = \"WARNING: The notebook server is listening on all IP addresses\"\n            if ssl_options is None:\n                app.log.warning(warning + \" and not using encryption. This \"\n                    \"is not recommended.\")\n            if not app.password and not app.token:\n                app.log.warning(warning + \" and not using authentication. \"\n                    \"This is highly insecure and not recommended.\")\n        else:\n            if not app.password and not app.token:\n                app.log.warning(\n                    \"All authentication is disabled.\"\n                    \"  Anyone who can connect to this server will be able to run code.\")\n\n    @classmethod\n    def password_from_settings(cls, settings):\n        \"\"\"Return the hashed password from the tornado settings.\n\n        If there is no configured password, an empty string will be returned.\n        \"\"\"\n        return settings.get('password', u'')\n\n    @classmethod\n    def get_login_available(cls, settings):\n        \"\"\"Whether this LoginHandler is needed - and therefore whether the login page should be displayed.\"\"\"\n        return bool(cls.password_from_settings(settings) or settings.get('token'))\n/n/n/nnotebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 0}, {"id": "70e79a0ad69f02d46abed57e007ce5ef7f79319b", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n    \n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n    \n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def check_xsrf_cookie(self):\n        \"\"\"Check non-empty body on POST for XSRF\n\n        instead of checking the cookie for forms.\n        \"\"\"\n        if self.request.method.upper() == 'POST' and not self.request.body:\n            # Require non-empty POST body for XSRF\n            raise web.HTTPError(400, \"POST requests must have a JSON body. If no content is needed, use '{}'.\")\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/nnotebook/notebookapp.py/n/n# coding: utf-8\n\"\"\"A tornado based Jupyter notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nfrom __future__ import absolute_import, print_function\n\nimport binascii\nimport datetime\nimport errno\nimport importlib\nimport io\nimport json\nimport logging\nimport mimetypes\nimport os\nimport random\nimport re\nimport select\nimport signal\nimport socket\nimport sys\nimport threading\nimport warnings\nimport webbrowser\n\ntry: #PY3\n    from base64 import encodebytes\nexcept ImportError: #PY2\n    from base64 import encodestring as encodebytes\n\n\nfrom jinja2 import Environment, FileSystemLoader\n\n# Install the pyzmq ioloop. This has to be done before anything else from\n# tornado is imported.\nfrom zmq.eventloop import ioloop\nioloop.install()\n\n# check for tornado 3.1.0\nmsg = \"The Jupyter Notebook requires tornado >= 4.0\"\ntry:\n    import tornado\nexcept ImportError:\n    raise ImportError(msg)\ntry:\n    version_info = tornado.version_info\nexcept AttributeError:\n    raise ImportError(msg + \", but you have < 1.1.0\")\nif version_info < (4,0):\n    raise ImportError(msg + \", but you have %s\" % tornado.version)\n\nfrom tornado import httpserver\nfrom tornado import web\nfrom tornado.httputil import url_concat\nfrom tornado.log import LogFormatter, app_log, access_log, gen_log\n\nfrom notebook import (\n    DEFAULT_STATIC_FILES_PATH,\n    DEFAULT_TEMPLATE_PATH_LIST,\n    __version__,\n)\n\n# py23 compatibility\ntry:\n    raw_input = raw_input\nexcept NameError:\n    raw_input = input\n\nfrom .base.handlers import Template404, RedirectWithParams\nfrom .log import log_request\nfrom .services.kernels.kernelmanager import MappingKernelManager\nfrom .services.config import ConfigManager\nfrom .services.contents.manager import ContentsManager\nfrom .services.contents.filemanager import FileContentsManager\nfrom .services.sessions.sessionmanager import SessionManager\n\nfrom .auth.login import LoginHandler\nfrom .auth.logout import LogoutHandler\nfrom .base.handlers import FileFindHandler\n\nfrom traitlets.config import Config\nfrom traitlets.config.application import catch_config_error, boolean_flag\nfrom jupyter_core.application import (\n    JupyterApp, base_flags, base_aliases,\n)\nfrom jupyter_client import KernelManager\nfrom jupyter_client.kernelspec import KernelSpecManager, NoSuchKernel, NATIVE_KERNEL_NAME\nfrom jupyter_client.session import Session\nfrom nbformat.sign import NotebookNotary\nfrom traitlets import (\n    Dict, Unicode, Integer, List, Bool, Bytes, Instance,\n    TraitError, Type, Float, observe, default, validate\n)\nfrom ipython_genutils import py3compat\nfrom jupyter_core.paths import jupyter_runtime_dir, jupyter_path\nfrom notebook._sysinfo import get_sys_info\n\nfrom .utils import url_path_join, check_pid, url_escape\n\n#-----------------------------------------------------------------------------\n# Module globals\n#-----------------------------------------------------------------------------\n\n_examples = \"\"\"\njupyter notebook                       # start the notebook\njupyter notebook --certfile=mycert.pem # use SSL/TLS certificate\n\"\"\"\n\nDEV_NOTE_NPM = \"\"\"It looks like you're running the notebook from source.\nIf you're working on the Javascript of the notebook, try running\n\n    npm run build:watch\n\nin another terminal window to have the system incrementally\nwatch and build the notebook's JavaScript for you, as you make changes.\n\"\"\"\n\n#-----------------------------------------------------------------------------\n# Helper functions\n#-----------------------------------------------------------------------------\n\ndef random_ports(port, n):\n    \"\"\"Generate a list of n random ports near the given port.\n\n    The first 5 ports will be sequential, and the remaining n-5 will be\n    randomly selected in the range [port-2*n, port+2*n].\n    \"\"\"\n    for i in range(min(5, n)):\n        yield port + i\n    for i in range(n-5):\n        yield max(1, port + random.randint(-2*n, 2*n))\n\ndef load_handlers(name):\n    \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n    name = 'notebook.' + name\n    mod = __import__(name, fromlist=['default_handlers'])\n    return mod.default_handlers\n\n#-----------------------------------------------------------------------------\n# The Tornado web application\n#-----------------------------------------------------------------------------\n\nclass NotebookWebApplication(web.Application):\n\n    def __init__(self, jupyter_app, kernel_manager, contents_manager,\n                 session_manager, kernel_spec_manager,\n                 config_manager, log,\n                 base_url, default_url, settings_overrides, jinja_env_options):\n\n        # If the user is running the notebook in a git directory, make the assumption\n        # that this is a dev install and suggest to the developer `npm run build:watch`.\n        base_dir = os.path.realpath(os.path.join(__file__, '..', '..'))\n        dev_mode = os.path.exists(os.path.join(base_dir, '.git'))\n        if dev_mode:\n            log.info(DEV_NOTE_NPM)\n\n        settings = self.init_settings(\n            jupyter_app, kernel_manager, contents_manager,\n            session_manager, kernel_spec_manager, config_manager, log, base_url,\n            default_url, settings_overrides, jinja_env_options)\n        handlers = self.init_handlers(settings)\n\n        super(NotebookWebApplication, self).__init__(handlers, **settings)\n\n    def init_settings(self, jupyter_app, kernel_manager, contents_manager,\n                      session_manager, kernel_spec_manager,\n                      config_manager,\n                      log, base_url, default_url, settings_overrides,\n                      jinja_env_options=None):\n\n        _template_path = settings_overrides.get(\n            \"template_path\",\n            jupyter_app.template_file_path,\n        )\n        if isinstance(_template_path, py3compat.string_types):\n            _template_path = (_template_path,)\n        template_path = [os.path.expanduser(path) for path in _template_path]\n\n        jenv_opt = {\"autoescape\": True}\n        jenv_opt.update(jinja_env_options if jinja_env_options else {})\n\n        env = Environment(loader=FileSystemLoader(template_path), **jenv_opt)\n        \n        sys_info = get_sys_info()\n        if sys_info['commit_source'] == 'repository':\n            # don't cache (rely on 304) when working from master\n            version_hash = ''\n        else:\n            # reset the cache on server restart\n            version_hash = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n\n        if jupyter_app.ignore_minified_js:\n            log.warning(\"\"\"The `ignore_minified_js` flag is deprecated and no \n                longer works.  Alternatively use `npm run build:watch` when\n                working on the notebook's Javascript and LESS\"\"\")\n            warnings.warn(\"The `ignore_minified_js` flag is deprecated and will be removed in Notebook 6.0\", DeprecationWarning)\n\n        settings = dict(\n            # basics\n            log_function=log_request,\n            base_url=base_url,\n            default_url=default_url,\n            template_path=template_path,\n            static_path=jupyter_app.static_file_path,\n            static_custom_path=jupyter_app.static_custom_path,\n            static_handler_class = FileFindHandler,\n            static_url_prefix = url_path_join(base_url,'/static/'),\n            static_handler_args = {\n                # don't cache custom.js\n                'no_cache_paths': [url_path_join(base_url, 'static', 'custom')],\n            },\n            version_hash=version_hash,\n            ignore_minified_js=jupyter_app.ignore_minified_js,\n            \n            # rate limits\n            iopub_msg_rate_limit=jupyter_app.iopub_msg_rate_limit,\n            iopub_data_rate_limit=jupyter_app.iopub_data_rate_limit,\n            rate_limit_window=jupyter_app.rate_limit_window,\n            \n            # authentication\n            cookie_secret=jupyter_app.cookie_secret,\n            login_url=url_path_join(base_url,'/login'),\n            login_handler_class=jupyter_app.login_handler_class,\n            logout_handler_class=jupyter_app.logout_handler_class,\n            password=jupyter_app.password,\n            xsrf_cookies=True,\n            disable_check_xsrf=ipython_app.disable_check_xsrf,\n\n            # managers\n            kernel_manager=kernel_manager,\n            contents_manager=contents_manager,\n            session_manager=session_manager,\n            kernel_spec_manager=kernel_spec_manager,\n            config_manager=config_manager,\n\n            # IPython stuff\n            jinja_template_vars=jupyter_app.jinja_template_vars,\n            nbextensions_path=jupyter_app.nbextensions_path,\n            websocket_url=jupyter_app.websocket_url,\n            mathjax_url=jupyter_app.mathjax_url,\n            mathjax_config=jupyter_app.mathjax_config,\n            config=jupyter_app.config,\n            config_dir=jupyter_app.config_dir,\n            jinja2_env=env,\n            terminals_available=False,  # Set later if terminals are available\n        )\n\n        # allow custom overrides for the tornado web app.\n        settings.update(settings_overrides)\n        return settings\n\n    def init_handlers(self, settings):\n        \"\"\"Load the (URL pattern, handler) tuples for each component.\"\"\"\n        \n        # Order matters. The first handler to match the URL will handle the request.\n        handlers = []\n        handlers.extend(load_handlers('tree.handlers'))\n        handlers.extend([(r\"/login\", settings['login_handler_class'])])\n        handlers.extend([(r\"/logout\", settings['logout_handler_class'])])\n        handlers.extend(load_handlers('files.handlers'))\n        handlers.extend(load_handlers('notebook.handlers'))\n        handlers.extend(load_handlers('nbconvert.handlers'))\n        handlers.extend(load_handlers('bundler.handlers'))\n        handlers.extend(load_handlers('kernelspecs.handlers'))\n        handlers.extend(load_handlers('edit.handlers'))\n        handlers.extend(load_handlers('services.api.handlers'))\n        handlers.extend(load_handlers('services.config.handlers'))\n        handlers.extend(load_handlers('services.kernels.handlers'))\n        handlers.extend(load_handlers('services.contents.handlers'))\n        handlers.extend(load_handlers('services.sessions.handlers'))\n        handlers.extend(load_handlers('services.nbconvert.handlers'))\n        handlers.extend(load_handlers('services.kernelspecs.handlers'))\n        handlers.extend(load_handlers('services.security.handlers'))\n        \n        # BEGIN HARDCODED WIDGETS HACK\n        # TODO: Remove on notebook 5.0\n        widgets = None\n        try:\n            import widgetsnbextension\n        except:\n            try:\n                import ipywidgets as widgets\n                handlers.append(\n                    (r\"/nbextensions/widgets/(.*)\", FileFindHandler, {\n                        'path': widgets.find_static_assets(),\n                        'no_cache_paths': ['/'], # don't cache anything in nbextensions\n                    }),\n                )\n            except:\n                app_log.warning('Widgets are unavailable. Please install widgetsnbextension or ipywidgets 4.0')\n        # END HARDCODED WIDGETS HACK\n        \n        handlers.append(\n            (r\"/nbextensions/(.*)\", FileFindHandler, {\n                'path': settings['nbextensions_path'],\n                'no_cache_paths': ['/'], # don't cache anything in nbextensions\n            }),\n        )\n        handlers.append(\n            (r\"/custom/(.*)\", FileFindHandler, {\n                'path': settings['static_custom_path'],\n                'no_cache_paths': ['/'], # don't cache anything in custom\n            })\n        )\n        # register base handlers last\n        handlers.extend(load_handlers('base.handlers'))\n        # set the URL that will be redirected from `/`\n        handlers.append(\n            (r'/?', RedirectWithParams, {\n                'url' : settings['default_url'],\n                'permanent': False, # want 302, not 301\n            })\n        )\n\n        # prepend base_url onto the patterns that we match\n        new_handlers = []\n        for handler in handlers:\n            pattern = url_path_join(settings['base_url'], handler[0])\n            new_handler = tuple([pattern] + list(handler[1:]))\n            new_handlers.append(new_handler)\n        # add 404 on the end, which will catch everything that falls through\n        new_handlers.append((r'(.*)', Template404))\n        return new_handlers\n\n\nclass NbserverListApp(JupyterApp):\n    version = __version__\n    description=\"List currently running notebook servers.\"\n    \n    flags = dict(\n        json=({'NbserverListApp': {'json': True}},\n              \"Produce machine-readable JSON output.\"),\n    )\n    \n    json = Bool(False, config=True,\n          help=\"If True, each line of output will be a JSON object with the \"\n                  \"details from the server info file.\")\n\n    def start(self):\n        if not self.json:\n            print(\"Currently running servers:\")\n        for serverinfo in list_running_servers(self.runtime_dir):\n            if self.json:\n                print(json.dumps(serverinfo))\n            else:\n                url = serverinfo['url']\n                if serverinfo.get('token'):\n                    url = url + '?token=%s' % serverinfo['token']\n                print(url, \"::\", serverinfo['notebook_dir'])\n\n#-----------------------------------------------------------------------------\n# Aliases and Flags\n#-----------------------------------------------------------------------------\n\nflags = dict(base_flags)\nflags['no-browser']=(\n    {'NotebookApp' : {'open_browser' : False}},\n    \"Don't open the notebook in a browser after startup.\"\n)\nflags['pylab']=(\n    {'NotebookApp' : {'pylab' : 'warn'}},\n    \"DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\"\n)\nflags['no-mathjax']=(\n    {'NotebookApp' : {'enable_mathjax' : False}},\n    \"\"\"Disable MathJax\n    \n    MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n    very large, so you may want to disable it if you have a slow internet\n    connection, or for offline use of the notebook.\n    \n    When disabled, equations etc. will appear as their untransformed TeX source.\n    \"\"\"\n)\n\nflags['allow-root']=(\n    {'NotebookApp' : {'allow_root' : True}},\n    \"Allow the notebook to be run from root user.\"\n)\n\n# Add notebook manager flags\nflags.update(boolean_flag('script', 'FileContentsManager.save_script',\n               'DEPRECATED, IGNORED',\n               'DEPRECATED, IGNORED'))\n\naliases = dict(base_aliases)\n\naliases.update({\n    'ip': 'NotebookApp.ip',\n    'port': 'NotebookApp.port',\n    'port-retries': 'NotebookApp.port_retries',\n    'transport': 'KernelManager.transport',\n    'keyfile': 'NotebookApp.keyfile',\n    'certfile': 'NotebookApp.certfile',\n    'client-ca': 'NotebookApp.client_ca',\n    'notebook-dir': 'NotebookApp.notebook_dir',\n    'browser': 'NotebookApp.browser',\n    'pylab': 'NotebookApp.pylab',\n})\n\n#-----------------------------------------------------------------------------\n# NotebookApp\n#-----------------------------------------------------------------------------\n\nclass NotebookApp(JupyterApp):\n\n    name = 'jupyter-notebook'\n    version = __version__\n    description = \"\"\"\n        The Jupyter HTML Notebook.\n        \n        This launches a Tornado based HTML Notebook Server that serves up an\n        HTML5/Javascript Notebook client.\n    \"\"\"\n    examples = _examples\n    aliases = aliases\n    flags = flags\n    \n    classes = [\n        KernelManager, Session, MappingKernelManager,\n        ContentsManager, FileContentsManager, NotebookNotary,\n        KernelSpecManager,\n    ]\n    flags = Dict(flags)\n    aliases = Dict(aliases)\n    \n    subcommands = dict(\n        list=(NbserverListApp, NbserverListApp.description.splitlines()[0]),\n    )\n\n    _log_formatter_cls = LogFormatter\n\n    @default('log_level')\n    def _default_log_level(self):\n        return logging.INFO\n\n    @default('log_datefmt')\n    def _default_log_datefmt(self):\n        \"\"\"Exclude date from default date format\"\"\"\n        return \"%H:%M:%S\"\n    \n    @default('log_format')\n    def _default_log_format(self):\n        \"\"\"override default log format to include time\"\"\"\n        return u\"%(color)s[%(levelname)1.1s %(asctime)s.%(msecs).03d %(name)s]%(end_color)s %(message)s\"\n\n    ignore_minified_js = Bool(False,\n            config=True,\n            help='Deprecated: Use minified JS file or not, mainly use during dev to avoid JS recompilation', \n            )\n\n    # file to be opened in the notebook server\n    file_to_run = Unicode('', config=True)\n\n    # Network related information\n    \n    allow_origin = Unicode('', config=True,\n        help=\"\"\"Set the Access-Control-Allow-Origin header\n        \n        Use '*' to allow any origin to access your server.\n        \n        Takes precedence over allow_origin_pat.\n        \"\"\"\n    )\n    \n    allow_origin_pat = Unicode('', config=True,\n        help=\"\"\"Use a regular expression for the Access-Control-Allow-Origin header\n        \n        Requests from an origin matching the expression will get replies with:\n        \n            Access-Control-Allow-Origin: origin\n        \n        where `origin` is the origin of the request.\n        \n        Ignored if allow_origin is set.\n        \"\"\"\n    )\n    \n    allow_credentials = Bool(False, config=True,\n        help=\"Set the Access-Control-Allow-Credentials: true header\"\n    )\n    \n    allow_root = Bool(False, config=True, \n        help=\"Whether to allow the user to run the notebook as root.\"\n    )\n\n    default_url = Unicode('/tree', config=True,\n        help=\"The default URL to redirect to from `/`\"\n    )\n    \n    ip = Unicode('localhost', config=True,\n        help=\"The IP address the notebook server will listen on.\"\n    )\n\n    @default('ip')\n    def _default_ip(self):\n        \"\"\"Return localhost if available, 127.0.0.1 otherwise.\n        \n        On some (horribly broken) systems, localhost cannot be bound.\n        \"\"\"\n        s = socket.socket()\n        try:\n            s.bind(('localhost', 0))\n        except socket.error as e:\n            self.log.warning(\"Cannot bind to localhost, using 127.0.0.1 as default ip\\n%s\", e)\n            return '127.0.0.1'\n        else:\n            s.close()\n            return 'localhost'\n\n    @validate('ip')\n    def _valdate_ip(self, proposal):\n        value = proposal['value']\n        if value == u'*':\n            value = u''\n        return value\n\n    port = Integer(8888, config=True,\n        help=\"The port the notebook server will listen on.\"\n    )\n\n    port_retries = Integer(50, config=True,\n        help=\"The number of additional ports to try if the specified port is not available.\"\n    )\n\n    certfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to an SSL/TLS certificate file.\"\"\"\n    )\n    \n    keyfile = Unicode(u'', config=True, \n        help=\"\"\"The full path to a private key file for usage with SSL/TLS.\"\"\"\n    )\n    \n    client_ca = Unicode(u'', config=True,\n        help=\"\"\"The full path to a certificate authority certificate for SSL/TLS client authentication.\"\"\"\n    )\n    \n    cookie_secret_file = Unicode(config=True,\n        help=\"\"\"The file where the cookie secret is stored.\"\"\"\n    )\n\n    @default('cookie_secret_file')\n    def _default_cookie_secret_file(self):\n        return os.path.join(self.runtime_dir, 'notebook_cookie_secret')\n    \n    cookie_secret = Bytes(b'', config=True,\n        help=\"\"\"The random bytes used to secure cookies.\n        By default this is a new random number every time you start the Notebook.\n        Set it to a value in a config file to enable logins to persist across server sessions.\n        \n        Note: Cookie secrets should be kept private, do not share config files with\n        cookie_secret stored in plaintext (you can read the value from a file).\n        \"\"\"\n    )\n    \n    @default('cookie_secret')\n    def _default_cookie_secret(self):\n        if os.path.exists(self.cookie_secret_file):\n            with io.open(self.cookie_secret_file, 'rb') as f:\n                return f.read()\n        else:\n            secret = encodebytes(os.urandom(1024))\n            self._write_cookie_secret_file(secret)\n            return secret\n    \n    def _write_cookie_secret_file(self, secret):\n        \"\"\"write my secret to my secret_file\"\"\"\n        self.log.info(\"Writing notebook server cookie secret to %s\", self.cookie_secret_file)\n        with io.open(self.cookie_secret_file, 'wb') as f:\n            f.write(secret)\n        try:\n            os.chmod(self.cookie_secret_file, 0o600)\n        except OSError:\n            self.log.warning(\n                \"Could not set permissions on %s\",\n                self.cookie_secret_file\n            )\n\n    token = Unicode('<generated>',\n        help=\"\"\"Token used for authenticating first-time connections to the server.\n\n        When no password is enabled,\n        the default is to generate a new, random token.\n\n        Setting to an empty string disables authentication altogether, which is NOT RECOMMENDED.\n        \"\"\"\n    ).tag(config=True)\n\n    one_time_token = Unicode(\n        help=\"\"\"One-time token used for opening a browser.\n\n        Once used, this token cannot be used again.\n        \"\"\"\n    )\n\n    _token_generated = True\n\n    @default('token')\n    def _token_default(self):\n        if self.password:\n            # no token if password is enabled\n            self._token_generated = False\n            return u''\n        else:\n            self._token_generated = True\n            return binascii.hexlify(os.urandom(24)).decode('ascii')\n\n    @observe('token')\n    def _token_changed(self, change):\n        self._token_generated = False\n\n    password = Unicode(u'', config=True,\n                      help=\"\"\"Hashed password to use for web authentication.\n\n                      To generate, type in a python/IPython shell:\n\n                        from notebook.auth import passwd; passwd()\n\n                      The string should be of the form type:salt:hashed-password.\n                      \"\"\"\n    )\n\n    password_required = Bool(False, config=True,\n                      help=\"\"\"Forces users to use a password for the Notebook server.\n                      This is useful in a multi user environment, for instance when\n                      everybody in the LAN can access each other's machine though ssh.\n\n                      In such a case, server the notebook server on localhost is not secure\n                      since any user can connect to the notebook server via ssh.\n\n                      \"\"\"\n\n    disable_check_xsrf = Bool(False, config=True,\n        help=\"\"\"Disable cross-site-request-forgery protection\n\n        Jupyter notebook 4.3.1 introduces protection from cross-site request forgeries,\n        requiring API requests to either:\n\n        - originate from the (validated with XSRF cookie and token), or\n        - authenticate with a token\n\n        Some anonymous compute resources still desire the ability to run code,\n        completely without authentication.\n        These services can disable all authentication and security checks,\n        with the full knowledge of what that implies.\n        \"\"\"\n    )\n\n    open_browser = Bool(True, config=True,\n                        help=\"\"\"Whether to open in a browser after starting.\n                        The specific browser used is platform dependent and\n                        determined by the python standard library `webbrowser`\n                        module, unless it is overridden using the --browser\n                        (NotebookApp.browser) configuration option.\n                        \"\"\")\n\n    browser = Unicode(u'', config=True,\n                      help=\"\"\"Specify what command to use to invoke a web\n                      browser when opening the notebook. If not specified, the\n                      default browser will be determined by the `webbrowser`\n                      standard library module, which allows setting of the\n                      BROWSER environment variable to override it.\n                      \"\"\")\n    \n    webapp_settings = Dict(config=True,\n        help=\"DEPRECATED, use tornado_settings\"\n    )\n\n    @observe('webapp_settings') \n    def _update_webapp_settings(self, change):\n        self.log.warning(\"\\n    webapp_settings is deprecated, use tornado_settings.\\n\")\n        self.tornado_settings = change['new']\n    \n    tornado_settings = Dict(config=True,\n            help=\"Supply overrides for the tornado.web.Application that the \"\n                 \"Jupyter notebook uses.\")\n    \n    terminado_settings = Dict(config=True,\n            help='Supply overrides for terminado. Currently only supports \"shell_command\".')\n\n    cookie_options = Dict(config=True,\n        help=\"Extra keyword arguments to pass to `set_secure_cookie`.\"\n             \" See tornado's set_secure_cookie docs for details.\"\n    )\n    ssl_options = Dict(config=True,\n            help=\"\"\"Supply SSL options for the tornado HTTPServer.\n            See the tornado docs for details.\"\"\")\n    \n    jinja_environment_options = Dict(config=True, \n            help=\"Supply extra arguments that will be passed to Jinja environment.\")\n\n    jinja_template_vars = Dict(\n        config=True,\n        help=\"Extra variables to supply to jinja templates when rendering.\",\n    )\n    \n    enable_mathjax = Bool(True, config=True,\n        help=\"\"\"Whether to enable MathJax for typesetting math/TeX\n\n        MathJax is the javascript library Jupyter uses to render math/LaTeX. It is\n        very large, so you may want to disable it if you have a slow internet\n        connection, or for offline use of the notebook.\n\n        When disabled, equations etc. will appear as their untransformed TeX source.\n        \"\"\"\n    )\n\n    @observe('enable_mathjax')\n    def _update_enable_mathjax(self, change):\n        \"\"\"set mathjax url to empty if mathjax is disabled\"\"\"\n        if not change['new']:\n            self.mathjax_url = u''\n\n    base_url = Unicode('/', config=True,\n                               help='''The base URL for the notebook server.\n\n                               Leading and trailing slashes can be omitted,\n                               and will automatically be added.\n                               ''')\n\n    @validate('base_url')\n    def _update_base_url(self, proposal):\n        value = proposal['value']\n        if not value.startswith('/'):\n            value = '/' + value\n        elif not value.endswith('/'):\n            value = value + '/'\n        return value\n    \n    base_project_url = Unicode('/', config=True, help=\"\"\"DEPRECATED use base_url\"\"\")\n\n    @observe('base_project_url')\n    def _update_base_project_url(self, change):\n        self.log.warning(\"base_project_url is deprecated, use base_url\")\n        self.base_url = change['new']\n\n    extra_static_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving static files.\n        \n        This allows adding javascript/css to be available from the notebook server machine,\n        or overriding individual files in the IPython\"\"\"\n    )\n    \n    @property\n    def static_file_path(self):\n        \"\"\"return extra paths + the default location\"\"\"\n        return self.extra_static_paths + [DEFAULT_STATIC_FILES_PATH]\n    \n    static_custom_path = List(Unicode(),\n        help=\"\"\"Path to search for custom.js, css\"\"\"\n    )\n\n    @default('static_custom_path')\n    def _default_static_custom_path(self):\n        return [\n            os.path.join(d, 'custom') for d in (\n                self.config_dir,\n                DEFAULT_STATIC_FILES_PATH)\n        ]\n\n    extra_template_paths = List(Unicode(), config=True,\n        help=\"\"\"Extra paths to search for serving jinja templates.\n\n        Can be used to override templates from notebook.templates.\"\"\"\n    )\n\n    @property\n    def template_file_path(self):\n        \"\"\"return extra paths + the default locations\"\"\"\n        return self.extra_template_paths + DEFAULT_TEMPLATE_PATH_LIST\n\n    extra_nbextensions_path = List(Unicode(), config=True,\n        help=\"\"\"extra paths to look for Javascript notebook extensions\"\"\"\n    )\n    \n    @property\n    def nbextensions_path(self):\n        \"\"\"The path to look for Javascript notebook extensions\"\"\"\n        path = self.extra_nbextensions_path + jupyter_path('nbextensions')\n        # FIXME: remove IPython nbextensions path after a migration period\n        try:\n            from IPython.paths import get_ipython_dir\n        except ImportError:\n            pass\n        else:\n            path.append(os.path.join(get_ipython_dir(), 'nbextensions'))\n        return path\n\n    websocket_url = Unicode(\"\", config=True,\n        help=\"\"\"The base URL for websockets,\n        if it differs from the HTTP server (hint: it almost certainly doesn't).\n        \n        Should be in the form of an HTTP origin: ws[s]://hostname[:port]\n        \"\"\"\n    )\n\n    mathjax_url = Unicode(\"\", config=True,\n        help=\"\"\"A custom url for MathJax.js.\n        Should be in the form of a case-sensitive url to MathJax,\n        for example:  /static/components/MathJax/MathJax.js\n        \"\"\"\n    )\n\n    @default('mathjax_url')\n    def _default_mathjax_url(self):\n        if not self.enable_mathjax:\n            return u''\n        static_url_prefix = self.tornado_settings.get(\"static_url_prefix\", \"static\")\n        return url_path_join(static_url_prefix, 'components', 'MathJax', 'MathJax.js')\n    \n    @observe('mathjax_url')\n    def _update_mathjax_url(self, change):\n        new = change['new']\n        if new and not self.enable_mathjax:\n            # enable_mathjax=False overrides mathjax_url\n            self.mathjax_url = u''\n        else:\n            self.log.info(\"Using MathJax: %s\", new)\n\n    mathjax_config = Unicode(\"TeX-AMS-MML_HTMLorMML-full,Safe\", config=True,\n        help=\"\"\"The MathJax.js configuration file that is to be used.\"\"\"\n    )\n\n    @observe('mathjax_config')\n    def _update_mathjax_config(self, change):\n        self.log.info(\"Using MathJax configuration file: %s\", change['new'])\n\n    contents_manager_class = Type(\n        default_value=FileContentsManager,\n        klass=ContentsManager,\n        config=True,\n        help='The notebook manager class to use.'\n    )\n\n    kernel_manager_class = Type(\n        default_value=MappingKernelManager,\n        config=True,\n        help='The kernel manager class to use.'\n    )\n\n    session_manager_class = Type(\n        default_value=SessionManager,\n        config=True,\n        help='The session manager class to use.'\n    )\n\n    config_manager_class = Type(\n        default_value=ConfigManager,\n        config = True,\n        help='The config manager class to use'\n    )\n\n    kernel_spec_manager = Instance(KernelSpecManager, allow_none=True)\n\n    kernel_spec_manager_class = Type(\n        default_value=KernelSpecManager,\n        config=True,\n        help=\"\"\"\n        The kernel spec manager class to use. Should be a subclass\n        of `jupyter_client.kernelspec.KernelSpecManager`.\n\n        The Api of KernelSpecManager is provisional and might change\n        without warning between this version of Jupyter and the next stable one.\n        \"\"\"\n    )\n\n    login_handler_class = Type(\n        default_value=LoginHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The login handler class to use.',\n    )\n\n    logout_handler_class = Type(\n        default_value=LogoutHandler,\n        klass=web.RequestHandler,\n        config=True,\n        help='The logout handler class to use.',\n    )\n\n    trust_xheaders = Bool(False, config=True,\n        help=(\"Whether to trust or not X-Scheme/X-Forwarded-Proto and X-Real-Ip/X-Forwarded-For headers\"\n              \"sent by the upstream reverse proxy. Necessary if the proxy handles SSL\")\n    )\n\n    info_file = Unicode()\n\n    @default('info_file')\n    def _default_info_file(self):\n        info_file = \"nbserver-%s.json\" % os.getpid()\n        return os.path.join(self.runtime_dir, info_file)\n    \n    pylab = Unicode('disabled', config=True,\n        help=\"\"\"\n        DISABLED: use %pylab or %matplotlib in the notebook to enable matplotlib.\n        \"\"\"\n    )\n\n    @observe('pylab')\n    def _update_pylab(self, change):\n        \"\"\"when --pylab is specified, display a warning and exit\"\"\"\n        if change['new'] != 'warn':\n            backend = ' %s' % change['new']\n        else:\n            backend = ''\n        self.log.error(\"Support for specifying --pylab on the command line has been removed.\")\n        self.log.error(\n            \"Please use `%pylab{0}` or `%matplotlib{0}` in the notebook itself.\".format(backend)\n        )\n        self.exit(1)\n\n    notebook_dir = Unicode(config=True,\n        help=\"The directory to use for notebooks and kernels.\"\n    )\n\n    @default('notebook_dir')\n    def _default_notebook_dir(self):\n        if self.file_to_run:\n            return os.path.dirname(os.path.abspath(self.file_to_run))\n        else:\n            return py3compat.getcwd()\n\n    @validate('notebook_dir')\n    def _notebook_dir_validate(self, proposal):\n        value = proposal['value']\n        # Strip any trailing slashes\n        # *except* if it's root\n        _, path = os.path.splitdrive(value)\n        if path == os.sep:\n            return value\n        value = value.rstrip(os.sep)\n        if not os.path.isabs(value):\n            # If we receive a non-absolute path, make it absolute.\n            value = os.path.abspath(value)\n        if not os.path.isdir(value):\n            raise TraitError(\"No such notebook dir: %r\" % value)\n        return value\n\n    @observe('notebook_dir')\n    def _update_notebook_dir(self, change):\n        \"\"\"Do a bit of validation of the notebook dir.\"\"\"\n        # setting App.notebook_dir implies setting notebook and kernel dirs as well\n        new = change['new']\n        self.config.FileContentsManager.root_dir = new\n        self.config.MappingKernelManager.root_dir = new\n\n    # TODO: Remove me in notebook 5.0\n    server_extensions = List(Unicode(), config=True,\n        help=(\"DEPRECATED use the nbserver_extensions dict instead\")\n    )\n    \n    @observe('server_extensions')\n    def _update_server_extensions(self, change):\n        self.log.warning(\"server_extensions is deprecated, use nbserver_extensions\")\n        self.server_extensions = change['new']\n        \n    nbserver_extensions = Dict({}, config=True,\n        help=(\"Dict of Python modules to load as notebook server extensions.\"\n              \"Entry values can be used to enable and disable the loading of\"\n              \"the extensions. The extensions will be loaded in alphabetical \"\n              \"order.\")\n    )\n\n    reraise_server_extension_failures = Bool(\n        False,\n        config=True,\n        help=\"Reraise exceptions encountered loading server extensions?\",\n    )\n\n    iopub_msg_rate_limit = Float(1000, config=True, help=\"\"\"(msgs/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    iopub_data_rate_limit = Float(1000000, config=True, help=\"\"\"(bytes/sec)\n        Maximum rate at which messages can be sent on iopub before they are\n        limited.\"\"\")\n\n    rate_limit_window = Float(3, config=True, help=\"\"\"(sec) Time window used to \n        check the message and data rate limits.\"\"\")\n\n    def parse_command_line(self, argv=None):\n        super(NotebookApp, self).parse_command_line(argv)\n\n        if self.extra_args:\n            arg0 = self.extra_args[0]\n            f = os.path.abspath(arg0)\n            self.argv.remove(arg0)\n            if not os.path.exists(f):\n                self.log.critical(\"No such file or directory: %s\", f)\n                self.exit(1)\n            \n            # Use config here, to ensure that it takes higher priority than\n            # anything that comes from the config dirs.\n            c = Config()\n            if os.path.isdir(f):\n                c.NotebookApp.notebook_dir = f\n            elif os.path.isfile(f):\n                c.NotebookApp.file_to_run = f\n            self.update_config(c)\n\n    def init_configurables(self):\n        self.kernel_spec_manager = self.kernel_spec_manager_class(\n            parent=self,\n        )\n        self.kernel_manager = self.kernel_manager_class(\n            parent=self,\n            log=self.log,\n            connection_dir=self.runtime_dir,\n            kernel_spec_manager=self.kernel_spec_manager,\n        )\n        self.contents_manager = self.contents_manager_class(\n            parent=self,\n            log=self.log,\n        )\n        self.session_manager = self.session_manager_class(\n            parent=self,\n            log=self.log,\n            kernel_manager=self.kernel_manager,\n            contents_manager=self.contents_manager,\n        )\n        self.config_manager = self.config_manager_class(\n            parent=self,\n            log=self.log,\n            config_dir=os.path.join(self.config_dir, 'nbconfig'),\n        )\n\n    def init_logging(self):\n        # This prevents double log messages because tornado use a root logger that\n        # self.log is a child of. The logging module dipatches log messages to a log\n        # and all of its ancenstors until propagate is set to False.\n        self.log.propagate = False\n        \n        for log in app_log, access_log, gen_log:\n            # consistent log output name (NotebookApp instead of tornado.access, etc.)\n            log.name = self.log.name\n        # hook up tornado 3's loggers to our app handlers\n        logger = logging.getLogger('tornado')\n        logger.propagate = True\n        logger.parent = self.log\n        logger.setLevel(self.log.level)\n    \n    def init_webapp(self):\n        \"\"\"initialize tornado webapp and httpserver\"\"\"\n        self.tornado_settings['allow_origin'] = self.allow_origin\n        if self.allow_origin_pat:\n            self.tornado_settings['allow_origin_pat'] = re.compile(self.allow_origin_pat)\n        self.tornado_settings['allow_credentials'] = self.allow_credentials\n        self.tornado_settings['cookie_options'] = self.cookie_options\n        self.tornado_settings['token'] = self.token\n        if (self.open_browser or self.file_to_run) and not self.password:\n            self.one_time_token = binascii.hexlify(os.urandom(24)).decode('ascii')\n            self.tornado_settings['one_time_token'] = self.one_time_token\n\n        # ensure default_url starts with base_url\n        if not self.default_url.startswith(self.base_url):\n            self.default_url = url_path_join(self.base_url, self.default_url)\n\n        if self.password_required and (not self.password):\n            self.log.critical(\"Notebook servers are configured to only be run with a password.\")\n            self.log.critical(\"Hint: run the following command to set a password\")\n            self.log.critical(\"\\t$ python -m notebook.auth password\")\n            sys.exit(1)\n\n        self.web_app = NotebookWebApplication(\n            self, self.kernel_manager, self.contents_manager,\n            self.session_manager, self.kernel_spec_manager,\n            self.config_manager,\n            self.log, self.base_url, self.default_url, self.tornado_settings,\n            self.jinja_environment_options\n        )\n        ssl_options = self.ssl_options\n        if self.certfile:\n            ssl_options['certfile'] = self.certfile\n        if self.keyfile:\n            ssl_options['keyfile'] = self.keyfile\n        if self.client_ca:\n            ssl_options['ca_certs'] = self.client_ca\n        if not ssl_options:\n            # None indicates no SSL config\n            ssl_options = None\n        else:\n            # SSL may be missing, so only import it if it's to be used\n            import ssl\n            # Disable SSLv3 by default, since its use is discouraged.\n            ssl_options.setdefault('ssl_version', ssl.PROTOCOL_TLSv1)\n            if ssl_options.get('ca_certs', False):\n                ssl_options.setdefault('cert_reqs', ssl.CERT_REQUIRED)\n        \n        self.login_handler_class.validate_security(self, ssl_options=ssl_options)\n        self.http_server = httpserver.HTTPServer(self.web_app, ssl_options=ssl_options,\n                                                 xheaders=self.trust_xheaders)\n\n        success = None\n        for port in random_ports(self.port, self.port_retries+1):\n            try:\n                self.http_server.listen(port, self.ip)\n            except socket.error as e:\n                if e.errno == errno.EADDRINUSE:\n                    self.log.info('The port %i is already in use, trying another port.' % port)\n                    continue\n                elif e.errno in (errno.EACCES, getattr(errno, 'WSAEACCES', errno.EACCES)):\n                    self.log.warning(\"Permission to listen on port %i denied\" % port)\n                    continue\n                else:\n                    raise\n            else:\n                self.port = port\n                success = True\n                break\n        if not success:\n            self.log.critical('ERROR: the notebook server could not be started because '\n                              'no available port could be found.')\n            self.exit(1)\n    \n    @property\n    def display_url(self):\n        ip = self.ip if self.ip else '[all ip addresses on your system]'\n        url = self._url(ip)\n        if self.token:\n            # Don't log full token if it came from config\n            token = self.token if self._token_generated else '...'\n            url = url_concat(url, {'token': token})\n        return url\n\n    @property\n    def connection_url(self):\n        ip = self.ip if self.ip else 'localhost'\n        return self._url(ip)\n\n    def _url(self, ip):\n        proto = 'https' if self.certfile else 'http'\n        return \"%s://%s:%i%s\" % (proto, ip, self.port, self.base_url)\n\n    def init_terminals(self):\n        try:\n            from .terminal import initialize\n            initialize(self.web_app, self.notebook_dir, self.connection_url, self.terminado_settings)\n            self.web_app.settings['terminals_available'] = True\n        except ImportError as e:\n            log = self.log.debug if sys.platform == 'win32' else self.log.warning\n            log(\"Terminals not available (error was %s)\", e)\n\n    def init_signal(self):\n        if not sys.platform.startswith('win') and sys.stdin.isatty():\n            signal.signal(signal.SIGINT, self._handle_sigint)\n        signal.signal(signal.SIGTERM, self._signal_stop)\n        if hasattr(signal, 'SIGUSR1'):\n            # Windows doesn't support SIGUSR1\n            signal.signal(signal.SIGUSR1, self._signal_info)\n        if hasattr(signal, 'SIGINFO'):\n            # only on BSD-based systems\n            signal.signal(signal.SIGINFO, self._signal_info)\n    \n    def _handle_sigint(self, sig, frame):\n        \"\"\"SIGINT handler spawns confirmation dialog\"\"\"\n        # register more forceful signal handler for ^C^C case\n        signal.signal(signal.SIGINT, self._signal_stop)\n        # request confirmation dialog in bg thread, to avoid\n        # blocking the App\n        thread = threading.Thread(target=self._confirm_exit)\n        thread.daemon = True\n        thread.start()\n    \n    def _restore_sigint_handler(self):\n        \"\"\"callback for restoring original SIGINT handler\"\"\"\n        signal.signal(signal.SIGINT, self._handle_sigint)\n    \n    def _confirm_exit(self):\n        \"\"\"confirm shutdown on ^C\n        \n        A second ^C, or answering 'y' within 5s will cause shutdown,\n        otherwise original SIGINT handler will be restored.\n        \n        This doesn't work on Windows.\n        \"\"\"\n        info = self.log.info\n        info('interrupted')\n        print(self.notebook_info())\n        sys.stdout.write(\"Shutdown this notebook server (y/[n])? \")\n        sys.stdout.flush()\n        r,w,x = select.select([sys.stdin], [], [], 5)\n        if r:\n            line = sys.stdin.readline()\n            if line.lower().startswith('y') and 'n' not in line.lower():\n                self.log.critical(\"Shutdown confirmed\")\n                ioloop.IOLoop.current().stop()\n                return\n        else:\n            print(\"No answer for 5s:\", end=' ')\n        print(\"resuming operation...\")\n        # no answer, or answer is no:\n        # set it back to original SIGINT handler\n        # use IOLoop.add_callback because signal.signal must be called\n        # from main thread\n        ioloop.IOLoop.current().add_callback(self._restore_sigint_handler)\n    \n    def _signal_stop(self, sig, frame):\n        self.log.critical(\"received signal %s, stopping\", sig)\n        ioloop.IOLoop.current().stop()\n\n    def _signal_info(self, sig, frame):\n        print(self.notebook_info())\n    \n    def init_components(self):\n        \"\"\"Check the components submodule, and warn if it's unclean\"\"\"\n        # TODO: this should still check, but now we use bower, not git submodule\n        pass\n\n    def init_server_extensions(self):\n        \"\"\"Load any extensions specified by config.\n\n        Import the module, then call the load_jupyter_server_extension function,\n        if one exists.\n        \n        The extension API is experimental, and may change in future releases.\n        \"\"\"\n        \n        # TODO: Remove me in notebook 5.0\n        for modulename in self.server_extensions:\n            # Don't override disable state of the extension if it already exist\n            # in the new traitlet\n            if not modulename in self.nbserver_extensions:\n                self.nbserver_extensions[modulename] = True\n        \n        for modulename in sorted(self.nbserver_extensions):\n            if self.nbserver_extensions[modulename]:\n                try:\n                    mod = importlib.import_module(modulename)\n                    func = getattr(mod, 'load_jupyter_server_extension', None)\n                    if func is not None:\n                        func(self)\n                except Exception:\n                    if self.reraise_server_extension_failures:\n                        raise\n                    self.log.warning(\"Error loading server extension %s\", modulename,\n                                  exc_info=True)\n\n    def init_mime_overrides(self):\n        # On some Windows machines, an application has registered an incorrect\n        # mimetype for CSS in the registry. Tornado uses this when serving\n        # .css files, causing browsers to reject the stylesheet. We know the\n        # mimetype always needs to be text/css, so we override it here.\n        mimetypes.add_type('text/css', '.css')\n\n    @catch_config_error\n    def initialize(self, argv=None):\n        super(NotebookApp, self).initialize(argv)\n        self.init_logging()\n        if self._dispatching:\n            return\n        self.init_configurables()\n        self.init_components()\n        self.init_webapp()\n        self.init_terminals()\n        self.init_signal()\n        self.init_server_extensions()\n        self.init_mime_overrides()\n\n    def cleanup_kernels(self):\n        \"\"\"Shutdown all kernels.\n        \n        The kernels will shutdown themselves when this process no longer exists,\n        but explicit shutdown allows the KernelManagers to cleanup the connection files.\n        \"\"\"\n        self.log.info('Shutting down kernels')\n        self.kernel_manager.shutdown_all()\n\n    def notebook_info(self):\n        \"Return the current working directory and the server url information\"\n        info = self.contents_manager.info_string() + \"\\n\"\n        info += \"%d active kernels \\n\" % len(self.kernel_manager._kernels)\n        return info + \"The Jupyter Notebook is running at: %s\" % self.display_url\n\n    def server_info(self):\n        \"\"\"Return a JSONable dict of information about this server.\"\"\"\n        return {'url': self.connection_url,\n                'hostname': self.ip if self.ip else 'localhost',\n                'port': self.port,\n                'secure': bool(self.certfile),\n                'base_url': self.base_url,\n                'token': self.token,\n                'notebook_dir': os.path.abspath(self.notebook_dir),\n                'password': bool(self.password),\n                'pid': os.getpid(),\n               }\n\n    def write_server_info_file(self):\n        \"\"\"Write the result of server_info() to the JSON file info_file.\"\"\"\n        with open(self.info_file, 'w') as f:\n            json.dump(self.server_info(), f, indent=2, sort_keys=True)\n\n    def remove_server_info_file(self):\n        \"\"\"Remove the nbserver-<pid>.json file created for this server.\n        \n        Ignores the error raised when the file has already been removed.\n        \"\"\"\n        try:\n            os.unlink(self.info_file)\n        except OSError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\n    def start(self):\n        \"\"\" Start the Notebook server app, after initialization\n        \n        This method takes no arguments so all configuration and initialization\n        must be done prior to calling this method.\"\"\"\n\n        if not self.allow_root:\n            # check if we are running as root, and abort if it's not allowed\n            try:\n                uid = os.geteuid()\n            except AttributeError:\n                uid = -1 # anything nonzero here, since we can't check UID assume non-root\n            if uid == 0:\n                self.log.critical(\"Running as root is not recommended. Use --allow-root to bypass.\")\n                self.exit(1)\n\n        super(NotebookApp, self).start()\n\n        info = self.log.info\n        for line in self.notebook_info().split(\"\\n\"):\n            info(line)\n        info(\"Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\")\n\n        self.write_server_info_file()\n\n        if self.open_browser or self.file_to_run:\n            try:\n                browser = webbrowser.get(self.browser or None)\n            except webbrowser.Error as e:\n                self.log.warning('No web browser found: %s.' % e)\n                browser = None\n            \n            if self.file_to_run:\n                if not os.path.exists(self.file_to_run):\n                    self.log.critical(\"%s does not exist\" % self.file_to_run)\n                    self.exit(1)\n\n                relpath = os.path.relpath(self.file_to_run, self.notebook_dir)\n                uri = url_escape(url_path_join('notebooks', *relpath.split(os.sep)))\n            else:\n                # default_url contains base_url, but so does connection_url\n                uri = self.default_url[len(self.base_url):]\n            if self.one_time_token:\n                uri = url_concat(uri, {'token': self.one_time_token})\n            if browser:\n                b = lambda : browser.open(url_path_join(self.connection_url, uri),\n                                          new=2)\n                threading.Thread(target=b).start()\n\n        if self.token and self._token_generated:\n            # log full URL with generated token, so there's a copy/pasteable link\n            # with auth info.\n            self.log.critical('\\n'.join([\n                '\\n',\n                'Copy/paste this URL into your browser when you connect for the first time,',\n                'to login with a token:',\n                '    %s' % url_concat(self.connection_url, {'token': self.token}),\n            ]))\n\n        self.io_loop = ioloop.IOLoop.current()\n        if sys.platform.startswith('win'):\n            # add no-op to wake every 5s\n            # to handle signals that may be ignored by the inner loop\n            pc = ioloop.PeriodicCallback(lambda : None, 5000)\n            pc.start()\n        try:\n            self.io_loop.start()\n        except KeyboardInterrupt:\n            info(\"Interrupted...\")\n        finally:\n            self.remove_server_info_file()\n            self.cleanup_kernels()\n\n    def stop(self):\n        def _stop():\n            self.http_server.stop()\n            self.io_loop.stop()\n        self.io_loop.add_callback(_stop)\n\n\ndef list_running_servers(runtime_dir=None):\n    \"\"\"Iterate over the server info files of running notebook servers.\n    \n    Given a runtime directory, find nbserver-* files in the security directory,\n    and yield dicts of their information, each one pertaining to\n    a currently running notebook server instance.\n    \"\"\"\n    if runtime_dir is None:\n        runtime_dir = jupyter_runtime_dir()\n\n    # The runtime dir might not exist\n    if not os.path.isdir(runtime_dir):\n        return\n\n    for file in os.listdir(runtime_dir):\n        if file.startswith('nbserver-'):\n            with io.open(os.path.join(runtime_dir, file), encoding='utf-8') as f:\n                info = json.load(f)\n\n            # Simple check whether that process is really still running\n            # Also remove leftover files from IPython 2.x without a pid field\n            if ('pid' in info) and check_pid(info['pid']):\n                yield info\n            else:\n                # If the process has died, try to delete its info file\n                try:\n                    os.unlink(os.path.join(runtime_dir, file))\n                except OSError:\n                    pass  # TODO: This should warn or log or something\n#-----------------------------------------------------------------------------\n# Main entry point\n#-----------------------------------------------------------------------------\n\nmain = launch_new_instance = NotebookApp.launch_instance\n/n/n/n", "label": 0}, {"id": "d6f091c4439c174c7700776c0cee03053403f600", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport os\nimport re\nimport sys\nimport traceback\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\nsys_info = json.dumps(get_sys_info())\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + url_path_join(self.base_url, csp_report_uri),\n        ])\n\n    def set_default_headers(self):\n        headers = self.settings.get('headers', {})\n\n        if \"Content-Security-Policy\" not in headers:\n            headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name,value in headers.items() :\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/built/contents'))\n        return self.settings.get('contents_js_source', 'services/built/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, allow it.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf checks when token-authenticated\"\"\"\n        if self.token_authenticated:\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=sys_info,\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n        \n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            self.log.debug(\"No template for %d\", status_code)\n            html = self.render_template('error.html', **ns)\n        \n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n    \n    def finish(self, *args, **kwargs):\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb':\n            name = path.rsplit('/', 1)[-1]\n            self.set_header('Content-Type', 'application/json')\n            self.set_header('Content-Disposition','attachment; filename=\"%s\"' % escape.url_escape(name))\n        \n        return web.StaticFileHandler.get(self, path)\n    \n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    @functools.wraps(method)\n    @gen.coroutine\n    def wrapper(self, *args, **kwargs):\n        try:\n            result = yield gen.maybe_future(method(self, *args, **kwargs))\n        except web.HTTPError as e:\n            self.set_header('Content-Type', 'application/json')\n            status = e.status_code\n            message = e.log_message\n            self.log.warning(message)\n            self.set_status(e.status_code)\n            reply = dict(message=message, reason=e.reason)\n            self.finish(json.dumps(reply))\n        except Exception:\n            self.set_header('Content-Type', 'application/json')\n            self.log.error(\"Unhandled error in API request\", exc_info=True)\n            status = 500\n            message = \"Unknown server error\"\n            t, value, tb = sys.exc_info()\n            self.set_status(status)\n            tb_text = ''.join(traceback.format_exception(t, value, tb))\n            reply = dict(message=message, reason=None, traceback=tb_text)\n            self.finish(json.dumps(reply))\n        else:\n            # FIXME: can use regular return in generators in py3\n            raise gen.Return(result)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    @json_errors\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler)\n]\n/n/n/n", "label": 1}, {"id": "1c2a256addf7a5273a40963f92a6351e5d053ae0", "code": "notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook._tz import utcnow\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        if user is None:\n            raise web.HTTPError(403)\n        return user\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if self._track_activity and self.get_current_user():\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers',\n                        'accept, content-type, authorization, x-xsrftoken')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n    \n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n]\n/n/n/n", "label": 0}, {"id": "1c2a256addf7a5273a40963f92a6351e5d053ae0", "code": "/notebook/base/handlers.py/n/n\"\"\"Base Tornado handlers for the notebook server.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport functools\nimport json\nimport mimetypes\nimport os\nimport re\nimport sys\nimport traceback\nimport types\nimport warnings\ntry:\n    # py3\n    from http.client import responses\nexcept ImportError:\n    from httplib import responses\ntry:\n    from urllib.parse import urlparse # Py 3\nexcept ImportError:\n    from urlparse import urlparse # Py 2\n\nfrom jinja2 import TemplateNotFound\nfrom tornado import web, gen, escape\nfrom tornado.log import app_log\n\nfrom notebook._sysinfo import get_sys_info\n\nfrom traitlets.config import Application\nfrom ipython_genutils.path import filefind\nfrom ipython_genutils.py3compat import string_types\n\nimport notebook\nfrom notebook._tz import utcnow\nfrom notebook.utils import is_hidden, url_path_join, url_is_absolute, url_escape\nfrom notebook.services.security import csp_report_uri\n\n#-----------------------------------------------------------------------------\n# Top-level handlers\n#-----------------------------------------------------------------------------\nnon_alphanum = re.compile(r'[^A-Za-z0-9]')\n\n_sys_info_cache = None\ndef json_sys_info():\n    global _sys_info_cache\n    if _sys_info_cache is None:\n        _sys_info_cache = json.dumps(get_sys_info())\n    return _sys_info_cache\n\ndef log():\n    if Application.initialized():\n        return Application.instance().log\n    else:\n        return app_log\n\nclass AuthenticatedHandler(web.RequestHandler):\n    \"\"\"A RequestHandler with an authenticated user.\"\"\"\n\n    @property\n    def content_security_policy(self):\n        \"\"\"The default Content-Security-Policy header\n        \n        Can be overridden by defining Content-Security-Policy in settings['headers']\n        \"\"\"\n        if 'Content-Security-Policy' in self.settings.get('headers', {}):\n            # user-specified, don't override\n            return self.settings['headers']['Content-Security-Policy']\n\n        return '; '.join([\n            \"frame-ancestors 'self'\",\n            # Make sure the report-uri is relative to the base_url\n            \"report-uri \" + self.settings.get('csp_report_uri', url_path_join(self.base_url, csp_report_uri)),\n        ])\n\n    def set_default_headers(self):\n        headers = {}\n        headers.update(self.settings.get('headers', {}))\n\n        headers[\"Content-Security-Policy\"] = self.content_security_policy\n\n        # Allow for overriding headers\n        for header_name, value in headers.items():\n            try:\n                self.set_header(header_name, value)\n            except Exception as e:\n                # tornado raise Exception (not a subclass)\n                # if method is unsupported (websocket and Access-Control-Allow-Origin\n                # for example, so just ignore)\n                self.log.debug(e)\n    \n    def clear_login_cookie(self):\n        self.clear_cookie(self.cookie_name)\n    \n    def get_current_user(self):\n        if self.login_handler is None:\n            return 'anonymous'\n        return self.login_handler.get_user(self)\n\n    def skip_check_origin(self):\n        \"\"\"Ask my login_handler if I should skip the origin_check\n        \n        For example: in the default LoginHandler, if a request is token-authenticated,\n        origin checking should be skipped.\n        \"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'should_check_origin'):\n            return False\n        return not self.login_handler.should_check_origin(self)\n\n    @property\n    def token_authenticated(self):\n        \"\"\"Have I been authenticated with a token?\"\"\"\n        if self.login_handler is None or not hasattr(self.login_handler, 'is_token_authenticated'):\n            return False\n        return self.login_handler.is_token_authenticated(self)\n\n    @property\n    def cookie_name(self):\n        default_cookie_name = non_alphanum.sub('-', 'username-{}'.format(\n            self.request.host\n        ))\n        return self.settings.get('cookie_name', default_cookie_name)\n    \n    @property\n    def logged_in(self):\n        \"\"\"Is a user currently logged in?\"\"\"\n        user = self.get_current_user()\n        return (user and not user == 'anonymous')\n\n    @property\n    def login_handler(self):\n        \"\"\"Return the login handler for this application, if any.\"\"\"\n        return self.settings.get('login_handler_class', None)\n\n    @property\n    def token(self):\n        \"\"\"Return the login token for this application, if any.\"\"\"\n        return self.settings.get('token', None)\n\n    @property\n    def one_time_token(self):\n        \"\"\"Return the one-time-use token for this application, if any.\"\"\"\n        return self.settings.get('one_time_token', None)\n\n    @property\n    def login_available(self):\n        \"\"\"May a user proceed to log in?\n\n        This returns True if login capability is available, irrespective of\n        whether the user is already logged in or not.\n\n        \"\"\"\n        if self.login_handler is None:\n            return False\n        return bool(self.login_handler.get_login_available(self.settings))\n\n\nclass IPythonHandler(AuthenticatedHandler):\n    \"\"\"IPython-specific extensions to authenticated handling\n    \n    Mostly property shortcuts to IPython-specific settings.\n    \"\"\"\n\n    @property\n    def ignore_minified_js(self):\n        \"\"\"Wether to user bundle in template. (*.min files)\n        \n        Mainly use for development and avoid file recompilation\n        \"\"\"\n        return self.settings.get('ignore_minified_js', False)\n\n    @property\n    def config(self):\n        return self.settings.get('config', None)\n    \n    @property\n    def log(self):\n        \"\"\"use the IPython log by default, falling back on tornado's logger\"\"\"\n        return log()\n\n    @property\n    def jinja_template_vars(self):\n        \"\"\"User-supplied values to supply to jinja templates.\"\"\"\n        return self.settings.get('jinja_template_vars', {})\n    \n    #---------------------------------------------------------------\n    # URLs\n    #---------------------------------------------------------------\n    \n    @property\n    def version_hash(self):\n        \"\"\"The version hash to use for cache hints for static files\"\"\"\n        return self.settings.get('version_hash', '')\n    \n    @property\n    def mathjax_url(self):\n        url = self.settings.get('mathjax_url', '')\n        if not url or url_is_absolute(url):\n            return url\n        return url_path_join(self.base_url, url)\n    \n    @property\n    def mathjax_config(self):\n        return self.settings.get('mathjax_config', 'TeX-AMS-MML_HTMLorMML-full,Safe')\n\n    @property\n    def base_url(self):\n        return self.settings.get('base_url', '/')\n\n    @property\n    def default_url(self):\n        return self.settings.get('default_url', '')\n\n    @property\n    def ws_url(self):\n        return self.settings.get('websocket_url', '')\n\n    @property\n    def contents_js_source(self):\n        self.log.debug(\"Using contents: %s\", self.settings.get('contents_js_source',\n            'services/contents'))\n        return self.settings.get('contents_js_source', 'services/contents')\n    \n    #---------------------------------------------------------------\n    # Manager objects\n    #---------------------------------------------------------------\n    \n    @property\n    def kernel_manager(self):\n        return self.settings['kernel_manager']\n\n    @property\n    def contents_manager(self):\n        return self.settings['contents_manager']\n    \n    @property\n    def session_manager(self):\n        return self.settings['session_manager']\n    \n    @property\n    def terminal_manager(self):\n        return self.settings['terminal_manager']\n    \n    @property\n    def kernel_spec_manager(self):\n        return self.settings['kernel_spec_manager']\n\n    @property\n    def config_manager(self):\n        return self.settings['config_manager']\n\n    #---------------------------------------------------------------\n    # CORS\n    #---------------------------------------------------------------\n    \n    @property\n    def allow_origin(self):\n        \"\"\"Normal Access-Control-Allow-Origin\"\"\"\n        return self.settings.get('allow_origin', '')\n    \n    @property\n    def allow_origin_pat(self):\n        \"\"\"Regular expression version of allow_origin\"\"\"\n        return self.settings.get('allow_origin_pat', None)\n    \n    @property\n    def allow_credentials(self):\n        \"\"\"Whether to set Access-Control-Allow-Credentials\"\"\"\n        return self.settings.get('allow_credentials', False)\n    \n    def set_default_headers(self):\n        \"\"\"Add CORS headers, if defined\"\"\"\n        super(IPythonHandler, self).set_default_headers()\n        if self.allow_origin:\n            self.set_header(\"Access-Control-Allow-Origin\", self.allow_origin)\n        elif self.allow_origin_pat:\n            origin = self.get_origin()\n            if origin and self.allow_origin_pat.match(origin):\n                self.set_header(\"Access-Control-Allow-Origin\", origin)\n        if self.allow_credentials:\n            self.set_header(\"Access-Control-Allow-Credentials\", 'true')\n    \n    def set_attachment_header(self, filename):\n        \"\"\"Set Content-Disposition: attachment header\n\n        As a method to ensure handling of filename encoding\n        \"\"\"\n        escaped_filename = url_escape(filename)\n        self.set_header('Content-Disposition',\n            'attachment;'\n            \" filename*=utf-8''{utf8}\"\n            .format(\n                utf8=escaped_filename,\n            )\n        )\n\n    def get_origin(self):\n        # Handle WebSocket Origin naming convention differences\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if \"Origin\" in self.request.headers:\n            origin = self.request.headers.get(\"Origin\")\n        else:\n            origin = self.request.headers.get(\"Sec-Websocket-Origin\", None)\n        return origin\n\n    # origin_to_satisfy_tornado is present because tornado requires\n    # check_origin to take an origin argument, but we don't use it\n    def check_origin(self, origin_to_satisfy_tornado=\"\"):\n        \"\"\"Check Origin for cross-site API requests, including websockets\n\n        Copied from WebSocket with changes:\n\n        - allow unspecified host/origin (e.g. scripts)\n        - allow token-authenticated requests\n        \"\"\"\n        if self.allow_origin == '*' or self.skip_check_origin():\n            return True\n\n        host = self.request.headers.get(\"Host\")\n        origin = self.request.headers.get(\"Origin\")\n\n        # If no header is provided, let the request through.\n        # Origin can be None for:\n        # - same-origin (IE, Firefox)\n        # - Cross-site POST form (IE, Firefox)\n        # - Scripts\n        # The cross-site POST (XSRF) case is handled by tornado's xsrf_token\n        if origin is None or host is None:\n            return True\n\n        origin = origin.lower()\n        origin_host = urlparse(origin).netloc\n\n        # OK if origin matches host\n        if origin_host == host:\n            return True\n\n        # Check CORS headers\n        if self.allow_origin:\n            allow = self.allow_origin == origin\n        elif self.allow_origin_pat:\n            allow = bool(self.allow_origin_pat.match(origin))\n        else:\n            # No CORS headers deny the request\n            allow = False\n        if not allow:\n            self.log.warning(\"Blocking Cross Origin API request for %s.  Origin: %s, Host: %s\",\n                self.request.path, origin, host,\n            )\n        return allow\n\n    def check_xsrf_cookie(self):\n        \"\"\"Bypass xsrf cookie checks when token-authenticated\"\"\"\n        if self.token_authenticated or self.settings.get('disable_check_xsrf', False):\n            # Token-authenticated requests do not need additional XSRF-check\n            # Servers without authentication are vulnerable to XSRF\n            return\n        return super(IPythonHandler, self).check_xsrf_cookie()\n\n    #---------------------------------------------------------------\n    # template rendering\n    #---------------------------------------------------------------\n    \n    def get_template(self, name):\n        \"\"\"Return the jinja template object for a given name\"\"\"\n        return self.settings['jinja2_env'].get_template(name)\n    \n    def render_template(self, name, **ns):\n        ns.update(self.template_namespace)\n        template = self.get_template(name)\n        return template.render(**ns)\n    \n    @property\n    def template_namespace(self):\n        return dict(\n            base_url=self.base_url,\n            default_url=self.default_url,\n            ws_url=self.ws_url,\n            logged_in=self.logged_in,\n            login_available=self.login_available,\n            token_available=bool(self.token or self.one_time_token),\n            static_url=self.static_url,\n            sys_info=json_sys_info(),\n            contents_js_source=self.contents_js_source,\n            version_hash=self.version_hash,\n            ignore_minified_js=self.ignore_minified_js,\n            xsrf_form_html=self.xsrf_form_html,\n            token=self.token,\n            xsrf_token=self.xsrf_token.decode('utf8'),\n            **self.jinja_template_vars\n        )\n    \n    def get_json_body(self):\n        \"\"\"Return the body of the request as JSON data.\"\"\"\n        if not self.request.body:\n            return None\n        # Do we need to call body.decode('utf-8') here?\n        body = self.request.body.strip().decode(u'utf-8')\n        try:\n            model = json.loads(body)\n        except Exception:\n            self.log.debug(\"Bad JSON: %r\", body)\n            self.log.error(\"Couldn't parse JSON\", exc_info=True)\n            raise web.HTTPError(400, u'Invalid JSON in body of request')\n        return model\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"render custom error pages\"\"\"\n        exc_info = kwargs.get('exc_info')\n        message = ''\n        status_message = responses.get(status_code, 'Unknown HTTP Error')\n        exception = '(unknown)'\n        if exc_info:\n            exception = exc_info[1]\n            # get the custom message, if defined\n            try:\n                message = exception.log_message % exception.args\n            except Exception:\n                pass\n            \n            # construct the custom reason, if defined\n            reason = getattr(exception, 'reason', '')\n            if reason:\n                status_message = reason\n        \n        # build template namespace\n        ns = dict(\n            status_code=status_code,\n            status_message=status_message,\n            message=message,\n            exception=exception,\n        )\n\n        self.set_header('Content-Type', 'text/html')\n        # render the template\n        try:\n            html = self.render_template('%s.html' % status_code, **ns)\n        except TemplateNotFound:\n            html = self.render_template('error.html', **ns)\n\n        self.write(html)\n\n\nclass APIHandler(IPythonHandler):\n    \"\"\"Base class for API handlers\"\"\"\n\n    def prepare(self):\n        if not self.check_origin():\n            raise web.HTTPError(404)\n        return super(APIHandler, self).prepare()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"APIHandler errors are JSON, not human pages\"\"\"\n        self.set_header('Content-Type', 'application/json')\n        message = responses.get(status_code, 'Unknown HTTP Error')\n        reply = {\n            'message': message,\n        }\n        exc_info = kwargs.get('exc_info')\n        if exc_info:\n            e = exc_info[1]\n            if isinstance(e, HTTPError):\n                reply['message'] = e.log_message or message\n            else:\n                reply['message'] = 'Unhandled error'\n                reply['traceback'] = ''.join(traceback.format_exception(*exc_info))\n        self.log.warning(reply['message'])\n        self.finish(json.dumps(reply))\n\n    def get_current_user(self):\n        \"\"\"Raise 403 on API handlers instead of redirecting to human login page\"\"\"\n        # preserve _user_cache so we don't raise more than once\n        if hasattr(self, '_user_cache'):\n            return self._user_cache\n        self._user_cache = user = super(APIHandler, self).get_current_user()\n        if user is None:\n            raise web.HTTPError(403)\n        return user\n\n    @property\n    def content_security_policy(self):\n        csp = '; '.join([\n                super(APIHandler, self).content_security_policy,\n                \"default-src 'none'\",\n            ])\n        return csp\n\n    # set _track_activity = False on API handlers that shouldn't track activity\n    _track_activity = True\n\n    def update_api_activity(self):\n        \"\"\"Update last_activity of API requests\"\"\"\n        # record activity of authenticated requests\n        if self._track_activity and self.get_current_user():\n            self.settings['api_last_activity'] = utcnow()\n\n    def finish(self, *args, **kwargs):\n        self.update_api_activity()\n        self.set_header('Content-Type', 'application/json')\n        return super(APIHandler, self).finish(*args, **kwargs)\n\n    def options(self, *args, **kwargs):\n        self.set_header('Access-Control-Allow-Headers', 'accept, content-type, authorization')\n        self.set_header('Access-Control-Allow-Methods',\n                        'GET, PUT, POST, PATCH, DELETE, OPTIONS')\n        self.finish()\n\n\nclass Template404(IPythonHandler):\n    \"\"\"Render our 404 template\"\"\"\n    def prepare(self):\n        raise web.HTTPError(404)\n\n\nclass AuthenticatedFileHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"static files should only be accessible when logged in\"\"\"\n\n    @web.authenticated\n    def get(self, path):\n        if os.path.splitext(path)[1] == '.ipynb' or self.get_argument(\"download\", False):\n            name = path.rsplit('/', 1)[-1]\n            self.set_attachment_header(name)\n\n        return web.StaticFileHandler.get(self, path)\n    \n    def get_content_type(self):\n        path = self.absolute_path.strip('/')\n        if '/' in path:\n            _, name = path.rsplit('/', 1)\n        else:\n            name = path\n        if name.endswith('.ipynb'):\n            return 'application/x-ipynb+json'\n        else:\n            cur_mime = mimetypes.guess_type(name)[0]\n            if cur_mime == 'text/plain':\n                return 'text/plain; charset=UTF-8'\n            else:\n                return super(AuthenticatedFileHandler, self).get_content_type()\n\n    def set_headers(self):\n        super(AuthenticatedFileHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments:\n            self.add_header(\"Cache-Control\", \"no-cache\")\n    \n    def compute_etag(self):\n        return None\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n        \n        Requires tornado 3.1\n        \n        Adding to tornado's own handling, forbids the serving of hidden files.\n        \"\"\"\n        abs_path = super(AuthenticatedFileHandler, self).validate_absolute_path(root, absolute_path)\n        abs_root = os.path.abspath(root)\n        if is_hidden(abs_path, abs_root):\n            self.log.info(\"Refusing to serve hidden file, via 404 Error\")\n            raise web.HTTPError(404)\n        return abs_path\n\n\ndef json_errors(method):\n    \"\"\"Decorate methods with this to return GitHub style JSON errors.\n    \n    This should be used on any JSON API on any handler method that can raise HTTPErrors.\n    \n    This will grab the latest HTTPError exception using sys.exc_info\n    and then:\n    \n    1. Set the HTTP status code based on the HTTPError\n    2. Create and return a JSON body with a message field describing\n       the error in a human readable form.\n    \"\"\"\n    warnings.warn('@json_errors is deprecated in notebook 5.2.0. Subclass APIHandler instead.',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        self.write_error = types.MethodType(APIHandler.write_error, self)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\n\n#-----------------------------------------------------------------------------\n# File handler\n#-----------------------------------------------------------------------------\n\n# to minimize subclass changes:\nHTTPError = web.HTTPError\n\nclass FileFindHandler(IPythonHandler, web.StaticFileHandler):\n    \"\"\"subclass of StaticFileHandler for serving files from a search path\"\"\"\n    \n    # cache search results, don't search for files more than once\n    _static_paths = {}\n    \n    def set_headers(self):\n        super(FileFindHandler, self).set_headers()\n        # disable browser caching, rely on 304 replies for savings\n        if \"v\" not in self.request.arguments or \\\n                any(self.request.path.startswith(path) for path in self.no_cache_paths):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n    \n    def initialize(self, path, default_filename=None, no_cache_paths=None):\n        self.no_cache_paths = no_cache_paths or []\n        \n        if isinstance(path, string_types):\n            path = [path]\n        \n        self.root = tuple(\n            os.path.abspath(os.path.expanduser(p)) + os.sep for p in path\n        )\n        self.default_filename = default_filename\n    \n    def compute_etag(self):\n        return None\n    \n    @classmethod\n    def get_absolute_path(cls, roots, path):\n        \"\"\"locate a file to serve on our static file search path\"\"\"\n        with cls._lock:\n            if path in cls._static_paths:\n                return cls._static_paths[path]\n            try:\n                abspath = os.path.abspath(filefind(path, roots))\n            except IOError:\n                # IOError means not found\n                return ''\n            \n            cls._static_paths[path] = abspath\n            \n\n            log().debug(\"Path %s served from %s\"%(path, abspath))\n            return abspath\n    \n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"check if the file should be served (raises 404, 403, etc.)\"\"\"\n        if absolute_path == '':\n            raise web.HTTPError(404)\n        \n        for root in self.root:\n            if (absolute_path + os.sep).startswith(root):\n                break\n        \n        return super(FileFindHandler, self).validate_absolute_path(root, absolute_path)\n\n\nclass APIVersionHandler(APIHandler):\n\n    def get(self):\n        # not authenticated, so give as few info as possible\n        self.finish(json.dumps({\"version\":notebook.__version__}))\n\n\nclass TrailingSlashHandler(web.RequestHandler):\n    \"\"\"Simple redirect handler that strips trailing slashes\n    \n    This should be the first, highest priority handler.\n    \"\"\"\n    \n    def get(self):\n        self.redirect(self.request.uri.rstrip('/'))\n    \n    post = put = get\n\n\nclass FilesRedirectHandler(IPythonHandler):\n    \"\"\"Handler for redirecting relative URLs to the /files/ handler\"\"\"\n    \n    @staticmethod\n    def redirect_to_files(self, path):\n        \"\"\"make redirect logic a reusable static method\n        \n        so it can be called from other handlers.\n        \"\"\"\n        cm = self.contents_manager\n        if cm.dir_exists(path):\n            # it's a *directory*, redirect to /tree\n            url = url_path_join(self.base_url, 'tree', url_escape(path))\n        else:\n            orig_path = path\n            # otherwise, redirect to /files\n            parts = path.split('/')\n\n            if not cm.file_exists(path=path) and 'files' in parts:\n                # redirect without files/ iff it would 404\n                # this preserves pre-2.0-style 'files/' links\n                self.log.warning(\"Deprecated files/ URL: %s\", orig_path)\n                parts.remove('files')\n                path = '/'.join(parts)\n\n            if not cm.file_exists(path=path):\n                raise web.HTTPError(404)\n\n            url = url_path_join(self.base_url, 'files', url_escape(path))\n        self.log.debug(\"Redirecting %s to %s\", self.request.path, url)\n        self.redirect(url)\n    \n    def get(self, path=''):\n        return self.redirect_to_files(self, path)\n\n\nclass RedirectWithParams(web.RequestHandler):\n    \"\"\"Sam as web.RedirectHandler, but preserves URL parameters\"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        sep = '&' if '?' in self._url else '?'\n        url = sep.join([self._url, self.request.query])\n        self.redirect(url, permanent=self._permanent)\n\n#-----------------------------------------------------------------------------\n# URL pattern fragments for re-use\n#-----------------------------------------------------------------------------\n\n# path matches any number of `/foo[/bar...]` or just `/` or ''\npath_regex = r\"(?P<path>(?:(?:/[^/]+)+|/?))\"\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n\ndefault_handlers = [\n    (r\".*/\", TrailingSlashHandler),\n    (r\"api\", APIVersionHandler),\n    (r'/(robots\\.txt|favicon\\.ico)', web.StaticFileHandler),\n]\n/n/n/n", "label": 1}, {"id": "95d81b6b99a2718be934743e7ba59a1842b273c3", "code": "acl.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport base64\nimport datetime\nimport hashlib\nimport logging\nimport os\nimport re\nimport time\n\n# The app engine headers are located locally, so don't worry about not finding\n# them.\n# pylint: disable=E0611,F0401\nimport webapp2\nfrom google.appengine.api import app_identity\nfrom google.appengine.api import users\nfrom google.appengine.ext import ndb\n# pylint: enable=E0611,F0401\n\nimport template\n\n\n### Models\n\n\nclass GlobalSecret(ndb.Model):\n  \"\"\"Secret.\"\"\"\n  secret = ndb.BlobProperty()\n\n  def _pre_put_hook(self):\n    \"\"\"Generates random data only when necessary.\n\n    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of\n    random data on every process startup, which is unnecessary.\n    \"\"\"\n    self.secret = self.secret or os.urandom(16)\n\n\nclass WhitelistedIP(ndb.Model):\n  \"\"\"Items where the IP address is allowed.\n\n  The key is the ip as returned by ip_to_str(*parse_ip(ip)).\n  \"\"\"\n  # Logs who made the change.\n  timestamp = ndb.DateTimeProperty(auto_now=True)\n  who = ndb.UserProperty(auto_current_user=True)\n\n  # This is used for sharing token. Use case: a slave are multiple HTTP proxies\n  # which different public IP used in a round-robin fashion, so the slave looks\n  # like a different IP at each request, but reuses the original token.\n  group = ndb.StringProperty(indexed=False)\n\n  # The textual representation of the IP of the machine to whitelist. Not used\n  # in practice, just there since the canonical representation is hard to make\n  # sense of.\n  ip = ndb.StringProperty(indexed=False)\n\n  # Is only for maintenance purpose.\n  comment = ndb.StringProperty(indexed=False)\n\n\nclass WhitelistedDomain(ndb.Model):\n  \"\"\"Domain from which users can use the isolate server.\n\n  The key is the domain name, like 'example.com'.\n  \"\"\"\n  # Logs who made the change.\n  timestamp = ndb.DateTimeProperty(auto_now=True)\n  who = ndb.UserProperty(auto_current_user=True)\n\n\n### Utility\n\n\n_GLOBAL_KEY = 'global'\n\n\ndef htmlwrap(text):\n  \"\"\"Wraps text in minimal HTML tags.\"\"\"\n  return '<html><body>%s</body></html>' % text\n\n\ndef parse_ip(ipstr):\n  \"\"\"Returns a long number representing the IP and its type, 'v4' or 'v6'.\n\n  This works around potentially different representations of the same value,\n  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.\n  \"\"\"\n  if '.' in ipstr:\n    # IPv4.\n    try:\n      values = [int(i) for i in ipstr.split('.')]\n    except ValueError:\n      return None, None\n    if len(values) != 4 or not all(0 <= i <= 255 for i in values):\n      return None, None\n    factor = 256\n    iptype = 'v4'\n  else:\n    # IPv6.\n    try:\n      values = [int(i, 16) for i in ipstr.split(':')]\n    except ValueError:\n      return None, None\n    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):\n      return None, None\n    factor = 65536\n    iptype = 'v6'\n  value = 0L\n  for i in values:\n    value = value * factor + i\n  return iptype, value\n\n\ndef ip_to_str(iptype, ipvalue):\n  if not iptype:\n    return None\n  return '%s-%d' % (iptype, ipvalue)\n\n\ndef ipv4_to_int(ip):\n  values = [int(i) for i in ip.split('.')]\n  factor = 256\n  value = 0L\n  for i in values:\n    value = value * factor + i\n  return value\n\n\ndef int_to_ipv4(integer):\n  values = []\n  factor = 256\n  for _ in range(4):\n    values.append(integer % factor)\n    integer = integer / factor\n  return '.'.join(str(i) for i in reversed(values))\n\n\ndef expand_subnet(ip, mask):\n  \"\"\"Returns all the IP addressed comprised in a range.\"\"\"\n  if mask == 32:\n    return [ip]\n  bit = 1 << (32 - mask)\n  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]\n\n\ndef gen_token(access_id, offset, now):\n  \"\"\"Returns a valid token for the access_id.\n\n  |offset| is the offset versus current time of day, in hours. It should be 0\n  or -1.\n  \"\"\"\n  assert offset <= 0\n  # Rotate every hour.\n  this_hour = int(now / 3600.)\n  timestamp = str(this_hour + offset)\n  app_id = app_identity.get_application_id()\n  secrets = (\n      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,\n      str(access_id),\n      str(app_id),\n      timestamp)\n  hashed = hashlib.sha1('\\0'.join(secrets)).digest()\n  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp\n\n\ndef is_valid_token(provided_token, access_id, now):\n  \"\"\"Returns True if the provided token is valid.\"\"\"\n  token_0 = gen_token(access_id, 0, now)\n  if provided_token != token_0:\n    token_1 = gen_token(access_id, -1, now)\n    if provided_token != token_1:\n      logging.info(\n          'Token was invalid:\\nGot %s\\nExpected %s or %s\\nAccessId: %s',\n          provided_token, token_0, token_1, access_id)\n      return False\n  return True\n\n\n### Handlers\n\n\nclass ACLRequestHandler(webapp2.RequestHandler):\n  \"\"\"Adds ACL to the request handler to ensure only valid users can use\n  the handlers.\"\"\"\n  # Set to the uniquely identifiable token, either the userid or the IP address.\n  access_id = None\n  # Set to False if custom processing is required. In that case, a call to\n  # self.enforce_valid_token() is required inside the post() handler.\n  enforce_token_on_post = True\n\n  def dispatch(self):\n    \"\"\"Ensures that only users from valid domains can continue, and that users\n    from invalid domains receive an error message.\"\"\"\n    current_user = users.get_current_user()\n    if current_user:\n      self.check_user(current_user)\n    else:\n      self.check_ip(self.request.remote_addr)\n    if self.request.method == 'POST' and self.enforce_token_on_post:\n      self.enforce_valid_token()\n    return webapp2.RequestHandler.dispatch(self)\n\n  def check_ip(self, ip):\n    \"\"\"Verifies if the IP is whitelisted.\"\"\"\n    self.access_id = ip\n    iptype, ipvalue = parse_ip(ip)\n    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))\n    if not whitelisted:\n      logging.warning('Blocking IP %s', ip)\n      self.abort(401, detail='Please login first.')\n    if whitelisted.group:\n      # Any member of of the group can impersonate others. This is to enable\n      # support for slaves behind proxies with multiple IPs.\n      self.access_id = whitelisted.group\n\n  def check_user(self, user):\n    \"\"\"Verifies if the user is whitelisted.\"\"\"\n    domain = user.email().partition('@')[2]\n    if (not WhitelistedDomain.get_by_id(domain) and\n        not users.is_current_user_admin()):\n      logging.warning('Disallowing %s, invalid domain' % user.email())\n      self.abort(403, detail='Invalid domain, %s' % domain)\n    # user_id() is only set with Google accounts, fallback to the email address\n    # otherwise.\n    self.access_id = user.user_id() or user.email()\n\n  def get_token(self, offset, now):\n    return gen_token(self.access_id, offset, now)\n\n  def enforce_valid_token(self):\n    \"\"\"Ensures the token is valid.\"\"\"\n    token = self.request.get('token')\n    if not token:\n      logging.info('Token was not provided')\n      self.abort(403)\n    if not is_valid_token(token, self.access_id, time.time()):\n      self.abort(403, detail='Invalid token.')\n\n\nclass RestrictedWhitelistIPHandler(ACLRequestHandler):\n  \"\"\"Whitelists the current IP.\n\n  This handler must have login:admin in app.yaml.\n  \"\"\"\n  def get(self):\n    # The user must authenticate with a user credential before being able to\n    # whitelist the IP. This is done with login:admin.\n    data = {\n      'default_comment': '',\n      'default_group': '',\n      'default_ip': self.request.remote_addr,\n      'note': '',\n      'now': datetime.datetime.utcnow(),\n      'token': self.get_token(0, time.time()),\n      'whitelistips': WhitelistedIP.query(),\n    }\n    self.response.out.write(template.get('whitelistip.html').render(data))\n    self.response.headers['Content-Type'] = 'text/html'\n\n  def post(self):\n    comment = self.request.get('comment')\n    group = self.request.get('group')\n    ip = self.request.get('ip')\n    if not comment:\n      self.abort(403, 'Comment is required.')\n    mask = 32\n    if '/' in ip:\n      ip, mask = ip.split('/', 1)\n      mask = int(mask)\n\n    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):\n      self.abort(403, 'IP is invalid')\n\n    note = []\n    for i in expand_subnet(ip, mask):\n      key = ip_to_str(*parse_ip(i))\n      item = WhitelistedIP.get_by_id(key)\n      item_comment = comment\n      if mask != 32:\n        item_comment += ' ' + self.request.get('ip')\n      if item:\n        item.comment = item_comment\n        item.group = group\n        item.ip = i\n        item.put()\n        note.append('Already present: %s' % i)\n      else:\n        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()\n        note.append('Success: %s' % i)\n\n    data = {\n      'default_comment': self.request.get('comment'),\n      'default_group': self.request.get('group'),\n      'default_ip': self.request.get('ip'),\n      'note': '<br>'.join(note),\n      'now': datetime.datetime.utcnow(),\n      'token': self.get_token(0, time.time()),\n      'whitelistips': WhitelistedIP.query(),\n    }\n    self.response.out.write(template.get('whitelistip.html').render(data))\n    self.response.headers['Content-Type'] = 'text/html'\n\n\nclass RestrictedWhitelistDomainHandler(ACLRequestHandler):\n  \"\"\"Whitelists a domain.\n\n  This handler must have login:admin in app.yaml.\n  \"\"\"\n  def get(self):\n    # The user must authenticate with a user credential before being able to\n    # whitelist the IP. This is done with login:admin.\n    self.response.out.write(htmlwrap(\n      '<form name=\"whitelist\" method=\"post\">'\n      'Domain: <input type=\"text\" name=\"domain\" /><br />'\n      '<input type=\"hidden\" name=\"token\" value=\"%s\" />'\n      '<input type=\"submit\" value=\"SUBMIT\" />' %\n        self.get_token(0, time.time())))\n    self.response.headers['Content-Type'] = 'text/html'\n\n  def post(self):\n    domain = self.request.get('domain')\n    if not re.match(r'^[a-z\\.\\-]+$', domain):\n      self.abort(403, 'Invalid domain format')\n    # Do not use get_or_insert() right away so we know if the entity existed\n    # before.\n    if not WhitelistedDomain.get_by_id(domain):\n      WhitelistedDomain.get_or_insert(domain)\n      self.response.out.write(htmlwrap('Success: %s' % domain))\n    else:\n      self.response.out.write(htmlwrap('Already present: %s' % domain))\n    self.response.headers['Content-Type'] = 'text/html'\n\n\nclass GetTokenHandler(ACLRequestHandler):\n  \"\"\"Returns the token.\"\"\"\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/plain'\n    token = self.get_token(0, time.time())\n    self.response.out.write(token)\n    logging.info('Generated %s\\nAccessId: %s', token, self.access_id)\n\n\ndef bootstrap():\n  \"\"\"Adds example.com as a valid domain when testing.\"\"\"\n  if os.environ['SERVER_SOFTWARE'].startswith('Development'):\n    WhitelistedDomain.get_or_insert('example.com')\n    WhitelistedIP.get_or_insert(\n        ip_to_str('v4', 2130706433),\n        ip='127.0.0.1',\n        comment='automatic because of running on dev server')\n/n/n/n", "label": 0}, {"id": "95d81b6b99a2718be934743e7ba59a1842b273c3", "code": "/acl.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport base64\nimport datetime\nimport hashlib\nimport logging\nimport os\nimport re\nimport time\n\n# The app engine headers are located locally, so don't worry about not finding\n# them.\n# pylint: disable=E0611,F0401\nimport webapp2\nfrom google.appengine.api import users\nfrom google.appengine.ext import ndb\n# pylint: enable=E0611,F0401\n\nimport template\n\n\n### Models\n\n\nclass GlobalSecret(ndb.Model):\n  \"\"\"Secret.\"\"\"\n  secret = ndb.BlobProperty()\n\n  def _pre_put_hook(self):\n    \"\"\"Generates random data only when necessary.\n\n    If default=os.urandom(16) was set on secret, it would fetch 16 bytes of\n    random data on every process startup, which is unnecessary.\n    \"\"\"\n    self.secret = self.secret or os.urandom(16)\n\n\nclass WhitelistedIP(ndb.Model):\n  \"\"\"Items where the IP address is allowed.\n\n  The key is the ip as returned by ip_to_str(*parse_ip(ip)).\n  \"\"\"\n  # Logs who made the change.\n  timestamp = ndb.DateTimeProperty(auto_now=True)\n  who = ndb.UserProperty(auto_current_user=True)\n\n  # This is used for sharing token. Use case: a slave are multiple HTTP proxies\n  # which different public IP used in a round-robin fashion, so the slave looks\n  # like a different IP at each request, but reuses the original token.\n  group = ndb.StringProperty(indexed=False)\n\n  # The textual representation of the IP of the machine to whitelist. Not used\n  # in practice, just there since the canonical representation is hard to make\n  # sense of.\n  ip = ndb.StringProperty(indexed=False)\n\n  # Is only for maintenance purpose.\n  comment = ndb.StringProperty(indexed=False)\n\n\nclass WhitelistedDomain(ndb.Model):\n  \"\"\"Domain from which users can use the isolate server.\n\n  The key is the domain name, like 'example.com'.\n  \"\"\"\n  # Logs who made the change.\n  timestamp = ndb.DateTimeProperty(auto_now=True)\n  who = ndb.UserProperty(auto_current_user=True)\n\n\n### Utility\n\n\n_GLOBAL_KEY = 'global'\n\n\ndef htmlwrap(text):\n  \"\"\"Wraps text in minimal HTML tags.\"\"\"\n  return '<html><body>%s</body></html>' % text\n\n\ndef parse_ip(ipstr):\n  \"\"\"Returns a long number representing the IP and its type, 'v4' or 'v6'.\n\n  This works around potentially different representations of the same value,\n  like 1.1.1.1 vs 1.01.1.1 or hex case difference in IPv6.\n  \"\"\"\n  if '.' in ipstr:\n    # IPv4.\n    try:\n      values = [int(i) for i in ipstr.split('.')]\n    except ValueError:\n      return None, None\n    if len(values) != 4 or not all(0 <= i <= 255 for i in values):\n      return None, None\n    factor = 256\n    iptype = 'v4'\n  else:\n    # IPv6.\n    try:\n      values = [int(i, 16) for i in ipstr.split(':')]\n    except ValueError:\n      return None, None\n    if len(values) != 8 or not all(0 <= i <= 65535 for i in values):\n      return None, None\n    factor = 65536\n    iptype = 'v6'\n  value = 0L\n  for i in values:\n    value = value * factor + i\n  return iptype, value\n\n\ndef ip_to_str(iptype, ipvalue):\n  if not iptype:\n    return None\n  return '%s-%d' % (iptype, ipvalue)\n\n\ndef ipv4_to_int(ip):\n  values = [int(i) for i in ip.split('.')]\n  factor = 256\n  value = 0L\n  for i in values:\n    value = value * factor + i\n  return value\n\n\ndef int_to_ipv4(integer):\n  values = []\n  factor = 256\n  for _ in range(4):\n    values.append(integer % factor)\n    integer = integer / factor\n  return '.'.join(str(i) for i in reversed(values))\n\n\ndef expand_subnet(ip, mask):\n  \"\"\"Returns all the IP addressed comprised in a range.\"\"\"\n  if mask == 32:\n    return [ip]\n  bit = 1 << (32 - mask)\n  return [int_to_ipv4(ipv4_to_int(ip) + r) for r in range(bit)]\n\n\ndef gen_token(access_id, offset, now):\n  \"\"\"Returns a valid token for the access_id.\n\n  |offset| is the offset versus current time of day, in hours. It should be 0\n  or -1.\n  \"\"\"\n  assert offset <= 0\n  # Rotate every hour.\n  this_hour = int(now / 3600.)\n  timestamp = str(this_hour + offset)\n  version = os.environ['CURRENT_VERSION_ID']\n  secrets = (\n      GlobalSecret.get_or_insert(_GLOBAL_KEY).secret,\n      str(access_id),\n      str(version),\n      timestamp)\n  hashed = hashlib.sha1('\\0'.join(secrets)).digest()\n  return base64.urlsafe_b64encode(hashed)[:16] + '-' + timestamp\n\n\ndef is_valid_token(provided_token, access_id, now):\n  \"\"\"Returns True if the provided token is valid.\"\"\"\n  token_0 = gen_token(access_id, 0, now)\n  if provided_token != token_0:\n    token_1 = gen_token(access_id, -1, now)\n    if provided_token != token_1:\n      logging.info(\n          'Token was invalid:\\nGot %s\\nExpected %s or %s\\nAccessId: %s',\n          provided_token, token_0, token_1, access_id)\n      return False\n  return True\n\n\n### Handlers\n\n\nclass ACLRequestHandler(webapp2.RequestHandler):\n  \"\"\"Adds ACL to the request handler to ensure only valid users can use\n  the handlers.\"\"\"\n  # Set to the uniquely identifiable token, either the userid or the IP address.\n  access_id = None\n  # Set to False if custom processing is required. In that case, a call to\n  # self.enforce_valid_token() is required inside the post() handler.\n  enforce_token_on_post = True\n\n  def dispatch(self):\n    \"\"\"Ensures that only users from valid domains can continue, and that users\n    from invalid domains receive an error message.\"\"\"\n    current_user = users.get_current_user()\n    if current_user:\n      self.check_user(current_user)\n    else:\n      self.check_ip(self.request.remote_addr)\n    if self.request.method == 'POST' and self.enforce_token_on_post:\n      self.enforce_valid_token()\n    return webapp2.RequestHandler.dispatch(self)\n\n  def check_ip(self, ip):\n    \"\"\"Verifies if the IP is whitelisted.\"\"\"\n    self.access_id = ip\n    iptype, ipvalue = parse_ip(ip)\n    whitelisted = WhitelistedIP.get_by_id(ip_to_str(iptype, ipvalue))\n    if not whitelisted:\n      logging.warning('Blocking IP %s', ip)\n      self.abort(401, detail='Please login first.')\n    if whitelisted.group:\n      # Any member of of the group can impersonate others. This is to enable\n      # support for slaves behind proxies with multiple IPs.\n      self.access_id = whitelisted.group\n\n  def check_user(self, user):\n    \"\"\"Verifies if the user is whitelisted.\"\"\"\n    domain = user.email().partition('@')[2]\n    if (not WhitelistedDomain.get_by_id(domain) and\n        not users.is_current_user_admin()):\n      logging.warning('Disallowing %s, invalid domain' % user.email())\n      self.abort(403, detail='Invalid domain, %s' % domain)\n    # user_id() is only set with Google accounts, fallback to the email address\n    # otherwise.\n    self.access_id = user.user_id() or user.email()\n\n  def get_token(self, offset, now):\n    return gen_token(self.access_id, offset, now)\n\n  def enforce_valid_token(self):\n    \"\"\"Ensures the token is valid.\"\"\"\n    token = self.request.get('token')\n    if not token:\n      logging.info('Token was not provided')\n      self.abort(403)\n    if not is_valid_token(token, self.access_id, time.time()):\n      self.abort(403, detail='Invalid token.')\n\n\nclass RestrictedWhitelistIPHandler(ACLRequestHandler):\n  \"\"\"Whitelists the current IP.\n\n  This handler must have login:admin in app.yaml.\n  \"\"\"\n  def get(self):\n    # The user must authenticate with a user credential before being able to\n    # whitelist the IP. This is done with login:admin.\n    data = {\n      'default_comment': '',\n      'default_group': '',\n      'default_ip': self.request.remote_addr,\n      'note': '',\n      'now': datetime.datetime.utcnow(),\n      'token': self.get_token(0, time.time()),\n      'whitelistips': WhitelistedIP.query(),\n    }\n    self.response.out.write(template.get('whitelistip.html').render(data))\n    self.response.headers['Content-Type'] = 'text/html'\n\n  def post(self):\n    comment = self.request.get('comment')\n    group = self.request.get('group')\n    ip = self.request.get('ip')\n    if not comment:\n      self.abort(403, 'Comment is required.')\n    mask = 32\n    if '/' in ip:\n      ip, mask = ip.split('/', 1)\n      mask = int(mask)\n\n    if not all(ip_to_str(*parse_ip(i)) for i in expand_subnet(ip, mask)):\n      self.abort(403, 'IP is invalid')\n\n    note = []\n    for i in expand_subnet(ip, mask):\n      key = ip_to_str(*parse_ip(i))\n      item = WhitelistedIP.get_by_id(key)\n      item_comment = comment\n      if mask != 32:\n        item_comment += ' ' + self.request.get('ip')\n      if item:\n        item.comment = item_comment\n        item.group = group\n        item.ip = i\n        item.put()\n        note.append('Already present: %s' % i)\n      else:\n        WhitelistedIP(id=key, comment=item_comment, group=group, ip=i).put()\n        note.append('Success: %s' % i)\n\n    data = {\n      'default_comment': self.request.get('comment'),\n      'default_group': self.request.get('group'),\n      'default_ip': self.request.get('ip'),\n      'note': '<br>'.join(note),\n      'now': datetime.datetime.utcnow(),\n      'token': self.get_token(0, time.time()),\n      'whitelistips': WhitelistedIP.query(),\n    }\n    self.response.out.write(template.get('whitelistip.html').render(data))\n    self.response.headers['Content-Type'] = 'text/html'\n\n\nclass RestrictedWhitelistDomainHandler(ACLRequestHandler):\n  \"\"\"Whitelists a domain.\n\n  This handler must have login:admin in app.yaml.\n  \"\"\"\n  def get(self):\n    # The user must authenticate with a user credential before being able to\n    # whitelist the IP. This is done with login:admin.\n    self.response.out.write(htmlwrap(\n      '<form name=\"whitelist\" method=\"post\">'\n      'Domain: <input type=\"text\" name=\"domain\" /><br />'\n      '<input type=\"hidden\" name=\"token\" value=\"%s\" />'\n      '<input type=\"submit\" value=\"SUBMIT\" />' %\n        self.get_token(0, time.time())))\n    self.response.headers['Content-Type'] = 'text/html'\n\n  def post(self):\n    domain = self.request.get('domain')\n    if not re.match(r'^[a-z\\.\\-]+$', domain):\n      self.abort(403, 'Invalid domain format')\n    # Do not use get_or_insert() right away so we know if the entity existed\n    # before.\n    if not WhitelistedDomain.get_by_id(domain):\n      WhitelistedDomain.get_or_insert(domain)\n      self.response.out.write(htmlwrap('Success: %s' % domain))\n    else:\n      self.response.out.write(htmlwrap('Already present: %s' % domain))\n    self.response.headers['Content-Type'] = 'text/html'\n\n\nclass GetTokenHandler(ACLRequestHandler):\n  \"\"\"Returns the token.\"\"\"\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/plain'\n    token = self.get_token(0, time.time())\n    self.response.out.write(token)\n    logging.info('Generated %s\\nAccessId: %s', token, self.access_id)\n\n\ndef bootstrap():\n  \"\"\"Adds example.com as a valid domain when testing.\"\"\"\n  if os.environ['SERVER_SOFTWARE'].startswith('Development'):\n    WhitelistedDomain.get_or_insert('example.com')\n    WhitelistedIP.get_or_insert(\n        ip_to_str('v4', 2130706433),\n        ip='127.0.0.1',\n        comment='automatic because of running on dev server')\n/n/n/n", "label": 1}, {"id": "7b18349622ca2f78a4aeb14ba2eb1e7fc224911d", "code": "services/swarming/swarm_bot/url_helper.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"A helper script for wrapping url calls.\"\"\"\n\nimport hashlib\nimport httplib\nimport logging\nimport math\nimport os\nimport random\nimport socket\nimport time\nimport urllib\nimport urllib2\nimport urlparse\n\nfrom common import swarm_constants  # pylint: disable=W0403\n\n\n# The index of the query elements from urlparse.\nQUERY_INDEX = 4\n\n# The timeout to apply whenever opening a url.\nURL_OPEN_TIMEOUT = 5 * 60\n\n\nclass XsrfRemote(object):\n  \"\"\"Transparently adds XSRF token to requests.\"\"\"\n\n  def __init__(self, url):\n    self.url = url.rstrip('/')\n    self.token = None\n    self.max_tries = 40\n\n  def url_read(self, resource, **kwargs):\n    url = self.url + resource\n    if kwargs.get('method') == 'GET':\n      return UrlOpen(url, max_tries=self.max_tries, **kwargs)\n\n    if not self.token:\n      self.token = self.refresh_token()\n    headers = {'X-XSRF-Token': self.token}\n    resp = UrlOpen(url, headers=headers, max_tries=self.max_tries, **kwargs)\n    if not resp:\n      # This includes 403 because the XSRF token expired. Renew the token.\n      # TODO(maruel): It'd be great if it were transparent.\n      headers = {'X-XSRF-Token': self.refresh_token()}\n      resp = UrlOpen(url, headers=headers, max_tries=self.max_tries, **kwargs)\n    return resp\n\n  def refresh_token(self):\n    \"\"\"Returns a fresh token. Necessary as the token may expire after an hour.\n    \"\"\"\n    url = self.url + '/auth/api/v1/accounts/self/xsrf_token'\n    self.token = UrlOpen(url, max_tries=self.max_tries, method='GET')\n    return self.token\n\n\ndef UrlOpen(url, data=None, files=None, max_tries=5, wait_duration=None,\n            method='POST', headers=None):\n  \"\"\"Attempts to open the given url multiple times.\n\n  UrlOpen will attempt to open the the given url several times, stopping\n  if it succeeds at reaching the url. It also includes an additional data pair\n  in the data that is sent to indicate how many times it has attempted to\n  connect so far.\n\n  Args:\n    url: The url to open.\n    data: The unencoded data to send to the url. This must be a mapping object.\n    files: Files to upload with the url, in the format (key, filename, value).\n        This is only valid when the method is POSTFORM.\n    max_tries: The maximum number of times to try sending this data. Must be\n        greater than 0.\n    wait_duration: The number of seconds to wait between successive attempts.\n        This must be greater than or equal to 0. If no value is given then a\n        random value between 0.1 and 10 will be chosen each time (with\n        exponential back off to give later retries a longer wait).\n    method: Indicates if the request should be a GET or POST request.\n    headers: List of HTTP headers to add.\n\n  Returns:\n    The reponse from the url contacted. If it failed to connect or is given\n    invalid arguments, then it returns None.\n  \"\"\"\n  if max_tries <= 0:\n    logging.error('UrlOpen(%s): Invalid number of tries: %d', url, max_tries)\n    return None\n\n  if wait_duration and wait_duration < 0:\n    logging.error('UrlOpen(%s): Invalid wait duration: %d', url, wait_duration)\n    return None\n\n  data = data or {}\n\n  if swarm_constants.COUNT_KEY in data:\n    logging.error(\n        'UrlOpen(%s): key \\'%s\\' is duplicate.', url, swarm_constants.COUNT_KEY)\n    return None\n\n  url_response = None\n  for attempt in range(max_tries):\n    data[swarm_constants.COUNT_KEY] = attempt\n    try:\n      # urlencode requires that all strings be in ASCII form.\n      for key, value in data.iteritems():\n        if isinstance(value, basestring):\n          data[key] = value.encode('utf-8', 'xmlcharrefreplace')\n\n      encoded_data = urllib.urlencode(data)\n\n      if method == 'POSTFORM':\n        content_type, body = EncodeMultipartFormData(fields=data.iteritems(),\n                                                     files=files)\n        # We must ensure body isn't None to ensure the request is a POST.\n        body = body or ''\n        request = urllib2.Request(url, data=body)\n        request.add_header('Content-Type', content_type)\n        request.add_header('Content-Length', len(body))\n      elif method == 'POST':\n        # Simply specifying data to urlopen makes it a POST.\n        request = urllib2.Request(url, encoded_data)\n      else:\n        url_parts = list(urlparse.urlparse(url))\n        url_parts[QUERY_INDEX] = encoded_data\n        url = urlparse.urlunparse(url_parts)\n        request = urllib2.Request(url)\n\n      for header, value in (headers or {}).iteritems():\n        request.add_header(header, value)\n      url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()\n    except urllib2.HTTPError as e:\n      if e.code >= 500:\n        # The HTTPError was due to a server error, so retry the attempt.\n        logging.warning('UrlOpen(%s): attempt %d: %s ', url, attempt, e)\n      else:\n        # This HTTPError means we reached the server and there was a problem\n        # with the request, so don't retry.\n        logging.exception('UrlOpen(%s): %s', url, e)\n        return None\n    except (httplib.HTTPException, socket.error, urllib2.URLError) as e:\n      logging.warning('UrlOpen(%s): attempt %d: %s', url, attempt, e)\n\n    if url_response is not None:\n      logging.info('UrlOpen(%s) got %d bytes.', url, len(url_response))\n      return url_response\n    elif attempt != max_tries - 1:\n      # Only sleep if we are going to try and connect again.\n      if wait_duration is None:\n        duration = random.random() * 3 + math.pow(1.5, (attempt + 1))\n        duration = min(10, max(0.1, duration))\n      else:\n        duration = wait_duration\n\n      time.sleep(duration)\n\n  logging.error('UrlOpen(%s): Unable to open after %d attempts', url, max_tries)\n  return None\n\n\ndef DownloadFile(local_file, url):\n  \"\"\"Downloads the data from the given url and saves it in the local_file.\n\n  Args:\n    local_file: Where to save the data downloaded from the url.\n    url: Where to fetch the data from.\n\n  Returns:\n    True if the file is successfully downloaded.\n  \"\"\"\n  local_file = os.path.abspath(local_file)\n\n  url_data = UrlOpen(url, method='GET')\n\n  if url_data is None:\n    return False\n\n  try:\n    with open(local_file, 'wb') as f:\n      f.write(url_data)\n  except IOError as e:\n    logging.error('Failed to write to %s\\n%s', local_file, e)\n    return False\n\n  return True\n\n\ndef _ConvertToAscii(value):\n  \"\"\"Convert the given value to an ascii string.\n\n  Args:\n    value: The value to convert.\n\n  Returns:\n    The value as an ascii string.\n  \"\"\"\n  if isinstance(value, str):\n    return value\n  if isinstance(value, unicode):\n    return value.encode('utf-8')\n\n  return str(value)\n\n\ndef EncodeMultipartFormData(fields=None, files=None):\n  \"\"\"Encodes a Multipart form data object.\n\n  This recipe is taken from http://code.activestate.com/recipes/146306/,\n  although it has been slighly modified.\n\n  Args:\n    fields: a sequence (name, value) elements for\n      regular form fields.\n    files: a sequence of (name, filename, value) elements for data to be\n      uploaded as files.\n\n  Returns:\n    content_type: for httplib.HTTP instance\n    body: for httplib.HTTP instance\n  \"\"\"\n  fields = fields or []\n  files = files or []\n\n  boundary = hashlib.md5(str(time.time())).hexdigest()\n  body_list = []\n  for (key, value) in fields:\n    key = _ConvertToAscii(key)\n    value = _ConvertToAscii(value)\n\n    body_list.append('--' + boundary)\n    body_list.append('Content-Disposition: form-data; name=\"%s\"' % key)\n    body_list.append('')\n    body_list.append(value)\n    body_list.append('--' + boundary)\n    body_list.append('')\n\n  for (key, filename, value) in files:\n    key = _ConvertToAscii(key)\n    filename = _ConvertToAscii(filename)\n    value = _ConvertToAscii(value)\n\n    body_list.append('--' + boundary)\n    body_list.append('Content-Disposition: form-data; name=\"%s\"; '\n                     'filename=\"%s\"' % (key, filename))\n    # Other contents types are possible, but swarm is currently only using\n    # this type.\n    body_list.append('Content-Type: application/octet-stream')\n    body_list.append('')\n    body_list.append(value)\n    body_list.append('--' + boundary)\n    body_list.append('')\n\n  if len(body_list) > 1:\n    body_list[-2] += '--'\n\n  body = '\\r\\n'.join(body_list)\n  content_type = 'multipart/form-data; boundary=%s' % boundary\n\n  return content_type, body\n/n/n/nservices/swarming/swarm_bot/url_helper_test.py/n/n#!/usr/bin/env python\n# Copyright 2013 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Unittest to exercise the code in url_helper.py.\"\"\"\n\n\nimport logging\nimport os\nimport stat\nimport StringIO\nimport sys\nimport tempfile\nimport time\nimport unittest\nimport urllib\nimport urllib2\n\nROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, ROOT_DIR)\n\nimport test_env\n\ntest_env.setup_test_env()\n\nfrom depot_tools import auto_stub\nfrom third_party.mox import mox\n\nimport url_helper  # pylint: disable=W0403\n\n\nclass UrlHelperTest(auto_stub.TestCase):\n  def setUp(self):\n    self._mox = mox.Mox()\n\n    self.mock(logging, 'error', lambda *_: None)\n    self.mock(logging, 'exception', lambda *_: None)\n    self.mock(logging, 'info', lambda *_: None)\n    self.mock(logging, 'warning', lambda *_: None)\n    self._mox.StubOutWithMock(time, 'sleep')\n    self._mox.StubOutWithMock(urllib2, 'urlopen')\n\n  def tearDown(self):\n    self._mox.UnsetStubs()\n\n  def testXsrfRemoteGET(self):\n    def assert_url(url):\n      def has_url(req):\n        self.assertEqual(url, req.get_full_url())\n        return True\n      return mox.Func(has_url)\n\n    url_helper.urllib2.urlopen(\n        assert_url('http://localhost/a?UrlOpenAttempt=0'),\n        timeout=300).AndReturn(StringIO.StringIO('foo'))\n    self._mox.ReplayAll()\n\n    remote = url_helper.XsrfRemote('http://localhost/')\n    self.assertEqual('foo', remote.url_read('/a', method='GET'))\n    self._mox.VerifyAll()\n\n  def testXsrfRemoteSimple(self):\n    def assert_url(url):\n      def has_url(req):\n        self.assertEqual(url, req.get_full_url())\n        return True\n      return mox.Func(has_url)\n\n    xsrf_url = (\n      'http://localhost/auth/api/v1/accounts/self/xsrf_token?UrlOpenAttempt=0')\n    url_helper.urllib2.urlopen(\n        assert_url(xsrf_url), timeout=300).AndReturn(StringIO.StringIO('token'))\n    url_helper.urllib2.urlopen(\n        assert_url('http://localhost/a'),\n        timeout=300).AndReturn(StringIO.StringIO('foo'))\n    self._mox.ReplayAll()\n\n    remote = url_helper.XsrfRemote('http://localhost/')\n    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))\n    self._mox.VerifyAll()\n\n  def testXsrfRemoteRefresh(self):\n    self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n\n    url_helper.UrlOpen(\n        'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n        max_tries=40, method='GET').AndReturn('token')\n    url_helper.UrlOpen(\n        'http://localhost/a', data={'foo': 'bar'}, max_tries=40,\n        headers={'X-XSRF-Token': 'token'}\n        ).AndReturn(None)\n    url_helper.UrlOpen(\n        'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n        max_tries=40, method='GET').AndReturn('token2')\n    url_helper.UrlOpen(\n        'http://localhost/a', data={'foo': 'bar'}, max_tries=40,\n        headers={'X-XSRF-Token': 'token2'}\n        ).AndReturn('foo')\n    self._mox.ReplayAll()\n\n    remote = url_helper.XsrfRemote('http://localhost/')\n    remote.url_read('/a', data={'foo': 'bar'})\n    #self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))\n    self._mox.VerifyAll()\n\n  def testUrlOpenInvalidTryCount(self):\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', max_tries=-1), None)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenInvalidWaitDuration(self):\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', wait_duration=-1), None)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenGETSuccess(self):\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(mox.IgnoreArg(),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, method='GET'), response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenPOSTSuccess(self):\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(\n            StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, method='POST'),\n                     response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenPOSTFORMSuccess(self):\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(\n        mox.IsA(urllib2.Request), timeout=mox.IgnoreArg()).AndReturn(\n            StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, method='POSTFORM'),\n                     response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenSuccessAfterFailure(self):\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.URLError('url'))\n    time.sleep(mox.IgnoreArg())\n    response = 'True'\n    url_helper.urllib2.urlopen(mox.IgnoreArg(),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', max_tries=2), response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenFailure(self):\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.URLError('url'))\n    self._mox.ReplayAll()\n\n    self.assertIsNone(url_helper.UrlOpen('url', max_tries=1))\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenHTTPErrorNoRetry(self):\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.HTTPError('url', 400, 'error message', None, None))\n    self._mox.ReplayAll()\n\n    # Even though we set max_tries to 10, we should only try once since\n    # we get an HTTPError.\n    self.assertIsNone(url_helper.UrlOpen('url', max_tries=10))\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenHTTPErrorWithRetry(self):\n    response = 'response'\n\n    # Urlopen failure attempt.\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.HTTPError('url', 500, 'error message', None, None))\n    time.sleep(mox.IgnoreArg())\n\n    # Urlopen success attempt.\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(\n            StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    # Since the HTTPError was a server error, we should retry and get the\n    # desired response after the error.\n    self.assertEqual(response, url_helper.UrlOpen('url', max_tries=10))\n\n    self._mox.VerifyAll()\n\n  def testEnsureCountKeyIncludedInOpen(self):\n    def assert_data(url):\n      def has_data(req):\n        self.assertEqual(url, req.get_data())\n        return True\n      return mox.Func(has_data)\n\n    attempts = 5\n    for i in range(attempts):\n      encoded_data = urllib.urlencode({url_helper.swarm_constants.COUNT_KEY: i})\n      url_helper.urllib2.urlopen(\n          assert_data(encoded_data), timeout=mox.IgnoreArg()).AndRaise(\n              urllib2.URLError('url'))\n      if i != attempts - 1:\n        time.sleep(mox.IgnoreArg())\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', max_tries=attempts), None)\n    self._mox.VerifyAll()\n\n  def testCountKeyInData(self):\n    data = {url_helper.swarm_constants.COUNT_KEY: 1}\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', data=data), None)\n    self._mox.VerifyAll()\n\n  def testNonAcsiiData(self):\n    data = {'r': u'not ascii \\xa3 \\u04bb'}\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(mox.IgnoreArg(),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, data=data), response)\n\n    self._mox.VerifyAll()\n\n  def testDownloadFile(self):\n    local_file = None\n    try:\n      local_file = tempfile.NamedTemporaryFile(delete=False)\n      local_file.close()\n\n      self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n      file_data = 'data'\n      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(file_data)\n      self._mox.ReplayAll()\n\n      self.assertTrue(url_helper.DownloadFile(local_file.name,\n                                              'http://www.fakeurl.com'))\n      with open(local_file.name) as f:\n        self.assertEqual(file_data, f.read())\n\n      self._mox.VerifyAll()\n    finally:\n      if local_file:\n        os.remove(local_file.name)\n\n  def testDownloadFileDownloadError(self):\n    try:\n      fake_file = 'fake_local_file.fake'\n\n      self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(None)\n      self._mox.ReplayAll()\n\n      self.assertFalse(url_helper.DownloadFile(fake_file,\n                                               'http://www.fakeurl.com'))\n      self._mox.VerifyAll()\n    finally:\n      if os.path.exists(fake_file):\n        os.remove(fake_file)\n\n  def testDownloadFileSavingErrors(self):\n    file_readonly = None\n    try:\n      file_readonly = tempfile.NamedTemporaryFile(delete=False)\n      file_readonly.close()\n      os.chmod(file_readonly.name, stat.S_IREAD)\n\n      self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n\n      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn('data')\n      self._mox.ReplayAll()\n\n      self.assertFalse(url_helper.DownloadFile(file_readonly.name,\n                                               'http://www.fakeurl.com'))\n\n      self._mox.VerifyAll()\n    finally:\n      if file_readonly:\n        os.remove(file_readonly.name)\n\n  def testEncodeMultipartFormData(self):\n    fields = [('x', 'y'), (1, 2)]\n    files = [('key', 'filename', 'file data')]\n\n    # Ensure that EncodeMultipartFormData works with any combination of fields\n    # and files.\n    content_type, body = url_helper.EncodeMultipartFormData()\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertEqual('', body)\n\n    content_type, body = url_helper.EncodeMultipartFormData(fields=fields)\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertTrue('name=\"x\"\\r\\n\\r\\ny' in body, body)\n    self.assertTrue('name=\"1\"\\r\\n\\r\\n2' in body, body)\n\n    content_type, body = url_helper.EncodeMultipartFormData(files=files)\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertTrue('name=\"key\"; filename=\"filename\"' in body, body)\n    self.assertTrue('file data' in body, body)\n\n    content_type, body = url_helper.EncodeMultipartFormData(fields=fields,\n                                                            files=files)\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertTrue('name=\"x\"\\r\\n\\r\\ny' in body, body)\n    self.assertTrue('name=\"1\"\\r\\n\\r\\n2' in body, body)\n\n\nif __name__ == '__main__':\n  # We don't want the application logs to interfere with our own messages.\n  # You can comment it out for more information when debugging.\n  logging.disable(logging.FATAL)\n  unittest.main()\n/n/n/n", "label": 0}, {"id": "7b18349622ca2f78a4aeb14ba2eb1e7fc224911d", "code": "/services/swarming/swarm_bot/url_helper.py/n/n# Copyright 2013 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"A helper script for wrapping url calls.\"\"\"\n\nimport hashlib\nimport httplib\nimport logging\nimport math\nimport os\nimport random\nimport socket\nimport time\nimport urllib\nimport urllib2\nimport urlparse\n\nfrom common import swarm_constants  # pylint: disable=W0403\n\n\n# The index of the query elements from urlparse.\nQUERY_INDEX = 4\n\n# The timeout to apply whenever opening a url.\nURL_OPEN_TIMEOUT = 5 * 60\n\n\ndef UrlOpen(url, data=None, files=None, max_tries=5, wait_duration=None,\n            method='POST'):\n  \"\"\"Attempts to open the given url multiple times.\n\n  UrlOpen will attempt to open the the given url several times, stopping\n  if it succeeds at reaching the url. It also includes an additional data pair\n  in the data that is sent to indicate how many times it has attempted to\n  connect so far.\n\n  Args:\n    url: The url to open.\n    data: The unencoded data to send to the url. This must be a mapping object.\n    files: Files to upload with the url, in the format (key, filename, value).\n        This is only valid when the method is POSTFORM.\n    max_tries: The maximum number of times to try sending this data. Must be\n        greater than 0.\n    wait_duration: The number of seconds to wait between successive attempts.\n        This must be greater than or equal to 0. If no value is given then a\n        random value between 0.1 and 10 will be chosen each time (with\n        exponential back off to give later retries a longer wait).\n    method: Indicates if the request should be a GET or POST request.\n\n  Returns:\n    The reponse from the url contacted. If it failed to connect or is given\n    invalid arguments, then it returns None.\n  \"\"\"\n  if max_tries <= 0:\n    logging.error('UrlOpen(%s): Invalid number of tries: %d', url, max_tries)\n    return None\n\n  if wait_duration and wait_duration < 0:\n    logging.error('UrlOpen(%s): Invalid wait duration: %d', url, wait_duration)\n    return None\n\n  data = data or {}\n\n  if swarm_constants.COUNT_KEY in data:\n    logging.error(\n        'UrlOpen(%s): key \\'%s\\' is duplicate.', url, swarm_constants.COUNT_KEY)\n    return None\n\n  url_response = None\n  for attempt in range(max_tries):\n    data[swarm_constants.COUNT_KEY] = attempt\n    try:\n      # urlencode requires that all strings be in ASCII form.\n      for key, value in data.iteritems():\n        if isinstance(value, basestring):\n          data[key] = value.encode('utf-8', 'xmlcharrefreplace')\n\n      encoded_data = urllib.urlencode(data)\n\n      if method == 'POSTFORM':\n        content_type, body = EncodeMultipartFormData(fields=data.iteritems(),\n                                                     files=files)\n        # We must ensure body isn't None to ensure the request is a POST.\n        body = body or ''\n        request = urllib2.Request(url, data=body)\n        request.add_header('Content-Type', content_type)\n        request.add_header('Content-Length', len(body))\n\n        url_response = urllib2.urlopen(request, timeout=URL_OPEN_TIMEOUT).read()\n      elif method == 'POST':\n        # Simply specifying data to urlopen makes it a POST.\n        url_response = urllib2.urlopen(url, encoded_data,\n                                       timeout=URL_OPEN_TIMEOUT).read()\n      else:\n        url_parts = list(urlparse.urlparse(url))\n        url_parts[QUERY_INDEX] = encoded_data\n        url = urlparse.urlunparse(url_parts)\n        url_response = urllib2.urlopen(url, timeout=URL_OPEN_TIMEOUT).read()\n    except urllib2.HTTPError as e:\n      if e.code >= 500:\n        # The HTTPError was due to a server error, so retry the attempt.\n        logging.warning('UrlOpen(%s): attempt %d: %s ', url, attempt, e)\n      else:\n        # This HTTPError means we reached the server and there was a problem\n        # with the request, so don't retry.\n        logging.exception('UrlOpen(%s): %s', url, e)\n        return None\n    except (httplib.HTTPException, socket.error, urllib2.URLError) as e:\n      logging.warning('UrlOpen(%s): attempt %d: %s', url, attempt, e)\n\n    if url_response is not None:\n      logging.info('UrlOpen(%s) got %d bytes.', url, len(url_response))\n      return url_response\n    elif attempt != max_tries - 1:\n      # Only sleep if we are going to try and connect again.\n      if wait_duration is None:\n        duration = random.random() * 3 + math.pow(1.5, (attempt + 1))\n        duration = min(10, max(0.1, duration))\n      else:\n        duration = wait_duration\n\n      time.sleep(duration)\n\n  logging.error('UrlOpen(%s): Unable to open after %d attempts', url, max_tries)\n  return None\n\n\ndef DownloadFile(local_file, url):\n  \"\"\"Downloads the data from the given url and saves it in the local_file.\n\n  Args:\n    local_file: Where to save the data downloaded from the url.\n    url: Where to fetch the data from.\n\n  Returns:\n    True if the file is successfully downloaded.\n  \"\"\"\n  local_file = os.path.abspath(local_file)\n\n  url_data = UrlOpen(url, method='GET')\n\n  if url_data is None:\n    return False\n\n  try:\n    with open(local_file, 'wb') as f:\n      f.write(url_data)\n  except IOError as e:\n    logging.error('Failed to write to %s\\n%s', local_file, e)\n    return False\n\n  return True\n\n\ndef _ConvertToAscii(value):\n  \"\"\"Convert the given value to an ascii string.\n\n  Args:\n    value: The value to convert.\n\n  Returns:\n    The value as an ascii string.\n  \"\"\"\n  if isinstance(value, str):\n    return value\n  if isinstance(value, unicode):\n    return value.encode('utf-8')\n\n  return str(value)\n\n\ndef EncodeMultipartFormData(fields=None, files=None):\n  \"\"\"Encodes a Multipart form data object.\n\n  This recipe is taken from http://code.activestate.com/recipes/146306/,\n  although it has been slighly modified.\n\n  Args:\n    fields: a sequence (name, value) elements for\n      regular form fields.\n    files: a sequence of (name, filename, value) elements for data to be\n      uploaded as files.\n\n  Returns:\n    content_type: for httplib.HTTP instance\n    body: for httplib.HTTP instance\n  \"\"\"\n  fields = fields or []\n  files = files or []\n\n  boundary = hashlib.md5(str(time.time())).hexdigest()\n  body_list = []\n  for (key, value) in fields:\n    key = _ConvertToAscii(key)\n    value = _ConvertToAscii(value)\n\n    body_list.append('--' + boundary)\n    body_list.append('Content-Disposition: form-data; name=\"%s\"' % key)\n    body_list.append('')\n    body_list.append(value)\n    body_list.append('--' + boundary)\n    body_list.append('')\n\n  for (key, filename, value) in files:\n    key = _ConvertToAscii(key)\n    filename = _ConvertToAscii(filename)\n    value = _ConvertToAscii(value)\n\n    body_list.append('--' + boundary)\n    body_list.append('Content-Disposition: form-data; name=\"%s\"; '\n                     'filename=\"%s\"' % (key, filename))\n    # Other contents types are possible, but swarm is currently only using\n    # this type.\n    body_list.append('Content-Type: application/octet-stream')\n    body_list.append('')\n    body_list.append(value)\n    body_list.append('--' + boundary)\n    body_list.append('')\n\n  if len(body_list) > 1:\n    body_list[-2] += '--'\n\n  body = '\\r\\n'.join(body_list)\n  content_type = 'multipart/form-data; boundary=%s' % boundary\n\n  return content_type, body\n/n/n/n/services/swarming/swarm_bot/url_helper_test.py/n/n#!/usr/bin/env python\n# Copyright 2013 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Unittest to exercise the code in url_helper.py.\"\"\"\n\n\nimport logging\nimport os\nimport stat\nimport StringIO\nimport sys\nimport tempfile\nimport time\nimport unittest\nimport urllib\nimport urllib2\n\nROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nsys.path.insert(0, ROOT_DIR)\n\nimport test_env\n\ntest_env.setup_test_env()\n\nfrom depot_tools import auto_stub\nfrom third_party.mox import mox\n\nimport url_helper  # pylint: disable=W0403\n\n\nclass UrlHelperTest(auto_stub.TestCase):\n  def setUp(self):\n    self._mox = mox.Mox()\n\n    self.mock(logging, 'error', lambda *_: None)\n    self.mock(logging, 'exception', lambda *_: None)\n    self.mock(logging, 'info', lambda *_: None)\n    self.mock(logging, 'warning', lambda *_: None)\n    self._mox.StubOutWithMock(time, 'sleep')\n    self._mox.StubOutWithMock(urllib2, 'urlopen')\n\n  def tearDown(self):\n    self._mox.UnsetStubs()\n\n  def testUrlOpenInvalidTryCount(self):\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', max_tries=-1), None)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenInvalidWaitDuration(self):\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', wait_duration=-1), None)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenGETSuccess(self):\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(mox.StrContains(url),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, method='GET'), response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenPOSTSuccess(self):\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(url, mox.IgnoreArg(),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, method='POST'),\n                     response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenPOSTFORMSuccess(self):\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(\n        mox.IsA(urllib2.Request), timeout=mox.IgnoreArg()).AndReturn(\n            StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, method='POSTFORM'),\n                     response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenSuccessAfterFailure(self):\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.URLError('url'))\n    time.sleep(mox.IgnoreArg())\n    response = 'True'\n    url_helper.urllib2.urlopen(mox.IgnoreArg(), mox.IgnoreArg(),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', max_tries=2), response)\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenFailure(self):\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.URLError('url'))\n    self._mox.ReplayAll()\n\n    self.assertIsNone(url_helper.UrlOpen('url', max_tries=1))\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenHTTPErrorNoRetry(self):\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.HTTPError('url', 400, 'error message', None, None))\n    self._mox.ReplayAll()\n\n    # Even though we set max_tries to 10, we should only try once since\n    # we get an HTTPError.\n    self.assertIsNone(url_helper.UrlOpen('url', max_tries=10))\n\n    self._mox.VerifyAll()\n\n  def testUrlOpenHTTPErrorWithRetry(self):\n    response = 'response'\n\n    # Urlopen failure attempt.\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndRaise(\n            urllib2.HTTPError('url', 500, 'error message', None, None))\n    time.sleep(mox.IgnoreArg())\n\n    # Urlopen success attempt.\n    url_helper.urllib2.urlopen(\n        mox.IgnoreArg(), mox.IgnoreArg(), timeout=mox.IgnoreArg()).AndReturn(\n            StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    # Since the HTTPError was a server error, we should retry and get the\n    # desired response after the error.\n    self.assertEqual(response, url_helper.UrlOpen('url', max_tries=10))\n\n    self._mox.VerifyAll()\n\n  def testEnsureCountKeyIncludedInOpen(self):\n    attempts = 5\n    for i in range(attempts):\n      encoded_data = urllib.urlencode({url_helper.swarm_constants.COUNT_KEY: i})\n\n      url_helper.urllib2.urlopen(\n          mox.IgnoreArg(), encoded_data, timeout=mox.IgnoreArg()).AndRaise(\n              urllib2.URLError('url'))\n      if i != attempts - 1:\n        time.sleep(mox.IgnoreArg())\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', max_tries=attempts), None)\n    self._mox.VerifyAll()\n\n  def testCountKeyInData(self):\n    data = {url_helper.swarm_constants.COUNT_KEY: 1}\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen('url', data=data), None)\n    self._mox.VerifyAll()\n\n  def testNonAcsiiData(self):\n    data = {'r': u'not ascii \\xa3 \\u04bb'}\n    url = 'http://my.url.com'\n\n    response = 'True'\n    url_helper.urllib2.urlopen(mox.StrContains(url), mox.IgnoreArg(),\n                               timeout=mox.IgnoreArg()).AndReturn(\n                                   StringIO.StringIO(response))\n\n    self._mox.ReplayAll()\n\n    self.assertEqual(url_helper.UrlOpen(url, data=data), response)\n\n    self._mox.VerifyAll()\n\n  def testDownloadFile(self):\n    local_file = None\n    try:\n      local_file = tempfile.NamedTemporaryFile(delete=False)\n      local_file.close()\n\n      self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n      file_data = 'data'\n      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(file_data)\n      self._mox.ReplayAll()\n\n      self.assertTrue(url_helper.DownloadFile(local_file.name,\n                                              'http://www.fakeurl.com'))\n      with open(local_file.name) as f:\n        self.assertEqual(file_data, f.read())\n\n      self._mox.VerifyAll()\n    finally:\n      if local_file:\n        os.remove(local_file.name)\n\n  def testDownloadFileDownloadError(self):\n    try:\n      fake_file = 'fake_local_file.fake'\n\n      self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn(None)\n      self._mox.ReplayAll()\n\n      self.assertFalse(url_helper.DownloadFile(fake_file,\n                                               'http://www.fakeurl.com'))\n      self._mox.VerifyAll()\n    finally:\n      if os.path.exists(fake_file):\n        os.remove(fake_file)\n\n  def testDownloadFileSavingErrors(self):\n    file_readonly = None\n    try:\n      file_readonly = tempfile.NamedTemporaryFile(delete=False)\n      file_readonly.close()\n      os.chmod(file_readonly.name, stat.S_IREAD)\n\n      self._mox.StubOutWithMock(url_helper, 'UrlOpen')\n\n      url_helper.UrlOpen(mox.IgnoreArg(), method='GET').AndReturn('data')\n      self._mox.ReplayAll()\n\n      self.assertFalse(url_helper.DownloadFile(file_readonly.name,\n                                               'http://www.fakeurl.com'))\n\n      self._mox.VerifyAll()\n    finally:\n      if file_readonly:\n        os.remove(file_readonly.name)\n\n  def testEncodeMultipartFormData(self):\n    fields = [('x', 'y'), (1, 2)]\n    files = [('key', 'filename', 'file data')]\n\n    # Ensure that EncodeMultipartFormData works with any combination of fields\n    # and files.\n    content_type, body = url_helper.EncodeMultipartFormData()\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertEqual('', body)\n\n    content_type, body = url_helper.EncodeMultipartFormData(fields=fields)\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertTrue('name=\"x\"\\r\\n\\r\\ny' in body, body)\n    self.assertTrue('name=\"1\"\\r\\n\\r\\n2' in body, body)\n\n    content_type, body = url_helper.EncodeMultipartFormData(files=files)\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertTrue('name=\"key\"; filename=\"filename\"' in body, body)\n    self.assertTrue('file data' in body, body)\n\n    content_type, body = url_helper.EncodeMultipartFormData(fields=fields,\n                                                            files=files)\n    self.assertTrue(content_type.startswith('multipart/form-data; boundary='))\n    self.assertTrue('name=\"x\"\\r\\n\\r\\ny' in body, body)\n    self.assertTrue('name=\"1\"\\r\\n\\r\\n2' in body, body)\n\n\nif __name__ == '__main__':\n  # We don't want the application logs to interfere with our own messages.\n  # You can comment it out for more information when debugging.\n  logging.disable(logging.FATAL)\n  unittest.main()\n/n/n/n", "label": 1}, {"id": "0ba6a589d77baefc5ae20cde5c3a5dc24a6290f9", "code": "appengine/components/components/auth/handler.py/n/n# Copyright 2014 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Integration with webapp2.\"\"\"\n\n# Disable 'Method could be a function.'\n# pylint: disable=R0201\n\nimport functools\nimport json\nimport logging\nimport urllib\nimport webapp2\n\nfrom google.appengine.api import urlfetch\nfrom google.appengine.api import users\n\nfrom components import utils\n\nfrom . import api\nfrom . import config\nfrom . import delegation\nfrom . import host_token\nfrom . import ipaddr\nfrom . import model\nfrom . import openid\nfrom . import tokens\n\n# Part of public API of 'auth' component, exposed by this module.\n__all__ = [\n  'ApiHandler',\n  'AuthenticatingHandler',\n  'gae_cookie_authentication',\n  'get_authenticated_routes',\n  'oauth_authentication',\n  'openid_cookie_authentication',\n  'require_xsrf_token_request',\n  'service_to_service_authentication',\n]\n\n\ndef require_xsrf_token_request(f):\n  \"\"\"Use for handshaking APIs.\"\"\"\n  @functools.wraps(f)\n  def hook(self, *args, **kwargs):\n    if not self.request.headers.get('X-XSRF-Token-Request'):\n      raise api.AuthorizationError('Missing required XSRF request header')\n    return f(self, *args, **kwargs)\n  return hook\n\n\nclass XSRFToken(tokens.TokenKind):\n  \"\"\"XSRF token parameters.\"\"\"\n  expiration_sec = 4 * 3600\n  secret_key = api.SecretKey('xsrf_token', scope='local')\n  version = 1\n\n\nclass AuthenticatingHandlerMetaclass(type):\n  \"\"\"Ensures that 'get', 'post', etc. are marked with @require or @public.\"\"\"\n\n  def __new__(mcs, name, bases, attributes):\n    for method in webapp2.WSGIApplication.allowed_methods:\n      func = attributes.get(method.lower())\n      if func and not api.is_decorated(func):\n        raise TypeError(\n            'Method \\'%s\\' of \\'%s\\' is not protected by @require or @public '\n            'decorator' % (method.lower(), name))\n    return type.__new__(mcs, name, bases, attributes)\n\n\nclass AuthenticatingHandler(webapp2.RequestHandler):\n  \"\"\"Base class for webapp2 request handlers that use Auth system.\n\n  Knows how to extract Identity from request data and how to initialize auth\n  request context, so that get_current_identity() and is_group_member() work.\n\n  All request handling methods (like 'get', 'post', etc) should be marked by\n  either @require or @public decorators.\n  \"\"\"\n\n  # Checks that all 'get', 'post', etc. are marked with @require or @public.\n  __metaclass__ = AuthenticatingHandlerMetaclass\n\n  # List of HTTP methods that trigger XSRF token validation.\n  xsrf_token_enforce_on = ('DELETE', 'POST', 'PUT')\n  # If not None, the header to search for XSRF token.\n  xsrf_token_header = 'X-XSRF-Token'\n  # If not None, the request parameter (GET or POST) to search for XSRF token.\n  xsrf_token_request_param = 'xsrf_token'\n  # Embedded data extracted from XSRF token of current request.\n  xsrf_token_data = None\n  # If not None, sets X_Frame-Options on all replies.\n  frame_options = 'DENY'\n  # A method used to authenticate this request, see get_auth_methods().\n  auth_method = None\n\n  def dispatch(self):\n    \"\"\"Extracts and verifies Identity, sets up request auth context.\"\"\"\n    # Ensure auth component is configured before executing any code.\n    conf = config.ensure_configured()\n    auth_context = api.reinitialize_request_cache()\n\n    # http://www.html5rocks.com/en/tutorials/security/content-security-policy/\n    # https://www.owasp.org/index.php/Content_Security_Policy\n    # TODO(maruel): Remove 'unsafe-inline' once all inline style=\"foo:bar\" in\n    # all HTML tags were removed. Warning if seeing this post 2016, it could\n    # take a while.\n    # - https://www.google.com is due to Google Viz library.\n    # - https://www.google-analytics.com due to Analytics.\n    # - 'unsafe-eval' due to polymer.\n    self.response.headers['Content-Security-Policy'] = (\n        'default-src https: \\'self\\' \\'unsafe-inline\\' https://www.google.com '\n        'https://www.google-analytics.com \\'unsafe-eval\\'')\n    # Enforce HTTPS by adding the HSTS header; 365*24*60*60s.\n    # https://www.owasp.org/index.php/HTTP_Strict_Transport_Security\n    self.response.headers['Strict-Transport-Security'] = (\n        'max-age=31536000; includeSubDomains; preload')\n    # Disable frame support wholesale.\n    # https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet\n    if self.frame_options:\n      self.response.headers['X-Frame-Options'] = self.frame_options\n\n    identity = None\n    for method_func in self.get_auth_methods(conf):\n      try:\n        identity = method_func(self.request)\n        if identity:\n          break\n      except api.AuthenticationError as err:\n        self.authentication_error(err)\n        return\n      except api.AuthorizationError as err:\n        self.authorization_error(err)\n        return\n    else:\n      method_func = None\n    self.auth_method = method_func\n\n    # If no authentication method is applicable, default to anonymous identity.\n    identity = identity or model.Anonymous\n\n    # XSRF token is required only if using Cookie based or IP whitelist auth.\n    # A browser doesn't send Authorization: 'Bearer ...' or any other headers\n    # by itself. So XSRF check is not required if header based authentication\n    # is used.\n    using_headers_auth = method_func in (\n        oauth_authentication, service_to_service_authentication)\n\n    # Extract caller host name from host token header, if present and valid.\n    host_tok = self.request.headers.get(host_token.HTTP_HEADER)\n    if host_tok:\n      validated_host = host_token.validate_host_token(host_tok)\n      if validated_host:\n        auth_context.peer_host = validated_host\n\n    # Verify IP is whitelisted and authenticate requests from bots.\n    assert self.request.remote_addr\n    ip = ipaddr.ip_from_string(self.request.remote_addr)\n    auth_context.peer_ip = ip\n    try:\n      # 'verify_ip_whitelisted' may change identity for bots, store new one.\n      auth_context.peer_identity = api.verify_ip_whitelisted(\n          identity, ip, self.request.headers)\n    except api.AuthorizationError as err:\n      self.authorization_error(err)\n      return\n\n    # Parse delegation token, if given, to deduce end-user identity.\n    delegation_tok = self.request.headers.get(delegation.HTTP_HEADER)\n    if delegation_tok:\n      try:\n        auth_context.current_identity = delegation.check_delegation_token(\n            delegation_tok, auth_context.peer_identity)\n      except delegation.BadTokenError as exc:\n        self.authorization_error(\n            api.AuthorizationError('Bad delegation token: %s' % exc))\n      except delegation.TransientError as exc:\n        msg = 'Transient error while validating delegation token.\\n%s' % exc\n        logging.error(msg)\n        self.abort(500, detail=msg)\n    else:\n      auth_context.current_identity = auth_context.peer_identity\n\n    try:\n      # Fail if XSRF token is required, but not provided.\n      need_xsrf_token = (\n          not using_headers_auth and\n          self.request.method in self.xsrf_token_enforce_on)\n      if need_xsrf_token and self.xsrf_token is None:\n        raise api.AuthorizationError('XSRF token is missing')\n\n      # If XSRF token is present, verify it is valid and extract its payload.\n      # Do it even if XSRF token is not strictly required, since some handlers\n      # use it to store session state (it is similar to a signed cookie).\n      self.xsrf_token_data = {}\n      if self.xsrf_token is not None:\n        # This raises AuthorizationError if token is invalid.\n        try:\n          self.xsrf_token_data = self.verify_xsrf_token()\n        except api.AuthorizationError as exc:\n          if not need_xsrf_token:\n            logging.warning('XSRF token is broken, ignoring - %s', exc)\n          else:\n            raise\n\n      # All other ACL checks will be performed by corresponding handlers\n      # manually or via '@required' decorator. Failed ACL check raises\n      # AuthorizationError.\n      super(AuthenticatingHandler, self).dispatch()\n    except api.AuthorizationError as err:\n      self.authorization_error(err)\n\n  @classmethod\n  def get_auth_methods(cls, conf):\n    \"\"\"Returns an enumerable of functions to use to authenticate request.\n\n    The handler will try to apply auth methods sequentially one by one by until\n    it finds one that works.\n\n    Each auth method is a function that accepts webapp2.Request and can finish\n    with 3 outcomes:\n\n    * Return None: authentication method is not applicable to that request\n      and next method should be tried (for example cookie-based\n      authentication is not applicable when there's no cookies).\n\n    * Returns Identity associated with the request. Means authentication method\n      is applicable and request authenticity is confirmed.\n\n    * Raises AuthenticationError: authentication method is applicable, but\n      request contains bad credentials or invalid token, etc. For example,\n      OAuth2 token is given, but it is revoked.\n\n    A chosen auth method function will be stored in request's auth_method field.\n\n    Args:\n      conf: components.auth GAE config, see config.py.\n    \"\"\"\n    if conf.USE_OPENID:\n      cookie_auth = openid_cookie_authentication\n    else:\n      cookie_auth = gae_cookie_authentication\n    return oauth_authentication, cookie_auth, service_to_service_authentication\n\n  def generate_xsrf_token(self, xsrf_token_data=None):\n    \"\"\"Returns new XSRF token that embeds |xsrf_token_data|.\n\n    The token is bound to current identity and is valid only when used by same\n    identity.\n    \"\"\"\n    return XSRFToken.generate(\n        [api.get_current_identity().to_bytes()], xsrf_token_data)\n\n  @property\n  def xsrf_token(self):\n    \"\"\"Returns XSRF token passed with the request or None if missing.\n\n    Doesn't do any validation. Use verify_xsrf_token() instead.\n    \"\"\"\n    token = None\n    if self.xsrf_token_header:\n      token = self.request.headers.get(self.xsrf_token_header)\n    if not token and self.xsrf_token_request_param:\n      param = self.request.get_all(self.xsrf_token_request_param)\n      token = param[0] if param else None\n    return token\n\n  def verify_xsrf_token(self):\n    \"\"\"Grabs a token from the request, validates it and extracts embedded data.\n\n    Current identity must be the same as one used to generate the token.\n\n    Returns:\n      Whatever was passed as |xsrf_token_data| in 'generate_xsrf_token'\n      method call used to generate the token.\n\n    Raises:\n      AuthorizationError if token is missing, invalid or expired.\n    \"\"\"\n    token = self.xsrf_token\n    if not token:\n      raise api.AuthorizationError('XSRF token is missing')\n    # Check that it was generated for the same identity.\n    try:\n      return XSRFToken.validate(token, [api.get_current_identity().to_bytes()])\n    except tokens.InvalidTokenError as err:\n      raise api.AuthorizationError(str(err))\n\n  def authentication_error(self, error):\n    \"\"\"Called when authentication fails to report the error to requester.\n\n    Authentication error means that some credentials are provided but they are\n    invalid. If no credentials are provided at all, no authentication is\n    attempted and current identity is just set to 'anonymous:anonymous'.\n\n    Default behavior is to abort the request with HTTP 401 error (and human\n    readable HTML body).\n\n    Args:\n      error: instance of AuthenticationError subclass.\n    \"\"\"\n    logging.warning('Authentication error.\\n%s', error)\n    self.abort(401, detail=str(error))\n\n  def authorization_error(self, error):\n    \"\"\"Called when authentication succeeds, but access to a resource is denied.\n\n    Called whenever request handler raises AuthorizationError exception.\n    In particular this exception is raised by method decorated with @require if\n    current identity doesn't have required permission.\n\n    Default behavior is to abort the request with HTTP 403 error (and human\n    readable HTML body).\n\n    Args:\n      error: instance of AuthorizationError subclass.\n    \"\"\"\n    logging.warning(\n        'Authorization error.\\n%s\\nPeer: %s\\nIP: %s',\n        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)\n    self.abort(403, detail=str(error))\n\n  ### Wrappers around Users API or its OpenID equivalent.\n\n  def get_current_user(self):\n    \"\"\"When cookie auth is used returns instance of CurrentUser or None.\"\"\"\n    return self._get_users_api().get_current_user(self.request)\n\n  def is_current_user_gae_admin(self):\n    \"\"\"When cookie auth is used returns True if current caller is GAE admin.\"\"\"\n    return self._get_users_api().is_current_user_gae_admin(self.request)\n\n  def create_login_url(self, dest_url):\n    \"\"\"When cookie auth is used returns URL to redirect user to login.\"\"\"\n    return self._get_users_api().create_login_url(self.request, dest_url)\n\n  def create_logout_url(self, dest_url):\n    \"\"\"When cookie auth is used returns URL to redirect user to logout.\"\"\"\n    return self._get_users_api().create_logout_url(self.request, dest_url)\n\n  def _get_users_api(self):\n    \"\"\"Returns GAEUsersAPI, OpenIDAPI or raises NotImplementedError.\n\n    Chooses based on what auth_method was used of what methods are available.\n    \"\"\"\n    method = self.auth_method\n    if not method:\n      # Anonymous request -> pick first method that supports API.\n      for method in self.get_auth_methods(config.ensure_configured()):\n        if method in _METHOD_TO_USERS_API:\n          break\n      else:\n        raise NotImplementedError('No methods support UsersAPI')\n    elif method not in _METHOD_TO_USERS_API:\n      raise NotImplementedError(\n          '%s doesn\\'t support UsersAPI' % method.__name__)\n    return _METHOD_TO_USERS_API[method]\n\n\nclass ApiHandler(AuthenticatingHandler):\n  \"\"\"Parses JSON request body to a dict, serializes response to JSON.\"\"\"\n  CONTENT_TYPE_BASE = 'application/json'\n  CONTENT_TYPE_FULL = 'application/json; charset=utf-8'\n  _json_body = None\n  # Clickjacking not applicable to APIs.\n  frame_options = None\n\n  def authentication_error(self, error):\n    logging.warning('Authentication error.\\n%s', error)\n    self.abort_with_error(401, text=str(error))\n\n  def authorization_error(self, error):\n    logging.warning(\n        'Authorization error.\\n%s\\nPeer: %s\\nIP: %s',\n        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)\n    self.abort_with_error(403, text=str(error))\n\n  def send_response(self, response, http_code=200, headers=None):\n    \"\"\"Sends successful reply and continues execution.\"\"\"\n    self.response.set_status(http_code)\n    self.response.headers.update(headers or {})\n    self.response.headers['Content-Type'] = self.CONTENT_TYPE_FULL\n    self.response.write(json.dumps(response))\n\n  def abort_with_error(self, http_code, **kwargs):\n    \"\"\"Sends error reply and stops execution.\"\"\"\n    self.abort(\n        http_code,\n        json=kwargs,\n        headers={'Content-Type': self.CONTENT_TYPE_FULL})\n\n  def parse_body(self):\n    \"\"\"Parses JSON body and verifies it's a dict.\n\n    webob.Request doesn't cache the decoded json body, this function does.\n    \"\"\"\n    if self._json_body is None:\n      if (self.CONTENT_TYPE_BASE and\n          self.request.content_type != self.CONTENT_TYPE_BASE):\n        msg = (\n            'Expecting JSON body with content type \\'%s\\'' %\n            self.CONTENT_TYPE_BASE)\n        self.abort_with_error(400, text=msg)\n      try:\n        self._json_body = self.request.json\n        if not isinstance(self._json_body, dict):\n          raise ValueError()\n      except (LookupError, ValueError):\n        self.abort_with_error(400, text='Not a valid json dict body')\n    return self._json_body.copy()\n\n\ndef get_authenticated_routes(app):\n  \"\"\"Given WSGIApplication returns list of routes that use authentication.\n\n  Intended to be used only for testing.\n  \"\"\"\n  # This code is adapted from router's __repr__ method (that enumerate\n  # all routes for pretty-printing).\n  routes = list(app.router.match_routes)\n  routes.extend(\n      v for k, v in app.router.build_routes.iteritems()\n      if v not in app.router.match_routes)\n  return [r for r in routes if issubclass(r.handler, AuthenticatingHandler)]\n\n\n################################################################################\n## All supported implementations of authentication methods for webapp2 handlers.\n\n\ndef gae_cookie_authentication(_request):\n  \"\"\"AppEngine cookie based authentication via users.get_current_user().\"\"\"\n  user = users.get_current_user()\n  try:\n    return model.Identity(model.IDENTITY_USER, user.email()) if user else None\n  except ValueError:\n    raise api.AuthenticationError('Unsupported user email: %s' % user.email())\n\n\ndef openid_cookie_authentication(request):\n  \"\"\"Cookie based authentication that uses OpenID flow for login.\"\"\"\n  user = openid.get_current_user(request)\n  try:\n    return model.Identity(model.IDENTITY_USER, user.email) if user else None\n  except ValueError:\n    raise api.AuthenticationError('Unsupported user email: %s' % user.email)\n\n\ndef oauth_authentication(request):\n  \"\"\"OAuth2 based authentication via oauth.get_current_user().\"\"\"\n  if not request.headers.get('Authorization'):\n    return None\n  if not utils.is_local_dev_server():\n    return api.extract_oauth_caller_identity()\n\n  # OAuth2 library is mocked on dev server to return some nonsense. Use (slow,\n  # but real) OAuth2 API endpoint instead to validate access_token. It is also\n  # what Cloud Endpoints do on a local server. For simplicity ignore client_id\n  # on dev server.\n  header = request.headers['Authorization'].split(' ', 1)\n  if len(header) != 2 or header[0] not in ('OAuth', 'Bearer'):\n    raise api.AuthenticationError('Invalid authorization header')\n\n  # Adapted from endpoints/users_id_tokens.py, _set_bearer_user_vars_local.\n  base_url = 'https://www.googleapis.com/oauth2/v1/tokeninfo'\n  result = urlfetch.fetch(\n      url='%s?%s' % (base_url, urllib.urlencode({'access_token': header[1]})),\n      follow_redirects=False,\n      validate_certificate=True)\n  if result.status_code != 200:\n    try:\n      error = json.loads(result.content)['error_description']\n    except (KeyError, ValueError):\n      error = repr(result.content)\n    raise api.AuthenticationError('Failed to validate the token: %s' % error)\n\n  token_info = json.loads(result.content)\n  if 'email' not in token_info:\n    raise api.AuthenticationError('Token doesn\\'t include an email address')\n  if not token_info.get('verified_email'):\n    raise api.AuthenticationError('Token email isn\\'t verified')\n\n  email = token_info['email']\n  try:\n    return model.Identity(model.IDENTITY_USER, email)\n  except ValueError:\n    raise api.AuthenticationError('Unsupported user email: %s' % email)\n\n\ndef service_to_service_authentication(request):\n  \"\"\"Used for AppEngine <-> AppEngine communication.\n\n  Relies on X-Appengine-Inbound-Appid header set by AppEngine itself. It can't\n  be set by external users (with exception of admins).\n  \"\"\"\n  app_id = request.headers.get('X-Appengine-Inbound-Appid')\n  try:\n    return model.Identity(model.IDENTITY_SERVICE, app_id) if app_id else None\n  except ValueError:\n    raise api.AuthenticationError('Unsupported application ID: %s' % app_id)\n\n\n################################################################################\n## API wrapper on top of Users API and OpenID API to make them similar.\n\n\nclass CurrentUser(object):\n  \"\"\"Mimics subset of GAE users.User object for ease of transition.\n\n  Also adds .picture().\n  \"\"\"\n\n  def __init__(self, user_id, email, picture):\n    self._user_id = user_id\n    self._email = email\n    self._picture = picture\n\n  def nickname(self):\n    return self._email\n\n  def email(self):\n    return self._email\n\n  def user_id(self):\n    return self._user_id\n\n  def picture(self):\n    return self._picture\n\n  def __unicode__(self):\n    return unicode(self.nickname())\n\n  def __str__(self):\n    return str(self.nickname())\n\n\nclass GAEUsersAPI(object):\n  @staticmethod\n  def get_current_user(request):  # pylint: disable=unused-argument\n    user = users.get_current_user()\n    return CurrentUser(user.user_id(), user.email(), None) if user else None\n\n  @staticmethod\n  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument\n    return users.is_current_user_admin()\n\n  @staticmethod\n  def create_login_url(request, dest_url):  # pylint: disable=unused-argument\n    return users.create_login_url(dest_url)\n\n  @staticmethod\n  def create_logout_url(request, dest_url):  # pylint: disable=unused-argument\n    return users.create_logout_url(dest_url)\n\n\nclass OpenIDAPI(object):\n  @staticmethod\n  def get_current_user(request):\n    user = openid.get_current_user(request)\n    return CurrentUser(user.sub, user.email, user.picture) if user else None\n\n  @staticmethod\n  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument\n    return False\n\n  @staticmethod\n  def create_login_url(request, dest_url):\n    return openid.create_login_url(request, dest_url)\n\n  @staticmethod\n  def create_logout_url(request, dest_url):\n    return openid.create_logout_url(request, dest_url)\n\n\n# See AuthenticatingHandler._get_users_api().\n_METHOD_TO_USERS_API = {\n  gae_cookie_authentication: GAEUsersAPI,\n  openid_cookie_authentication: OpenIDAPI,\n}\n/n/n/nappengine/components/components/auth/handler_test.py/n/n#!/usr/bin/env python\n# Copyright 2014 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n# Disable 'Unused variable', 'Unused argument' and 'Method could be a function'.\n# pylint: disable=W0612,W0613,R0201\n\nimport datetime\nimport json\nimport os\nimport sys\nimport unittest\n\nfrom test_support import test_env\ntest_env.setup_test_env()\n\nfrom google.appengine.api import oauth\nfrom google.appengine.api import users\n\nimport webapp2\nimport webtest\n\nfrom components import utils\nfrom components.auth import api\nfrom components.auth import delegation\nfrom components.auth import handler\nfrom components.auth import host_token\nfrom components.auth import ipaddr\nfrom components.auth import model\nfrom components.auth.proto import delegation_pb2\nfrom test_support import test_case\n\n\nclass AuthenticatingHandlerMetaclassTest(test_case.TestCase):\n  \"\"\"Tests for AuthenticatingHandlerMetaclass.\"\"\"\n\n  def test_good(self):\n    # No request handling methods defined at all.\n    class TestHandler1(handler.AuthenticatingHandler):\n      def some_other_method(self):\n        pass\n\n    # @public is used.\n    class TestHandler2(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        pass\n\n    # @require is used.\n    class TestHandler3(handler.AuthenticatingHandler):\n      @api.require(lambda: True)\n      def get(self):\n        pass\n\n  def test_bad(self):\n    # @public or @require is missing.\n    with self.assertRaises(TypeError):\n      class TestHandler1(handler.AuthenticatingHandler):\n        def get(self):\n          pass\n\n\nclass AuthenticatingHandlerTest(test_case.TestCase):\n  \"\"\"Tests for AuthenticatingHandler class.\"\"\"\n\n  def setUp(self):\n    super(AuthenticatingHandlerTest, self).setUp()\n    # Reset global config of auth library before each test.\n    api.reset_local_state()\n    # Capture error and warning log messages.\n    self.logged_errors = []\n    self.mock(handler.logging, 'error',\n        lambda *args, **kwargs: self.logged_errors.append((args, kwargs)))\n    self.logged_warnings = []\n    self.mock(handler.logging, 'warning',\n        lambda *args, **kwargs: self.logged_warnings.append((args, kwargs)))\n\n  def make_test_app(self, path, request_handler):\n    \"\"\"Returns webtest.TestApp with single route.\"\"\"\n    return webtest.TestApp(\n        webapp2.WSGIApplication([(path, request_handler)], debug=True),\n        extra_environ={'REMOTE_ADDR': '127.0.0.1'})\n\n  def test_anonymous(self):\n    \"\"\"If all auth methods are not applicable, identity is set to Anonymous.\"\"\"\n    test = self\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        non_applicable = lambda _request: None\n        return [non_applicable, non_applicable]\n\n      @api.public\n      def get(self):\n        test.assertEqual(model.Anonymous, api.get_current_identity())\n        self.response.write('OK')\n\n    app = self.make_test_app('/request', Handler)\n    self.assertEqual('OK', app.get('/request').body)\n\n  def test_ip_whitelist_bot(self):\n    \"\"\"Requests from client in \"bots\" IP whitelist are authenticated as bot.\"\"\"\n    model.bootstrap_ip_whitelist('bots', ['192.168.1.100/32'])\n\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(api.get_current_identity().to_bytes())\n\n    app = self.make_test_app('/request', Handler)\n    def call(ip):\n      api.reset_local_state()\n      return app.get('/request', extra_environ={'REMOTE_ADDR': ip}).body\n\n    self.assertEqual('bot:whitelisted-ip', call('192.168.1.100'))\n    self.assertEqual('anonymous:anonymous', call('127.0.0.1'))\n\n  def test_ip_whitelist(self):\n    \"\"\"Per-account IP whitelist works.\"\"\"\n    ident1 = model.Identity(model.IDENTITY_USER, 'a@example.com')\n    ident2 = model.Identity(model.IDENTITY_USER, 'b@example.com')\n\n    model.bootstrap_ip_whitelist('whitelist', ['192.168.1.100/32'])\n    model.bootstrap_ip_whitelist_assignment(ident1, 'whitelist')\n\n    mocked_ident = [None]\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [lambda _req: mocked_ident[0]]\n\n      @api.public\n      def get(self):\n        self.response.write('OK')\n\n    app = self.make_test_app('/request', Handler)\n    def call(ident, ip):\n      api.reset_local_state()\n      mocked_ident[0] = ident\n      response = app.get(\n          '/request', extra_environ={'REMOTE_ADDR': ip}, expect_errors=True)\n      return response.status_int\n\n    # IP is whitelisted.\n    self.assertEqual(200, call(ident1, '192.168.1.100'))\n    # IP is NOT whitelisted.\n    self.assertEqual(403, call(ident1, '127.0.0.1'))\n    # Whitelist is not used.\n    self.assertEqual(200, call(ident2, '127.0.0.1'))\n\n  def test_auth_method_order(self):\n    \"\"\"Registered auth methods are tested in order.\"\"\"\n    test = self\n    calls = []\n    ident = model.Identity(model.IDENTITY_USER, 'joe@example.com')\n\n    def not_applicable(request):\n      self.assertEqual('/request', request.path)\n      calls.append('not_applicable')\n      return None\n\n    def applicable(request):\n      self.assertEqual('/request', request.path)\n      calls.append('applicable')\n      return ident\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [not_applicable, applicable]\n\n      @api.public\n      def get(self):\n        test.assertEqual(ident, api.get_current_identity())\n        self.response.write('OK')\n\n    app = self.make_test_app('/request', Handler)\n    self.assertEqual('OK', app.get('/request').body)\n\n    # Both methods should be tried.\n    expected_calls = [\n      'not_applicable',\n      'applicable',\n    ]\n    self.assertEqual(expected_calls, calls)\n\n  def test_authentication_error(self):\n    \"\"\"AuthenticationError in auth method stops request processing.\"\"\"\n    test = self\n    calls = []\n\n    def failing(request):\n      raise api.AuthenticationError('Too bad')\n\n    def skipped(request):\n      self.fail('authenticate should not be called')\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [failing, skipped]\n\n      @api.public\n      def get(self):\n        test.fail('Handler code should not be called')\n\n      def authentication_error(self, err):\n        test.assertEqual('Too bad', err.message)\n        calls.append('authentication_error')\n        # pylint: disable=bad-super-call\n        super(Handler, self).authentication_error(err)\n\n    app = self.make_test_app('/request', Handler)\n    response = app.get('/request', expect_errors=True)\n\n    # Custom error handler is called and returned HTTP 401.\n    self.assertEqual(['authentication_error'], calls)\n    self.assertEqual(401, response.status_int)\n\n    # Authentication error is logged.\n    self.assertEqual(1, len(self.logged_warnings))\n\n  def test_authorization_error(self):\n    \"\"\"AuthorizationError in auth method is handled.\"\"\"\n    test = self\n    calls = []\n\n    class Handler(handler.AuthenticatingHandler):\n      @api.require(lambda: False)\n      def get(self):\n        test.fail('Handler code should not be called')\n\n      def authorization_error(self, err):\n        calls.append('authorization_error')\n        # pylint: disable=bad-super-call\n        super(Handler, self).authorization_error(err)\n\n    app = self.make_test_app('/request', Handler)\n    response = app.get('/request', expect_errors=True)\n\n    # Custom error handler is called and returned HTTP 403.\n    self.assertEqual(['authorization_error'], calls)\n    self.assertEqual(403, response.status_int)\n\n  def make_xsrf_handling_app(\n      self,\n      xsrf_token_enforce_on=None,\n      xsrf_token_header=None,\n      xsrf_token_request_param=None):\n    \"\"\"Returns webtest app with single XSRF-aware handler.\n\n    If generates XSRF tokens on GET and validates them on POST, PUT, DELETE.\n    \"\"\"\n    calls = []\n\n    def record(request_handler, method):\n      is_valid = request_handler.xsrf_token_data == {'some': 'data'}\n      calls.append((method, is_valid))\n\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(self.generate_xsrf_token({'some': 'data'}))\n      @api.public\n      def post(self):\n        record(self, 'POST')\n      @api.public\n      def put(self):\n        record(self, 'PUT')\n      @api.public\n      def delete(self):\n        record(self, 'DELETE')\n\n    if xsrf_token_enforce_on is not None:\n      Handler.xsrf_token_enforce_on = xsrf_token_enforce_on\n    if xsrf_token_header is not None:\n      Handler.xsrf_token_header = xsrf_token_header\n    if xsrf_token_request_param is not None:\n      Handler.xsrf_token_request_param = xsrf_token_request_param\n\n    app = self.make_test_app('/request', Handler)\n    return app, calls\n\n  def mock_get_current_identity(self, ident):\n    \"\"\"Mocks api.get_current_identity() to return |ident|.\"\"\"\n    self.mock(handler.api, 'get_current_identity', lambda: ident)\n\n  def test_xsrf_token_get_param(self):\n    \"\"\"XSRF token works if put in GET parameters.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    token = app.get('/request').body\n    app.post('/request?xsrf_token=%s' % token)\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_post_param(self):\n    \"\"\"XSRF token works if put in POST parameters.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    token = app.get('/request').body\n    app.post('/request', {'xsrf_token': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_header(self):\n    \"\"\"XSRF token works if put in the headers.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    token = app.get('/request').body\n    app.post('/request', headers={'X-XSRF-Token': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_missing(self):\n    \"\"\"XSRF token is not given but handler requires it.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    response = app.post('/request', expect_errors=True)\n    self.assertEqual(403, response.status_int)\n    self.assertFalse(calls)\n\n  def test_xsrf_token_uses_enforce_on(self):\n    \"\"\"Only methods set in |xsrf_token_enforce_on| require token validation.\"\"\"\n    # Validate tokens only on PUT (not on POST).\n    app, calls = self.make_xsrf_handling_app(xsrf_token_enforce_on=('PUT',))\n    token = app.get('/request').body\n    # Both POST and PUT work when token provided, verifying it.\n    app.post('/request', {'xsrf_token': token})\n    app.put('/request', {'xsrf_token': token})\n    self.assertEqual([('POST', True), ('PUT', True)], calls)\n    # POST works without a token, put PUT doesn't.\n    self.assertEqual(200, app.post('/request').status_int)\n    self.assertEqual(403, app.put('/request', expect_errors=True).status_int)\n    # Only the one that requires the token fails if wrong token is provided.\n    bad_token = {'xsrf_token': 'boo'}\n    self.assertEqual(200, app.post('/request', bad_token).status_int)\n    self.assertEqual(\n        403, app.put('/request', bad_token, expect_errors=True).status_int)\n\n  def test_xsrf_token_uses_xsrf_token_header(self):\n    \"\"\"Name of the header used for XSRF can be changed.\"\"\"\n    app, calls = self.make_xsrf_handling_app(xsrf_token_header='X-Some')\n    token = app.get('/request').body\n    app.post('/request', headers={'X-Some': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_uses_xsrf_token_request_param(self):\n    \"\"\"Name of the request param used for XSRF can be changed.\"\"\"\n    app, calls = self.make_xsrf_handling_app(xsrf_token_request_param='tok')\n    token = app.get('/request').body\n    app.post('/request', {'tok': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_identity_matters(self):\n    app, calls = self.make_xsrf_handling_app()\n    # Generate token for identity A.\n    self.mock_get_current_identity(\n        model.Identity(model.IDENTITY_USER, 'a@example.com'))\n    token = app.get('/request').body\n    # Try to use it by identity B.\n    self.mock_get_current_identity(\n        model.Identity(model.IDENTITY_USER, 'b@example.com'))\n    response = app.post('/request', expect_errors=True)\n    self.assertEqual(403, response.status_int)\n    self.assertFalse(calls)\n\n  def test_get_authenticated_routes(self):\n    class Authenticated(handler.AuthenticatingHandler):\n      pass\n\n    class NotAuthenticated(webapp2.RequestHandler):\n      pass\n\n    app = webapp2.WSGIApplication([\n      webapp2.Route('/authenticated', Authenticated),\n      webapp2.Route('/not-authenticated', NotAuthenticated),\n    ])\n    routes = handler.get_authenticated_routes(app)\n    self.assertEqual(1, len(routes))\n    self.assertEqual(Authenticated, routes[0].handler)\n\n  def test_get_peer_ip(self):\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(ipaddr.ip_to_string(api.get_peer_ip()))\n\n    app = self.make_test_app('/request', Handler)\n    response = app.get('/request', extra_environ={'REMOTE_ADDR': '192.1.2.3'})\n    self.assertEqual('192.1.2.3', response.body)\n\n  def test_get_peer_host(self):\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(api.get_peer_host() or '<none>')\n\n    app = self.make_test_app('/request', Handler)\n    def call(headers):\n      api.reset_local_state()\n      return app.get('/request', headers=headers).body\n\n    # Good token.\n    token = host_token.create_host_token('HOST.domain.com')\n    self.assertEqual('host.domain.com', call({'X-Host-Token-V1': token}))\n\n    # Missing or invalid tokens.\n    self.assertEqual('<none>', call({}))\n    self.assertEqual('<none>', call({'X-Host-Token-V1': 'broken'}))\n\n    # Expired token.\n    origin = datetime.datetime(2014, 1, 1, 1, 1, 1)\n    self.mock_now(origin)\n    token = host_token.create_host_token('HOST.domain.com', expiration_sec=60)\n    self.mock_now(origin, 61)\n    self.assertEqual('<none>', call({'X-Host-Token-V1': token}))\n\n  def test_delegation_token(self):\n    peer_ident = model.Identity.from_bytes('user:peer@a.com')\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [lambda _request: peer_ident]\n\n      @api.public\n      def get(self):\n        self.response.write(json.dumps({\n          'peer_id': api.get_peer_identity().to_bytes(),\n          'cur_id': api.get_current_identity().to_bytes(),\n        }))\n\n    app = self.make_test_app('/request', Handler)\n    def call(headers=None):\n      return json.loads(app.get('/request', headers=headers).body)\n\n    # No delegation.\n    self.assertEqual(\n        {u'cur_id': u'user:peer@a.com', u'peer_id': u'user:peer@a.com'}, call())\n\n    # TODO(vadimsh): Mint token via some high-level function call.\n    subtokens = delegation_pb2.SubtokenList(subtokens=[\n        delegation_pb2.Subtoken(\n            issuer_id='user:delegated@a.com',\n            creation_time=int(utils.time_time()),\n            validity_duration=3600),\n    ])\n    tok = delegation.serialize_token(delegation.seal_token(subtokens))\n\n    # With valid delegation token.\n    self.assertEqual(\n        {u'cur_id': u'user:delegated@a.com', u'peer_id': u'user:peer@a.com'},\n        call({'X-Delegation-Token-V1': tok}))\n\n    # With invalid delegation token.\n    r = app.get(\n        '/request',\n        headers={'X-Delegation-Token-V1': tok + 'blah'},\n        expect_errors=True)\n    self.assertEqual(403, r.status_int)\n\n    # Transient error.\n    def mocked_check(*_args):\n      raise delegation.TransientError('Blah')\n    self.mock(delegation, 'check_delegation_token', mocked_check)\n    r = app.get(\n        '/request',\n        headers={'X-Delegation-Token-V1': tok},\n        expect_errors=True)\n    self.assertEqual(500, r.status_int)\n\n\nclass GaeCookieAuthenticationTest(test_case.TestCase):\n  \"\"\"Tests for gae_cookie_authentication function.\"\"\"\n\n  def test_non_applicable(self):\n    self.assertIsNone(handler.gae_cookie_authentication(webapp2.Request({})))\n\n  def test_applicable(self):\n    os.environ.update({\n      'USER_EMAIL': 'joe@example.com',\n      'USER_ID': '123',\n      'USER_IS_ADMIN': '0',\n    })\n    # Actual request is not used by CookieAuthentication.\n    self.assertEqual(\n        model.Identity(model.IDENTITY_USER, 'joe@example.com'),\n        handler.gae_cookie_authentication(webapp2.Request({})))\n\n\nclass ServiceToServiceAuthenticationTest(test_case.TestCase):\n  \"\"\"Tests for service_to_service_authentication.\"\"\"\n\n  def test_non_applicable(self):\n    request = webapp2.Request({})\n    self.assertIsNone(\n        handler.service_to_service_authentication(request))\n\n  def test_applicable(self):\n    request = webapp2.Request({\n      'HTTP_X_APPENGINE_INBOUND_APPID': 'some-app',\n    })\n    self.assertEqual(\n      model.Identity(model.IDENTITY_SERVICE, 'some-app'),\n      handler.service_to_service_authentication(request))\n\n\nif __name__ == '__main__':\n  if '-v' in sys.argv:\n    unittest.TestCase.maxDiff = None\n  unittest.main()\n/n/n/nappengine/components/components/auth/model.py/n/n# Copyright 2014 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"NDB model classes used to model AuthDB relations.\n\nOverview\n--------\n\nModels defined here are used by central authentication service (that stores all\ngroups and secrets) and by services that implement some concrete functionality\nprotected with ACLs (like isolate and swarming services).\n\nApplications that use auth component may work in 3 modes:\n  1. Standalone. Application is self contained and manages its own groups.\n     Useful when developing a new service or for simple installations.\n  2. Replica. Application uses a central authentication service. An application\n     can be dynamically switched from Standalone to Replica mode.\n  3. Primary. Application IS a central authentication service. Only 'auth'\n     service is running in this mode. 'configure_as_primary' call during startup\n     switches application to that mode.\n\nCentral authentication service (Primary) holds authoritative copy of all auth\nrelated information (groups, secrets, etc.) and acts as a single source of truth\nfor it. All other services (Replicas) hold copies of a relevant subset of\nthis information (that they use to perform authorization checks).\n\nPrimary service is responsible for updating replicas' configuration via\nservice-to-service push based replication protocol.\n\nAuthDB holds a list of groups. Each group has a unique name and is defined\nas union of 3 sets:\n  1) Explicit enumeration of particular Identities e.g. 'user:alice@example.com'\n  2) Set of glob-like identity patterns e.g. 'user:*@example.com'\n  3) Set of nested Groups.\n\nIdentity defines an actor making an action (it can be a real person, a bot,\nan AppEngine application or special 'anonymous' identity).\n\nIn addition to that, AuthDB stores small amount of authentication related\nconfiguration data, such as OAuth2 client_id and client_secret and various\nsecret keys.\n\nAudit trail\n-----------\n\nEach change to AuthDB has an associated revision number (that monotonically\nincreases with each change). All entities modified by a change are copied to\nappend-only log under an entity key associated with the revision (see\nhistorical_revision_key below). Removals are marked by special auth_db_deleted\nflag in entites in the log. This is enough to recover a snapshot of all groups\nat some specific moment in time, or to produce a diff between two revisions.\n\nNote that entities in the historical log are not used by online queries. At any\nmoment in time most recent version of an AuthDB entity exists in two copies:\n  1) Main copy used for online queries. It is mutated in-place with each change.\n  2) Most recent record in the historical log. Read only.\n\nTo reduce a possibility of misuse of historical copies in online transactions,\nhistory log entity classes are suffixied with 'History' suffix. They also have\nall indexes stripped.\n\nThis mechanism is enabled only on services in Standalone or Primary mode.\nReplicas do not keep track of AuthDB revisions and do not keep any historical\nlog.\n\"\"\"\n\nimport collections\nimport fnmatch\nimport logging\nimport os\nimport re\n\nfrom google.appengine.api import app_identity\nfrom google.appengine.ext import ndb\n\nfrom components import datastore_utils\nfrom components import utils\n\nfrom . import ipaddr\n\n# Part of public API of 'auth' component, exposed by this module.\n__all__ = [\n  'ADMIN_GROUP',\n  'Anonymous',\n  'bootstrap_group',\n  'bootstrap_ip_whitelist',\n  'bootstrap_loopback_ips',\n  'BOTS_IP_WHITELIST',\n  'configure_as_primary',\n  'find_group_dependency_cycle',\n  'find_referencing_groups',\n  'get_auth_db_revision',\n  'get_missing_groups',\n  'get_service_self_identity',\n  'group_key',\n  'Identity',\n  'IDENTITY_ANONYMOUS',\n  'IDENTITY_BOT',\n  'IDENTITY_SERVICE',\n  'IDENTITY_USER',\n  'IdentityGlob',\n  'IdentityProperty',\n  'ip_whitelist_key',\n  'is_empty_group',\n  'is_external_group_name',\n  'is_primary',\n  'is_replica',\n  'is_standalone',\n  'is_valid_group_name',\n  'is_valid_ip_whitelist_name',\n  'replicate_auth_db',\n]\n\n\n# Name of a group whose members have access to Group management UI. It's the\n# only group needed to bootstrap everything else.\nADMIN_GROUP = 'administrators'\n\n# Name of AuthIPWhitelist with bots IP ranges. See AuthIPWhitelist.\nBOTS_IP_WHITELIST = 'bots'\n\n# No identity information is provided. Identity name is always 'anonymous'.\nIDENTITY_ANONYMOUS = 'anonymous'\n# Using bot credentials. Identity name is bot's id.\nIDENTITY_BOT = 'bot'\n# Using App Engine service credentials. Identity name is app name.\nIDENTITY_SERVICE = 'service'\n# Using user credentials. Identity name is user's email.\nIDENTITY_USER = 'user'\n\n# All allowed identity kinds + regexps to validate identity name.\nALLOWED_IDENTITY_KINDS = {\n  IDENTITY_ANONYMOUS: re.compile(r'^anonymous$'),\n  IDENTITY_BOT: re.compile(r'^[0-9a-zA-Z_\\-\\.@]+$'),\n  IDENTITY_SERVICE: re.compile(r'^[0-9a-zA-Z_\\-\\:\\.]+$'),\n  IDENTITY_USER: re.compile(r'^[0-9a-zA-Z_\\-\\.\\+]+@[0-9a-z_\\-\\.]+$'),\n}\n\n# Regular expression that matches group names. ASCII only, no leading or\n# trailing spaces allowed (spaces inside are fine).\nGROUP_NAME_RE = re.compile(\n    r'^([a-z\\-]+/)?[0-9a-zA-Z_][0-9a-zA-Z_\\-\\.\\ ]{1,80}[0-9a-zA-Z_\\-\\.]$')\n# Special group name that means 'All possible users' (including anonymous!).\nGROUP_ALL = '*'\n\n# Regular expression for IP whitelist name.\nIP_WHITELIST_NAME_RE = re.compile(r'^[0-9a-zA-Z_\\-\\+\\.\\ ]{2,200}$')\n\n\n# Configuration of Primary service, set by 'configure_as_primary'.\n_replication_callback = None\n\n\n# Root ndb keys of various models. They can't be defined as a module level\n# constants because ndb.Key implicitly includes current APPLICATION_ID. And in\n# testing environment it is '_' during module loading time. Trying to use such\n# key from within a testbed test case results in the following error:\n# BadRequestError: app \"testbed-test\" cannot access app \"_\"'s data\n\n\ndef root_key():\n  \"\"\"Global root key of auth models entity group.\"\"\"\n  return ndb.Key('AuthGlobalConfig', 'root')\n\n\ndef replication_state_key():\n  \"\"\"Key of AuthReplicationState entity.\"\"\"\n  return ndb.Key('AuthReplicationState', 'self', parent=root_key())\n\n\ndef ip_whitelist_assignments_key():\n  \"\"\"Key of AuthIPWhitelistAssignments entity.\"\"\"\n  return ndb.Key('AuthIPWhitelistAssignments', 'default', parent=root_key())\n\n\ndef historical_revision_key(auth_db_rev):\n  \"\"\"Key for entity subgroup that holds changes done in a concrete revision.\"\"\"\n  return ndb.Key('Rev', auth_db_rev, parent=root_key())\n\n\n################################################################################\n## Identity & IdentityGlob.\n\n\nclass Identity(\n    datastore_utils.BytesSerializable,\n    collections.namedtuple('Identity', 'kind, name')):\n  \"\"\"Represents a caller that makes requests. Immutable.\n\n  A tuple of (kind, name) where 'kind' is one of IDENTITY_* constants and\n  meaning of 'name' depends on a kind (see comments for IDENTITY_*).\n  It generalizes accounts of real people, bot accounts and service-to-service\n  accounts.\n\n  It's a pure identity information. Any additional information that may be\n  related to an identity (e.g. registration date, last access time, etc.) should\n  be stored elsewhere using Identity.to_bytes() as a key.\n  \"\"\"\n\n  # Inheriting from tuple requires use of __new__ instead of __init__. __init__\n  # is called with object already 'frozen', so it's not possible to modify its\n  # attributes in __init__.\n  # See http://docs.python.org/2/reference/datamodel.html#object.__new__\n  def __new__(cls, kind, name):\n    if isinstance(name, unicode):\n      try:\n        name = name.encode('ascii')\n      except UnicodeEncodeError:\n        raise ValueError('Identity has invalid format: only ASCII is allowed')\n    if (kind not in ALLOWED_IDENTITY_KINDS or\n        not ALLOWED_IDENTITY_KINDS[kind].match(name)):\n      raise ValueError('Identity has invalid format: %s' % name)\n    return super(Identity, cls).__new__(cls, str(kind), name)\n\n  def to_bytes(self):\n    \"\"\"Serializes this identity to byte buffer.\"\"\"\n    return '%s:%s' % (self.kind, self.name)\n\n  @classmethod\n  def from_bytes(cls, byte_buf):\n    \"\"\"Given a byte buffer returns corresponding Identity object.\"\"\"\n    kind, sep, name = byte_buf.partition(':')\n    if not sep:\n      raise ValueError('Missing \\':\\' separator in Identity string')\n    return cls(kind, name)\n\n  @property\n  def is_anonymous(self):\n    \"\"\"True if this object represents anonymous identity.\"\"\"\n    return self.kind == IDENTITY_ANONYMOUS\n\n  @property\n  def is_bot(self):\n    \"\"\"True if this object represents bot account.\"\"\"\n    return self.kind == IDENTITY_BOT\n\n  @property\n  def is_service(self):\n    \"\"\"True if this object represents service account.\"\"\"\n    return self.kind == IDENTITY_SERVICE\n\n  @property\n  def is_user(self):\n    \"\"\"True if this object represents user account.\"\"\"\n    return self.kind == IDENTITY_USER\n\n\n# Predefined Anonymous identity.\nAnonymous = Identity(IDENTITY_ANONYMOUS, 'anonymous')\n\n\nclass IdentityProperty(datastore_utils.BytesSerializableProperty):\n  \"\"\"NDB model property for Identity values.\n\n  Identities are stored as indexed short blobs internally.\n  \"\"\"\n  _value_type = Identity\n  _indexed = True\n\n\nclass IdentityGlob(\n    datastore_utils.BytesSerializable,\n    collections.namedtuple('IdentityGlob', 'kind, pattern')):\n  \"\"\"Glob-like pattern that matches subset of identities. Immutable.\n\n  Tuple (kind, glob) where 'kind' is is one of IDENTITY_* constants and 'glob'\n  defines pattern that identity names' should match. For example, IdentityGlob\n  that matches all bots is (IDENTITY_BOT, '*') which is also can be written\n  as 'bot:*'.\n  \"\"\"\n\n  # See comment for Identity.__new__ regarding use of __new__ here.\n  def __new__(cls, kind, pattern):\n    if isinstance(pattern, unicode):\n      try:\n        pattern = pattern.encode('ascii')\n      except UnicodeEncodeError:\n        raise ValueError('Invalid IdentityGlob pattern: only ASCII is allowed')\n    if not pattern:\n      raise ValueError('No pattern is given')\n    if kind not in ALLOWED_IDENTITY_KINDS:\n      raise ValueError('Invalid Identity kind: %s' % kind)\n    return super(IdentityGlob, cls).__new__(cls, str(kind), pattern)\n\n  def to_bytes(self):\n    \"\"\"Serializes this identity glob to byte buffer.\"\"\"\n    return '%s:%s' % (self.kind, self.pattern)\n\n  @classmethod\n  def from_bytes(cls, byte_buf):\n    \"\"\"Given a byte buffer returns corresponding IdentityGlob object.\"\"\"\n    kind, sep, pattern = byte_buf.partition(':')\n    if not sep:\n      raise ValueError('Missing \\':\\' separator in IdentityGlob string')\n    return cls(kind, pattern)\n\n  def match(self, identity):\n    \"\"\"Return True if |identity| matches this pattern.\"\"\"\n    if identity.kind != self.kind:\n      return False\n    return fnmatch.fnmatchcase(identity.name, self.pattern)\n\n\nclass IdentityGlobProperty(datastore_utils.BytesSerializableProperty):\n  \"\"\"NDB model property for IdentityGlob values.\n\n  IdentityGlobs are stored as short indexed blobs internally.\n  \"\"\"\n  _value_type = IdentityGlob\n  _indexed = True\n\n\n################################################################################\n## Singleton entities and replication related models.\n\n\ndef configure_as_primary(replication_callback):\n  \"\"\"Registers a callback to be called when AuthDB changes.\n\n  Should be called during Primary application startup. The callback will be\n  called as 'replication_callback(AuthReplicationState)' from inside transaction\n  on root_key() entity group whenever replicate_auth_db() is called (i.e. on\n  every change to auth db that should be replication to replicas).\n  \"\"\"\n  global _replication_callback\n  _replication_callback = replication_callback\n\n\ndef is_primary():\n  \"\"\"Returns True if current application was configured as Primary.\"\"\"\n  return bool(_replication_callback)\n\n\ndef is_replica():\n  \"\"\"Returns True if application is in Replica mode.\"\"\"\n  return not is_primary() and not is_standalone()\n\n\ndef is_standalone():\n  \"\"\"Returns True if application is in Standalone mode.\"\"\"\n  ent = get_replication_state()\n  return not ent or not ent.primary_id\n\n\ndef get_replication_state():\n  \"\"\"Returns AuthReplicationState singleton entity if it exists.\"\"\"\n  return replication_state_key().get()\n\n\ndef get_auth_db_revision():\n  \"\"\"Returns current revision of AuthDB, it increases with each change.\"\"\"\n  state = get_replication_state()\n  return state.auth_db_rev if state else 0\n\n\ndef get_service_self_identity():\n  \"\"\"Returns Identity that correspond to the current GAE app itself.\"\"\"\n  return Identity(IDENTITY_SERVICE, app_identity.get_application_id())\n\n\nclass AuthVersionedEntityMixin(object):\n  \"\"\"Mixin class for entities that keep track of when they change.\n\n  Entities that have this mixin are supposed to be updated in get()\\put() or\n  get()\\delete() transactions. Caller must call record_revision(...) sometime\n  during the transaction (but before put()). Similarly a call to\n  record_deletion(...) is expected sometime before delete().\n\n  replicate_auth_db will store a copy of the entity in the revision log when\n  committing a transaction.\n\n  A pair of properties auth_db_rev and auth_db_prev_rev are used to implement\n  a linked list of versions of this entity (e.g. one can take most recent entity\n  version and go back in time by following auth_db_prev_rev links).\n  \"\"\"\n  # When the entity was modified last time. Do not use 'auto_now' property since\n  # such property overrides any explicitly set value with now() during put. It's\n  # undesired when storing a copy of entity received from Primary (Replica\n  # should have modified_ts to be same as on Primary).\n  modified_ts = ndb.DateTimeProperty()\n  # Who modified the entity last time.\n  modified_by = IdentityProperty()\n\n  # Revision of Auth DB at which this entity was updated last time.\n  auth_db_rev = ndb.IntegerProperty()\n  # Revision of Auth DB of previous version of this entity or None.\n  auth_db_prev_rev = ndb.IntegerProperty()\n\n  def record_revision(self, modified_by, modified_ts=None, comment=None):\n    \"\"\"Updates the entity to record Auth DB revision of the current transaction.\n\n    Stages the entity to be copied to historical log.\n\n    Must be called sometime before 'put' (not necessary right before it). Note\n    that NDB hooks are not used because they are buggy. See docstring for\n    replicate_auth_db for more info.\n\n    Args:\n      modified_by: Identity that made the change.\n      modified_ts: datetime when the change was made (or None for current time).\n      comment: optional comment to put in the revision log.\n    \"\"\"\n    _get_pending_auth_db_transaction().record_change(\n        entity=self,\n        deletion=False,\n        modified_by=modified_by,\n        modified_ts=modified_ts or utils.utcnow(),\n        comment=comment)\n\n  def record_deletion(self, modified_by, modified_ts=None, comment=None):\n    \"\"\"Marks entity as being deleted in the current transaction.\n\n    Stages the entity to be copied to historical log (with 'auth_db_deleted'\n    flag set). The entity must not be mutated between 'get' and AuthDB commit.\n\n    Must be called sometime before 'delete' (not necessary right before it).\n    Note that NDB hooks are not used because they are buggy. See docstring for\n    replicate_auth_db for more info.\n\n    Args:\n      modified_by: Identity that made the change.\n      modified_ts: datetime when the change was made (or None for current time).\n      comment: optional comment to put in the revision log.\n    \"\"\"\n    _get_pending_auth_db_transaction().record_change(\n        entity=self,\n        deletion=True,\n        modified_by=modified_by,\n        modified_ts=modified_ts or utils.utcnow(),\n        comment=comment)\n\n  ## Internal interface. Do not use directly unless you know what you are doing.\n\n  @classmethod\n  def get_historical_copy_class(cls):\n    \"\"\"Returns entity class for historical copies of original entity.\n\n    Has all the same properties, but unindexed (not needed), unvalidated\n    (original entity is already validated) and not cached.\n\n    The name of the new entity class is \"<original name>History\" (to make sure\n    it doesn't show up in indexes for original entity class).\n    \"\"\"\n    existing = getattr(cls, '_auth_db_historical_copy_cls', None)\n    if existing:\n      return existing\n    props = {}\n    for name, prop in cls._properties.iteritems():\n      # Whitelist supported property classes. Better to fail loudly when\n      # encountering something new, rather than silently produce (possibly)\n      # incorrect result. Note that all AuthDB classes are instantiated in\n      # unit tests, so there should be no unexpected asserts in production.\n      assert prop.__class__ in (\n        IdentityGlobProperty,\n        IdentityProperty,\n        ndb.BlobProperty,\n        ndb.BooleanProperty,\n        ndb.DateTimeProperty,\n        ndb.IntegerProperty,\n        ndb.LocalStructuredProperty,\n        ndb.StringProperty,\n        ndb.TextProperty,\n      ), prop.__class__\n      kwargs = {\n        'name': prop._name,\n        'indexed': False,\n        'required': False,\n        'repeated': prop._repeated,\n      }\n      if prop.__class__ == ndb.LocalStructuredProperty:\n        kwargs['modelclass'] = prop._modelclass\n      props[name] = prop.__class__(**kwargs)\n    new_cls = type(\n        '%sHistory' % cls.__name__, (_AuthDBHistoricalEntity,), props)\n    cls._auth_db_historical_copy_cls = new_cls\n    return new_cls\n\n  def make_historical_copy(self, deleted, comment):\n    \"\"\"Returns an entity to put in the historical log.\n\n    It's a copy of the original entity, but stored under another key and with\n    indexes removed. It also has a bunch of additional properties (defined\n    in _AuthDBHistoricalEntity). See 'get_historical_copy_class'.\n\n    The key is derived from auth_db_rev and class and ID of the original entity.\n    For example, AuthGroup \"admins\" modified at rev 123 will be copied to\n    the history as ('AuthGlobalConfig', 'root', 'Rev', 123, 'AuthGroupHistory',\n    'admins'), where the key prefix (first two pairs) is obtained with\n    historical_revision_key(...).\n    \"\"\"\n    assert self.key.parent() == root_key() or self.key == root_key(), self.key\n    cls = self.get_historical_copy_class()\n    entity = cls(\n        id=self.key.id(),\n        parent=historical_revision_key(self.auth_db_rev))\n    for prop in self._properties:\n      setattr(entity, prop, getattr(self, prop))\n    entity.auth_db_deleted = deleted\n    entity.auth_db_change_comment = comment\n    entity.auth_db_app_version = utils.get_app_version()\n    return entity\n\n\nclass AuthGlobalConfig(ndb.Model, AuthVersionedEntityMixin):\n  \"\"\"Acts as a root entity for auth models.\n\n  There should be only one instance of this model in Datastore, with a key set\n  to root_key(). A change to an entity group rooted at this key is a signal that\n  AuthDB has to be refetched (see 'fetch_auth_db' in api.py).\n\n  Entities that change often or associated with particular bot or user\n  MUST NOT be in this entity group.\n\n  Content of this particular entity is replicated from Primary service to all\n  Replicas.\n\n  Entities that belong to this entity group are:\n   * AuthGroup\n   * AuthIPWhitelist\n   * AuthIPWhitelistAssignments\n   * AuthReplicationState\n   * AuthSecret\n  \"\"\"\n  # OAuth2 client_id to use to mint new OAuth2 tokens.\n  oauth_client_id = ndb.StringProperty(indexed=False, default='')\n  # OAuth2 client secret. Not so secret really, since it's passed to clients.\n  oauth_client_secret = ndb.StringProperty(indexed=False, default='')\n  # Additional OAuth2 client_ids allowed to access the services.\n  oauth_additional_client_ids = ndb.StringProperty(repeated=True, indexed=False)\n\n\nclass AuthReplicationState(ndb.Model, datastore_utils.SerializableModelMixin):\n  \"\"\"Contains state used to control Primary -> Replica replication.\n\n  It's a singleton entity with key replication_state_key() (in same entity\n  groups as root_key()). This entity should be small since it is updated\n  (auth_db_rev is incremented) whenever AuthDB changes.\n\n  Exists in any AuthDB (on Primary and Replicas). Primary updates it whenever\n  changes to AuthDB are made, Replica updates it whenever it receives a push\n  from Primary.\n  \"\"\"\n  # How to convert this entity to or from serializable dict.\n  serializable_properties = {\n    'primary_id': datastore_utils.READABLE,\n    'primary_url': datastore_utils.READABLE,\n    'auth_db_rev': datastore_utils.READABLE,\n    'modified_ts': datastore_utils.READABLE,\n  }\n\n  # For services in Standalone mode it is None.\n  # For services in Primary mode: own GAE application ID.\n  # For services in Replica mode it is a GAE application ID of Primary.\n  primary_id = ndb.StringProperty(indexed=False)\n\n  # For services in Replica mode, root URL of Primary, i.e https://<host>.\n  primary_url = ndb.StringProperty(indexed=False)\n\n  # Revision of auth DB. Increased by 1 with every change that should be\n  # propagate to replicas. Only services in Standalone or Primary mode\n  # update this property by themselves. Replicas receive it from Primary.\n  auth_db_rev = ndb.IntegerProperty(default=0, indexed=False)\n\n  # Time when auth_db_rev was created (by Primary clock). For informational\n  # purposes only. See comment at AuthGroup.modified_ts for explanation why\n  # auto_now is not used.\n  modified_ts = ndb.DateTimeProperty(auto_now_add=True, indexed=False)\n\n\ndef replicate_auth_db():\n  \"\"\"Increments auth_db_rev, updates historical log, triggers replication.\n\n  Must be called once from inside a transaction (right before exiting it).\n\n  Should only be called for services in Standalone or Primary modes. Will raise\n  ValueError if called on Replica. When called for service in Standalone mode,\n  will update auth_db_rev but won't kick any replication. For services in\n  Primary mode will also initiate replication by calling callback set in\n  'configure_as_primary'. The callback usually transactionally enqueues a task\n  (to gracefully handle transaction rollbacks).\n\n  WARNING: This function relies on a valid transaction context. NDB hooks and\n  asynchronous operations are known to be buggy in this regard: NDB hook for\n  an async operation in a transaction may be called with a wrong context\n  (main event loop context instead of transaction context). One way to work\n  around that is to monkey patch NDB (as done here: https://goo.gl/1yASjL).\n  Another is to not use hooks at all. There's no way to differentiate between\n  sync and async modes of an NDB operation from inside a hook. And without a\n  strict assert it's very easy to forget about \"Do not use put_async\" warning.\n  For that reason _post_put_hook is NOT used and replicate_auth_db() should be\n  called explicitly whenever relevant part of root_key() entity group is\n  updated.\n\n  Returns:\n    New AuthDB revision number.\n  \"\"\"\n  assert ndb.in_transaction()\n  txn = _get_pending_auth_db_transaction()\n  txn.commit()\n  if is_primary():\n    _replication_callback(txn.replication_state)\n  return txn.replication_state.auth_db_rev\n\n\n################################################################################\n## Auth DB transaction details (used for historical log of changes).\n\n\n_commit_callbacks = []\n\n\ndef commit_callback(cb):\n  \"\"\"Adds a callback that's called before AuthDB transaction is committed.\n\n  Can be used as decorator. Adding a callback second time is noop.\n\n  Args:\n    cb: function that takes single auth_db_rev argument as input.\n  \"\"\"\n  if cb not in _commit_callbacks:\n    _commit_callbacks.append(cb)\n  return cb\n\n\ndef _get_pending_auth_db_transaction():\n  \"\"\"Used internally to keep track of changes done in the transaction.\n\n  Returns:\n    Instance of _AuthDBTransaction (stored in the transaction context).\n  \"\"\"\n  # Use transaction context to store the object. Note that each transaction\n  # retry gets its own new transaction context which is what we need,\n  # see ndb/context.py, 'transaction' tasklet, around line 982 (for SDK 1.9.6).\n  assert ndb.in_transaction()\n  ctx = ndb.get_context()\n  txn = getattr(ctx, '_auth_db_transaction', None)\n  if txn:\n    return txn\n\n  # Prepare next AuthReplicationState (auth_db_rev +1).\n  state = replication_state_key().get()\n  if not state:\n    primary_id = app_identity.get_application_id() if is_primary() else None\n    state = AuthReplicationState(\n        key=replication_state_key(),\n        primary_id=primary_id,\n        auth_db_rev=0)\n  # Assert Primary or Standalone. Replicas can't increment auth db revision.\n  if not is_primary() and state.primary_id:\n    raise ValueError('Can\\'t modify Auth DB on Replica')\n  state.auth_db_rev += 1\n  state.modified_ts = utils.utcnow()\n\n  # Store the state in the transaction context. Used in replicate_auth_db(...)\n  # later.\n  txn = _AuthDBTransaction(state)\n  ctx._auth_db_transaction = txn\n  return txn\n\n\nclass _AuthDBTransaction(object):\n  \"\"\"Keeps track of entities updated or removed in current transaction.\"\"\"\n\n  _Change = collections.namedtuple('_Change', 'entity deletion comment')\n\n  def __init__(self, replication_state):\n    self.replication_state = replication_state\n    self.changes = [] # list of _Change tuples\n    self.committed = False\n\n  def record_change(self, entity, deletion, modified_by, modified_ts, comment):\n    assert not self.committed\n    assert isinstance(entity, AuthVersionedEntityMixin)\n    assert all(entity.key != c.entity.key for c in self.changes)\n\n    # Mutate the main entity (the one used to serve online requests).\n    entity.modified_by = modified_by\n    entity.modified_ts = modified_ts\n    entity.auth_db_prev_rev = entity.auth_db_rev # can be None for new entities\n    entity.auth_db_rev = self.replication_state.auth_db_rev\n\n    # Keep a historical copy. Delay make_historical_copy call until the commit.\n    # Here (in 'record_change') entity may not have all the fields updated yet.\n    self.changes.append(self._Change(entity, deletion, comment))\n\n  def commit(self):\n    assert not self.committed\n    puts = [\n      c.entity.make_historical_copy(c.deletion, c.comment)\n      for c in self.changes\n    ]\n    ndb.put_multi(puts + [self.replication_state])\n    for cb in _commit_callbacks:\n      cb(self.replication_state.auth_db_rev)\n    self.committed = True\n\n\nclass _AuthDBHistoricalEntity(ndb.Model):\n  \"\"\"Base class for *History magic class in AuthVersionedEntityMixin.\n\n  In addition to properties defined here the child classes (*History) also\n  always inherit (for some definition of \"inherit\") properties from\n  AuthVersionedEntityMixin.\n\n  See get_historical_copy_class().\n  \"\"\"\n  # Historical entities are not intended to be read often, and updating the\n  # cache will make AuthDB transactions only slower.\n  _use_cache = False\n  _use_memcache = False\n\n  # True if entity was deleted in the given revision.\n  auth_db_deleted = ndb.BooleanProperty(indexed=False)\n  # Comment string passed to record_revision or record_deletion.\n  auth_db_change_comment = ndb.StringProperty(indexed=False)\n  # A GAE module version that committed the change.\n  auth_db_app_version = ndb.StringProperty(indexed=False)\n\n  def get_previous_historical_copy_key(self):\n    \"\"\"Returns ndb.Key of *History entity matching auth_db_prev_rev revision.\"\"\"\n    if self.auth_db_prev_rev is None:\n      return None\n    return ndb.Key(\n        self.__class__, self.key.id(),\n        parent=historical_revision_key(self.auth_db_prev_rev))\n\n\n################################################################################\n## Groups.\n\n\nclass AuthGroup(\n    ndb.Model,\n    AuthVersionedEntityMixin,\n    datastore_utils.SerializableModelMixin):\n  \"\"\"A group of identities, entity id is a group name.\n\n  Parent is AuthGlobalConfig entity keyed at root_key().\n\n  Primary service holds authoritative list of Groups, that gets replicated to\n  all Replicas.\n  \"\"\"\n  # How to convert this entity to or from serializable dict.\n  serializable_properties = {\n    'members': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'globs': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'nested': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'description': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'owners': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'created_ts': datastore_utils.READABLE,\n    'created_by': datastore_utils.READABLE,\n    'modified_ts': datastore_utils.READABLE,\n    'modified_by': datastore_utils.READABLE,\n  }\n\n  # List of members that are explicitly in this group. Indexed.\n  members = IdentityProperty(repeated=True)\n  # List of identity-glob expressions (like 'user:*@example.com'). Indexed.\n  globs = IdentityGlobProperty(repeated=True)\n  # List of nested group names. Indexed.\n  nested = ndb.StringProperty(repeated=True)\n\n  # Human readable description.\n  description = ndb.TextProperty(default='')\n  # A name of the group that can modify or delete this group.\n  owners = ndb.StringProperty(default=ADMIN_GROUP)\n\n  # When the group was created.\n  created_ts = ndb.DateTimeProperty()\n  # Who created the group.\n  created_by = IdentityProperty()\n\n\ndef group_key(group):\n  \"\"\"Returns ndb.Key for AuthGroup entity.\"\"\"\n  return ndb.Key(AuthGroup, group, parent=root_key())\n\n\ndef is_empty_group(group):\n  \"\"\"Returns True if group is missing or completely empty.\"\"\"\n  group = group_key(group).get()\n  return not group or not(group.members or group.globs or group.nested)\n\n\ndef is_valid_group_name(name):\n  \"\"\"True if string looks like a valid group name.\"\"\"\n  return bool(GROUP_NAME_RE.match(name))\n\n\ndef is_external_group_name(name):\n  \"\"\"True if group is imported from outside and is not writable.\"\"\"\n  return is_valid_group_name(name) and '/' in name\n\n\n@ndb.transactional\ndef bootstrap_group(group, identities, description=''):\n  \"\"\"Makes a group (if not yet exists) and adds |identities| to it as members.\n\n  Returns True if modified the group, False if identities are already there.\n  \"\"\"\n  key = group_key(group)\n  entity = key.get()\n  if entity and all(i in entity.members for i in identities):\n    return False\n  now = utils.utcnow()\n  if not entity:\n    entity = AuthGroup(\n        key=key,\n        description=description,\n        created_ts=now,\n        created_by=get_service_self_identity())\n  for i in identities:\n    if i not in entity.members:\n      entity.members.append(i)\n  entity.record_revision(\n      modified_by=get_service_self_identity(),\n      modified_ts=now,\n      comment='Bootstrap')\n  entity.put()\n  replicate_auth_db()\n  return True\n\n\ndef find_referencing_groups(group):\n  \"\"\"Finds groups that reference the specified group as nested group or owner.\n\n  Used to verify that |group| is safe to delete, i.e. no other group is\n  depending on it.\n\n  Returns:\n    Set of names of referencing groups.\n  \"\"\"\n  nesting_groups = AuthGroup.query(\n      AuthGroup.nested == group,\n      ancestor=root_key()).fetch_async(keys_only=True)\n  owned_groups = AuthGroup.query(\n      AuthGroup.owners == group,\n      ancestor=root_key()).fetch_async(keys_only=True)\n  refs = set()\n  refs.update(key.id() for key in nesting_groups.get_result())\n  refs.update(key.id() for key in owned_groups.get_result())\n  return refs\n\n\ndef get_missing_groups(groups):\n  \"\"\"Given a list of group names, returns a list of groups that do not exist.\"\"\"\n  # We need to iterate over |groups| twice. It won't work if |groups|\n  # is a generator. So convert to list first.\n  groups = list(groups)\n  entities = ndb.get_multi(group_key(name) for name in groups)\n  return [name for name, ent in zip(groups, entities) if not ent]\n\n\ndef find_group_dependency_cycle(group):\n  \"\"\"Searches for dependency cycle between nested groups.\n\n  Traverses the dependency graph starting from |group|, fetching all necessary\n  groups from datastore along the way.\n\n  Args:\n    group: instance of AuthGroup to start traversing from. It doesn't have to be\n        committed to Datastore itself (but all its nested groups should be\n        there already).\n\n  Returns:\n    List of names of groups that form a cycle or empty list if no cycles.\n  \"\"\"\n  # It is a depth-first search on a directed graph with back edge detection.\n  # See http://www.cs.nyu.edu/courses/summer04/G22.1170-001/6a-Graphs-More.pdf\n\n  # Cache of already fetched groups.\n  groups = {group.key.id(): group}\n\n  # List of groups that are completely explored (all subtree is traversed).\n  visited = []\n  # Stack of groups that are being explored now. In case cycle is detected\n  # it would contain that cycle.\n  visiting = []\n\n  def visit(group):\n    \"\"\"Recursively explores |group| subtree, returns True if finds a cycle.\"\"\"\n    assert group not in visiting\n    assert group not in visited\n\n    # Load bodies of nested groups not seen so far into |groups|.\n    entities = ndb.get_multi(\n        group_key(name) for name in group.nested if name not in groups)\n    groups.update({entity.key.id(): entity for entity in entities if entity})\n\n    visiting.append(group)\n    for nested in group.nested:\n      obj = groups.get(nested)\n      # Do not crash if non-existent group is referenced somehow.\n      if not obj:\n        continue\n      # Cross edge. Can happen in diamond-like graph, not a cycle.\n      if obj in visited:\n        continue\n      # Back edge: |group| references its own ancestor -> cycle.\n      if obj in visiting:\n        return True\n      # Explore subtree.\n      if visit(obj):\n        return True\n    visiting.pop()\n\n    visited.append(group)\n    return False\n\n  visit(group)\n  return [group.key.id() for group in visiting]\n\n\n################################################################################\n## Secrets store.\n\n\nclass AuthSecretScope(ndb.Model):\n  \"\"\"Entity to act as parent entity for AuthSecret.\n\n  Parent is AuthGlobalConfig entity keyed at root_key().\n\n  Id of this entity defines scope of secret keys that have this entity as\n  a parent. Possible scopes are 'local' and 'global'.\n\n  Secrets in 'local' scope never leave Datastore they are stored in and they\n  are different for each service (even for Replicas). Only service that\n  generated a local secret knows it.\n\n  Secrets in 'global' scope are known to all services (via Primary -> Replica\n  DB replication mechanism). Source of truth for global secrets is in Primary's\n  Datastore.\n  \"\"\"\n\n\ndef secret_scope_key(scope):\n  \"\"\"Key of AuthSecretScope entity for a given scope ('global' or 'local').\"\"\"\n  return ndb.Key(AuthSecretScope, scope, parent=root_key())\n\n\nclass AuthSecret(ndb.Model):\n  \"\"\"Some service-wide named secret blob.\n\n  Entity can be a child of:\n    * Key(AuthSecretScope, 'global', parent=root_key()):\n        Global secrets replicated across all services.\n    * Key(AuthSecretScope, 'local', parent=root_key()):\n        Secrets local to the current service.\n\n  There should be only very limited number of AuthSecret entities around. AuthDB\n  fetches them all at once. Do not use this entity for per-user secrets.\n\n  Holds most recent value of a secret as well as several previous values. Most\n  recent value is used to generate new tokens, previous values may be used to\n  validate existing tokens. That way secret can be rotated without invalidating\n  any existing outstanding tokens.\n  \"\"\"\n  # Last several values of a secret, with current value in front.\n  values = ndb.BlobProperty(repeated=True, indexed=False)\n\n  # When secret was modified last time.\n  modified_ts = ndb.DateTimeProperty(auto_now_add=True)\n  # Who modified the secret last time.\n  modified_by = IdentityProperty()\n\n  @classmethod\n  def bootstrap(cls, name, scope, length=32):\n    \"\"\"Creates a secret if it doesn't exist yet.\n\n    Args:\n      name: name of the secret.\n      scope: 'local' or 'global', see doc string for AuthSecretScope. 'global'\n          scope should only be used on Primary service.\n      length: length of the secret to generate if secret doesn't exist yet.\n\n    Returns:\n      Instance of AuthSecret (creating it if necessary) with random secret set.\n    \"\"\"\n    # Note that 'get_or_insert' is a bad fit here. With 'get_or_insert' we'd\n    # have to call os.urandom every time we want to get a key. It's a waste of\n    # time and entropy.\n    if scope not in ('local', 'global'):\n      raise ValueError('Invalid secret scope: %s' % scope)\n    key = ndb.Key(cls, name, parent=secret_scope_key(scope))\n    entity = key.get()\n    if entity is not None:\n      return entity\n    @ndb.transactional\n    def create():\n      entity = key.get()\n      if entity is not None:\n        return entity\n      logging.info('Creating new secret key %s in %s scope', name, scope)\n      # Global keys can only be created on Primary or Standalone service.\n      if scope == 'global' and is_replica():\n        raise ValueError('Can\\'t bootstrap global key on Replica')\n      entity = cls(\n          key=key,\n          values=[os.urandom(length)],\n          modified_by=get_service_self_identity())\n      entity.put()\n      # Only global keys are part of replicated state.\n      if scope == 'global':\n        replicate_auth_db()\n      return entity\n    return create()\n\n\n################################################################################\n## IP whitelist.\n\n\nclass AuthIPWhitelistAssignments(ndb.Model, AuthVersionedEntityMixin):\n  \"\"\"A singleton entity with \"identity -> AuthIPWhitelist to use\" mapping.\n\n  Entity key is ip_whitelist_assignments_key(). Parent entity is root_key().\n\n  See AuthIPWhitelist for more info about IP whitelists.\n  \"\"\"\n  class Assignment(ndb.Model):\n    # Identity name to limit by IP whitelist. Unique key in 'assignments' list.\n    identity = IdentityProperty()\n    # Name of IP whitelist to use (see AuthIPWhitelist).\n    ip_whitelist = ndb.StringProperty()\n    # Why the assignment was created.\n    comment = ndb.StringProperty()\n    # When the assignment was created.\n    created_ts = ndb.DateTimeProperty()\n    # Who created the assignment.\n    created_by = IdentityProperty()\n\n  # Holds all the assignments.\n  assignments = ndb.LocalStructuredProperty(Assignment, repeated=True)\n\n\nclass AuthIPWhitelist(\n    ndb.Model,\n    AuthVersionedEntityMixin,\n    datastore_utils.SerializableModelMixin):\n  \"\"\"A named set of whitelisted IPv4 and IPv6 subnets.\n\n  Can be assigned to individual user accounts to forcibly limit them only to\n  particular IP addresses, e.g. it can be used to enforce that specific service\n  account is used only from some known IP range. The mapping between accounts\n  and IP whitelists is stored in AuthIPWhitelistAssignments.\n\n  Entity id is a name of the whitelist. Parent entity is root_key().\n\n  There's a special IP whitelist named 'bots' that can be used to list\n  IP addresses of machines the service trusts unconditionally. Requests from\n  such machines doesn't have to have any additional credentials attached.\n  Requests will be authenticated as coming from identity 'bot:<IP address>'.\n  \"\"\"\n  # How to convert this entity to or from serializable dict.\n  serializable_properties = {\n    'subnets': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'description': datastore_utils.READABLE | datastore_utils.WRITABLE,\n    'created_ts': datastore_utils.READABLE,\n    'created_by': datastore_utils.READABLE,\n    'modified_ts': datastore_utils.READABLE,\n    'modified_by': datastore_utils.READABLE,\n  }\n\n  # The list of subnets. The validator is used only as a last measure. JSON API\n  # handler should do validation too.\n  subnets = ndb.StringProperty(\n      repeated=True, validator=lambda _, val: ipaddr.normalize_subnet(val))\n\n  # Human readable description.\n  description = ndb.TextProperty(default='')\n\n  # When the list was created.\n  created_ts = ndb.DateTimeProperty()\n  # Who created the list.\n  created_by = IdentityProperty()\n\n  def is_ip_whitelisted(self, ip):\n    \"\"\"Returns True if ipaddr.IP is in the whitelist.\"\"\"\n    # TODO(vadimsh): If number of subnets to check grows it makes sense to add\n    # an internal cache to 'subnet_from_string' (sort of like in re.compile).\n    return any(\n        ipaddr.is_in_subnet(ip, ipaddr.subnet_from_string(net))\n        for net in self.subnets)\n\n\ndef ip_whitelist_key(name):\n  \"\"\"Returns ndb.Key for AuthIPWhitelist entity given its name.\"\"\"\n  return ndb.Key(AuthIPWhitelist, name, parent=root_key())\n\n\ndef is_valid_ip_whitelist_name(name):\n  \"\"\"True if string looks like a valid IP whitelist name.\"\"\"\n  return bool(IP_WHITELIST_NAME_RE.match(name))\n\n\n@ndb.transactional\ndef bootstrap_ip_whitelist(name, subnets, description=''):\n  \"\"\"Adds subnets to an IP whitelist if not there yet.\n\n  Can be used on local dev appserver to add 127.0.0.1 to IP whitelist during\n  startup. Should not be used from request handlers.\n\n  Args:\n    name: IP whitelist name to add a subnet to.\n    subnets: IP subnet to add (as a list of strings).\n    description: description of IP whitelist (if new entity is created).\n\n  Returns:\n    True if entry was added, False if it is already there or subnet is invalid.\n  \"\"\"\n  assert isinstance(subnets, (list, tuple))\n  try:\n    subnets = [ipaddr.normalize_subnet(s) for s in subnets]\n  except ValueError:\n    return False\n  key = ip_whitelist_key(name)\n  entity = key.get()\n  if entity and all(s in entity.subnets for s in subnets):\n    return False\n  now = utils.utcnow()\n  if not entity:\n    entity = AuthIPWhitelist(\n        key=key,\n        description=description,\n        created_ts=now,\n        created_by=get_service_self_identity())\n  for s in subnets:\n    if s not in entity.subnets:\n      entity.subnets.append(s)\n  entity.record_revision(\n      modified_by=get_service_self_identity(),\n      modified_ts=now,\n      comment='Bootstrap')\n  entity.put()\n  replicate_auth_db()\n  return True\n\n\ndef bootstrap_loopback_ips():\n  \"\"\"Adds 127.0.0.1 and ::1 to 'bots' IP whitelist.\n\n  Useful on local dev server and in tests. Must not be used in production.\n\n  Returns list of corresponding bot Identities.\n  \"\"\"\n  # See api.py, AuthDB.verify_ip_whitelisted for IP -> Identity conversion.\n  assert utils.is_local_dev_server()\n  bootstrap_ip_whitelist(BOTS_IP_WHITELIST, ['127.0.0.1', '::1'], 'Local bots')\n  return [\n    Identity(IDENTITY_BOT, 'whitelisted-ip'),\n    Identity(IDENTITY_BOT, '127.0.0.1'),\n    Identity(IDENTITY_BOT, '0-0-0-0-0-0-0-1'),\n  ]\n\n\n@ndb.transactional\ndef bootstrap_ip_whitelist_assignment(identity, ip_whitelist, comment=''):\n  \"\"\"Sets a mapping \"identity -> IP whitelist to use\" for some account.\n\n  Replaces existing assignment. Can be used on local dev appserver to configure\n  IP whitelist assignments during startup or in tests. Should not be used from\n  request handlers.\n\n  Args:\n    identity: Identity to modify.\n    ip_whitelist: name of AuthIPWhitelist to assign.\n    comment: comment to set.\n\n  Returns:\n    True if IP whitelist assignment was modified, False if it was already set.\n  \"\"\"\n  entity = (\n      ip_whitelist_assignments_key().get() or\n      AuthIPWhitelistAssignments(key=ip_whitelist_assignments_key()))\n\n  found = False\n  for assignment in entity.assignments:\n    if assignment.identity == identity:\n      if assignment.ip_whitelist == ip_whitelist:\n        return False\n      assignment.ip_whitelist = ip_whitelist\n      assignment.comment = comment\n      found = True\n      break\n\n  now = utils.utcnow()\n  if not found:\n    entity.assignments.append(\n        AuthIPWhitelistAssignments.Assignment(\n            identity=identity,\n            ip_whitelist=ip_whitelist,\n            comment=comment,\n            created_ts=now,\n            created_by=get_service_self_identity()))\n\n  entity.record_revision(\n      modified_by=get_service_self_identity(),\n      modified_ts=now,\n      comment='Bootstrap')\n  entity.put()\n  replicate_auth_db()\n  return True\n\n\ndef fetch_ip_whitelists():\n  \"\"\"Fetches AuthIPWhitelistAssignments and relevant AuthIPWhitelist entities.\n\n  Returns:\n    (AuthIPWhitelistAssignments, list of AuthIPWhitelist).\n  \"\"\"\n  assignments = (\n      ip_whitelist_assignments_key().get() or\n      AuthIPWhitelistAssignments(key=ip_whitelist_assignments_key()))\n\n  names = set(a.ip_whitelist for a in assignments.assignments)\n  names.add(BOTS_IP_WHITELIST)\n\n  whitelists = ndb.get_multi(ip_whitelist_key(n) for n in names)\n  whitelists = sorted(filter(None, whitelists), key=lambda x: x.key.id())\n  return assignments, whitelists\n/n/n/nappengine/swarming/handlers_bot.py/n/n# Copyright 2015 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Internal bot API handlers.\"\"\"\n\nimport base64\nimport json\nimport logging\nimport textwrap\n\nimport webob\nimport webapp2\n\nfrom google.appengine.api import app_identity\nfrom google.appengine.api import datastore_errors\nfrom google.appengine.datastore import datastore_query\nfrom google.appengine import runtime\nfrom google.appengine.ext import ndb\n\nfrom components import auth\nfrom components import ereporter2\nfrom components import utils\nfrom server import acl\nfrom server import bot_code\nfrom server import bot_management\nfrom server import stats\nfrom server import task_pack\nfrom server import task_scheduler\nfrom server import task_to_run\n\n\ndef has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):\n  \"\"\"Returns an error if unexpected keys are present or expected keys are\n  missing.\n\n  Accepts optional keys.\n\n  This is important to catch typos.\n  \"\"\"\n  actual_keys = frozenset(actual_keys)\n  superfluous = actual_keys - expected_keys\n  missing = minimum_keys - actual_keys\n  if superfluous or missing:\n    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''\n    msg_superfluous = (\n        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')\n    return 'Unexpected %s%s%s; did you make a typo?' % (\n        name, msg_missing, msg_superfluous)\n\n\ndef has_unexpected_keys(expected_keys, actual_keys, name):\n  \"\"\"Return an error if unexpected keys are present or expected keys are\n  missing.\n  \"\"\"\n  return has_unexpected_subset_keys(\n      expected_keys, expected_keys, actual_keys, name)\n\n\ndef log_unexpected_subset_keys(\n    expected_keys, minimum_keys, actual_keys, request, source, name):\n  \"\"\"Logs an error if unexpected keys are present or expected keys are missing.\n\n  Accepts optional keys.\n\n  This is important to catch typos.\n  \"\"\"\n  message = has_unexpected_subset_keys(\n    expected_keys, minimum_keys, actual_keys, name)\n  if message:\n    ereporter2.log_request(request, source=source, message=message)\n  return message\n\n\ndef log_unexpected_keys(expected_keys, actual_keys, request, source, name):\n  \"\"\"Logs an error if unexpected keys are present or expected keys are missing.\n  \"\"\"\n  return log_unexpected_subset_keys(\n      expected_keys, expected_keys, actual_keys, request, source, name)\n\n\ndef has_missing_keys(minimum_keys, actual_keys, name):\n  \"\"\"Returns an error if expected keys are not present.\n\n  Do not warn about unexpected keys.\n  \"\"\"\n  actual_keys = frozenset(actual_keys)\n  missing = minimum_keys - actual_keys\n  if missing:\n    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''\n    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)\n\n\nclass BootstrapHandler(auth.AuthenticatingHandler):\n  \"\"\"Returns python code to run to bootstrap a swarming bot.\"\"\"\n\n  @auth.require(acl.is_bot)\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/x-python'\n    self.response.headers['Content-Disposition'] = (\n        'attachment; filename=\"swarming_bot_bootstrap.py\"')\n    self.response.out.write(\n        bot_code.get_bootstrap(self.request.host_url).content)\n\n\nclass BotCodeHandler(auth.AuthenticatingHandler):\n  \"\"\"Returns a zip file with all the files required by a bot.\n\n  Optionally specify the hash version to download. If so, the returned data is\n  cacheable.\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def get(self, version=None):\n    if version:\n      expected = bot_code.get_bot_version(self.request.host_url)\n      if version != expected:\n        # This can happen when the server is rapidly updated.\n        logging.error('Requested Swarming bot %s, have %s', version, expected)\n        self.abort(404)\n      self.response.headers['Cache-Control'] = 'public, max-age=3600'\n    else:\n      self.response.headers['Cache-Control'] = 'no-cache, no-store'\n    self.response.headers['Content-Type'] = 'application/octet-stream'\n    self.response.headers['Content-Disposition'] = (\n        'attachment; filename=\"swarming_bot.zip\"')\n    self.response.out.write(\n        bot_code.get_swarming_bot_zip(self.request.host_url))\n\n\nclass _BotBaseHandler(auth.ApiHandler):\n  \"\"\"\n  Request body is a JSON dict:\n    {\n      \"dimensions\": <dict of properties>,\n      \"state\": <dict of properties>,\n      \"version\": <sha-1 of swarming_bot.zip uncompressed content>,\n    }\n  \"\"\"\n\n  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}\n  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  def _process(self):\n    \"\"\"Returns True if the bot has invalid parameter and should be automatically\n    quarantined.\n\n    Does one DB synchronous GET.\n\n    Returns:\n      tuple(request, bot_id, version, state, dimensions, quarantined_msg)\n    \"\"\"\n    request = self.parse_body()\n    version = request.get('version', None)\n\n    dimensions = request.get('dimensions', {})\n    state = request.get('state', {})\n    bot_id = None\n    if dimensions.get('id'):\n      dimension_id = dimensions['id']\n      if (isinstance(dimension_id, list) and len(dimension_id) == 1\n          and isinstance(dimension_id[0], unicode)):\n        bot_id = dimensions['id'][0]\n\n    # The bot may decide to \"self-quarantine\" itself. Accept both via\n    # dimensions or via state. See bot_management._BotCommon.quarantined for\n    # more details.\n    if (bool(dimensions.get('quarantined')) or\n        bool(state.get('quarantined'))):\n      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'\n\n    quarantined_msg = None\n    # Use a dummy 'for' to be able to break early from the block.\n    for _ in [0]:\n\n      quarantined_msg = has_unexpected_keys(\n          self.EXPECTED_KEYS, request, 'keys')\n      if quarantined_msg:\n        break\n\n      quarantined_msg = has_missing_keys(\n          self.REQUIRED_STATE_KEYS, state, 'state')\n      if quarantined_msg:\n        break\n\n      if not bot_id:\n        quarantined_msg = 'Missing bot id'\n        break\n\n      if not all(\n          isinstance(key, unicode) and\n          isinstance(values, list) and\n          all(isinstance(value, unicode) for value in values)\n          for key, values in dimensions.iteritems()):\n        quarantined_msg = (\n            'Invalid dimensions type:\\n%s' % json.dumps(dimensions,\n              sort_keys=True, indent=2, separators=(',', ': ')))\n        break\n\n      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)\n      if dimensions_count > task_to_run.MAX_DIMENSIONS:\n        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count\n        break\n\n    if quarantined_msg:\n      line = 'Quarantined Bot\\nhttps://%s/restricted/bot/%s\\n%s' % (\n          app_identity.get_default_version_hostname(), bot_id,\n          quarantined_msg)\n      ereporter2.log_request(self.request, source='bot', message=line)\n      return request, bot_id, version, state, dimensions, quarantined_msg\n\n    # Look for admin enforced quarantine.\n    bot_settings = bot_management.get_settings_key(bot_id).get()\n    if bool(bot_settings and bot_settings.quarantined):\n      return request, bot_id, version, state, dimensions, 'Quarantined by admin'\n\n    return request, bot_id, version, state, dimensions, None\n\n\nclass BotHandshakeHandler(_BotBaseHandler):\n  \"\"\"First request to be called to get initial data like XSRF token.\n\n  The bot is server-controled so the server doesn't have to support multiple API\n  version. When running a task, the bot sync the the version specific URL. Once\n  abot finished its currently running task, it'll be immediately be upgraded\n  after on its next poll.\n\n  This endpoint does not return commands to the bot, for example to upgrade\n  itself. It'll be told so when it does its first poll.\n\n  Response body is a JSON dict:\n    {\n      \"bot_version\": <sha-1 of swarming_bot.zip uncompressed content>,\n      \"server_version\": \"138-193f1f3\",\n      \"xsrf_token\": \"......\",\n    }\n  \"\"\"\n\n  # This handler is called to get XSRF token, there's nothing to enforce yet.\n  xsrf_token_enforce_on = ()\n\n  @auth.require_xsrf_token_request\n  @auth.require(acl.is_bot)\n  def post(self):\n    (_request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    bot_management.bot_event(\n        event_type='bot_connected', bot_id=bot_id,\n        external_ip=self.request.remote_addr, dimensions=dimensions,\n        state=state, version=version, quarantined=bool(quarantined_msg),\n        task_id='', task_name=None, message=quarantined_msg)\n\n    data = {\n      # This access token will be used to validate each subsequent request.\n      'bot_version': bot_code.get_bot_version(self.request.host_url),\n      'expiration_sec': auth.handler.XSRFToken.expiration_sec,\n      'server_version': utils.get_app_version(),\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.send_response(data)\n\n\nclass BotPollHandler(_BotBaseHandler):\n  \"\"\"The bot polls for a task; returns either a task, update command or sleep.\n\n  In case of exception on the bot, this is enough to get it just far enough to\n  eventually self-update to a working version. This is to ensure that coding\n  errors in bot code doesn't kill all the fleet at once, they should still be up\n  just enough to be able to self-update again even if they don't get task\n  assigned anymore.\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    \"\"\"Handles a polling request.\n\n    Be very permissive on missing values. This can happen because of errors\n    on the bot, *we don't want to deny them the capacity to update*, so that the\n    bot code is eventually fixed and the bot self-update to this working code.\n\n    It makes recovery of the fleet in case of catastrophic failure much easier.\n    \"\"\"\n    (_request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    sleep_streak = state.get('sleep_streak', 0)\n    quarantined = bool(quarantined_msg)\n\n    # Note bot existence at two places, one for stats at 1 minute resolution,\n    # the other for the list of known bots.\n    action = 'bot_inactive' if quarantined else 'bot_active'\n    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)\n\n    def bot_event(event_type, task_id=None, task_name=None):\n      bot_management.bot_event(\n          event_type=event_type, bot_id=bot_id,\n          external_ip=self.request.remote_addr, dimensions=dimensions,\n          state=state, version=version, quarantined=quarantined,\n          task_id=task_id, task_name=task_name, message=quarantined_msg)\n\n    # Bot version is host-specific because the host URL is embedded in\n    # swarming_bot.zip\n    expected_version = bot_code.get_bot_version(self.request.host_url)\n    if version != expected_version:\n      bot_event('request_update')\n      self._cmd_update(expected_version)\n      return\n    if quarantined:\n      bot_event('request_sleep')\n      self._cmd_sleep(sleep_streak, quarantined)\n      return\n\n    #\n    # At that point, the bot should be in relatively good shape since it's\n    # running the right version. It is still possible that invalid code was\n    # pushed to the server, so be diligent about it.\n    #\n\n    # Bot may need a reboot if it is running for too long. We do not reboot\n    # quarantined bots.\n    needs_restart, restart_message = bot_management.should_restart_bot(\n        bot_id, state)\n    if needs_restart:\n      bot_event('request_restart')\n      self._cmd_restart(restart_message)\n      return\n\n    # The bot is in good shape. Try to grab a task.\n    try:\n      # This is a fairly complex function call, exceptions are expected.\n      request, run_result = task_scheduler.bot_reap_task(\n          dimensions, bot_id, version)\n      if not request:\n        # No task found, tell it to sleep a bit.\n        bot_event('request_sleep')\n        self._cmd_sleep(sleep_streak, quarantined)\n        return\n\n      try:\n        # This part is tricky since it intentionally runs a transaction after\n        # another one.\n        if request.properties.is_terminate:\n          bot_event('bot_terminate', task_id=run_result.task_id)\n          self._cmd_terminate(run_result.task_id)\n        else:\n          bot_event(\n              'request_task', task_id=run_result.task_id,\n              task_name=request.name)\n          self._cmd_run(request, run_result.key, bot_id)\n      except:\n        logging.exception('Dang, exception after reaping')\n        raise\n    except runtime.DeadlineExceededError:\n      # If the timeout happened before a task was assigned there is no problems.\n      # If the timeout occurred after a task was assigned, that task will\n      # timeout (BOT_DIED) since the bot didn't get the details required to\n      # run it) and it will automatically get retried (TODO) when the task times\n      # out.\n      # TODO(maruel): Note the task if possible and hand it out on next poll.\n      # https://code.google.com/p/swarming/issues/detail?id=130\n      self.abort(500, 'Deadline')\n\n  def _cmd_run(self, request, run_result_key, bot_id):\n    # Only one of 'command' or 'inputs_ref' can be set.\n    out = {\n      'cmd': 'run',\n      'manifest': {\n        'bot_id': bot_id,\n        'command':\n            request.properties.commands[0]\n            if request.properties.commands else None,\n        'data': request.properties.data,\n        'dimensions': request.properties.dimensions,\n        'env': request.properties.env,\n        'extra_args': request.properties.extra_args,\n        'grace_period': request.properties.grace_period_secs,\n        'hard_timeout': request.properties.execution_timeout_secs,\n        'host': utils.get_versioned_hosturl(),\n        'io_timeout': request.properties.io_timeout_secs,\n        'inputs_ref': request.properties.inputs_ref,\n        'task_id': task_pack.pack_run_result_key(run_result_key),\n      },\n    }\n    self.send_response(utils.to_json_encodable(out))\n\n  def _cmd_sleep(self, sleep_streak, quarantined):\n    out = {\n      'cmd': 'sleep',\n      'duration': task_scheduler.exponential_backoff(sleep_streak),\n      'quarantined': quarantined,\n    }\n    self.send_response(out)\n\n  def _cmd_terminate(self, task_id):\n    out = {\n      'cmd': 'terminate',\n      'task_id': task_id,\n    }\n    self.send_response(out)\n\n  def _cmd_update(self, expected_version):\n    out = {\n      'cmd': 'update',\n      'version': expected_version,\n    }\n    self.send_response(out)\n\n  def _cmd_restart(self, message):\n    logging.info('Rebooting bot: %s', message)\n    out = {\n      'cmd': 'restart',\n      'message': message,\n    }\n    self.send_response(out)\n\n\nclass BotEventHandler(_BotBaseHandler):\n  \"\"\"On signal that a bot had an event worth logging.\"\"\"\n\n  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    (request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    event = request.get('event')\n    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):\n      self.abort_with_error(400, error='Unsupported event type')\n    message = request.get('message')\n    bot_management.bot_event(\n        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,\n        dimensions=dimensions, state=state, version=version,\n        quarantined=bool(quarantined_msg), task_id=None, task_name=None,\n        message=message)\n\n    if event == 'bot_error':\n      line = (\n          'Bot: https://%s/restricted/bot/%s\\n'\n          'Bot error:\\n'\n          '%s') % (\n          app_identity.get_default_version_hostname(), bot_id, message)\n      ereporter2.log_request(self.request, source='bot', message=line)\n    self.send_response({})\n\n\nclass BotTaskUpdateHandler(auth.ApiHandler):\n  \"\"\"Receives updates from a Bot for a task.\n\n  The handler verifies packets are processed in order and will refuse\n  out-of-order packets.\n  \"\"\"\n  ACCEPTED_KEYS = {\n    u'cost_usd', u'duration', u'exit_code', u'hard_timeout',\n    u'id', u'io_timeout', u'output', u'output_chunk_start', u'outputs_ref',\n    u'task_id',\n  }\n  REQUIRED_KEYS = {u'id', u'task_id'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  @auth.require(acl.is_bot)\n  def post(self, task_id=None):\n    # Unlike handshake and poll, we do not accept invalid keys here. This code\n    # path is much more strict.\n    request = self.parse_body()\n    msg = log_unexpected_subset_keys(\n        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',\n        'keys')\n    if msg:\n      self.abort_with_error(400, error=msg)\n\n    bot_id = request['id']\n    cost_usd = request['cost_usd']\n    task_id = request['task_id']\n\n    duration = request.get('duration')\n    exit_code = request.get('exit_code')\n    hard_timeout = request.get('hard_timeout')\n    io_timeout = request.get('io_timeout')\n    output = request.get('output')\n    output_chunk_start = request.get('output_chunk_start')\n    outputs_ref = request.get('outputs_ref')\n\n    run_result_key = task_pack.unpack_run_result_key(task_id)\n    if output is not None:\n      try:\n        output = base64.b64decode(output)\n      except UnicodeEncodeError as e:\n        logging.error('Failed to decode output\\n%s\\n%r', e, output)\n        output = output.encode('ascii', 'replace')\n      except TypeError as e:\n        # Save the output as-is instead. The error will be logged in ereporter2\n        # and returning a HTTP 500 would only force the bot to stay in a retry\n        # loop.\n        logging.error('Failed to decode output\\n%s\\n%r', e, output)\n\n    try:\n      success, completed = task_scheduler.bot_update_task(\n          run_result_key, bot_id, output, output_chunk_start,\n          exit_code, duration, hard_timeout, io_timeout, cost_usd, outputs_ref)\n      if not success:\n        logging.info('Failed to update, please retry')\n        self.abort_with_error(500, error='Failed to update, please retry')\n\n      action = 'task_completed' if completed else 'task_update'\n      bot_management.bot_event(\n          event_type=action, bot_id=bot_id,\n          external_ip=self.request.remote_addr, dimensions=None, state=None,\n          version=None, quarantined=None, task_id=task_id, task_name=None)\n    except ValueError as e:\n      ereporter2.log_request(\n          request=self.request,\n          source='server',\n          category='task_failure',\n          message='Failed to update task: %s' % e)\n      self.abort_with_error(400, error=str(e))\n    except webob.exc.HTTPException:\n      raise\n    except Exception as e:\n      logging.exception('Internal error: %s', e)\n      self.abort_with_error(500, error=str(e))\n\n    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot\n    # reboots itself to abort the task abruptly. It is useful when a task hangs\n    # and the timeout was set too long or the task was superseded by a newer\n    # task with more recent executable (e.g. a new Try Server job on a newer\n    # patchset on Rietveld).\n    self.send_response({'ok': True})\n\n\nclass BotTaskErrorHandler(auth.ApiHandler):\n  \"\"\"It is a specialized version of ereporter2's /ereporter2/api/v1/on_error\n  that also attaches a task id to it.\n\n  This formally kills the task, marking it as an internal failure. This can be\n  used by bot_main.py to kill the task when task_runner misbehaved.\n  \"\"\"\n\n  EXPECTED_KEYS = {u'id', u'message', u'task_id'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  @auth.require(acl.is_bot)\n  def post(self, task_id=None):\n    request = self.parse_body()\n    bot_id = request.get('id')\n    task_id = request.get('task_id', '')\n    message = request.get('message', 'unknown')\n\n    bot_management.bot_event(\n        event_type='task_error', bot_id=bot_id,\n        external_ip=self.request.remote_addr, dimensions=None, state=None,\n        version=None, quarantined=None, task_id=task_id, task_name=None,\n        message=message)\n    line = (\n        'Bot: https://%s/restricted/bot/%s\\n'\n        'Task failed: https://%s/user/task/%s\\n'\n        '%s') % (\n        app_identity.get_default_version_hostname(), bot_id,\n        app_identity.get_default_version_hostname(), task_id,\n        message)\n    ereporter2.log_request(self.request, source='bot', message=line)\n\n    msg = log_unexpected_keys(\n        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')\n    if msg:\n      self.abort_with_error(400, error=msg)\n\n    msg = task_scheduler.bot_kill_task(\n        task_pack.unpack_run_result_key(task_id), bot_id)\n    if msg:\n      logging.error(msg)\n      self.abort_with_error(400, error=msg)\n    self.send_response({})\n\n\nclass ServerPingHandler(webapp2.RequestHandler):\n  \"\"\"Handler to ping when checking if the server is up.\n\n  This handler should be extremely lightweight. It shouldn't do any\n  computations, it should just state that the server is up. It's open to\n  everyone for simplicity and performance.\n  \"\"\"\n\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.out.write('Server up')\n\n\ndef get_routes():\n  routes = [\n      ('/bootstrap', BootstrapHandler),\n      ('/bot_code', BotCodeHandler),\n      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),\n      ('/swarming/api/v1/bot/event', BotEventHandler),\n      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),\n      ('/swarming/api/v1/bot/poll', BotPollHandler),\n      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),\n      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),\n      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',\n          BotTaskUpdateHandler),\n      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),\n      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',\n          BotTaskErrorHandler),\n  ]\n  return [webapp2.Route(*i) for i in routes]\n/n/n/n", "label": 0}, {"id": "0ba6a589d77baefc5ae20cde5c3a5dc24a6290f9", "code": "/appengine/components/components/auth/handler.py/n/n# Copyright 2014 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Integration with webapp2.\"\"\"\n\n# Disable 'Method could be a function.'\n# pylint: disable=R0201\n\nimport functools\nimport json\nimport logging\nimport urllib\nimport webapp2\n\nfrom google.appengine.api import urlfetch\nfrom google.appengine.api import users\n\nfrom components import utils\n\nfrom . import api\nfrom . import config\nfrom . import delegation\nfrom . import host_token\nfrom . import ipaddr\nfrom . import model\nfrom . import openid\nfrom . import tokens\n\n# Part of public API of 'auth' component, exposed by this module.\n__all__ = [\n  'ApiHandler',\n  'AuthenticatingHandler',\n  'gae_cookie_authentication',\n  'get_authenticated_routes',\n  'oauth_authentication',\n  'openid_cookie_authentication',\n  'require_xsrf_token_request',\n  'service_to_service_authentication',\n]\n\n\ndef require_xsrf_token_request(f):\n  \"\"\"Use for handshaking APIs.\"\"\"\n  @functools.wraps(f)\n  def hook(self, *args, **kwargs):\n    if not self.request.headers.get('X-XSRF-Token-Request'):\n      raise api.AuthorizationError('Missing required XSRF request header')\n    return f(self, *args, **kwargs)\n  return hook\n\n\nclass XSRFToken(tokens.TokenKind):\n  \"\"\"XSRF token parameters.\"\"\"\n  expiration_sec = 4 * 3600\n  secret_key = api.SecretKey('xsrf_token', scope='local')\n  version = 1\n\n\nclass AuthenticatingHandlerMetaclass(type):\n  \"\"\"Ensures that 'get', 'post', etc. are marked with @require or @public.\"\"\"\n\n  def __new__(mcs, name, bases, attributes):\n    for method in webapp2.WSGIApplication.allowed_methods:\n      func = attributes.get(method.lower())\n      if func and not api.is_decorated(func):\n        raise TypeError(\n            'Method \\'%s\\' of \\'%s\\' is not protected by @require or @public '\n            'decorator' % (method.lower(), name))\n    return type.__new__(mcs, name, bases, attributes)\n\n\nclass AuthenticatingHandler(webapp2.RequestHandler):\n  \"\"\"Base class for webapp2 request handlers that use Auth system.\n\n  Knows how to extract Identity from request data and how to initialize auth\n  request context, so that get_current_identity() and is_group_member() work.\n\n  All request handling methods (like 'get', 'post', etc) should be marked by\n  either @require or @public decorators.\n  \"\"\"\n\n  # Checks that all 'get', 'post', etc. are marked with @require or @public.\n  __metaclass__ = AuthenticatingHandlerMetaclass\n\n  # List of HTTP methods that trigger XSRF token validation.\n  xsrf_token_enforce_on = ('DELETE', 'POST', 'PUT')\n  # If not None, the header to search for XSRF token.\n  xsrf_token_header = 'X-XSRF-Token'\n  # If not None, the request parameter (GET or POST) to search for XSRF token.\n  xsrf_token_request_param = 'xsrf_token'\n  # Embedded data extracted from XSRF token of current request.\n  xsrf_token_data = None\n  # If not None, sets X_Frame-Options on all replies.\n  frame_options = 'DENY'\n  # A method used to authenticate this request, see get_auth_methods().\n  auth_method = None\n\n  def dispatch(self):\n    \"\"\"Extracts and verifies Identity, sets up request auth context.\"\"\"\n    # Ensure auth component is configured before executing any code.\n    conf = config.ensure_configured()\n    auth_context = api.reinitialize_request_cache()\n\n    # http://www.html5rocks.com/en/tutorials/security/content-security-policy/\n    # https://www.owasp.org/index.php/Content_Security_Policy\n    # TODO(maruel): Remove 'unsafe-inline' once all inline style=\"foo:bar\" in\n    # all HTML tags were removed. Warning if seeing this post 2016, it could\n    # take a while.\n    # - https://www.google.com is due to Google Viz library.\n    # - https://www.google-analytics.com due to Analytics.\n    # - 'unsafe-eval' due to polymer.\n    self.response.headers['Content-Security-Policy'] = (\n        'default-src https: \\'self\\' \\'unsafe-inline\\' https://www.google.com '\n        'https://www.google-analytics.com \\'unsafe-eval\\'')\n    # Enforce HTTPS by adding the HSTS header; 365*24*60*60s.\n    # https://www.owasp.org/index.php/HTTP_Strict_Transport_Security\n    self.response.headers['Strict-Transport-Security'] = (\n        'max-age=31536000; includeSubDomains; preload')\n    # Disable frame support wholesale.\n    # https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet\n    if self.frame_options:\n      self.response.headers['X-Frame-Options'] = self.frame_options\n\n    identity = None\n    for method_func in self.get_auth_methods(conf):\n      try:\n        identity = method_func(self.request)\n        if identity:\n          break\n      except api.AuthenticationError as err:\n        self.authentication_error(err)\n        return\n      except api.AuthorizationError as err:\n        self.authorization_error(err)\n        return\n    else:\n      method_func = None\n    self.auth_method = method_func\n\n    # If no authentication method is applicable, default to anonymous identity.\n    identity = identity or model.Anonymous\n\n    # XSRF token is required only if using Cookie based or IP whitelist auth.\n    # A browser doesn't send Authorization: 'Bearer ...' or any other headers\n    # by itself. So XSRF check is not required if header based authentication\n    # is used.\n    using_headers_auth = method_func in (\n        oauth_authentication, service_to_service_authentication)\n\n    # Extract caller host name from host token header, if present and valid.\n    host_tok = self.request.headers.get(host_token.HTTP_HEADER)\n    if host_tok:\n      validated_host = host_token.validate_host_token(host_tok)\n      if validated_host:\n        auth_context.peer_host = validated_host\n\n    # Verify IP is whitelisted and authenticate requests from bots.\n    assert self.request.remote_addr\n    ip = ipaddr.ip_from_string(self.request.remote_addr)\n    auth_context.peer_ip = ip\n    try:\n      # 'verify_ip_whitelisted' may change identity for bots, store new one.\n      auth_context.peer_identity = api.verify_ip_whitelisted(\n          identity, ip, self.request.headers)\n    except api.AuthorizationError as err:\n      self.authorization_error(err)\n      return\n\n    # Parse delegation token, if given, to deduce end-user identity.\n    delegation_tok = self.request.headers.get(delegation.HTTP_HEADER)\n    if delegation_tok:\n      try:\n        auth_context.current_identity = delegation.check_delegation_token(\n            delegation_tok, auth_context.peer_identity)\n      except delegation.BadTokenError as exc:\n        self.authorization_error(\n            api.AuthorizationError('Bad delegation token: %s' % exc))\n      except delegation.TransientError as exc:\n        msg = 'Transient error while validating delegation token.\\n%s' % exc\n        logging.error(msg)\n        self.abort(500, detail=msg)\n    else:\n      auth_context.current_identity = auth_context.peer_identity\n\n    try:\n      # Fail if XSRF token is required, but not provided.\n      need_xsrf_token = (\n          not using_headers_auth and\n          self.request.method in self.xsrf_token_enforce_on)\n      if need_xsrf_token and self.xsrf_token is None:\n        raise api.AuthorizationError('XSRF token is missing')\n\n      # If XSRF token is present, verify it is valid and extract its payload.\n      # Do it even if XSRF token is not strictly required, since some handlers\n      # use it to store session state (it is similar to a signed cookie).\n      self.xsrf_token_data = {}\n      if self.xsrf_token is not None:\n        # This raises AuthorizationError if token is invalid.\n        self.xsrf_token_data = self.verify_xsrf_token()\n\n      # All other ACL checks will be performed by corresponding handlers\n      # manually or via '@required' decorator. Failed ACL check raises\n      # AuthorizationError.\n      super(AuthenticatingHandler, self).dispatch()\n    except api.AuthorizationError as err:\n      self.authorization_error(err)\n\n  @classmethod\n  def get_auth_methods(cls, conf):\n    \"\"\"Returns an enumerable of functions to use to authenticate request.\n\n    The handler will try to apply auth methods sequentially one by one by until\n    it finds one that works.\n\n    Each auth method is a function that accepts webapp2.Request and can finish\n    with 3 outcomes:\n\n    * Return None: authentication method is not applicable to that request\n      and next method should be tried (for example cookie-based\n      authentication is not applicable when there's no cookies).\n\n    * Returns Identity associated with the request. Means authentication method\n      is applicable and request authenticity is confirmed.\n\n    * Raises AuthenticationError: authentication method is applicable, but\n      request contains bad credentials or invalid token, etc. For example,\n      OAuth2 token is given, but it is revoked.\n\n    A chosen auth method function will be stored in request's auth_method field.\n\n    Args:\n      conf: components.auth GAE config, see config.py.\n    \"\"\"\n    if conf.USE_OPENID:\n      cookie_auth = openid_cookie_authentication\n    else:\n      cookie_auth = gae_cookie_authentication\n    return oauth_authentication, cookie_auth, service_to_service_authentication\n\n  def generate_xsrf_token(self, xsrf_token_data=None):\n    \"\"\"Returns new XSRF token that embeds |xsrf_token_data|.\n\n    The token is bound to current identity and is valid only when used by same\n    identity.\n    \"\"\"\n    return XSRFToken.generate(\n        [api.get_current_identity().to_bytes()], xsrf_token_data)\n\n  @property\n  def xsrf_token(self):\n    \"\"\"Returns XSRF token passed with the request or None if missing.\n\n    Doesn't do any validation. Use verify_xsrf_token() instead.\n    \"\"\"\n    token = None\n    if self.xsrf_token_header:\n      token = self.request.headers.get(self.xsrf_token_header)\n    if not token and self.xsrf_token_request_param:\n      param = self.request.get_all(self.xsrf_token_request_param)\n      token = param[0] if param else None\n    return token\n\n  def verify_xsrf_token(self):\n    \"\"\"Grabs a token from the request, validates it and extracts embedded data.\n\n    Current identity must be the same as one used to generate the token.\n\n    Returns:\n      Whatever was passed as |xsrf_token_data| in 'generate_xsrf_token'\n      method call used to generate the token.\n\n    Raises:\n      AuthorizationError if token is missing, invalid or expired.\n    \"\"\"\n    token = self.xsrf_token\n    if not token:\n      raise api.AuthorizationError('XSRF token is missing')\n    # Check that it was generated for the same identity.\n    try:\n      return XSRFToken.validate(token, [api.get_current_identity().to_bytes()])\n    except tokens.InvalidTokenError as err:\n      raise api.AuthorizationError(str(err))\n\n  def authentication_error(self, error):\n    \"\"\"Called when authentication fails to report the error to requester.\n\n    Authentication error means that some credentials are provided but they are\n    invalid. If no credentials are provided at all, no authentication is\n    attempted and current identity is just set to 'anonymous:anonymous'.\n\n    Default behavior is to abort the request with HTTP 401 error (and human\n    readable HTML body).\n\n    Args:\n      error: instance of AuthenticationError subclass.\n    \"\"\"\n    logging.warning('Authentication error.\\n%s', error)\n    self.abort(401, detail=str(error))\n\n  def authorization_error(self, error):\n    \"\"\"Called when authentication succeeds, but access to a resource is denied.\n\n    Called whenever request handler raises AuthorizationError exception.\n    In particular this exception is raised by method decorated with @require if\n    current identity doesn't have required permission.\n\n    Default behavior is to abort the request with HTTP 403 error (and human\n    readable HTML body).\n\n    Args:\n      error: instance of AuthorizationError subclass.\n    \"\"\"\n    logging.warning(\n        'Authorization error.\\n%s\\nPeer: %s\\nIP: %s',\n        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)\n    self.abort(403, detail=str(error))\n\n  ### Wrappers around Users API or its OpenID equivalent.\n\n  def get_current_user(self):\n    \"\"\"When cookie auth is used returns instance of CurrentUser or None.\"\"\"\n    return self._get_users_api().get_current_user(self.request)\n\n  def is_current_user_gae_admin(self):\n    \"\"\"When cookie auth is used returns True if current caller is GAE admin.\"\"\"\n    return self._get_users_api().is_current_user_gae_admin(self.request)\n\n  def create_login_url(self, dest_url):\n    \"\"\"When cookie auth is used returns URL to redirect user to login.\"\"\"\n    return self._get_users_api().create_login_url(self.request, dest_url)\n\n  def create_logout_url(self, dest_url):\n    \"\"\"When cookie auth is used returns URL to redirect user to logout.\"\"\"\n    return self._get_users_api().create_logout_url(self.request, dest_url)\n\n  def _get_users_api(self):\n    \"\"\"Returns GAEUsersAPI, OpenIDAPI or raises NotImplementedError.\n\n    Chooses based on what auth_method was used of what methods are available.\n    \"\"\"\n    method = self.auth_method\n    if not method:\n      # Anonymous request -> pick first method that supports API.\n      for method in self.get_auth_methods(config.ensure_configured()):\n        if method in _METHOD_TO_USERS_API:\n          break\n      else:\n        raise NotImplementedError('No methods support UsersAPI')\n    elif method not in _METHOD_TO_USERS_API:\n      raise NotImplementedError(\n          '%s doesn\\'t support UsersAPI' % method.__name__)\n    return _METHOD_TO_USERS_API[method]\n\n\nclass ApiHandler(AuthenticatingHandler):\n  \"\"\"Parses JSON request body to a dict, serializes response to JSON.\"\"\"\n  CONTENT_TYPE_BASE = 'application/json'\n  CONTENT_TYPE_FULL = 'application/json; charset=utf-8'\n  _json_body = None\n  # Clickjacking not applicable to APIs.\n  frame_options = None\n\n  def authentication_error(self, error):\n    logging.warning('Authentication error.\\n%s', error)\n    self.abort_with_error(401, text=str(error))\n\n  def authorization_error(self, error):\n    logging.warning(\n        'Authorization error.\\n%s\\nPeer: %s\\nIP: %s',\n        error, api.get_peer_identity().to_bytes(), self.request.remote_addr)\n    self.abort_with_error(403, text=str(error))\n\n  def send_response(self, response, http_code=200, headers=None):\n    \"\"\"Sends successful reply and continues execution.\"\"\"\n    self.response.set_status(http_code)\n    self.response.headers.update(headers or {})\n    self.response.headers['Content-Type'] = self.CONTENT_TYPE_FULL\n    self.response.write(json.dumps(response))\n\n  def abort_with_error(self, http_code, **kwargs):\n    \"\"\"Sends error reply and stops execution.\"\"\"\n    self.abort(\n        http_code,\n        json=kwargs,\n        headers={'Content-Type': self.CONTENT_TYPE_FULL})\n\n  def parse_body(self):\n    \"\"\"Parses JSON body and verifies it's a dict.\n\n    webob.Request doesn't cache the decoded json body, this function does.\n    \"\"\"\n    if self._json_body is None:\n      if (self.CONTENT_TYPE_BASE and\n          self.request.content_type != self.CONTENT_TYPE_BASE):\n        msg = (\n            'Expecting JSON body with content type \\'%s\\'' %\n            self.CONTENT_TYPE_BASE)\n        self.abort_with_error(400, text=msg)\n      try:\n        self._json_body = self.request.json\n        if not isinstance(self._json_body, dict):\n          raise ValueError()\n      except (LookupError, ValueError):\n        self.abort_with_error(400, text='Not a valid json dict body')\n    return self._json_body.copy()\n\n\ndef get_authenticated_routes(app):\n  \"\"\"Given WSGIApplication returns list of routes that use authentication.\n\n  Intended to be used only for testing.\n  \"\"\"\n  # This code is adapted from router's __repr__ method (that enumerate\n  # all routes for pretty-printing).\n  routes = list(app.router.match_routes)\n  routes.extend(\n      v for k, v in app.router.build_routes.iteritems()\n      if v not in app.router.match_routes)\n  return [r for r in routes if issubclass(r.handler, AuthenticatingHandler)]\n\n\n################################################################################\n## All supported implementations of authentication methods for webapp2 handlers.\n\n\ndef gae_cookie_authentication(_request):\n  \"\"\"AppEngine cookie based authentication via users.get_current_user().\"\"\"\n  user = users.get_current_user()\n  try:\n    return model.Identity(model.IDENTITY_USER, user.email()) if user else None\n  except ValueError:\n    raise api.AuthenticationError('Unsupported user email: %s' % user.email())\n\n\ndef openid_cookie_authentication(request):\n  \"\"\"Cookie based authentication that uses OpenID flow for login.\"\"\"\n  user = openid.get_current_user(request)\n  try:\n    return model.Identity(model.IDENTITY_USER, user.email) if user else None\n  except ValueError:\n    raise api.AuthenticationError('Unsupported user email: %s' % user.email)\n\n\ndef oauth_authentication(request):\n  \"\"\"OAuth2 based authentication via oauth.get_current_user().\"\"\"\n  if not request.headers.get('Authorization'):\n    return None\n  if not utils.is_local_dev_server():\n    return api.extract_oauth_caller_identity()\n\n  # OAuth2 library is mocked on dev server to return some nonsense. Use (slow,\n  # but real) OAuth2 API endpoint instead to validate access_token. It is also\n  # what Cloud Endpoints do on a local server. For simplicity ignore client_id\n  # on dev server.\n  header = request.headers['Authorization'].split(' ', 1)\n  if len(header) != 2 or header[0] not in ('OAuth', 'Bearer'):\n    raise api.AuthenticationError('Invalid authorization header')\n\n  # Adapted from endpoints/users_id_tokens.py, _set_bearer_user_vars_local.\n  base_url = 'https://www.googleapis.com/oauth2/v1/tokeninfo'\n  result = urlfetch.fetch(\n      url='%s?%s' % (base_url, urllib.urlencode({'access_token': header[1]})),\n      follow_redirects=False,\n      validate_certificate=True)\n  if result.status_code != 200:\n    try:\n      error = json.loads(result.content)['error_description']\n    except (KeyError, ValueError):\n      error = repr(result.content)\n    raise api.AuthenticationError('Failed to validate the token: %s' % error)\n\n  token_info = json.loads(result.content)\n  if 'email' not in token_info:\n    raise api.AuthenticationError('Token doesn\\'t include an email address')\n  if not token_info.get('verified_email'):\n    raise api.AuthenticationError('Token email isn\\'t verified')\n\n  email = token_info['email']\n  try:\n    return model.Identity(model.IDENTITY_USER, email)\n  except ValueError:\n    raise api.AuthenticationError('Unsupported user email: %s' % email)\n\n\ndef service_to_service_authentication(request):\n  \"\"\"Used for AppEngine <-> AppEngine communication.\n\n  Relies on X-Appengine-Inbound-Appid header set by AppEngine itself. It can't\n  be set by external users (with exception of admins).\n  \"\"\"\n  app_id = request.headers.get('X-Appengine-Inbound-Appid')\n  try:\n    return model.Identity(model.IDENTITY_SERVICE, app_id) if app_id else None\n  except ValueError:\n    raise api.AuthenticationError('Unsupported application ID: %s' % app_id)\n\n\n################################################################################\n## API wrapper on top of Users API and OpenID API to make them similar.\n\n\nclass CurrentUser(object):\n  \"\"\"Mimics subset of GAE users.User object for ease of transition.\n\n  Also adds .picture().\n  \"\"\"\n\n  def __init__(self, user_id, email, picture):\n    self._user_id = user_id\n    self._email = email\n    self._picture = picture\n\n  def nickname(self):\n    return self._email\n\n  def email(self):\n    return self._email\n\n  def user_id(self):\n    return self._user_id\n\n  def picture(self):\n    return self._picture\n\n  def __unicode__(self):\n    return unicode(self.nickname())\n\n  def __str__(self):\n    return str(self.nickname())\n\n\nclass GAEUsersAPI(object):\n  @staticmethod\n  def get_current_user(request):  # pylint: disable=unused-argument\n    user = users.get_current_user()\n    return CurrentUser(user.user_id(), user.email(), None) if user else None\n\n  @staticmethod\n  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument\n    return users.is_current_user_admin()\n\n  @staticmethod\n  def create_login_url(request, dest_url):  # pylint: disable=unused-argument\n    return users.create_login_url(dest_url)\n\n  @staticmethod\n  def create_logout_url(request, dest_url):  # pylint: disable=unused-argument\n    return users.create_logout_url(dest_url)\n\n\nclass OpenIDAPI(object):\n  @staticmethod\n  def get_current_user(request):\n    user = openid.get_current_user(request)\n    return CurrentUser(user.sub, user.email, user.picture) if user else None\n\n  @staticmethod\n  def is_current_user_gae_admin(request):  # pylint: disable=unused-argument\n    return False\n\n  @staticmethod\n  def create_login_url(request, dest_url):\n    return openid.create_login_url(request, dest_url)\n\n  @staticmethod\n  def create_logout_url(request, dest_url):\n    return openid.create_logout_url(request, dest_url)\n\n\n# See AuthenticatingHandler._get_users_api().\n_METHOD_TO_USERS_API = {\n  gae_cookie_authentication: GAEUsersAPI,\n  openid_cookie_authentication: OpenIDAPI,\n}\n/n/n/n/appengine/components/components/auth/handler_test.py/n/n#!/usr/bin/env python\n# Copyright 2014 The Swarming Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n# Disable 'Unused variable', 'Unused argument' and 'Method could be a function'.\n# pylint: disable=W0612,W0613,R0201\n\nimport datetime\nimport json\nimport os\nimport sys\nimport unittest\n\nfrom test_support import test_env\ntest_env.setup_test_env()\n\nfrom google.appengine.api import oauth\nfrom google.appengine.api import users\n\nimport webapp2\nimport webtest\n\nfrom components import utils\nfrom components.auth import api\nfrom components.auth import delegation\nfrom components.auth import handler\nfrom components.auth import host_token\nfrom components.auth import ipaddr\nfrom components.auth import model\nfrom components.auth.proto import delegation_pb2\nfrom test_support import test_case\n\n\nclass AuthenticatingHandlerMetaclassTest(test_case.TestCase):\n  \"\"\"Tests for AuthenticatingHandlerMetaclass.\"\"\"\n\n  def test_good(self):\n    # No request handling methods defined at all.\n    class TestHandler1(handler.AuthenticatingHandler):\n      def some_other_method(self):\n        pass\n\n    # @public is used.\n    class TestHandler2(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        pass\n\n    # @require is used.\n    class TestHandler3(handler.AuthenticatingHandler):\n      @api.require(lambda: True)\n      def get(self):\n        pass\n\n  def test_bad(self):\n    # @public or @require is missing.\n    with self.assertRaises(TypeError):\n      class TestHandler1(handler.AuthenticatingHandler):\n        def get(self):\n          pass\n\n\nclass AuthenticatingHandlerTest(test_case.TestCase):\n  \"\"\"Tests for AuthenticatingHandler class.\"\"\"\n\n  def setUp(self):\n    super(AuthenticatingHandlerTest, self).setUp()\n    # Reset global config of auth library before each test.\n    api.reset_local_state()\n    # Capture error and warning log messages.\n    self.logged_errors = []\n    self.mock(handler.logging, 'error',\n        lambda *args, **kwargs: self.logged_errors.append((args, kwargs)))\n    self.logged_warnings = []\n    self.mock(handler.logging, 'warning',\n        lambda *args, **kwargs: self.logged_warnings.append((args, kwargs)))\n\n  def make_test_app(self, path, request_handler):\n    \"\"\"Returns webtest.TestApp with single route.\"\"\"\n    return webtest.TestApp(\n        webapp2.WSGIApplication([(path, request_handler)], debug=True),\n        extra_environ={'REMOTE_ADDR': '127.0.0.1'})\n\n  def test_anonymous(self):\n    \"\"\"If all auth methods are not applicable, identity is set to Anonymous.\"\"\"\n    test = self\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        non_applicable = lambda _request: None\n        return [non_applicable, non_applicable]\n\n      @api.public\n      def get(self):\n        test.assertEqual(model.Anonymous, api.get_current_identity())\n        self.response.write('OK')\n\n    app = self.make_test_app('/request', Handler)\n    self.assertEqual('OK', app.get('/request').body)\n\n  def test_ip_whitelist_bot(self):\n    \"\"\"Requests from client in \"bots\" IP whitelist are authenticated as bot.\"\"\"\n    model.bootstrap_ip_whitelist('bots', ['192.168.1.100/32'])\n\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(api.get_current_identity().to_bytes())\n\n    app = self.make_test_app('/request', Handler)\n    def call(ip):\n      api.reset_local_state()\n      return app.get('/request', extra_environ={'REMOTE_ADDR': ip}).body\n\n    self.assertEqual('bot:whitelisted-ip', call('192.168.1.100'))\n    self.assertEqual('anonymous:anonymous', call('127.0.0.1'))\n\n  def test_ip_whitelist(self):\n    \"\"\"Per-account IP whitelist works.\"\"\"\n    ident1 = model.Identity(model.IDENTITY_USER, 'a@example.com')\n    ident2 = model.Identity(model.IDENTITY_USER, 'b@example.com')\n\n    model.bootstrap_ip_whitelist('whitelist', ['192.168.1.100/32'])\n    model.bootstrap_ip_whitelist_assignment(ident1, 'whitelist')\n\n    mocked_ident = [None]\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [lambda _req: mocked_ident[0]]\n\n      @api.public\n      def get(self):\n        self.response.write('OK')\n\n    app = self.make_test_app('/request', Handler)\n    def call(ident, ip):\n      api.reset_local_state()\n      mocked_ident[0] = ident\n      response = app.get(\n          '/request', extra_environ={'REMOTE_ADDR': ip}, expect_errors=True)\n      return response.status_int\n\n    # IP is whitelisted.\n    self.assertEqual(200, call(ident1, '192.168.1.100'))\n    # IP is NOT whitelisted.\n    self.assertEqual(403, call(ident1, '127.0.0.1'))\n    # Whitelist is not used.\n    self.assertEqual(200, call(ident2, '127.0.0.1'))\n\n  def test_auth_method_order(self):\n    \"\"\"Registered auth methods are tested in order.\"\"\"\n    test = self\n    calls = []\n    ident = model.Identity(model.IDENTITY_USER, 'joe@example.com')\n\n    def not_applicable(request):\n      self.assertEqual('/request', request.path)\n      calls.append('not_applicable')\n      return None\n\n    def applicable(request):\n      self.assertEqual('/request', request.path)\n      calls.append('applicable')\n      return ident\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [not_applicable, applicable]\n\n      @api.public\n      def get(self):\n        test.assertEqual(ident, api.get_current_identity())\n        self.response.write('OK')\n\n    app = self.make_test_app('/request', Handler)\n    self.assertEqual('OK', app.get('/request').body)\n\n    # Both methods should be tried.\n    expected_calls = [\n      'not_applicable',\n      'applicable',\n    ]\n    self.assertEqual(expected_calls, calls)\n\n  def test_authentication_error(self):\n    \"\"\"AuthenticationError in auth method stops request processing.\"\"\"\n    test = self\n    calls = []\n\n    def failing(request):\n      raise api.AuthenticationError('Too bad')\n\n    def skipped(request):\n      self.fail('authenticate should not be called')\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [failing, skipped]\n\n      @api.public\n      def get(self):\n        test.fail('Handler code should not be called')\n\n      def authentication_error(self, err):\n        test.assertEqual('Too bad', err.message)\n        calls.append('authentication_error')\n        # pylint: disable=bad-super-call\n        super(Handler, self).authentication_error(err)\n\n    app = self.make_test_app('/request', Handler)\n    response = app.get('/request', expect_errors=True)\n\n    # Custom error handler is called and returned HTTP 401.\n    self.assertEqual(['authentication_error'], calls)\n    self.assertEqual(401, response.status_int)\n\n    # Authentication error is logged.\n    self.assertEqual(1, len(self.logged_warnings))\n\n  def test_authorization_error(self):\n    \"\"\"AuthorizationError in auth method is handled.\"\"\"\n    test = self\n    calls = []\n\n    class Handler(handler.AuthenticatingHandler):\n      @api.require(lambda: False)\n      def get(self):\n        test.fail('Handler code should not be called')\n\n      def authorization_error(self, err):\n        calls.append('authorization_error')\n        # pylint: disable=bad-super-call\n        super(Handler, self).authorization_error(err)\n\n    app = self.make_test_app('/request', Handler)\n    response = app.get('/request', expect_errors=True)\n\n    # Custom error handler is called and returned HTTP 403.\n    self.assertEqual(['authorization_error'], calls)\n    self.assertEqual(403, response.status_int)\n\n  def make_xsrf_handling_app(\n      self,\n      xsrf_token_enforce_on=None,\n      xsrf_token_header=None,\n      xsrf_token_request_param=None):\n    \"\"\"Returns webtest app with single XSRF-aware handler.\n\n    If generates XSRF tokens on GET and validates them on POST, PUT, DELETE.\n    \"\"\"\n    calls = []\n\n    def record(request_handler, method):\n      is_valid = request_handler.xsrf_token_data == {'some': 'data'}\n      calls.append((method, is_valid))\n\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(self.generate_xsrf_token({'some': 'data'}))\n      @api.public\n      def post(self):\n        record(self, 'POST')\n      @api.public\n      def put(self):\n        record(self, 'PUT')\n      @api.public\n      def delete(self):\n        record(self, 'DELETE')\n\n    if xsrf_token_enforce_on is not None:\n      Handler.xsrf_token_enforce_on = xsrf_token_enforce_on\n    if xsrf_token_header is not None:\n      Handler.xsrf_token_header = xsrf_token_header\n    if xsrf_token_request_param is not None:\n      Handler.xsrf_token_request_param = xsrf_token_request_param\n\n    app = self.make_test_app('/request', Handler)\n    return app, calls\n\n  def mock_get_current_identity(self, ident):\n    \"\"\"Mocks api.get_current_identity() to return |ident|.\"\"\"\n    self.mock(handler.api, 'get_current_identity', lambda: ident)\n\n  def test_xsrf_token_get_param(self):\n    \"\"\"XSRF token works if put in GET parameters.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    token = app.get('/request').body\n    app.post('/request?xsrf_token=%s' % token)\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_post_param(self):\n    \"\"\"XSRF token works if put in POST parameters.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    token = app.get('/request').body\n    app.post('/request', {'xsrf_token': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_header(self):\n    \"\"\"XSRF token works if put in the headers.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    token = app.get('/request').body\n    app.post('/request', headers={'X-XSRF-Token': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_missing(self):\n    \"\"\"XSRF token is not given but handler requires it.\"\"\"\n    app, calls = self.make_xsrf_handling_app()\n    response = app.post('/request', expect_errors=True)\n    self.assertEqual(403, response.status_int)\n    self.assertFalse(calls)\n\n  def test_xsrf_token_uses_enforce_on(self):\n    \"\"\"Only methods set in |xsrf_token_enforce_on| require token validation.\"\"\"\n    # Validate tokens only on PUT (not on POST).\n    app, calls = self.make_xsrf_handling_app(xsrf_token_enforce_on=('PUT',))\n    token = app.get('/request').body\n    # Both POST and PUT work when token provided, verifying it.\n    app.post('/request', {'xsrf_token': token})\n    app.put('/request', {'xsrf_token': token})\n    self.assertEqual([('POST', True), ('PUT', True)], calls)\n    # POST works without a token, put PUT doesn't.\n    self.assertEqual(200, app.post('/request').status_int)\n    self.assertEqual(403, app.put('/request', expect_errors=True).status_int)\n    # Both fail if wrong token is provided.\n    bad_token = {'xsrf_token': 'boo'}\n    self.assertEqual(\n        403, app.post('/request', bad_token, expect_errors=True).status_int)\n    self.assertEqual(\n        403, app.put('/request', bad_token, expect_errors=True).status_int)\n\n  def test_xsrf_token_uses_xsrf_token_header(self):\n    \"\"\"Name of the header used for XSRF can be changed.\"\"\"\n    app, calls = self.make_xsrf_handling_app(xsrf_token_header='X-Some')\n    token = app.get('/request').body\n    app.post('/request', headers={'X-Some': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_uses_xsrf_token_request_param(self):\n    \"\"\"Name of the request param used for XSRF can be changed.\"\"\"\n    app, calls = self.make_xsrf_handling_app(xsrf_token_request_param='tok')\n    token = app.get('/request').body\n    app.post('/request', {'tok': token})\n    self.assertEqual([('POST', True)], calls)\n\n  def test_xsrf_token_identity_matters(self):\n    app, calls = self.make_xsrf_handling_app()\n    # Generate token for identity A.\n    self.mock_get_current_identity(\n        model.Identity(model.IDENTITY_USER, 'a@example.com'))\n    token = app.get('/request').body\n    # Try to use it by identity B.\n    self.mock_get_current_identity(\n        model.Identity(model.IDENTITY_USER, 'b@example.com'))\n    response = app.post('/request', expect_errors=True)\n    self.assertEqual(403, response.status_int)\n    self.assertFalse(calls)\n\n  def test_get_authenticated_routes(self):\n    class Authenticated(handler.AuthenticatingHandler):\n      pass\n\n    class NotAuthenticated(webapp2.RequestHandler):\n      pass\n\n    app = webapp2.WSGIApplication([\n      webapp2.Route('/authenticated', Authenticated),\n      webapp2.Route('/not-authenticated', NotAuthenticated),\n    ])\n    routes = handler.get_authenticated_routes(app)\n    self.assertEqual(1, len(routes))\n    self.assertEqual(Authenticated, routes[0].handler)\n\n  def test_get_peer_ip(self):\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(ipaddr.ip_to_string(api.get_peer_ip()))\n\n    app = self.make_test_app('/request', Handler)\n    response = app.get('/request', extra_environ={'REMOTE_ADDR': '192.1.2.3'})\n    self.assertEqual('192.1.2.3', response.body)\n\n  def test_get_peer_host(self):\n    class Handler(handler.AuthenticatingHandler):\n      @api.public\n      def get(self):\n        self.response.write(api.get_peer_host() or '<none>')\n\n    app = self.make_test_app('/request', Handler)\n    def call(headers):\n      api.reset_local_state()\n      return app.get('/request', headers=headers).body\n\n    # Good token.\n    token = host_token.create_host_token('HOST.domain.com')\n    self.assertEqual('host.domain.com', call({'X-Host-Token-V1': token}))\n\n    # Missing or invalid tokens.\n    self.assertEqual('<none>', call({}))\n    self.assertEqual('<none>', call({'X-Host-Token-V1': 'broken'}))\n\n    # Expired token.\n    origin = datetime.datetime(2014, 1, 1, 1, 1, 1)\n    self.mock_now(origin)\n    token = host_token.create_host_token('HOST.domain.com', expiration_sec=60)\n    self.mock_now(origin, 61)\n    self.assertEqual('<none>', call({'X-Host-Token-V1': token}))\n\n  def test_delegation_token(self):\n    peer_ident = model.Identity.from_bytes('user:peer@a.com')\n\n    class Handler(handler.AuthenticatingHandler):\n      @classmethod\n      def get_auth_methods(cls, conf):\n        return [lambda _request: peer_ident]\n\n      @api.public\n      def get(self):\n        self.response.write(json.dumps({\n          'peer_id': api.get_peer_identity().to_bytes(),\n          'cur_id': api.get_current_identity().to_bytes(),\n        }))\n\n    app = self.make_test_app('/request', Handler)\n    def call(headers=None):\n      return json.loads(app.get('/request', headers=headers).body)\n\n    # No delegation.\n    self.assertEqual(\n        {u'cur_id': u'user:peer@a.com', u'peer_id': u'user:peer@a.com'}, call())\n\n    # TODO(vadimsh): Mint token via some high-level function call.\n    subtokens = delegation_pb2.SubtokenList(subtokens=[\n        delegation_pb2.Subtoken(\n            issuer_id='user:delegated@a.com',\n            creation_time=int(utils.time_time()),\n            validity_duration=3600),\n    ])\n    tok = delegation.serialize_token(delegation.seal_token(subtokens))\n\n    # With valid delegation token.\n    self.assertEqual(\n        {u'cur_id': u'user:delegated@a.com', u'peer_id': u'user:peer@a.com'},\n        call({'X-Delegation-Token-V1': tok}))\n\n    # With invalid delegation token.\n    r = app.get(\n        '/request',\n        headers={'X-Delegation-Token-V1': tok + 'blah'},\n        expect_errors=True)\n    self.assertEqual(403, r.status_int)\n\n    # Transient error.\n    def mocked_check(*_args):\n      raise delegation.TransientError('Blah')\n    self.mock(delegation, 'check_delegation_token', mocked_check)\n    r = app.get(\n        '/request',\n        headers={'X-Delegation-Token-V1': tok},\n        expect_errors=True)\n    self.assertEqual(500, r.status_int)\n\n\nclass GaeCookieAuthenticationTest(test_case.TestCase):\n  \"\"\"Tests for gae_cookie_authentication function.\"\"\"\n\n  def test_non_applicable(self):\n    self.assertIsNone(handler.gae_cookie_authentication(webapp2.Request({})))\n\n  def test_applicable(self):\n    os.environ.update({\n      'USER_EMAIL': 'joe@example.com',\n      'USER_ID': '123',\n      'USER_IS_ADMIN': '0',\n    })\n    # Actual request is not used by CookieAuthentication.\n    self.assertEqual(\n        model.Identity(model.IDENTITY_USER, 'joe@example.com'),\n        handler.gae_cookie_authentication(webapp2.Request({})))\n\n\nclass ServiceToServiceAuthenticationTest(test_case.TestCase):\n  \"\"\"Tests for service_to_service_authentication.\"\"\"\n\n  def test_non_applicable(self):\n    request = webapp2.Request({})\n    self.assertIsNone(\n        handler.service_to_service_authentication(request))\n\n  def test_applicable(self):\n    request = webapp2.Request({\n      'HTTP_X_APPENGINE_INBOUND_APPID': 'some-app',\n    })\n    self.assertEqual(\n      model.Identity(model.IDENTITY_SERVICE, 'some-app'),\n      handler.service_to_service_authentication(request))\n\n\nif __name__ == '__main__':\n  if '-v' in sys.argv:\n    unittest.TestCase.maxDiff = None\n  unittest.main()\n/n/n/n", "label": 1}, {"id": "c23a5bf6278f55b3f8135e0edab9927599a09236", "code": "appengine/swarming/handlers_bot.py/n/n# Copyright 2015 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Internal bot API handlers.\"\"\"\n\nimport base64\nimport json\nimport logging\nimport textwrap\n\nimport webob\nimport webapp2\n\nfrom google.appengine.api import app_identity\nfrom google.appengine.api import datastore_errors\nfrom google.appengine.datastore import datastore_query\nfrom google.appengine import runtime\nfrom google.appengine.ext import ndb\n\nfrom components import auth\nfrom components import ereporter2\nfrom components import utils\nfrom server import acl\nfrom server import bot_code\nfrom server import bot_management\nfrom server import stats\nfrom server import task_pack\nfrom server import task_request\nfrom server import task_result\nfrom server import task_scheduler\nfrom server import task_to_run\n\n\ndef has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):\n  \"\"\"Returns an error if unexpected keys are present or expected keys are\n  missing.\n\n  Accepts optional keys.\n\n  This is important to catch typos.\n  \"\"\"\n  actual_keys = frozenset(actual_keys)\n  superfluous = actual_keys - expected_keys\n  missing = minimum_keys - actual_keys\n  if superfluous or missing:\n    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''\n    msg_superfluous = (\n        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')\n    return 'Unexpected %s%s%s; did you make a typo?' % (\n        name, msg_missing, msg_superfluous)\n\n\ndef has_unexpected_keys(expected_keys, actual_keys, name):\n  \"\"\"Return an error if unexpected keys are present or expected keys are\n  missing.\n  \"\"\"\n  return has_unexpected_subset_keys(\n      expected_keys, expected_keys, actual_keys, name)\n\n\ndef log_unexpected_subset_keys(\n    expected_keys, minimum_keys, actual_keys, request, source, name):\n  \"\"\"Logs an error if unexpected keys are present or expected keys are missing.\n\n  Accepts optional keys.\n\n  This is important to catch typos.\n  \"\"\"\n  message = has_unexpected_subset_keys(\n    expected_keys, minimum_keys, actual_keys, name)\n  if message:\n    ereporter2.log_request(request, source=source, message=message)\n  return message\n\n\ndef log_unexpected_keys(expected_keys, actual_keys, request, source, name):\n  \"\"\"Logs an error if unexpected keys are present or expected keys are missing.\n  \"\"\"\n  return log_unexpected_subset_keys(\n      expected_keys, expected_keys, actual_keys, request, source, name)\n\n\ndef has_missing_keys(minimum_keys, actual_keys, name):\n  \"\"\"Returns an error if expected keys are not present.\n\n  Do not warn about unexpected keys.\n  \"\"\"\n  actual_keys = frozenset(actual_keys)\n  missing = minimum_keys - actual_keys\n  if missing:\n    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''\n    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)\n\n\nclass BootstrapHandler(auth.AuthenticatingHandler):\n  \"\"\"Returns python code to run to bootstrap a swarming bot.\"\"\"\n\n  @auth.require(acl.is_bot)\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/x-python'\n    self.response.headers['Content-Disposition'] = (\n        'attachment; filename=\"swarming_bot_bootstrap.py\"')\n    self.response.out.write(\n        bot_code.get_bootstrap(self.request.host_url).content)\n\n\nclass BotCodeHandler(auth.AuthenticatingHandler):\n  \"\"\"Returns a zip file with all the files required by a bot.\n\n  Optionally specify the hash version to download. If so, the returned data is\n  cacheable.\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def get(self, version=None):\n    if version:\n      expected = bot_code.get_bot_version(self.request.host_url)\n      if version != expected:\n        # This can happen when the server is rapidly updated.\n        logging.error('Requested Swarming bot %s, have %s', version, expected)\n        self.abort(404)\n      self.response.headers['Cache-Control'] = 'public, max-age=3600'\n    else:\n      self.response.headers['Cache-Control'] = 'no-cache, no-store'\n    self.response.headers['Content-Type'] = 'application/octet-stream'\n    self.response.headers['Content-Disposition'] = (\n        'attachment; filename=\"swarming_bot.zip\"')\n    self.response.out.write(\n        bot_code.get_swarming_bot_zip(self.request.host_url))\n\n\nclass _BotBaseHandler(auth.ApiHandler):\n  \"\"\"\n  Request body is a JSON dict:\n    {\n      \"dimensions\": <dict of properties>,\n      \"state\": <dict of properties>,\n      \"version\": <sha-1 of swarming_bot.zip uncompressed content>,\n    }\n  \"\"\"\n\n  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}\n  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  def _process(self):\n    \"\"\"Returns True if the bot has invalid parameter and should be automatically\n    quarantined.\n\n    Does one DB synchronous GET.\n\n    Returns:\n      tuple(request, bot_id, version, state, dimensions, quarantined_msg)\n    \"\"\"\n    request = self.parse_body()\n    version = request.get('version', None)\n\n    dimensions = request.get('dimensions', {})\n    state = request.get('state', {})\n    bot_id = None\n    if dimensions.get('id'):\n      dimension_id = dimensions['id']\n      if (isinstance(dimension_id, list) and len(dimension_id) == 1\n          and isinstance(dimension_id[0], unicode)):\n        bot_id = dimensions['id'][0]\n\n    # The bot may decide to \"self-quarantine\" itself. Accept both via\n    # dimensions or via state. See bot_management._BotCommon.quarantined for\n    # more details.\n    if (bool(dimensions.get('quarantined')) or\n        bool(state.get('quarantined'))):\n      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'\n\n    quarantined_msg = None\n    # Use a dummy 'for' to be able to break early from the block.\n    for _ in [0]:\n\n      quarantined_msg = has_unexpected_keys(\n          self.EXPECTED_KEYS, request, 'keys')\n      if quarantined_msg:\n        break\n\n      quarantined_msg = has_missing_keys(\n          self.REQUIRED_STATE_KEYS, state, 'state')\n      if quarantined_msg:\n        break\n\n      if not bot_id:\n        quarantined_msg = 'Missing bot id'\n        break\n\n      if not all(\n          isinstance(key, unicode) and\n          isinstance(values, list) and\n          all(isinstance(value, unicode) for value in values)\n          for key, values in dimensions.iteritems()):\n        quarantined_msg = (\n            'Invalid dimensions type:\\n%s' % json.dumps(dimensions,\n              sort_keys=True, indent=2, separators=(',', ': ')))\n        break\n\n      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)\n      if dimensions_count > task_to_run.MAX_DIMENSIONS:\n        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count\n        break\n\n      if not isinstance(\n          state.get('lease_expiration_ts'), (None.__class__, int)):\n        quarantined_msg = (\n            'lease_expiration_ts (%r) must be int or None' % (\n                state['lease_expiration_ts']))\n        break\n\n    if quarantined_msg:\n      line = 'Quarantined Bot\\nhttps://%s/restricted/bot/%s\\n%s' % (\n          app_identity.get_default_version_hostname(), bot_id,\n          quarantined_msg)\n      ereporter2.log_request(self.request, source='bot', message=line)\n      return request, bot_id, version, state, dimensions, quarantined_msg\n\n    # Look for admin enforced quarantine.\n    bot_settings = bot_management.get_settings_key(bot_id).get()\n    if bool(bot_settings and bot_settings.quarantined):\n      return request, bot_id, version, state, dimensions, 'Quarantined by admin'\n\n    return request, bot_id, version, state, dimensions, None\n\n\nclass BotHandshakeHandler(_BotBaseHandler):\n  \"\"\"First request to be called to get initial data like XSRF token.\n\n  The bot is server-controled so the server doesn't have to support multiple API\n  version. When running a task, the bot sync the the version specific URL. Once\n  abot finished its currently running task, it'll be immediately be upgraded\n  after on its next poll.\n\n  This endpoint does not return commands to the bot, for example to upgrade\n  itself. It'll be told so when it does its first poll.\n\n  Response body is a JSON dict:\n    {\n      \"bot_version\": <sha-1 of swarming_bot.zip uncompressed content>,\n      \"server_version\": \"138-193f1f3\",\n    }\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    (_request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    bot_management.bot_event(\n        event_type='bot_connected', bot_id=bot_id,\n        external_ip=self.request.remote_addr, dimensions=dimensions,\n        state=state, version=version, quarantined=bool(quarantined_msg),\n        task_id='', task_name=None, message=quarantined_msg)\n\n    data = {\n      # This access token will be used to validate each subsequent request.\n      'bot_version': bot_code.get_bot_version(self.request.host_url),\n      # TODO(maruel): Remove this once all the bots have been updated.\n      'expiration_sec': auth.handler.XSRFToken.expiration_sec,\n      'server_version': utils.get_app_version(),\n      # TODO(maruel): Remove this once all the bots have been updated.\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.send_response(data)\n\n\nclass BotPollHandler(_BotBaseHandler):\n  \"\"\"The bot polls for a task; returns either a task, update command or sleep.\n\n  In case of exception on the bot, this is enough to get it just far enough to\n  eventually self-update to a working version. This is to ensure that coding\n  errors in bot code doesn't kill all the fleet at once, they should still be up\n  just enough to be able to self-update again even if they don't get task\n  assigned anymore.\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    \"\"\"Handles a polling request.\n\n    Be very permissive on missing values. This can happen because of errors\n    on the bot, *we don't want to deny them the capacity to update*, so that the\n    bot code is eventually fixed and the bot self-update to this working code.\n\n    It makes recovery of the fleet in case of catastrophic failure much easier.\n    \"\"\"\n    (_request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    sleep_streak = state.get('sleep_streak', 0)\n    quarantined = bool(quarantined_msg)\n\n    # Note bot existence at two places, one for stats at 1 minute resolution,\n    # the other for the list of known bots.\n    action = 'bot_inactive' if quarantined else 'bot_active'\n    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)\n\n    def bot_event(event_type, task_id=None, task_name=None):\n      bot_management.bot_event(\n          event_type=event_type, bot_id=bot_id,\n          external_ip=self.request.remote_addr, dimensions=dimensions,\n          state=state, version=version, quarantined=quarantined,\n          task_id=task_id, task_name=task_name, message=quarantined_msg)\n\n    # Bot version is host-specific because the host URL is embedded in\n    # swarming_bot.zip\n    expected_version = bot_code.get_bot_version(self.request.host_url)\n    if version != expected_version:\n      bot_event('request_update')\n      self._cmd_update(expected_version)\n      return\n    if quarantined:\n      bot_event('request_sleep')\n      self._cmd_sleep(sleep_streak, quarantined)\n      return\n\n    #\n    # At that point, the bot should be in relatively good shape since it's\n    # running the right version. It is still possible that invalid code was\n    # pushed to the server, so be diligent about it.\n    #\n\n    # Bot may need a reboot if it is running for too long. We do not reboot\n    # quarantined bots.\n    needs_restart, restart_message = bot_management.should_restart_bot(\n        bot_id, state)\n    if needs_restart:\n      bot_event('request_restart')\n      self._cmd_restart(restart_message)\n      return\n\n    # The bot is in good shape. Try to grab a task.\n    try:\n      # This is a fairly complex function call, exceptions are expected.\n      request, run_result = task_scheduler.bot_reap_task(\n          dimensions, bot_id, version, state.get('lease_expiration_ts'))\n      if not request:\n        # No task found, tell it to sleep a bit.\n        bot_event('request_sleep')\n        self._cmd_sleep(sleep_streak, quarantined)\n        return\n\n      try:\n        # This part is tricky since it intentionally runs a transaction after\n        # another one.\n        if request.properties.is_terminate:\n          bot_event('bot_terminate', task_id=run_result.task_id)\n          self._cmd_terminate(run_result.task_id)\n        else:\n          bot_event(\n              'request_task', task_id=run_result.task_id,\n              task_name=request.name)\n          self._cmd_run(request, run_result.key, bot_id)\n      except:\n        logging.exception('Dang, exception after reaping')\n        raise\n    except runtime.DeadlineExceededError:\n      # If the timeout happened before a task was assigned there is no problems.\n      # If the timeout occurred after a task was assigned, that task will\n      # timeout (BOT_DIED) since the bot didn't get the details required to\n      # run it) and it will automatically get retried (TODO) when the task times\n      # out.\n      # TODO(maruel): Note the task if possible and hand it out on next poll.\n      # https://code.google.com/p/swarming/issues/detail?id=130\n      self.abort(500, 'Deadline')\n\n  def _cmd_run(self, request, run_result_key, bot_id):\n    cmd = None\n    if request.properties.commands:\n      cmd = request.properties.commands[0]\n    elif request.properties.command:\n      cmd = request.properties.command\n    out = {\n      'cmd': 'run',\n      'manifest': {\n        'bot_id': bot_id,\n        'command': cmd,\n        'dimensions': request.properties.dimensions,\n        'env': request.properties.env,\n        'extra_args': request.properties.extra_args,\n        'grace_period': request.properties.grace_period_secs,\n        'hard_timeout': request.properties.execution_timeout_secs,\n        'host': utils.get_versioned_hosturl(),\n        'io_timeout': request.properties.io_timeout_secs,\n        'inputs_ref': request.properties.inputs_ref,\n        'task_id': task_pack.pack_run_result_key(run_result_key),\n      },\n    }\n    self.send_response(utils.to_json_encodable(out))\n\n  def _cmd_sleep(self, sleep_streak, quarantined):\n    out = {\n      'cmd': 'sleep',\n      'duration': task_scheduler.exponential_backoff(sleep_streak),\n      'quarantined': quarantined,\n    }\n    self.send_response(out)\n\n  def _cmd_terminate(self, task_id):\n    out = {\n      'cmd': 'terminate',\n      'task_id': task_id,\n    }\n    self.send_response(out)\n\n  def _cmd_update(self, expected_version):\n    out = {\n      'cmd': 'update',\n      'version': expected_version,\n    }\n    self.send_response(out)\n\n  def _cmd_restart(self, message):\n    logging.info('Rebooting bot: %s', message)\n    out = {\n      'cmd': 'restart',\n      'message': message,\n    }\n    self.send_response(out)\n\n\nclass BotEventHandler(_BotBaseHandler):\n  \"\"\"On signal that a bot had an event worth logging.\"\"\"\n\n  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    (request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    event = request.get('event')\n    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):\n      self.abort_with_error(400, error='Unsupported event type')\n    message = request.get('message')\n    bot_management.bot_event(\n        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,\n        dimensions=dimensions, state=state, version=version,\n        quarantined=bool(quarantined_msg), task_id=None, task_name=None,\n        message=message)\n\n    if event == 'bot_error':\n      line = (\n          'Bot: https://%s/restricted/bot/%s\\n'\n          'Bot error:\\n'\n          '%s') % (\n          app_identity.get_default_version_hostname(), bot_id, message)\n      ereporter2.log_request(self.request, source='bot', message=line)\n    self.send_response({})\n\n\nclass BotTaskUpdateHandler(auth.ApiHandler):\n  \"\"\"Receives updates from a Bot for a task.\n\n  The handler verifies packets are processed in order and will refuse\n  out-of-order packets.\n  \"\"\"\n  ACCEPTED_KEYS = {\n    u'bot_overhead', u'cost_usd', u'duration', u'exit_code',\n    u'hard_timeout', u'id', u'io_timeout', u'isolated_stats', u'output',\n    u'output_chunk_start', u'outputs_ref', u'task_id',\n  }\n  REQUIRED_KEYS = {u'id', u'task_id'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  @auth.require(acl.is_bot)\n  def post(self, task_id=None):\n    # Unlike handshake and poll, we do not accept invalid keys here. This code\n    # path is much more strict.\n    request = self.parse_body()\n    msg = log_unexpected_subset_keys(\n        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',\n        'keys')\n    if msg:\n      self.abort_with_error(400, error=msg)\n\n    bot_id = request['id']\n    cost_usd = request['cost_usd']\n    task_id = request['task_id']\n\n    bot_overhead = request.get('bot_overhead')\n    duration = request.get('duration')\n    exit_code = request.get('exit_code')\n    hard_timeout = request.get('hard_timeout')\n    io_timeout = request.get('io_timeout')\n    isolated_stats = request.get('isolated_stats')\n    output = request.get('output')\n    output_chunk_start = request.get('output_chunk_start')\n    outputs_ref = request.get('outputs_ref')\n\n    if bool(isolated_stats) != (bot_overhead is not None):\n      ereporter2.log_request(\n          request=self.request,\n          source='server',\n          category='task_failure',\n          message='Failed to update task: %s' % task_id)\n      self.abort_with_error(\n          400,\n          error='Both bot_overhead and isolated_stats must be set '\n                'simultaneously\\nbot_overhead: %s\\nisolated_stats: %s' %\n                (bot_overhead, isolated_stats))\n\n    run_result_key = task_pack.unpack_run_result_key(task_id)\n    performance_stats = None\n    if isolated_stats:\n      download = isolated_stats['download']\n      upload = isolated_stats['upload']\n      performance_stats = task_result.PerformanceStats(\n          bot_overhead=bot_overhead,\n          isolated_download=task_result.IsolatedOperation(\n              duration=download['duration'],\n              initial_number_items=download['initial_number_items'],\n              initial_size=download['initial_size'],\n              items_cold=base64.b64decode(download['items_cold']),\n              items_hot=base64.b64decode(download['items_hot'])),\n          isolated_upload=task_result.IsolatedOperation(\n              duration=upload['duration'],\n              items_cold=base64.b64decode(upload['items_cold']),\n              items_hot=base64.b64decode(upload['items_hot'])))\n\n    if output is not None:\n      try:\n        output = base64.b64decode(output)\n      except UnicodeEncodeError as e:\n        logging.error('Failed to decode output\\n%s\\n%r', e, output)\n        output = output.encode('ascii', 'replace')\n      except TypeError as e:\n        # Save the output as-is instead. The error will be logged in ereporter2\n        # and returning a HTTP 500 would only force the bot to stay in a retry\n        # loop.\n        logging.error('Failed to decode output\\n%s\\n%r', e, output)\n    if outputs_ref:\n      outputs_ref = task_request.FilesRef(**outputs_ref)\n\n    try:\n      state = task_scheduler.bot_update_task(\n          run_result_key=run_result_key,\n          bot_id=bot_id,\n          output=output,\n          output_chunk_start=output_chunk_start,\n          exit_code=exit_code,\n          duration=duration,\n          hard_timeout=hard_timeout,\n          io_timeout=io_timeout,\n          cost_usd=cost_usd,\n          outputs_ref=outputs_ref,\n          performance_stats=performance_stats)\n      if not state:\n        logging.info('Failed to update, please retry')\n        self.abort_with_error(500, error='Failed to update, please retry')\n\n      if state in (task_result.State.COMPLETED, task_result.State.TIMED_OUT):\n        action = 'task_completed'\n      else:\n        assert state == task_result.State.RUNNING, state\n        action = 'task_update'\n      bot_management.bot_event(\n          event_type=action, bot_id=bot_id,\n          external_ip=self.request.remote_addr, dimensions=None, state=None,\n          version=None, quarantined=None, task_id=task_id, task_name=None)\n    except ValueError as e:\n      ereporter2.log_request(\n          request=self.request,\n          source='server',\n          category='task_failure',\n          message='Failed to update task: %s' % e)\n      self.abort_with_error(400, error=str(e))\n    except webob.exc.HTTPException:\n      raise\n    except Exception as e:\n      logging.exception('Internal error: %s', e)\n      self.abort_with_error(500, error=str(e))\n\n    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot\n    # reboots itself to abort the task abruptly. It is useful when a task hangs\n    # and the timeout was set too long or the task was superseded by a newer\n    # task with more recent executable (e.g. a new Try Server job on a newer\n    # patchset on Rietveld).\n    self.send_response({'ok': True})\n\n\nclass BotTaskErrorHandler(auth.ApiHandler):\n  \"\"\"It is a specialized version of ereporter2's /ereporter2/api/v1/on_error\n  that also attaches a task id to it.\n\n  This formally kills the task, marking it as an internal failure. This can be\n  used by bot_main.py to kill the task when task_runner misbehaved.\n  \"\"\"\n\n  EXPECTED_KEYS = {u'id', u'message', u'task_id'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  @auth.require(acl.is_bot)\n  def post(self, task_id=None):\n    request = self.parse_body()\n    bot_id = request.get('id')\n    task_id = request.get('task_id', '')\n    message = request.get('message', 'unknown')\n\n    bot_management.bot_event(\n        event_type='task_error', bot_id=bot_id,\n        external_ip=self.request.remote_addr, dimensions=None, state=None,\n        version=None, quarantined=None, task_id=task_id, task_name=None,\n        message=message)\n    line = (\n        'Bot: https://%s/restricted/bot/%s\\n'\n        'Task failed: https://%s/user/task/%s\\n'\n        '%s') % (\n        app_identity.get_default_version_hostname(), bot_id,\n        app_identity.get_default_version_hostname(), task_id,\n        message)\n    ereporter2.log_request(self.request, source='bot', message=line)\n\n    msg = log_unexpected_keys(\n        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')\n    if msg:\n      self.abort_with_error(400, error=msg)\n\n    msg = task_scheduler.bot_kill_task(\n        task_pack.unpack_run_result_key(task_id), bot_id)\n    if msg:\n      logging.error(msg)\n      self.abort_with_error(400, error=msg)\n    self.send_response({})\n\n\nclass ServerPingHandler(webapp2.RequestHandler):\n  \"\"\"Handler to ping when checking if the server is up.\n\n  This handler should be extremely lightweight. It shouldn't do any\n  computations, it should just state that the server is up. It's open to\n  everyone for simplicity and performance.\n  \"\"\"\n\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.out.write('Server up')\n\n\ndef get_routes():\n  routes = [\n      ('/bootstrap', BootstrapHandler),\n      ('/bot_code', BotCodeHandler),\n      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),\n      ('/swarming/api/v1/bot/event', BotEventHandler),\n      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),\n      ('/swarming/api/v1/bot/poll', BotPollHandler),\n      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),\n      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),\n      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',\n          BotTaskUpdateHandler),\n      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),\n      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',\n          BotTaskErrorHandler),\n  ]\n  return [webapp2.Route(*i) for i in routes]\n/n/n/nappengine/swarming/server/bot_archive.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Generates the swarming_bot.zip archive for the bot.\n\nUnlike the other source files, this file can be run from ../tools/bot_archive.py\nstand-alone to generate a swarming_bot.zip for local testing so it doesn't\nimport anything from the AppEngine SDK.\n\nThe hash of the content of the files in the archive is used to define the\ncurrent version of the swarming bot code.\n\"\"\"\n\nimport hashlib\nimport json\nimport logging\nimport os\nimport StringIO\nimport zipfile\n\n\n# List of files needed by the swarming bot.\n# TODO(maruel): Make the list automatically generated?\nFILES = (\n    '__main__.py',\n    'api/__init__.py',\n    'api/bot.py',\n    'api/parallel.py',\n    'api/os_utilities.py',\n    'api/platforms/__init__.py',\n    'api/platforms/android.py',\n    'api/platforms/common.py',\n    'api/platforms/gce.py',\n    'api/platforms/linux.py',\n    'api/platforms/osx.py',\n    'api/platforms/posix.py',\n    'api/platforms/win.py',\n    'bot_code/__init__.py',\n    'bot_code/bot_main.py',\n    'bot_code/common.py',\n    'bot_code/singleton.py',\n    'bot_code/task_runner.py',\n    'client/auth.py',\n    'client/isolated_format.py',\n    'client/isolateserver.py',\n    'client/run_isolated.py',\n    'config/__init__.py',\n    'third_party/__init__.py',\n    'third_party/colorama/__init__.py',\n    'third_party/colorama/ansi.py',\n    'third_party/colorama/ansitowin32.py',\n    'third_party/colorama/initialise.py',\n    'third_party/colorama/win32.py',\n    'third_party/colorama/winterm.py',\n    'third_party/depot_tools/__init__.py',\n    'third_party/depot_tools/fix_encoding.py',\n    'third_party/depot_tools/subcommand.py',\n    'third_party/httplib2/__init__.py',\n    'third_party/httplib2/cacerts.txt',\n    'third_party/httplib2/iri2uri.py',\n    'third_party/httplib2/socks.py',\n    'third_party/oauth2client/__init__.py',\n    'third_party/oauth2client/_helpers.py',\n    'third_party/oauth2client/_openssl_crypt.py',\n    'third_party/oauth2client/_pycrypto_crypt.py',\n    'third_party/oauth2client/client.py',\n    'third_party/oauth2client/clientsecrets.py',\n    'third_party/oauth2client/crypt.py',\n    'third_party/oauth2client/file.py',\n    'third_party/oauth2client/gce.py',\n    'third_party/oauth2client/keyring_storage.py',\n    'third_party/oauth2client/locked_file.py',\n    'third_party/oauth2client/multistore_file.py',\n    'third_party/oauth2client/service_account.py',\n    'third_party/oauth2client/tools.py',\n    'third_party/oauth2client/util.py',\n    'third_party/oauth2client/xsrfutil.py',\n    'third_party/pyasn1/pyasn1/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/ber/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/ber/decoder.py',\n    'third_party/pyasn1/pyasn1/codec/ber/encoder.py',\n    'third_party/pyasn1/pyasn1/codec/ber/eoo.py',\n    'third_party/pyasn1/pyasn1/codec/cer/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/cer/decoder.py',\n    'third_party/pyasn1/pyasn1/codec/cer/encoder.py',\n    'third_party/pyasn1/pyasn1/codec/der/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/der/decoder.py',\n    'third_party/pyasn1/pyasn1/codec/der/encoder.py',\n    'third_party/pyasn1/pyasn1/compat/__init__.py',\n    'third_party/pyasn1/pyasn1/compat/binary.py',\n    'third_party/pyasn1/pyasn1/compat/octets.py',\n    'third_party/pyasn1/pyasn1/debug.py',\n    'third_party/pyasn1/pyasn1/error.py',\n    'third_party/pyasn1/pyasn1/type/__init__.py',\n    'third_party/pyasn1/pyasn1/type/base.py',\n    'third_party/pyasn1/pyasn1/type/char.py',\n    'third_party/pyasn1/pyasn1/type/constraint.py',\n    'third_party/pyasn1/pyasn1/type/error.py',\n    'third_party/pyasn1/pyasn1/type/namedtype.py',\n    'third_party/pyasn1/pyasn1/type/namedval.py',\n    'third_party/pyasn1/pyasn1/type/tag.py',\n    'third_party/pyasn1/pyasn1/type/tagmap.py',\n    'third_party/pyasn1/pyasn1/type/univ.py',\n    'third_party/pyasn1/pyasn1/type/useful.py',\n    'third_party/requests/__init__.py',\n    'third_party/requests/adapters.py',\n    'third_party/requests/api.py',\n    'third_party/requests/auth.py',\n    'third_party/requests/certs.py',\n    'third_party/requests/compat.py',\n    'third_party/requests/cookies.py',\n    'third_party/requests/exceptions.py',\n    'third_party/requests/hooks.py',\n    'third_party/requests/models.py',\n    'third_party/requests/packages/__init__.py',\n    'third_party/requests/packages/urllib3/__init__.py',\n    'third_party/requests/packages/urllib3/_collections.py',\n    'third_party/requests/packages/urllib3/connection.py',\n    'third_party/requests/packages/urllib3/connectionpool.py',\n    'third_party/requests/packages/urllib3/contrib/__init__.py',\n    'third_party/requests/packages/urllib3/contrib/ntlmpool.py',\n    'third_party/requests/packages/urllib3/contrib/pyopenssl.py',\n    'third_party/requests/packages/urllib3/exceptions.py',\n    'third_party/requests/packages/urllib3/fields.py',\n    'third_party/requests/packages/urllib3/filepost.py',\n    'third_party/requests/packages/urllib3/packages/__init__.py',\n    'third_party/requests/packages/urllib3/packages/ordered_dict.py',\n    'third_party/requests/packages/urllib3/packages/six.py',\n    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'\n        '__init__.py',\n    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'\n        '_implementation.py',\n    'third_party/requests/packages/urllib3/poolmanager.py',\n    'third_party/requests/packages/urllib3/request.py',\n    'third_party/requests/packages/urllib3/response.py',\n    'third_party/requests/packages/urllib3/util/__init__.py',\n    'third_party/requests/packages/urllib3/util/connection.py',\n    'third_party/requests/packages/urllib3/util/request.py',\n    'third_party/requests/packages/urllib3/util/response.py',\n    'third_party/requests/packages/urllib3/util/retry.py',\n    'third_party/requests/packages/urllib3/util/ssl_.py',\n    'third_party/requests/packages/urllib3/util/timeout.py',\n    'third_party/requests/packages/urllib3/util/url.py',\n    'third_party/requests/sessions.py',\n    'third_party/requests/status_codes.py',\n    'third_party/requests/structures.py',\n    'third_party/requests/utils.py',\n    'third_party/rsa/rsa/__init__.py',\n    'third_party/rsa/rsa/_compat.py',\n    'third_party/rsa/rsa/_version133.py',\n    'third_party/rsa/rsa/_version200.py',\n    'third_party/rsa/rsa/asn1.py',\n    'third_party/rsa/rsa/bigfile.py',\n    'third_party/rsa/rsa/cli.py',\n    'third_party/rsa/rsa/common.py',\n    'third_party/rsa/rsa/core.py',\n    'third_party/rsa/rsa/key.py',\n    'third_party/rsa/rsa/parallel.py',\n    'third_party/rsa/rsa/pem.py',\n    'third_party/rsa/rsa/pkcs1.py',\n    'third_party/rsa/rsa/prime.py',\n    'third_party/rsa/rsa/randnum.py',\n    'third_party/rsa/rsa/transform.py',\n    'third_party/rsa/rsa/util.py',\n    'third_party/rsa/rsa/varblock.py',\n    'third_party/six/__init__.py',\n    'utils/__init__.py',\n    'utils/cacert.pem',\n    'utils/file_path.py',\n    'utils/fs.py',\n    'utils/large.py',\n    'utils/logging_utils.py',\n    'utils/lru.py',\n    'utils/net.py',\n    'utils/oauth.py',\n    'utils/on_error.py',\n    'utils/subprocess42.py',\n    'utils/threading_utils.py',\n    'utils/tools.py',\n    'utils/zip_package.py',\n    'adb/__init__.py',\n    'adb/adb_commands.py',\n    'adb/adb_protocol.py',\n    'adb/common.py',\n    'adb/contrib/__init__.py',\n    'adb/contrib/adb_commands_safe.py',\n    'adb/contrib/high.py',\n    'adb/contrib/parallel.py',\n    'adb/fastboot.py',\n    'adb/filesync_protocol.py',\n    'adb/sign_pythonrsa.py',\n    'adb/usb_exceptions.py',\n    'python_libusb1/__init__.py',\n    'python_libusb1/libusb1.py',\n    'python_libusb1/usb1.py',\n)\n\n\ndef is_windows():\n  \"\"\"Returns True if this code is running under Windows.\"\"\"\n  return os.__file__[0] != '/'\n\n\ndef resolve_symlink(path):\n  \"\"\"Processes path containing symlink on Windows.\n\n  This is needed to make ../swarming_bot/main_test.py pass on Windows because\n  git on Windows renders symlinks as normal files.\n  \"\"\"\n  if not is_windows():\n    # Only does this dance on Windows.\n    return path\n  parts = os.path.normpath(path).split(os.path.sep)\n  for i in xrange(2, len(parts)):\n    partial = os.path.sep.join(parts[:i])\n    if os.path.isfile(partial):\n      with open(partial) as f:\n        link = f.read()\n      assert '\\n' not in link and link, link\n      parts[i-1] = link\n  return os.path.normpath(os.path.sep.join(parts))\n\n\ndef yield_swarming_bot_files(root_dir, host, host_version, additionals):\n  \"\"\"Yields all the files to map as tuple(filename, content).\n\n  config.json is injected with json data about the server.\n\n  This function guarantees that the output is sorted by filename.\n  \"\"\"\n  items = {i: None for i in FILES}\n  items.update(additionals)\n  config = {\n    'server': host.rstrip('/'),\n    'server_version': host_version,\n  }\n  items['config/config.json'] = json.dumps(config)\n  for item, content in sorted(items.iteritems()):\n    if content is not None:\n      yield item, content\n    else:\n      with open(resolve_symlink(os.path.join(root_dir, item)), 'rb') as f:\n        yield item, f.read()\n\n\ndef get_swarming_bot_zip(root_dir, host, host_version, additionals):\n  \"\"\"Returns a zipped file of all the files a bot needs to run.\n\n  Arguments:\n    root_dir: directory swarming_bot.\n    additionals: dict(filepath: content) of additional items to put into the zip\n        file, in addition to FILES and MAPPED. In practice, it's going to be a\n        custom bot_config.py.\n  Returns:\n    Tuple(str being the zipped file's content, bot version (SHA-1) it\n    represents).\n  \"\"\"\n  zip_memory_file = StringIO.StringIO()\n  h = hashlib.sha1()\n  with zipfile.ZipFile(zip_memory_file, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n    for name, content in yield_swarming_bot_files(\n        root_dir, host, host_version, additionals):\n      zip_file.writestr(name, content)\n      h.update(str(len(name)))\n      h.update(name)\n      h.update(str(len(content)))\n      h.update(content)\n\n  data = zip_memory_file.getvalue()\n  bot_version = h.hexdigest()\n  logging.info(\n      'get_swarming_bot_zip(%s) is %d bytes; %s',\n      additionals.keys(), len(data), bot_version)\n  return data, bot_version\n\n\ndef get_swarming_bot_version(root_dir, host, host_version, additionals):\n  \"\"\"Returns the SHA1 hash of the bot code, representing the version.\n\n  Arguments:\n    root_dir: directory swarming_bot.\n    additionals: See get_swarming_bot_zip's doc.\n\n  Returns:\n    The SHA1 hash of the bot code.\n  \"\"\"\n  h = hashlib.sha1()\n  try:\n    # TODO(maruel): Deduplicate from zip_package.genereate_version().\n    for name, content in yield_swarming_bot_files(\n        root_dir, host, host_version, additionals):\n      h.update(str(len(name)))\n      h.update(name)\n      h.update(str(len(content)))\n      h.update(content)\n  except IOError:\n    logging.warning('Missing expected file. Hash will be invalid.')\n  bot_version = h.hexdigest()\n  logging.info(\n      'get_swarming_bot_version(%s) = %s', sorted(additionals), bot_version)\n  return bot_version\n/n/n/nappengine/swarming/swarming_bot/__main__.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Runs either task_runner.py, bot_main.py or bot_config.py.\n\nThe imports are done late so if an ImportError occurs, it is localized to this\ncommand only.\n\"\"\"\n\nimport code\nimport json\nimport logging\nimport os\nimport optparse\nimport shutil\nimport sys\nimport zipfile\n\n# That's from ../../../client/\nfrom third_party.depot_tools import fix_encoding\nfrom utils import logging_utils\nfrom utils import zip_package\n\n# This file can only be run as a zip.\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n\n# libusb1 expects to be directly in sys.path.\nsys.path.insert(0, os.path.join(THIS_FILE, 'python_libusb1'))\n\n# Copied from //client/utils/oauth.py.\nsys.path.insert(0, os.path.join(THIS_FILE, 'third_party'))\nsys.path.insert(0, os.path.join(THIS_FILE, 'third_party', 'pyasn1'))\nsys.path.insert(0, os.path.join(THIS_FILE, 'third_party', 'rsa'))\n\nfrom bot_code import common\n\n\n# TODO(maruel): Use depot_tools/subcommand.py. The goal here is to have all the\n# sub commands packed into the single .zip file as a swiss army knife (think\n# busybox but worse).\n\n\ndef CMDattributes(_args):\n  \"\"\"Prints out the bot's attributes.\"\"\"\n  from bot_code import bot_main\n  json.dump(\n      bot_main.get_attributes(bot_main.get_bot()), sys.stdout, indent=2,\n      sort_keys=True, separators=(',', ': '))\n  print('')\n  return 0\n\n\ndef CMDconfig(_args):\n  \"\"\"Prints the config.json embedded in this zip.\"\"\"\n  logging_utils.prepare_logging(None)\n  from bot_code import bot_main\n  json.dump(bot_main.get_config(), sys.stdout, indent=2, sort_keys=True)\n  print('')\n  return 0\n\n\ndef CMDis_fine(_args):\n  \"\"\"Just reports that the code doesn't throw.\n\n  That ensures that the bot has minimal viability before transfering control to\n  it. For now, it just imports bot_main but later it'll check the config, etc.\n  \"\"\"\n  # pylint: disable=unused-variable\n  from bot_code import bot_main\n  from config import bot_config\n  # We're #goodenough.\n  return 0\n\n\ndef CMDrestart(_args):\n  \"\"\"Utility subcommand that hides the difference between each OS to reboot\n  the host.\"\"\"\n  logging_utils.prepare_logging(None)\n  import os_utilities\n  # This function doesn't return.\n  os_utilities.restart()\n  # Should never reach here.\n  return 1\n\n\ndef CMDrun_isolated(args):\n  \"\"\"Internal command to run an isolated command.\"\"\"\n  sys.path.insert(0, os.path.join(THIS_FILE, 'client'))\n  # run_isolated setups logging by itself.\n  import run_isolated\n  return run_isolated.main(args)\n\n\ndef CMDsetup(_args):\n  \"\"\"Setup the bot to auto-start but doesn't start the bot.\"\"\"\n  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))\n  from bot_code import bot_main\n  bot_main.setup_bot(True)\n  return 0\n\n\ndef CMDserver(_args):\n  \"\"\"Prints the server url. It's like 'config' but easier to parse.\"\"\"\n  logging_utils.prepare_logging(None)\n  from bot_code import bot_main\n  print bot_main.get_config()['server']\n  return 0\n\n\ndef CMDshell(args):\n  \"\"\"Starts a shell with api.* in..\"\"\"\n  logging_utils.prepare_logging(None)\n  logging_utils.set_console_level(logging.DEBUG)\n\n  from bot_code import bot_main\n  from api import os_utilities\n  from api import platforms\n  local_vars = {\n    'bot_main': bot_main,\n    'json': json,\n    'os_utilities': os_utilities,\n    'platforms': platforms,\n  }\n  # Can't use: from api.platforms import *\n  local_vars.update(\n      (k, v) for k, v in platforms.__dict__.iteritems()\n      if not k.startswith('_'))\n\n  if args:\n    for arg in args:\n      exec code.compile_command(arg) in local_vars\n  else:\n    code.interact(\n        'Locals:\\n  ' + '\\n  '.join( sorted(local_vars)), None, local_vars)\n  return 0\n\n\ndef CMDstart_bot(args):\n  \"\"\"Starts the swarming bot.\"\"\"\n  logging_utils.prepare_logging(os.path.join('logs', 'swarming_bot.log'))\n  logging.info(\n      'importing bot_main: %s, %s', THIS_FILE, zip_package.generate_version())\n  from bot_code import bot_main\n  result = bot_main.main(args)\n  logging.info('bot_main exit code: %d', result)\n  return result\n\n\ndef CMDstart_slave(args):\n  \"\"\"Ill named command that actually sets up the bot then start it.\"\"\"\n  # TODO(maruel): Rename function.\n  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))\n\n  parser = optparse.OptionParser()\n  parser.add_option(\n      '--survive', action='store_true',\n      help='Do not reboot the host even if bot_config.setup_bot() asked to')\n  options, args = parser.parse_args(args)\n\n  try:\n    from bot_code import bot_main\n    bot_main.setup_bot(options.survive)\n  except Exception:\n    logging.exception('bot_main.py failed.')\n\n  logging.info('Starting the bot: %s', THIS_FILE)\n  return common.exec_python([THIS_FILE, 'start_bot'])\n\n\ndef CMDtask_runner(args):\n  \"\"\"Internal command to run a swarming task.\"\"\"\n  logging_utils.prepare_logging(os.path.join('logs', 'task_runner.log'))\n  from bot_code import task_runner\n  return task_runner.main(args)\n\n\ndef CMDversion(_args):\n  \"\"\"Prints the version of this file and the hash of the code.\"\"\"\n  logging_utils.prepare_logging(None)\n  print zip_package.generate_version()\n  return 0\n\n\ndef main():\n  if os.getenv('CHROME_REMOTE_DESKTOP_SESSION') == '1':\n    # Disable itself when run under Google Chrome Remote Desktop, as it's\n    # normally started at the console and starting up via Remote Desktop would\n    # cause multiple bots to run concurrently on the host.\n    print >> sys.stderr, (\n        'Inhibiting Swarming bot under Google Chrome Remote Desktop.')\n    return 0\n\n  # Always make the current working directory the directory containing this\n  # file. It simplifies assumptions.\n  os.chdir(os.path.dirname(THIS_FILE))\n  # Always create the logs dir first thing, before printing anything out.\n  if not os.path.isdir('logs'):\n    os.mkdir('logs')\n\n  # This is necessary so os.path.join() works with unicode path. No kidding.\n  # This must be done here as each of the command take wildly different code\n  # path and this must be run in every case, as it causes really unexpected\n  # issues otherwise, especially in module os.path.\n  fix_encoding.fix_encoding()\n\n  if os.path.basename(THIS_FILE) == 'swarming_bot.zip':\n    # Self-replicate itself right away as swarming_bot.1.zip and restart as it.\n    print >> sys.stderr, 'Self replicating pid:%d.' % os.getpid()\n    if os.path.isfile('swarming_bot.1.zip'):\n      os.remove('swarming_bot.1.zip')\n    shutil.copyfile('swarming_bot.zip', 'swarming_bot.1.zip')\n    cmd = ['swarming_bot.1.zip'] + sys.argv[1:]\n    print >> sys.stderr, 'cmd: %s' % cmd\n    return common.exec_python(cmd)\n\n  # sys.argv[0] is the zip file itself.\n  cmd = 'start_slave'\n  args = []\n  if len(sys.argv) > 1:\n    cmd = sys.argv[1]\n    args = sys.argv[2:]\n\n  fn = getattr(sys.modules[__name__], 'CMD%s' % cmd, None)\n  if fn:\n    try:\n      return fn(args)\n    except ImportError:\n      logging.exception('Failed to run %s', cmd)\n      with zipfile.ZipFile(THIS_FILE, 'r') as f:\n        logging.error('Files in %s:\\n%s', THIS_FILE, f.namelist())\n      return 1\n\n  print >> sys.stderr, 'Unknown command %s' % cmd\n  return 1\n\n\nif __name__ == '__main__':\n  sys.exit(main())\n/n/n/nappengine/swarming/swarming_bot/api/bot.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Bot interface used in bot_config.py.\"\"\"\n\nimport logging\nimport os\nimport threading\nimport time\n\nimport os_utilities\nfrom utils import net\nfrom utils import zip_package\n\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n# Method could be a function - pylint: disable=R0201\n\n\nclass Bot(object):\n  def __init__(\n      self, attributes, server, server_version, base_dir, shutdown_hook):\n    # Do not expose attributes  for now, as attributes may be refactored.\n    assert server is None or not server.endswith('/'), server\n    self._attributes = attributes\n    self._base_dir = base_dir\n    self._server = server\n    self._server_version = server_version\n    self._shutdown_hook = shutdown_hook\n    self._timers = []\n    self._timers_dying = False\n    self._timers_lock = threading.Lock()\n\n  @property\n  def base_dir(self):\n    \"\"\"Returns the working directory.\n\n    It is normally the current workind directory, e.g. os.getcwd() but it is\n    preferable to not assume that.\n    \"\"\"\n    return self._base_dir\n\n  @property\n  def dimensions(self):\n    \"\"\"The bot's current dimensions.\n\n    Dimensions are relatively static and not expected to change much. They\n    should change only when it effectively affects the bot's capacity to execute\n    tasks.\n    \"\"\"\n    return self._attributes.get('dimensions', {}).copy()\n\n  @property\n  def id(self):\n    \"\"\"Returns the bot's ID.\"\"\"\n    return self.dimensions.get('id', ['unknown'])[0]\n\n  @property\n  def server(self):\n    \"\"\"URL of the swarming server this bot is connected to.\n\n    It includes the https:// prefix but without trailing /, so it looks like\n    \"https://foo-bar.appspot.com\".\n    \"\"\"\n    return self._server\n\n  @property\n  def server_version(self):\n    \"\"\"Version of the server's implementation.\n\n    The form is nnn-hhhhhhh for pristine version and nnn-hhhhhhh-tainted-uuuu\n    for non-upstreamed code base:\n      nnn: revision pseudo number\n      hhhhhhh: git commit hash\n      uuuu: username\n    \"\"\"\n    return self._server_version\n\n  @property\n  def state(self):\n    return self._attributes['state']\n\n  @property\n  def swarming_bot_zip(self):\n    \"\"\"Absolute path to the swarming_bot.zip file.\n\n    The bot itself is run as swarming_bot.1.zip or swarming_bot.2.zip. Always\n    return swarming_bot.zip since this is the script that must be used when\n    starting up.\n    \"\"\"\n    return os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')\n\n  def post_event(self, event_type, message):\n    \"\"\"Posts an event to the server.\"\"\"\n    data = self._attributes.copy()\n    data['event'] = event_type\n    data['message'] = message\n    net.url_read_json(self.server + '/swarming/api/v1/bot/event', data=data)\n\n  def post_error(self, message):\n    \"\"\"Posts given string as a failure.\n\n    This is used in case of internal code error. It traps exception.\n    \"\"\"\n    logging.error('Error: %s\\n%s', self._attributes, message)\n    try:\n      self.post_event('bot_error', message)\n    except Exception:\n      logging.exception('post_error(%s) failed.', message)\n\n  def restart(self, message):\n    \"\"\"Reboots the machine.\n\n    If the reboot is successful, never returns: the process should just be\n    killed by OS.\n\n    If reboot fails, logs the error to the server and moves the bot to\n    quarantined mode.\n    \"\"\"\n    self.post_event('bot_rebooting', message)\n    self.cancel_all_timers()\n    if self._shutdown_hook:\n      try:\n        self._shutdown_hook(self)\n      except Exception as e:\n        logging.exception('shutdown hook failed: %s', e)\n    # os_utilities.restart should never return, unless restart is not happening.\n    # If restart is taking longer than N minutes, it probably not going to\n    # finish at all. Report this to the server.\n    try:\n      os_utilities.restart(message, timeout=15*60)\n    except LookupError:\n      # This is a special case where OSX is deeply hosed. In that case the disk\n      # is likely in read-only mode and there isn't much that can be done. This\n      # exception is deep inside pickle.py. So notify the server then hang in\n      # there.\n      self.post_error('This host partition is bad; please fix the host')\n      while True:\n        time.sleep(1)\n    self.post_error('Bot is stuck restarting for: %s' % message)\n\n  def call_later(self, delay_sec, callback):\n    \"\"\"Schedules a function to be called later (if bot is still running).\n\n    All calls are executed in a separate internal thread, be careful with what\n    you call from there (Bot object is generally not thread safe).\n\n    Multiple callbacks can be executed concurrently. It is safe to call\n    'call_later' from the callback.\n    \"\"\"\n    timer = None\n\n    def call_wrapper():\n      with self._timers_lock:\n        # Canceled already?\n        if timer not in self._timers:\n          return\n        self._timers.remove(timer)\n      try:\n        callback()\n      except Exception:\n        logging.exception('Timer callback failed')\n\n    with self._timers_lock:\n      if not self._timers_dying:\n        timer = threading.Timer(delay_sec, call_wrapper)\n        self._timers.append(timer)\n        timer.daemon = True\n        timer.start()\n\n  def cancel_all_timers(self):\n    \"\"\"Cancels all pending 'call_later' calls and forbids adding new ones.\"\"\"\n    timers = None\n    with self._timers_lock:\n      self._timers_dying = True\n      for t in self._timers:\n        t.cancel()\n      timers, self._timers = self._timers, []\n    for t in timers:\n      t.join(timeout=5)\n      if t.isAlive():\n        logging.error('Timer thread did not terminate fast enough: %s', t)\n\n  def update_dimensions(self, new_dimensions):\n    \"\"\"Called internally to update Bot.dimensions.\"\"\"\n    self._attributes['dimensions'] = new_dimensions\n\n  def update_state(self, new_state):\n    \"\"\"Called internally to update Bot.state.\"\"\"\n    self._attributes['state'] = new_state\n/n/n/nappengine/swarming/swarming_bot/api/bot_test.py/n/n#!/usr/bin/env python\n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport os\nimport sys\nimport unittest\nimport threading\n\nTHIS_FILE = os.path.abspath(__file__)\n\nimport test_env_api\ntest_env_api.setup_test_env()\n\nimport bot\n\n\nclass TestBot(unittest.TestCase):\n  def test_bot(self):\n    obj = bot.Bot(\n        {'dimensions': {'foo': 'bar'}},\n        'https://localhost:1',\n        '1234-1a2b3c4-tainted-joe',\n        'base_dir',\n        None)\n    self.assertEqual({'foo': 'bar'}, obj.dimensions)\n    self.assertEqual(\n        os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip'),\n        obj.swarming_bot_zip)\n    self.assertEqual('1234-1a2b3c4-tainted-joe', obj.server_version)\n    self.assertEqual('base_dir', obj.base_dir)\n\n  def test_bot_call_later(self):\n    obj = bot.Bot({}, 'https://localhost:1', '1234-1a2b3c4-tainted-joe',\n                  'base_dir', None)\n    ev = threading.Event()\n    obj.call_later(0.001, ev.set)\n    self.assertTrue(ev.wait(1))\n\n  def test_bot_call_later_cancel(self):\n    obj = bot.Bot({}, 'https://localhost:1', '1234-1a2b3c4-tainted-joe',\n                  'base_dir', None)\n    ev = threading.Event()\n    obj.call_later(0.1, ev.set)\n    obj.cancel_all_timers()\n    self.assertFalse(ev.wait(0.3))\n\n\nif __name__ == '__main__':\n  if '-v' in sys.argv:\n    unittest.TestCase.maxDiff = None\n  unittest.main()\n/n/n/nappengine/swarming/swarming_bot/bot_code/bot_main.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Swarming bot main process.\n\nThis is the program that communicates with the Swarming server, ensures the code\nis always up to date and executes a child process to run tasks and upload\nresults back.\n\nIt manages self-update and rebooting the host in case of problems.\n\nSet the environment variable SWARMING_LOAD_TEST=1 to disable the use of\nserver-provided bot_config.py. This permits safe load testing.\n\"\"\"\n\nimport contextlib\nimport json\nimport logging\nimport optparse\nimport os\nimport shutil\nimport signal\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport zipfile\n\nimport common\nimport singleton\nfrom api import bot\nfrom api import os_utilities\nfrom utils import file_path\nfrom utils import net\nfrom utils import on_error\nfrom utils import subprocess42\nfrom utils import zip_package\n\n\n# Used to opportunistically set the error handler to notify the server when the\n# process exits due to an exception.\n_ERROR_HANDLER_WAS_REGISTERED = False\n\n\n# Set to the zip's name containing this file. This is set to the absolute path\n# to swarming_bot.zip when run as part of swarming_bot.zip. This value is\n# overriden in unit tests.\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n\n# The singleton, initially unset.\nSINGLETON = singleton.Singleton(os.path.dirname(THIS_FILE))\n\n\n### bot_config handler part.\n\n\ndef _in_load_test_mode():\n  \"\"\"Returns True if the default values should be used instead of the server\n  provided bot_config.py.\n\n  This also disables server telling the bot to restart.\n  \"\"\"\n  return os.environ.get('SWARMING_LOAD_TEST') == '1'\n\n\ndef get_dimensions(botobj):\n  \"\"\"Returns bot_config.py's get_attributes() dict.\"\"\"\n  # Importing this administrator provided script could have side-effects on\n  # startup. That is why it is imported late.\n  try:\n    if _in_load_test_mode():\n      # Returns a minimal set of dimensions so it doesn't run tasks by error.\n      dimensions = os_utilities.get_dimensions()\n      return {\n        'id': dimensions['id'],\n        'load_test': ['1'],\n      }\n\n    from config import bot_config\n    out = bot_config.get_dimensions(botobj)\n    if not isinstance(out, dict):\n      raise ValueError('Unexpected type %s' % out.__class__)\n    return out\n  except Exception as e:\n    logging.exception('get_dimensions() failed')\n    try:\n      out = os_utilities.get_dimensions()\n      out['error'] = [str(e)]\n      out['quarantined'] = ['1']\n      return out\n    except Exception as e:\n      try:\n        botid = os_utilities.get_hostname_short()\n      except Exception as e2:\n        botid = 'error_%s' % str(e2)\n      return {\n          'id': [botid],\n          'error': ['%s\\n%s' % (e, traceback.format_exc()[-2048:])],\n          'quarantined': ['1'],\n        }\n\n\ndef get_state(botobj, sleep_streak):\n  \"\"\"Returns dict with a state of the bot reported to the server with each poll.\n  \"\"\"\n  try:\n    if _in_load_test_mode():\n      state = os_utilities.get_state()\n      state['dimensions'] = os_utilities.get_dimensions()\n    else:\n      from config import bot_config\n      state = bot_config.get_state(botobj)\n      if not isinstance(state, dict):\n        state = {'error': state}\n  except Exception as e:\n    logging.exception('get_state() failed')\n    state = {\n      'error': '%s\\n%s' % (e, traceback.format_exc()[-2048:]),\n      'quarantined': True,\n    }\n\n  state['sleep_streak'] = sleep_streak\n  return state\n\n\ndef call_hook(botobj, name, *args):\n  \"\"\"Calls a hook function in bot_config.py.\"\"\"\n  try:\n    if _in_load_test_mode():\n      return\n\n    logging.info('call_hook(%s)', name)\n    from config import bot_config\n    hook = getattr(bot_config, name, None)\n    if hook:\n      return hook(botobj, *args)\n  except Exception as e:\n    msg = '%s\\n%s' % (e, traceback.format_exc()[-2048:])\n    botobj.post_error('Failed to call hook %s(): %s' % (name, msg))\n\n\ndef setup_bot(skip_reboot):\n  \"\"\"Calls bot_config.setup_bot() to have the bot self-configure itself.\n\n  Reboot the host if bot_config.setup_bot() returns False, unless skip_reboot is\n  also true.\n  \"\"\"\n  if _in_load_test_mode():\n    return\n\n  botobj = get_bot()\n  try:\n    from config import bot_config\n  except Exception as e:\n    msg = '%s\\n%s' % (e, traceback.format_exc()[-2048:])\n    botobj.post_error('bot_config.py is bad: %s' % msg)\n    return\n\n  try:\n    should_continue = bot_config.setup_bot(botobj)\n  except Exception as e:\n    msg = '%s\\n%s' % (e, traceback.format_exc()[-2048:])\n    botobj.post_error('bot_config.setup_bot() threw: %s' % msg)\n    return\n\n  if not should_continue and not skip_reboot:\n    botobj.restart('Starting new swarming bot: %s' % THIS_FILE)\n\n\n### end of bot_config handler part.\n\n\ndef get_min_free_space():\n  \"\"\"Returns free disk space needed.\n\n  Add a \"250 MiB slack space\" for logs, temporary files and whatever other leak.\n  \"\"\"\n  return int((os_utilities.get_min_free_space(THIS_FILE) + 250.) * 1024 * 1024)\n\n\ndef generate_version():\n  \"\"\"Returns the bot's code version.\"\"\"\n  try:\n    return zip_package.generate_version()\n  except Exception as e:\n    return 'Error: %s' % e\n\n\ndef get_attributes(botobj):\n  \"\"\"Returns the attributes sent to the server.\n\n  Each called function catches all exceptions so the bot doesn't die on startup,\n  which is annoying to recover. In that case, we set a special property to catch\n  these and help the admin fix the swarming_bot code more quickly.\n\n  Arguments:\n  - botobj: bot.Bot instance or None\n  \"\"\"\n  return {\n    'dimensions': get_dimensions(botobj),\n    'state': get_state(botobj, 0),\n    'version': generate_version(),\n  }\n\n\ndef post_error_task(botobj, error, task_id):\n  \"\"\"Posts given error as failure cause for the task.\n\n  This is used in case of internal code error, and this causes the task to\n  become BOT_DIED.\n\n  Arguments:\n    botobj: A bot.Bot instance.\n    error: String representing the problem.\n    task_id: Task that had an internal error. When the Swarming server sends\n        commands to a bot, even though they could be completely wrong, the\n        server assumes the job as running. Thus this function acts as the\n        exception handler for incoming commands from the Swarming server. If for\n        any reason the local test runner script can not be run successfully,\n        this function is invoked.\n  \"\"\"\n  logging.error('Error: %s', error)\n  data = {\n    'id': botobj.id,\n    'message': error,\n    'task_id': task_id,\n  }\n  return net.url_read_json(\n      botobj.server + '/swarming/api/v1/bot/task_error/%s' % task_id, data=data)\n\n\ndef on_shutdown_hook(b):\n  \"\"\"Called when the bot is restarting.\"\"\"\n  call_hook(b, 'on_bot_shutdown')\n  # Aggressively set itself up so we ensure the auto-reboot configuration is\n  # fine before restarting the host. This is important as some tasks delete the\n  # autorestart script (!)\n  setup_bot(True)\n\n\ndef get_bot():\n  \"\"\"Returns a valid Bot instance.\n\n  Should only be called once in the process lifetime.\n  \"\"\"\n  # This variable is used to bootstrap the initial bot.Bot object, which then is\n  # used to get the dimensions and state.\n  attributes = {\n    'dimensions': {u'id': ['none']},\n    'state': {},\n    'version': generate_version(),\n  }\n  config = get_config()\n  assert not config['server'].endswith('/'), config\n\n  # Create a temporary object to call the hooks.\n  botobj = bot.Bot(\n      attributes,\n      config['server'],\n      config['server_version'],\n      os.path.dirname(THIS_FILE),\n      on_shutdown_hook)\n  return bot.Bot(\n      get_attributes(botobj),\n      config['server'],\n      config['server_version'],\n      os.path.dirname(THIS_FILE),\n      on_shutdown_hook)\n\n\ndef clean_isolated_cache(botobj):\n  \"\"\"Asks run_isolated to clean its cache.\n\n  This may take a while but it ensures that in the case of a run_isolated run\n  failed and it temporarily used more space than min_free_disk, it can cleans up\n  the mess properly.\n\n  It will remove unexpected files, remove corrupted files, trim the cache size\n  based on the policies and update state.json.\n  \"\"\"\n  bot_dir = botobj.base_dir\n  cmd = [\n    sys.executable, THIS_FILE, 'run_isolated',\n    '--clean',\n    '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),\n    '--cache', os.path.join(bot_dir, 'cache'),\n    '--min-free-space', str(get_min_free_space()),\n  ]\n  logging.info('Running: %s', cmd)\n  try:\n    # Intentionally do not use a timeout, it can take a while to hash 50gb but\n    # better be safe than sorry.\n    proc = subprocess42.Popen(\n        cmd,\n        stdin=subprocess42.PIPE,\n        stdout=subprocess42.PIPE, stderr=subprocess42.STDOUT,\n        cwd=bot_dir,\n        detached=True,\n        close_fds=sys.platform != 'win32')\n    output, _ = proc.communicate(None)\n    logging.info('Result:\\n%s', output)\n    if proc.returncode:\n      botobj.post_error(\n          'swarming_bot.zip failure during run_isolated --clean:\\n%s' % output)\n  except OSError:\n    botobj.post_error(\n        'swarming_bot.zip internal failure during run_isolated --clean')\n\n\ndef run_bot(arg_error):\n  \"\"\"Runs the bot until it reboots or self-update or a signal is received.\n\n  When a signal is received, simply exit.\n  \"\"\"\n  quit_bit = threading.Event()\n  def handler(sig, _):\n    logging.info('Got signal %s', sig)\n    quit_bit.set()\n\n  # TODO(maruel): Set quit_bit when stdin is closed on Windows.\n\n  with subprocess42.set_signal_handler(subprocess42.STOP_SIGNALS, handler):\n    config = get_config()\n    try:\n      # First thing is to get an arbitrary url. This also ensures the network is\n      # up and running, which is necessary before trying to get the FQDN below.\n      resp = net.url_read(config['server'] + '/swarming/api/v1/bot/server_ping')\n      if resp is None:\n        logging.error('No response from server_ping')\n    except Exception as e:\n      # url_read() already traps pretty much every exceptions. This except\n      # clause is kept there \"just in case\".\n      logging.exception('server_ping threw')\n\n    if quit_bit.is_set():\n      logging.info('Early quit 1')\n      return 0\n\n    # If this fails, there's hardly anything that can be done, the bot can't\n    # even get to the point to be able to self-update.\n    botobj = get_bot()\n    resp = net.url_read_json(\n        botobj.server + '/swarming/api/v1/bot/handshake',\n        data=botobj._attributes)\n    if not resp:\n      logging.error('Failed to contact for handshake')\n    else:\n      logging.info('Connected to %s', resp.get('server_version'))\n      if resp.get('bot_version') != botobj._attributes['version']:\n        logging.warning(\n            'Found out we\\'ll need to update: server said %s; we\\'re %s',\n            resp.get('bot_version'), botobj._attributes['version'])\n\n    if arg_error:\n      botobj.post_error('Bootstrapping error: %s' % arg_error)\n\n    if quit_bit.is_set():\n      logging.info('Early quit 2')\n      return 0\n\n    clean_isolated_cache(botobj)\n\n    call_hook(botobj, 'on_bot_startup')\n\n    if quit_bit.is_set():\n      logging.info('Early quit 3')\n      return 0\n\n    # This environment variable is accessible to the tasks executed by this bot.\n    os.environ['SWARMING_BOT_ID'] = botobj.id.encode('utf-8')\n\n    # Remove the 'work' directory if present, as not removing it may cause the\n    # bot to stay quarantined and not be able to get out of this state.\n    work_dir = os.path.join(botobj.base_dir, 'work')\n    try:\n      if os.path.isdir(work_dir):\n        file_path.rmtree(work_dir)\n    except Exception as e:\n      botobj.post_error('Failed to remove work: %s' % e)\n\n    consecutive_sleeps = 0\n    while not quit_bit.is_set():\n      try:\n        botobj.update_dimensions(get_dimensions(botobj))\n        botobj.update_state(get_state(botobj, consecutive_sleeps))\n        did_something = poll_server(botobj, quit_bit)\n        if did_something:\n          consecutive_sleeps = 0\n        else:\n          consecutive_sleeps += 1\n      except Exception as e:\n        logging.exception('poll_server failed')\n        msg = '%s\\n%s' % (e, traceback.format_exc()[-2048:])\n        botobj.post_error(msg)\n        consecutive_sleeps = 0\n    logging.info('Quitting')\n\n  # Tell the server we are going away.\n  botobj.post_event('bot_shutdown', 'Signal was received')\n  botobj.cancel_all_timers()\n  return 0\n\n\ndef poll_server(botobj, quit_bit):\n  \"\"\"Polls the server to run one loop.\n\n  Returns True if executed some action, False if server asked the bot to sleep.\n  \"\"\"\n  # Access to a protected member _XXX of a client class - pylint: disable=W0212\n  start = time.time()\n  resp = net.url_read_json(\n     botobj.server + '/swarming/api/v1/bot/poll', data=botobj._attributes)\n  if not resp:\n    return False\n  logging.debug('Server response:\\n%s', resp)\n\n  cmd = resp['cmd']\n  if cmd == 'sleep':\n    quit_bit.wait(resp['duration'])\n    return False\n\n  if cmd == 'terminate':\n    quit_bit.set()\n    # This is similar to post_update() in task_runner.py.\n    params = {\n      'cost_usd': 0,\n      'duration': 0,\n      'exit_code': 0,\n      'hard_timeout': False,\n      'id': botobj.id,\n      'io_timeout': False,\n      'output': '',\n      'output_chunk_start': 0,\n      'task_id': resp['task_id'],\n    }\n    net.url_read_json(\n        botobj.server + '/swarming/api/v1/bot/task_update/%s' % resp['task_id'],\n        data=params)\n    return False\n\n  if cmd == 'run':\n    if run_manifest(botobj, resp['manifest'], start):\n      # Completed a task successfully so update swarming_bot.zip if necessary.\n      update_lkgbc(botobj)\n    # TODO(maruel): Handle the case where quit_bit.is_set() happens here. This\n    # is concerning as this means a signal (often SIGTERM) was received while\n    # running the task. Make sure the host is properly restarting.\n  elif cmd == 'update':\n    update_bot(botobj, resp['version'])\n  elif cmd == 'restart':\n    if _in_load_test_mode():\n      logging.warning('Would have restarted: %s' % resp['message'])\n    else:\n      botobj.restart(resp['message'])\n  else:\n    raise ValueError('Unexpected command: %s\\n%s' % (cmd, resp))\n\n  return True\n\n\ndef run_manifest(botobj, manifest, start):\n  \"\"\"Defers to task_runner.py.\n\n  Return True if the task succeeded.\n  \"\"\"\n  # Ensure the manifest is valid. This can throw a json decoding error. Also\n  # raise if it is empty.\n  if not manifest:\n    raise ValueError('Empty manifest')\n\n  # Necessary to signal an internal_failure. This occurs when task_runner fails\n  # to execute the command. It is important to note that this data is extracted\n  # before any I/O is done, like writting the manifest to disk.\n  task_id = manifest['task_id']\n  hard_timeout = manifest['hard_timeout'] or None\n  # Default the grace period to 30s here, this doesn't affect the grace period\n  # for the actual task.\n  grace_period = manifest['grace_period'] or 30\n  if manifest['hard_timeout']:\n    # One for the child process, one for run_isolated, one for task_runner.\n    hard_timeout += 3 * manifest['grace_period']\n    # For isolated task, download time is not counted for hard timeout so add\n    # more time.\n    if not manifest['command']:\n      hard_timeout += manifest['io_timeout'] or 600\n\n  url = manifest.get('host', botobj.server)\n  task_dimensions = manifest['dimensions']\n  task_result = {}\n\n  failure = False\n  internal_failure = False\n  msg = None\n  work_dir = os.path.join(botobj.base_dir, 'work')\n  try:\n    try:\n      if os.path.isdir(work_dir):\n        file_path.rmtree(work_dir)\n    except OSError:\n      # If a previous task created an undeleteable file/directory inside 'work',\n      # make sure that following tasks are not affected. This is done by working\n      # around the undeleteable directory by creating a temporary directory\n      # instead. This is not normal behavior. The bot will report a failure on\n      # start.\n      work_dir = tempfile.mkdtemp(dir=botobj.base_dir, prefix='work')\n    else:\n      os.makedirs(work_dir)\n\n    env = os.environ.copy()\n    # Windows in particular does not tolerate unicode strings in environment\n    # variables.\n    env['SWARMING_TASK_ID'] = task_id.encode('ascii')\n\n    task_in_file = os.path.join(work_dir, 'task_runner_in.json')\n    with open(task_in_file, 'wb') as f:\n      f.write(json.dumps(manifest))\n    call_hook(botobj, 'on_before_task')\n    task_result_file = os.path.join(work_dir, 'task_runner_out.json')\n    if os.path.exists(task_result_file):\n      os.remove(task_result_file)\n    command = [\n      sys.executable, THIS_FILE, 'task_runner',\n      '--swarming-server', url,\n      '--in-file', task_in_file,\n      '--out-file', task_result_file,\n      '--cost-usd-hour', str(botobj.state.get('cost_usd_hour') or 0.),\n      # Include the time taken to poll the task in the cost.\n      '--start', str(start),\n      '--min-free-space', str(get_min_free_space()),\n    ]\n    logging.debug('Running command: %s', command)\n    # Put the output file into the current working directory, which should be\n    # the one containing swarming_bot.zip.\n    log_path = os.path.join(botobj.base_dir, 'logs', 'task_runner_stdout.log')\n    os_utilities.roll_log(log_path)\n    os_utilities.trim_rolled_log(log_path)\n    with open(log_path, 'a+b') as f:\n      proc = subprocess42.Popen(\n          command,\n          detached=True,\n          cwd=botobj.base_dir,\n          env=env,\n          stdin=subprocess42.PIPE,\n          stdout=f,\n          stderr=subprocess42.STDOUT,\n          close_fds=sys.platform != 'win32')\n      try:\n        proc.wait(hard_timeout)\n      except subprocess42.TimeoutExpired:\n        # That's the last ditch effort; as task_runner should have completed a\n        # while ago and had enforced the timeout itself (or run_isolated for\n        # hard_timeout for isolated task).\n        logging.error('Sending SIGTERM to task_runner')\n        proc.terminate()\n        internal_failure = True\n        msg = 'task_runner hung'\n        try:\n          proc.wait(grace_period)\n        except subprocess42.TimeoutExpired:\n          logging.error('Sending SIGKILL to task_runner')\n          proc.kill()\n        proc.wait()\n        return False\n\n    logging.info('task_runner exit: %d', proc.returncode)\n    if os.path.exists(task_result_file):\n      with open(task_result_file, 'rb') as fd:\n        task_result = json.load(fd)\n\n    if proc.returncode:\n      msg = 'Execution failed: internal error (%d).' % proc.returncode\n      internal_failure = True\n    elif not task_result:\n      logging.warning('task_runner failed to write metadata')\n      msg = 'Execution failed: internal error (no metadata).'\n      internal_failure = True\n    elif task_result[u'must_signal_internal_failure']:\n      msg = (\n        'Execution failed: %s' % task_result[u'must_signal_internal_failure'])\n      internal_failure = True\n\n    failure = bool(task_result.get('exit_code')) if task_result else False\n    return not internal_failure and not failure\n  except Exception as e:\n    # Failures include IOError when writing if the disk is full, OSError if\n    # swarming_bot.zip doesn't exist anymore, etc.\n    logging.exception('run_manifest failed')\n    msg = 'Internal exception occured: %s\\n%s' % (\n        e, traceback.format_exc()[-2048:])\n    internal_failure = True\n  finally:\n    if internal_failure:\n      post_error_task(botobj, msg, task_id)\n    call_hook(\n        botobj, 'on_after_task', failure, internal_failure, task_dimensions,\n        task_result)\n    if os.path.isdir(work_dir):\n      try:\n        file_path.rmtree(work_dir)\n      except Exception as e:\n        botobj.post_error(\n            'Failed to delete work directory %s: %s' % (work_dir, e))\n\n\ndef update_bot(botobj, version):\n  \"\"\"Downloads the new version of the bot code and then runs it.\n\n  Use alternating files; first load swarming_bot.1.zip, then swarming_bot.2.zip,\n  never touching swarming_bot.zip which was the originally bootstrapped file.\n\n  LKGBC is handled by update_lkgbc().\n\n  Does not return.\n  \"\"\"\n  # Alternate between .1.zip and .2.zip.\n  new_zip = 'swarming_bot.1.zip'\n  if os.path.basename(THIS_FILE) == new_zip:\n    new_zip = 'swarming_bot.2.zip'\n  new_zip = os.path.join(os.path.dirname(THIS_FILE), new_zip)\n\n  # Download as a new file.\n  url = botobj.server + '/swarming/api/v1/bot/bot_code/%s' % version\n  if not net.url_retrieve(new_zip, url):\n    # It can happen when a server is rapidly updated multiple times in a row.\n    botobj.post_error(\n        'Unable to download %s from %s; first tried version %s' %\n        (new_zip, url, version))\n    # Poll again, this may work next time. To prevent busy-loop, sleep a little.\n    time.sleep(2)\n    return\n\n  s = os.stat(new_zip)\n  logging.info('Restarting to %s; %d bytes.', new_zip, s.st_size)\n  sys.stdout.flush()\n  sys.stderr.flush()\n\n  proc = subprocess42.Popen(\n     [sys.executable, new_zip, 'is_fine'],\n     stdout=subprocess42.PIPE, stderr=subprocess42.STDOUT)\n  output, _ = proc.communicate()\n  if proc.returncode:\n    botobj.post_error(\n        'New bot code is bad: proc exit = %s. stdout:\\n%s' %\n        (proc.returncode, output))\n    # Poll again, the server may have better code next time. To prevent\n    # busy-loop, sleep a little.\n    time.sleep(2)\n    return\n\n  # Don't forget to release the singleton before restarting itself.\n  SINGLETON.release()\n\n  # Do not call on_bot_shutdown.\n  # On OSX, launchd will be unhappy if we quit so the old code bot process has\n  # to outlive the new code child process. Launchd really wants the main process\n  # to survive, and it'll restart it if it disappears. os.exec*() replaces the\n  # process so this is fine.\n  ret = common.exec_python([new_zip, 'start_slave', '--survive'])\n  if ret in (1073807364, -1073741510):\n    # 1073807364 is returned when the process is killed due to shutdown. No need\n    # to alert anyone in that case.\n    # -1073741510 is returned when rebooting too. This can happen when the\n    # parent code was running the old version and gets confused and decided to\n    # poll again.\n    # In any case, zap out the error code.\n    ret = 0\n  elif ret:\n    botobj.post_error('Bot failed to respawn after update: %s' % ret)\n  sys.exit(ret)\n\n\ndef update_lkgbc(botobj):\n  \"\"\"Updates the Last Known Good Bot Code if necessary.\"\"\"\n  try:\n    if not os.path.isfile(THIS_FILE):\n      botobj.post_error('Missing file %s for LKGBC' % THIS_FILE)\n      return\n\n    golden = os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')\n    if os.path.isfile(golden):\n      org = os.stat(golden)\n      cur = os.stat(THIS_FILE)\n      if org.st_size == org.st_size and org.st_mtime >= cur.st_mtime:\n        return\n\n    # Copy the file back.\n    shutil.copy(THIS_FILE, golden)\n  except Exception as e:\n    botobj.post_error('Failed to update LKGBC: %s' % e)\n\n\ndef get_config():\n  \"\"\"Returns the data from config.json.\"\"\"\n  global _ERROR_HANDLER_WAS_REGISTERED\n\n  with contextlib.closing(zipfile.ZipFile(THIS_FILE, 'r')) as f:\n    config = json.load(f.open('config/config.json', 'r'))\n\n  server = config.get('server', '')\n  if not _ERROR_HANDLER_WAS_REGISTERED and server:\n    on_error.report_on_exception_exit(server)\n    _ERROR_HANDLER_WAS_REGISTERED = True\n  return config\n\n\ndef main(args):\n  # Add SWARMING_HEADLESS into environ so subcommands know that they are running\n  # in a headless (non-interactive) mode.\n  os.environ['SWARMING_HEADLESS'] = '1'\n\n  # The only reason this is kept is to enable the unit test to use --help to\n  # quit the process.\n  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)\n  _, args = parser.parse_args(args)\n\n  # Enforces that only one process with a bot in this directory can be run on\n  # this host at once.\n  if not SINGLETON.acquire():\n    if sys.platform == 'darwin':\n      msg = (\n          'Found a previous bot, %d rebooting as a workaround for '\n          'https://crbug.com/569610.') % os.getpid()\n      print >> sys.stderr, msg\n      os_utilities.restart(msg)\n    else:\n      print >> sys.stderr, 'Found a previous bot, %d exiting.' % os.getpid()\n    return 1\n\n  for t in ('out', 'err'):\n    log_path = os.path.join(\n        os.path.dirname(THIS_FILE), 'logs', 'bot_std%s.log' % t)\n    os_utilities.roll_log(log_path)\n    os_utilities.trim_rolled_log(log_path)\n\n  error = None\n  if len(args) != 0:\n    error = 'Unexpected arguments: %s' % args\n  try:\n    return run_bot(error)\n  finally:\n    call_hook(bot.Bot(None, None, None, os.path.dirname(THIS_FILE), None),\n              'on_bot_shutdown')\n    logging.info('main() returning')\n/n/n/nappengine/swarming/swarming_bot/bot_code/bot_main_test.py/n/n#!/usr/bin/env python\n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport json\nimport logging\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nimport zipfile\n\nimport test_env_bot_code\ntest_env_bot_code.setup_test_env()\n\n# Creates a server mock for functions in net.py.\nimport net_utils\n\nimport bot_main\nfrom api import bot\nfrom api import os_utilities\nfrom depot_tools import fix_encoding\nfrom utils import file_path\nfrom utils import logging_utils\nfrom utils import net\nfrom utils import subprocess42\nfrom utils import zip_package\n\n\n# Access to a protected member XX of a client class - pylint: disable=W0212\n\n\nclass TestBotMain(net_utils.TestCase):\n  maxDiff = 2000\n\n  def setUp(self):\n    super(TestBotMain, self).setUp()\n    os.environ.pop('SWARMING_LOAD_TEST', None)\n    self.root_dir = tempfile.mkdtemp(prefix='bot_main')\n    self.old_cwd = os.getcwd()\n    os.chdir(self.root_dir)\n    # __main__ does it for us.\n    os.mkdir('logs')\n    self.url = 'https://localhost:1'\n    self.attributes = {\n      'dimensions': {\n        'foo': ['bar'],\n        'id': ['localhost'],\n        'pool': ['default'],\n      },\n      'state': {\n        'cost_usd_hour': 3600.,\n        'sleep_streak': 0,\n      },\n      'version': '123',\n    }\n    self.mock(zip_package, 'generate_version', lambda: '123')\n    self.bot = bot.Bot(\n        self.attributes, 'https://localhost:1', 'version1', self.root_dir,\n        self.fail)\n    self.mock(self.bot, 'post_error', self.fail)\n    self.mock(self.bot, 'restart', self.fail)\n    self.mock(subprocess42, 'call', self.fail)\n    self.mock(time, 'time', lambda: 100.)\n    config_path = os.path.join(\n        test_env_bot_code.BOT_DIR, 'config', 'config.json')\n    with open(config_path, 'rb') as f:\n      config = json.load(f)\n    self.mock(bot_main, 'get_config', lambda: config)\n    self.mock(\n        bot_main, 'THIS_FILE',\n        os.path.join(test_env_bot_code.BOT_DIR, 'swarming_bot.zip'))\n\n  def tearDown(self):\n    os.environ.pop('SWARMING_BOT_ID', None)\n    os.chdir(self.old_cwd)\n    file_path.rmtree(self.root_dir)\n    super(TestBotMain, self).tearDown()\n\n  def test_get_dimensions(self):\n    dimensions = set(bot_main.get_dimensions(None))\n    dimensions.discard('hidpi')\n    dimensions.discard('zone')  # Only set on GCE bots.\n    expected = {'cores', 'cpu', 'gpu', 'id', 'machine_type', 'os', 'pool'}\n    self.assertEqual(expected, dimensions)\n\n  def test_get_dimensions_load_test(self):\n    os.environ['SWARMING_LOAD_TEST'] = '1'\n    self.assertEqual(['id', 'load_test'], sorted(bot_main.get_dimensions(None)))\n\n  def test_generate_version(self):\n    self.assertEqual('123', bot_main.generate_version())\n\n  def test_get_state(self):\n    self.mock(time, 'time', lambda: 126.0)\n    expected = os_utilities.get_state()\n    expected['sleep_streak'] = 12\n    # During the execution of this test case, the free disk space could have\n    # changed.\n    for disk in expected['disks'].itervalues():\n      self.assertGreater(disk.pop('free_mb'), 1.)\n    actual = bot_main.get_state(None, 12)\n    for disk in actual['disks'].itervalues():\n      self.assertGreater(disk.pop('free_mb'), 1.)\n    self.assertGreater(actual.pop('nb_files_in_temp'), 0)\n    self.assertGreater(expected.pop('nb_files_in_temp'), 0)\n    self.assertGreater(actual.pop('uptime'), 0)\n    self.assertGreater(expected.pop('uptime'), 0)\n    self.assertEqual(sorted(expected.pop('temp', {})),\n                     sorted(actual.pop('temp', {})))\n    self.assertEqual(expected, actual)\n\n  def test_setup_bot(self):\n    setup_bots = []\n    def setup_bot(_bot):\n      setup_bots.append(1)\n      return False\n    from config import bot_config\n    self.mock(bot_config, 'setup_bot', setup_bot)\n    restarts = []\n    post_event = []\n    self.mock(\n        os_utilities, 'restart', lambda *a, **kw: restarts.append((a, kw)))\n    self.mock(\n        bot.Bot, 'post_event', lambda *a, **kw: post_event.append((a, kw)))\n    self.expected_requests([])\n    bot_main.setup_bot(False)\n    expected = [\n      (('Starting new swarming bot: %s' % bot_main.THIS_FILE,),\n        {'timeout': 900}),\n    ]\n    self.assertEqual(expected, restarts)\n    # It is called twice, one as part of setup_bot(False), another as part of\n    # on_shutdown_hook().\n    self.assertEqual([1, 1], setup_bots)\n    expected = [\n      'Starting new swarming bot: %s' % bot_main.THIS_FILE,\n      'Bot is stuck restarting for: Starting new swarming bot: %s' %\n        bot_main.THIS_FILE,\n    ]\n    self.assertEqual(expected, [i[0][2] for i in post_event])\n\n  def test_post_error_task(self):\n    self.mock(time, 'time', lambda: 126.0)\n    self.mock(logging, 'error', lambda *_, **_kw: None)\n    self.mock(\n        bot_main, 'get_config',\n        lambda: {'server': self.url, 'server_version': '1'})\n    expected_attribs = bot_main.get_attributes(None)\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/task_error/23',\n            {\n              'data': {\n                'id': expected_attribs['dimensions']['id'][0],\n                'message': 'error',\n                'task_id': 23,\n              },\n            },\n            {'resp': 1},\n          ),\n        ])\n    botobj = bot_main.get_bot()\n    self.assertEqual({'resp': 1}, bot_main.post_error_task(botobj, 'error', 23))\n\n  def test_run_bot(self):\n    # Test the run_bot() loop. Does not use self.bot.\n    self.mock(time, 'time', lambda: 126.0)\n    class Foo(Exception):\n      pass\n\n    def poll_server(botobj, _):\n      sleep_streak = botobj.state['sleep_streak']\n      self.assertEqual(self.url, botobj.server)\n      if sleep_streak == 5:\n        raise Exception('Jumping out of the loop')\n      return False\n    self.mock(bot_main, 'poll_server', poll_server)\n\n    def post_error(botobj, e):\n      self.assertEqual(self.url, botobj.server)\n      lines = e.splitlines()\n      self.assertEqual('Jumping out of the loop', lines[0])\n      self.assertEqual('Traceback (most recent call last):', lines[1])\n      raise Foo('Necessary to get out of the loop')\n    self.mock(bot.Bot, 'post_error', post_error)\n\n    self.mock(\n        bot_main, 'get_config',\n        lambda: {'server': self.url, 'server_version': '1'})\n    self.mock(\n        bot_main, 'get_dimensions', lambda _: self.attributes['dimensions'])\n    self.mock(os_utilities, 'get_state', lambda *_: self.attributes['state'])\n\n    # Method should have \"self\" as first argument - pylint: disable=E0213\n    # pylint: disable=unused-argument\n    class Popen(object):\n      def __init__(\n          self2, cmd, detached, cwd, stdout, stderr, stdin, close_fds):\n        self2.returncode = None\n        expected = [sys.executable, bot_main.THIS_FILE, 'run_isolated']\n        self.assertEqual(expected, cmd[:len(expected)])\n        self.assertEqual(True, detached)\n        self.assertEqual(subprocess42.PIPE, stdout)\n        self.assertEqual(subprocess42.STDOUT, stderr)\n        self.assertEqual(subprocess42.PIPE, stdin)\n        self.assertEqual(sys.platform != 'win32', close_fds)\n\n      def communicate(self2, i):\n        self.assertEqual(None, i)\n        self2.returncode = 0\n        return '', None\n    self.mock(subprocess42, 'Popen', Popen)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/server_ping',\n            {}, 'foo', None,\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/handshake',\n            {'data': self.attributes},\n            {'bot_version': '123', 'server': self.url, 'server_version': 1},\n          ),\n        ])\n\n    with self.assertRaises(Foo):\n      bot_main.run_bot(None)\n    self.assertEqual(\n        self.attributes['dimensions']['id'][0], os.environ['SWARMING_BOT_ID'])\n\n  def test_poll_server_sleep(self):\n    slept = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', slept.append)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', self.fail)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {'data': self.attributes},\n            {\n              'cmd': 'sleep',\n              'duration': 1.24,\n            },\n          ),\n        ])\n    self.assertFalse(bot_main.poll_server(self.bot, bit))\n    self.assertEqual([1.24], slept)\n\n  def test_poll_server_run(self):\n    manifest = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', lambda *args: manifest.append(args))\n    self.mock(bot_main, 'update_bot', self.fail)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {'data': self.bot._attributes},\n            {\n              'cmd': 'run',\n              'manifest': {'foo': 'bar'},\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n    expected = [(self.bot, {'foo': 'bar'}, time.time())]\n    self.assertEqual(expected, manifest)\n\n  def test_poll_server_update(self):\n    update = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', lambda *args: update.append(args))\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {'data': self.attributes},\n            {\n              'cmd': 'update',\n              'version': '123',\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n    self.assertEqual([(self.bot, '123')], update)\n\n  def test_poll_server_restart(self):\n    restart = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', self.fail)\n    self.mock(self.bot, 'restart', lambda *args: restart.append(args))\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {'data': self.attributes},\n            {\n              'cmd': 'restart',\n              'message': 'Please die now',\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n    self.assertEqual([('Please die now',)], restart)\n\n  def test_poll_server_restart_load_test(self):\n    os.environ['SWARMING_LOAD_TEST'] = '1'\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', self.fail)\n    self.mock(self.bot, 'restart', self.fail)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {\n              'data': self.attributes,\n            },\n            {\n              'cmd': 'restart',\n              'message': 'Please die now',\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n\n  def _mock_popen(self, returncode=0, exit_code=0, url='https://localhost:1'):\n    result = {\n      'exit_code': exit_code,\n      'must_signal_internal_failure': None,\n      'version': 3,\n    }\n    # Method should have \"self\" as first argument - pylint: disable=E0213\n    class Popen(object):\n      def __init__(\n          self2, cmd, detached, cwd, env, stdout, stderr, stdin, close_fds):\n        self2.returncode = None\n        self2._out_file = os.path.join(\n            self.root_dir, 'work', 'task_runner_out.json')\n        expected = [\n          sys.executable, bot_main.THIS_FILE, 'task_runner',\n          '--swarming-server', url,\n          '--in-file',\n          os.path.join(self.root_dir, 'work', 'task_runner_in.json'),\n          '--out-file', self2._out_file,\n          '--cost-usd-hour', '3600.0', '--start', '100.0',\n          '--min-free-space',\n          str(int(\n            (os_utilities.get_min_free_space(bot_main.THIS_FILE) + 250.) *\n            1024 * 1024)),\n        ]\n        self.assertEqual(expected, cmd)\n        self.assertEqual(True, detached)\n        self.assertEqual(self.bot.base_dir, cwd)\n        self.assertEqual('24', env['SWARMING_TASK_ID'])\n        self.assertTrue(stdout)\n        self.assertEqual(subprocess42.STDOUT, stderr)\n        self.assertEqual(subprocess42.PIPE, stdin)\n        self.assertEqual(sys.platform != 'win32', close_fds)\n\n      def wait(self2, timeout=None): # pylint: disable=unused-argument\n        self2.returncode = returncode\n        with open(self2._out_file, 'wb') as f:\n          json.dump(result, f)\n        return 0\n\n    self.mock(subprocess42, 'Popen', Popen)\n    return result\n\n  def test_run_manifest(self):\n    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))\n    def call_hook(botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(self.attributes['dimensions'], botobj.dimensions)\n        self.assertEqual(False, failure)\n        self.assertEqual(False, internal_failure)\n        self.assertEqual({'os': 'Amiga', 'pool': 'default'}, dimensions)\n        self.assertEqual(result, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    result = self._mock_popen(url='https://localhost:3')\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'os': 'Amiga', 'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'host': 'https://localhost:3',\n      'task_id': '24',\n    }\n    self.assertEqual(self.root_dir, self.bot.base_dir)\n    bot_main.run_manifest(self.bot, manifest, time.time())\n\n  def test_run_manifest_task_failure(self):\n    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))\n    def call_hook(_botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(True, failure)\n        self.assertEqual(False, internal_failure)\n        self.assertEqual({'pool': 'default'}, dimensions)\n        self.assertEqual(result, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    result = self._mock_popen(exit_code=1)\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'io_timeout': 60,\n      'task_id': '24',\n    }\n    bot_main.run_manifest(self.bot, manifest, time.time())\n\n  def test_run_manifest_internal_failure(self):\n    posted = []\n    self.mock(bot_main, 'post_error_task', lambda *args: posted.append(args))\n    def call_hook(_botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(False, failure)\n        self.assertEqual(True, internal_failure)\n        self.assertEqual({'pool': 'default'}, dimensions)\n        self.assertEqual(result, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    result = self._mock_popen(returncode=1)\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'io_timeout': 60,\n      'task_id': '24',\n    }\n    bot_main.run_manifest(self.bot, manifest, time.time())\n    expected = [(self.bot, 'Execution failed: internal error (1).', '24')]\n    self.assertEqual(expected, posted)\n\n  def test_run_manifest_exception(self):\n    posted = []\n    def post_error_task(botobj, msg, task_id):\n      posted.append((botobj, msg.splitlines()[0], task_id))\n    self.mock(bot_main, 'post_error_task', post_error_task)\n    def call_hook(_botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(False, failure)\n        self.assertEqual(True, internal_failure)\n        self.assertEqual({'pool': 'default'}, dimensions)\n        self.assertEqual({}, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    def raiseOSError(*_a, **_k):\n      raise OSError('Dang')\n    self.mock(subprocess42, 'Popen', raiseOSError)\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'task_id': '24',\n    }\n    bot_main.run_manifest(self.bot, manifest, time.time())\n    expected = [(self.bot, 'Internal exception occured: Dang', '24')]\n    self.assertEqual(expected, posted)\n\n  def test_update_bot(self):\n    # In a real case 'update_bot' never exits and doesn't call 'post_error'.\n    # Under the test however forever-blocking calls finish, and post_error is\n    # called.\n    self.mock(self.bot, 'post_error', lambda *_: None)\n    # Mock the file to download in the temporary directory.\n    self.mock(\n        bot_main, 'THIS_FILE',\n        os.path.join(self.root_dir, 'swarming_bot.1.zip'))\n    new_zip = os.path.join(self.root_dir, 'swarming_bot.2.zip')\n    # This is necessary otherwise zipfile will crash.\n    self.mock(time, 'time', lambda: 1400000000)\n    def url_retrieve(f, url):\n      self.assertEqual(\n          'https://localhost:1/swarming/api/v1/bot/bot_code/123', url)\n      self.assertEqual(new_zip, f)\n      # Create a valid zip that runs properly.\n      with zipfile.ZipFile(f, 'w') as z:\n        z.writestr('__main__.py', 'print(\"hi\")')\n      return True\n    self.mock(net, 'url_retrieve', url_retrieve)\n\n    calls = []\n    def exec_python(args):\n      calls.append(args)\n      return 23\n    self.mock(bot_main.common, 'exec_python', exec_python)\n\n    with self.assertRaises(SystemExit) as e:\n      bot_main.update_bot(self.bot, '123')\n    self.assertEqual(23, e.exception.code)\n\n    self.assertEqual([[new_zip, 'start_slave', '--survive']], calls)\n\n  def test_main(self):\n    def check(x):\n      self.assertEqual(logging.WARNING, x)\n    self.mock(logging_utils, 'set_console_level', check)\n\n    def run_bot(error):\n      self.assertEqual(None, error)\n      return 0\n    self.mock(bot_main, 'run_bot', run_bot)\n\n    class Singleton(object):\n      # pylint: disable=no-self-argument\n      def acquire(self2):\n        return True\n      def release(self2):\n        self.fail()\n    self.mock(bot_main, 'SINGLETON', Singleton())\n\n    self.assertEqual(0, bot_main.main([]))\n\n\nif __name__ == '__main__':\n  fix_encoding.fix_encoding()\n  if '-v' in sys.argv:\n    TestBotMain.maxDiff = None\n  logging.basicConfig(\n      level=logging.DEBUG if '-v' in sys.argv else logging.CRITICAL)\n  unittest.main()\n/n/n/nappengine/swarming/swarming_bot/bot_code/task_runner.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Runs a Swarming task.\n\nDownloads all the necessary files to run the task, executes the command and\nstreams results back to the Swarming server.\n\nThe process exit code is 0 when the task was executed, even if the task itself\nfailed. If there's any failure in the setup or teardown, like invalid packet\nresponse, failure to contact the server, etc, a non zero exit code is used. It's\nup to the calling process (bot_main.py) to signal that there was an internal\nfailure and to cancel this task run and ask the server to retry it.\n\"\"\"\n\nimport base64\nimport json\nimport logging\nimport optparse\nimport os\nimport signal\nimport sys\nimport time\n\nfrom utils import net\nfrom utils import on_error\nfrom utils import subprocess42\nfrom utils import zip_package\n\n\n# Path to this file or the zip containing this file.\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n\n# Sends a maximum of 100kb of stdout per task_update packet.\nMAX_CHUNK_SIZE = 102400\n\n\n# Maximum wait between task_update packet when there's no output.\nMAX_PACKET_INTERVAL = 30\n\n\n# Minimum wait between task_update packet when there's output.\nMIN_PACKET_INTERNAL = 10\n\n\n# Current task_runner_out version.\nOUT_VERSION = 3\n\n\n# On Windows, SIGTERM is actually sent as SIGBREAK since there's no real\n# SIGTERM.  SIGBREAK is not defined on posix since it's a pure Windows concept.\nSIG_BREAK_OR_TERM = (\n    signal.SIGBREAK if sys.platform == 'win32' else signal.SIGTERM)\n\n\n# Used to implement monotonic_time for a clock that never goes backward.\n_last_now = 0\n\n\ndef monotonic_time():\n  \"\"\"Returns monotonically increasing time.\"\"\"\n  global _last_now\n  now = time.time()\n  if now > _last_now:\n    # TODO(maruel): If delta is large, probably worth alerting via ereporter2.\n    _last_now = now\n  return _last_now\n\n\ndef get_run_isolated():\n  \"\"\"Returns the path to itself to run run_isolated.\n\n  Mocked in test to point to the real run_isolated.py script.\n  \"\"\"\n  return [sys.executable, THIS_FILE, 'run_isolated']\n\n\ndef get_isolated_cmd(\n    work_dir, task_details, isolated_result, min_free_space):\n  \"\"\"Returns the command to call run_isolated. Mocked in tests.\"\"\"\n  bot_dir = os.path.dirname(work_dir)\n  if os.path.isfile(isolated_result):\n    os.remove(isolated_result)\n  cmd = get_run_isolated()\n  cmd.extend(\n      [\n        '--isolated', task_details.inputs_ref['isolated'].encode('utf-8'),\n        '--namespace', task_details.inputs_ref['namespace'].encode('utf-8'),\n        '-I', task_details.inputs_ref['isolatedserver'].encode('utf-8'),\n        '--json', isolated_result,\n        '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),\n        '--cache', os.path.join(bot_dir, 'cache'),\n        '--root-dir', os.path.join(work_dir, 'isolated'),\n      ])\n  if min_free_space:\n    cmd.extend(('--min-free-space', str(min_free_space)))\n\n  if task_details.hard_timeout:\n    cmd.extend(('--hard-timeout', str(task_details.hard_timeout)))\n  if task_details.grace_period:\n    cmd.extend(('--grace-period', str(task_details.grace_period)))\n  if task_details.extra_args:\n    cmd.append('--')\n    cmd.extend(task_details.extra_args)\n  return cmd\n\n\nclass TaskDetails(object):\n  def __init__(self, data):\n    \"\"\"Loads the raw data.\n\n    It is expected to have at least:\n     - bot_id\n     - command as a list of str\n     - data as a list of urls\n     - env as a dict\n     - hard_timeout\n     - io_timeout\n     - task_id\n    \"\"\"\n    logging.info('TaskDetails(%s)', data)\n    if not isinstance(data, dict):\n      raise ValueError('Expected dict, got %r' % data)\n\n    # Get all the data first so it fails early if the task details is invalid.\n    self.bot_id = data['bot_id']\n\n    # Raw command. Only self.command or self.inputs_ref can be set.\n    self.command = data['command'] or []\n\n    # Isolated command. Is a serialized version of task_request.FilesRef.\n    self.inputs_ref = data['inputs_ref']\n    self.extra_args = data['extra_args']\n\n    self.env = {\n      k.encode('utf-8'): v.encode('utf-8') for k, v in data['env'].iteritems()\n    }\n    self.grace_period = data['grace_period']\n    self.hard_timeout = data['hard_timeout']\n    self.io_timeout = data['io_timeout']\n    self.task_id = data['task_id']\n\n\nclass MustExit(Exception):\n  \"\"\"Raised on signal that the process must exit immediately.\"\"\"\n  def __init__(self, sig):\n    super(MustExit, self).__init__()\n    self.signal = sig\n\n\ndef load_and_run(\n    in_file, swarming_server, cost_usd_hour, start, out_file, min_free_space):\n  \"\"\"Loads the task's metadata and execute it.\n\n  This may throw all sorts of exceptions in case of failure. It's up to the\n  caller to trap them. These shall be considered 'internal_failure' instead of\n  'failure' from a TaskRunResult standpoint.\n  \"\"\"\n  # The work directory is guaranteed to exist since it was created by\n  # bot_main.py and contains the manifest. Temporary files will be downloaded\n  # there. It's bot_main.py that will delete the directory afterward. Tests are\n  # not run from there.\n  task_result = None\n  def handler(sig, _):\n    logging.info('Got signal %s', sig)\n    raise MustExit(sig)\n  work_dir = os.path.dirname(out_file)\n  try:\n    with subprocess42.set_signal_handler([SIG_BREAK_OR_TERM], handler):\n      if not os.path.isdir(work_dir):\n        raise ValueError('%s expected to exist' % work_dir)\n\n      with open(in_file, 'rb') as f:\n        task_details = TaskDetails(json.load(f))\n\n      task_result = run_command(\n          swarming_server, task_details, work_dir, cost_usd_hour, start,\n          min_free_space)\n  except MustExit as e:\n    # This normally means run_command() didn't get the chance to run, as it\n    # itself trap MustExit and will report accordingly. In this case, we want\n    # the parent process to send the message instead.\n    if not task_result:\n      task_result = {\n        u'exit_code': None,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure':\n            u'task_runner received signal %s' % e.signal,\n        u'version': OUT_VERSION,\n      }\n  finally:\n    # We've found tests to delete 'work' when quitting, causing an exception\n    # here. Try to recreate the directory if necessary.\n    if not os.path.isdir(work_dir):\n      os.mkdir(work_dir)\n    with open(out_file, 'wb') as f:\n      json.dump(task_result, f)\n\n\ndef post_update(swarming_server, params, exit_code, stdout, output_chunk_start):\n  \"\"\"Posts task update to task_update.\n\n  Arguments:\n    swarming_server: Base URL to Swarming server.\n    params: Default JSON parameters for the POST.\n    exit_code: Process exit code, only when a command completed.\n    stdout: Incremental output since last call, if any.\n    output_chunk_start: Total number of stdout previously sent, for coherency\n        with the server.\n  \"\"\"\n  params = params.copy()\n  if exit_code is not None:\n    params['exit_code'] = exit_code\n  if stdout:\n    # The output_chunk_start is used by the server to make sure that the stdout\n    # chunks are processed and saved in the DB in order.\n    params['output'] = base64.b64encode(stdout)\n    params['output_chunk_start'] = output_chunk_start\n  # TODO(maruel): Support early cancellation.\n  # https://code.google.com/p/swarming/issues/detail?id=62\n  resp = net.url_read_json(\n      swarming_server+'/swarming/api/v1/bot/task_update/%s' % params['task_id'],\n      data=params)\n  logging.debug('post_update() = %s', resp)\n  if resp.get('error'):\n    # Abandon it. This will force a process exit.\n    raise ValueError(resp.get('error'))\n\n\ndef should_post_update(stdout, now, last_packet):\n  \"\"\"Returns True if it's time to send a task_update packet via post_update().\n\n  Sends a packet when one of this condition is met:\n  - more than MAX_CHUNK_SIZE of stdout is buffered.\n  - last packet was sent more than MIN_PACKET_INTERNAL seconds ago and there was\n    stdout.\n  - last packet was sent more than MAX_PACKET_INTERVAL seconds ago.\n  \"\"\"\n  packet_interval = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL\n  return len(stdout) >= MAX_CHUNK_SIZE or (now - last_packet) > packet_interval\n\n\ndef calc_yield_wait(task_details, start, last_io, timed_out, stdout):\n  \"\"\"Calculates the maximum number of seconds to wait in yield_any().\"\"\"\n  now = monotonic_time()\n  if timed_out:\n    # Give a |grace_period| seconds delay.\n    if task_details.grace_period:\n      return max(now - timed_out - task_details.grace_period, 0.)\n    return 0.\n\n  out = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL\n  if task_details.hard_timeout:\n    out = min(out, start + task_details.hard_timeout - now)\n  if task_details.io_timeout:\n    out = min(out, last_io + task_details.io_timeout - now)\n  out = max(out, 0)\n  logging.debug('calc_yield_wait() = %d', out)\n  return out\n\n\ndef kill_and_wait(proc, grace_period, reason):\n  logging.warning('SIGTERM finally due to %s', reason)\n  proc.terminate()\n  try:\n    proc.wait(grace_period)\n  except subprocess42.TimeoutError:\n    logging.warning('SIGKILL finally due to %s', reason)\n    proc.kill()\n  exit_code = proc.wait()\n  logging.info('Waiting for proces exit in finally - done')\n  return exit_code\n\n\ndef run_command(\n    swarming_server, task_details, work_dir, cost_usd_hour, task_start,\n    min_free_space):\n  \"\"\"Runs a command and sends packets to the server to stream results back.\n\n  Implements both I/O and hard timeouts. Sends the packets numbered, so the\n  server can ensure they are processed in order.\n\n  Returns:\n    Metadata about the command.\n  \"\"\"\n  # TODO(maruel): This function is incomprehensible, split and refactor.\n  # Signal the command is about to be started.\n  last_packet = start = now = monotonic_time()\n  params = {\n    'cost_usd': cost_usd_hour * (now - task_start) / 60. / 60.,\n    'id': task_details.bot_id,\n    'task_id': task_details.task_id,\n  }\n  post_update(swarming_server, params, None, '', 0)\n\n  if task_details.command:\n    # Raw command.\n    cmd = task_details.command\n    isolated_result = None\n  else:\n    # Isolated task.\n    isolated_result = os.path.join(work_dir, 'isolated_result.json')\n    cmd = get_isolated_cmd(\n        work_dir, task_details, isolated_result, min_free_space)\n    # Hard timeout enforcement is deferred to run_isolated. Grace is doubled to\n    # give one 'grace_period' slot to the child process and one slot to upload\n    # the results back.\n    task_details.hard_timeout = 0\n    if task_details.grace_period:\n      task_details.grace_period *= 2\n\n  try:\n    # TODO(maruel): Support both channels independently and display stderr in\n    # red.\n    env = None\n    if task_details.env:\n      env = os.environ.copy()\n      for key, value in task_details.env.iteritems():\n        if not value:\n          env.pop(key, None)\n        else:\n          env[key] = value\n    logging.info('cmd=%s', cmd)\n    logging.info('env=%s', env)\n    try:\n      proc = subprocess42.Popen(\n          cmd,\n          env=env,\n          cwd=work_dir,\n          detached=True,\n          stdout=subprocess42.PIPE,\n          stderr=subprocess42.STDOUT,\n          stdin=subprocess42.PIPE)\n    except OSError as e:\n      stdout = 'Command \"%s\" failed to start.\\nError: %s' % (' '.join(cmd), e)\n      now = monotonic_time()\n      params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.\n      params['duration'] = now - start\n      params['io_timeout'] = False\n      params['hard_timeout'] = False\n      post_update(swarming_server, params, 1, stdout, 0)\n      return {\n        u'exit_code': -1,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure': None,\n        u'version': OUT_VERSION,\n      }\n\n    output_chunk_start = 0\n    stdout = ''\n    exit_code = None\n    had_hard_timeout = False\n    had_io_timeout = False\n    must_signal_internal_failure = None\n    kill_sent = False\n    timed_out = None\n    try:\n      calc = lambda: calc_yield_wait(\n          task_details, start, last_io, timed_out, stdout)\n      maxsize = lambda: MAX_CHUNK_SIZE - len(stdout)\n      last_io = monotonic_time()\n      for _, new_data in proc.yield_any(maxsize=maxsize, timeout=calc):\n        now = monotonic_time()\n        if new_data:\n          stdout += new_data\n          last_io = now\n\n        # Post update if necessary.\n        if should_post_update(stdout, now, last_packet):\n          last_packet = monotonic_time()\n          params['cost_usd'] = (\n              cost_usd_hour * (last_packet - task_start) / 60. / 60.)\n          post_update(swarming_server, params, None, stdout, output_chunk_start)\n          output_chunk_start += len(stdout)\n          stdout = ''\n\n        # Send signal on timeout if necessary. Both are failures, not\n        # internal_failures.\n        # Eventually kill but return 0 so bot_main.py doesn't cancel the task.\n        if not timed_out:\n          if (task_details.io_timeout and\n              now - last_io > task_details.io_timeout):\n            had_io_timeout = True\n            logging.warning('I/O timeout; sending SIGTERM')\n            proc.terminate()\n            timed_out = monotonic_time()\n          elif (task_details.hard_timeout and\n              now - start > task_details.hard_timeout):\n            had_hard_timeout = True\n            logging.warning('Hard timeout; sending SIGTERM')\n            proc.terminate()\n            timed_out = monotonic_time()\n        else:\n          # During grace period.\n          if not kill_sent and now >= timed_out + task_details.grace_period:\n            # Now kill for real. The user can distinguish between the following\n            # states:\n            # - signal but process exited within grace period,\n            #   (hard_|io_)_timed_out will be set but the process exit code will\n            #   be script provided.\n            # - processed exited late, exit code will be -9 on posix.\n            logging.warning('Grace exhausted; sending SIGKILL')\n            proc.kill()\n            kill_sent = True\n      logging.info('Waiting for proces exit')\n      exit_code = proc.wait()\n    except MustExit as e:\n      # TODO(maruel): Do the send SIGTERM to child process and give it\n      # task_details.grace_period to terminate.\n      must_signal_internal_failure = (\n          u'task_runner received signal %s' % e.signal)\n      exit_code = kill_and_wait(\n          proc, task_details.grace_period, 'signal %d' % e.signal)\n    except (IOError, OSError):\n      # Something wrong happened, try to kill the child process.\n      had_hard_timeout = True\n      exit_code = kill_and_wait(\n          proc, task_details.grace_period, 'exception %s' % e)\n\n    # This is the very last packet for this command. It if was an isolated task,\n    # include the output reference to the archived .isolated file.\n    now = monotonic_time()\n    params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.\n    params['duration'] = now - start\n    params['io_timeout'] = had_io_timeout\n    params['hard_timeout'] = had_hard_timeout\n    if isolated_result:\n      try:\n        if ((had_io_timeout or had_hard_timeout) and\n            not os.path.isfile(isolated_result)):\n          # It's possible that run_isolated failed to quit quickly enough; it\n          # could be because there was too much data to upload back or something\n          # else. Do not create an internal error, just send back the (partial)\n          # view as task_runner saw it, for example the real exit_code is\n          # unknown.\n          logging.warning('TIMED_OUT and there\\'s no result file')\n          exit_code = -1\n        else:\n          # See run_isolated.py for the format.\n          with open(isolated_result, 'rb') as f:\n            run_isolated_result = json.load(f)\n          logging.debug('run_isolated:\\n%s', run_isolated_result)\n          # TODO(maruel): Grab statistics (cache hit rate, data downloaded,\n          # mapping time, etc) from run_isolated and push them to the server.\n          if run_isolated_result['outputs_ref']:\n            params['outputs_ref'] = run_isolated_result['outputs_ref']\n          had_hard_timeout = (\n              had_hard_timeout or run_isolated_result['had_hard_timeout'])\n          params['hard_timeout'] = had_hard_timeout\n          if not had_io_timeout and not had_hard_timeout:\n            if run_isolated_result['internal_failure']:\n              must_signal_internal_failure = (\n                  run_isolated_result['internal_failure'])\n              logging.error('%s', must_signal_internal_failure)\n            elif exit_code:\n              # TODO(maruel): Grab stdout from run_isolated.\n              must_signal_internal_failure = (\n                  'run_isolated internal failure %d' % exit_code)\n              logging.error('%s', must_signal_internal_failure)\n          exit_code = run_isolated_result['exit_code']\n          if run_isolated_result.get('duration') is not None:\n            # Calculate the real task duration as measured by run_isolated and\n            # calculate the remaining overhead.\n            params['bot_overhead'] = params['duration']\n            params['duration'] = run_isolated_result['duration']\n            params['bot_overhead'] -= params['duration']\n            params['bot_overhead'] -= run_isolated_result.get(\n                'download', {}).get('duration', 0)\n            params['bot_overhead'] -= run_isolated_result.get(\n                'upload', {}).get('duration', 0)\n            if params['bot_overhead'] < 0:\n              params['bot_overhead'] = 0\n          stats = run_isolated_result.get('stats')\n          if stats:\n            params['isolated_stats'] = stats\n      except (IOError, OSError, ValueError) as e:\n        logging.error('Swallowing error: %s', e)\n        if not must_signal_internal_failure:\n          must_signal_internal_failure = str(e)\n    # TODO(maruel): Send the internal failure here instead of sending it through\n    # bot_main, this causes a race condition.\n    if exit_code is None:\n      exit_code = -1\n    post_update(swarming_server, params, exit_code, stdout, output_chunk_start)\n    return {\n      u'exit_code': exit_code,\n      u'hard_timeout': had_hard_timeout,\n      u'io_timeout': had_io_timeout,\n      u'must_signal_internal_failure': must_signal_internal_failure,\n      u'version': OUT_VERSION,\n    }\n  finally:\n    if isolated_result:\n      try:\n        os.remove(isolated_result)\n      except OSError:\n        pass\n\n\ndef main(args):\n  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)\n  parser.add_option('--in-file', help='Name of the request file')\n  parser.add_option(\n      '--out-file', help='Name of the JSON file to write a task summary to')\n  parser.add_option(\n      '--swarming-server', help='Swarming server to send data back')\n  parser.add_option(\n      '--cost-usd-hour', type='float', help='Cost of this VM in $/h')\n  parser.add_option('--start', type='float', help='Time this task was started')\n  parser.add_option(\n      '--min-free-space', type='int',\n      help='Value to send down to run_isolated')\n\n  options, args = parser.parse_args(args)\n  if not options.in_file or not options.out_file or args:\n    parser.error('task_runner is meant to be used by swarming_bot.')\n\n  on_error.report_on_exception_exit(options.swarming_server)\n\n  logging.info('starting')\n  now = monotonic_time()\n  if options.start > now:\n    options.start = now\n\n  try:\n    load_and_run(\n        options.in_file, options.swarming_server, options.cost_usd_hour,\n        options.start, options.out_file, options.min_free_space)\n    return 0\n  finally:\n    logging.info('quitting')\n/n/n/nappengine/swarming/swarming_bot/bot_code/task_runner_test.py/n/n#!/usr/bin/env python\n# coding=utf-8\n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport base64\nimport json\nimport logging\nimport os\nimport signal\nimport shutil\nimport sys\nimport tempfile\nimport time\nimport unittest\n\nimport test_env_bot_code\ntest_env_bot_code.setup_test_env()\n\n# Creates a server mock for functions in net.py.\nimport net_utils\n\nfrom api import os_utilities\nfrom depot_tools import fix_encoding\nfrom utils import file_path\nfrom utils import large\nfrom utils import logging_utils\nfrom utils import subprocess42\nfrom utils import tools\nimport fake_swarming\nimport task_runner\n\nCLIENT_DIR = os.path.normpath(\n    os.path.join(test_env_bot_code.BOT_DIR, '..', '..', '..', 'client'))\n\nsys.path.insert(0, os.path.join(CLIENT_DIR, 'tests'))\nimport isolateserver_mock\n\n\ndef get_manifest(script=None, inputs_ref=None, **kwargs):\n  out = {\n    'bot_id': 'localhost',\n    'command':\n        [sys.executable, '-u', '-c', script] if not inputs_ref else None,\n    'env': {},\n    'extra_args': [],\n    'grace_period': 30.,\n    'hard_timeout': 10.,\n    'inputs_ref': inputs_ref,\n    'io_timeout': 10.,\n    'task_id': 23,\n  }\n  out.update(kwargs)\n  return out\n\n\nclass TestTaskRunnerBase(net_utils.TestCase):\n  def setUp(self):\n    super(TestTaskRunnerBase, self).setUp()\n    self.root_dir = tempfile.mkdtemp(prefix='task_runner')\n    logging.info('Temp: %s', self.root_dir)\n    self.work_dir = os.path.join(self.root_dir, 'work')\n    os.chdir(self.root_dir)\n    os.mkdir(self.work_dir)\n    # Create the logs directory so run_isolated.py can put its log there.\n    os.mkdir(os.path.join(self.root_dir, 'logs'))\n\n    self.mock(\n        task_runner, 'get_run_isolated',\n        lambda: [sys.executable, os.path.join(CLIENT_DIR, 'run_isolated.py')])\n\n  def tearDown(self):\n    os.chdir(test_env_bot_code.BOT_DIR)\n    try:\n      file_path.rmtree(self.root_dir)\n    except OSError:\n      print >> sys.stderr, 'Failed to delete %s' % self.root_dir\n    finally:\n      super(TestTaskRunnerBase, self).tearDown()\n\n  @classmethod\n  def get_task_details(cls, *args, **kwargs):\n    return task_runner.TaskDetails(get_manifest(*args, **kwargs))\n\n  def gen_requests(self, cost_usd=0., **kwargs):\n    return [\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        self.get_check_first(cost_usd),\n        {},\n      ),\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        self.get_check_final(**kwargs),\n        {},\n      ),\n    ]\n\n  def requests(self, **kwargs):\n    \"\"\"Generates the expected HTTP requests for a task run.\"\"\"\n    self.expected_requests(self.gen_requests(**kwargs))\n\n  def get_check_first(self, cost_usd):\n    def check_first(kwargs):\n      self.assertLessEqual(cost_usd, kwargs['data'].pop('cost_usd'))\n      self.assertEqual(\n        {\n          'data': {\n            'id': 'localhost',\n            'task_id': 23,\n          },\n        },\n        kwargs)\n    return check_first\n\n\nclass TestTaskRunner(TestTaskRunnerBase):\n  def setUp(self):\n    super(TestTaskRunner, self).setUp()\n    self.mock(time, 'time', lambda: 1000000000.)\n\n  def get_check_final(self, exit_code=0, output='hi\\n', outputs_ref=None):\n    def check_final(kwargs):\n      # It makes the diffing easier.\n      if 'output' in kwargs['data']:\n        kwargs['data']['output'] = base64.b64decode(kwargs['data']['output'])\n      expected = {\n        'data': {\n          'cost_usd': 10.,\n          'duration': 0.,\n          'exit_code': exit_code,\n          'hard_timeout': False,\n          'id': 'localhost',\n          'io_timeout': False,\n          'output': output,\n          'output_chunk_start': 0,\n          'task_id': 23,\n        },\n      }\n      if outputs_ref:\n        expected['data']['outputs_ref'] = outputs_ref\n      self.assertEqual(expected, kwargs)\n    return check_final\n\n  def _run_command(self, task_details):\n    start = time.time()\n    self.mock(time, 'time', lambda: start + 10)\n    server = 'https://localhost:1'\n    return task_runner.run_command(\n        server, task_details, self.work_dir, 3600., start, 1)\n\n  def test_load_and_run_raw(self):\n    server = 'https://localhost:1'\n\n    def run_command(\n        swarming_server, task_details, work_dir, cost_usd_hour, start,\n        min_free_space):\n      self.assertEqual(server, swarming_server)\n      # Necessary for OSX.\n      self.assertEqual(\n          os.path.realpath(self.work_dir), os.path.realpath(work_dir))\n      self.assertTrue(isinstance(task_details, task_runner.TaskDetails))\n      self.assertEqual(3600., cost_usd_hour)\n      self.assertEqual(time.time(), start)\n      self.assertEqual(1, min_free_space)\n      return {\n        u'exit_code': 1,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure': None,\n        u'version': task_runner.OUT_VERSION,\n      }\n    self.mock(task_runner, 'run_command', run_command)\n\n    manifest = os.path.join(self.root_dir, 'manifest')\n    with open(manifest, 'wb') as f:\n      data = {\n        'bot_id': 'localhost',\n        'command': ['a'],\n        'env': {'d': 'e'},\n        'extra_args': [],\n        'grace_period': 30.,\n        'hard_timeout': 10,\n        'inputs_ref': None,\n        'io_timeout': 11,\n        'task_id': 23,\n      }\n      json.dump(data, f)\n\n    out_file = os.path.join(self.root_dir, 'work', 'task_runner_out.json')\n    task_runner.load_and_run(manifest, server, 3600., time.time(), out_file, 1)\n    expected = {\n      u'exit_code': 1,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    with open(out_file, 'rb') as f:\n      self.assertEqual(expected, json.load(f))\n\n  def test_load_and_run_isolated(self):\n    self.expected_requests([])\n    server = 'https://localhost:1'\n\n    def run_command(\n        swarming_server, task_details, work_dir, cost_usd_hour, start,\n        min_free_space):\n      self.assertEqual(server, swarming_server)\n      # Necessary for OSX.\n      self.assertEqual(\n          os.path.realpath(self.work_dir), os.path.realpath(work_dir))\n      self.assertTrue(isinstance(task_details, task_runner.TaskDetails))\n      self.assertEqual(3600., cost_usd_hour)\n      self.assertEqual(time.time(), start)\n      self.assertEqual(1, min_free_space)\n      return {\n        u'exit_code': 0,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure': None,\n        u'version': task_runner.OUT_VERSION,\n      }\n    self.mock(task_runner, 'run_command', run_command)\n\n    manifest = os.path.join(self.root_dir, 'manifest')\n    with open(manifest, 'wb') as f:\n      data = {\n        'bot_id': 'localhost',\n        'command': None,\n        'env': {'d': 'e'},\n        'extra_args': ['foo', 'bar'],\n        'grace_period': 30.,\n        'hard_timeout': 10,\n        'io_timeout': 11,\n        'inputs_ref': {\n          'isolated': '123',\n          'isolatedserver': 'http://localhost:1',\n          'namespace': 'default-gzip',\n        },\n        'task_id': 23,\n      }\n      json.dump(data, f)\n\n    out_file = os.path.join(self.root_dir, 'work', 'task_runner_out.json')\n    task_runner.load_and_run(manifest, server, 3600., time.time(), out_file, 1)\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    with open(out_file, 'rb') as f:\n      self.assertEqual(expected, json.load(f))\n\n  def test_run_command_raw(self):\n    # This runs the command for real.\n    self.requests(cost_usd=1, exit_code=0)\n    task_details = self.get_task_details('print(\\'hi\\')')\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_run_command_isolated(self):\n    # This runs the command for real.\n    self.requests(\n        cost_usd=1, exit_code=0,\n        outputs_ref={\n          u'isolated': u'123',\n          u'isolatedserver': u'http://localhost:1',\n          u'namespace': u'default-gzip',\n        })\n    task_details = self.get_task_details(inputs_ref={\n      'isolated': '123',\n      'isolatedserver': 'localhost:1',\n      'namespace': 'default-gzip',\n    }, extra_args=['foo', 'bar'])\n    # Mock running run_isolated with a script.\n    SCRIPT_ISOLATED = (\n      'import json, sys;\\n'\n      'if len(sys.argv) != 2:\\n'\n      '  raise Exception(sys.argv);\\n'\n      'with open(sys.argv[1], \\'wb\\') as f:\\n'\n      '  json.dump({\\n'\n      '    \\'exit_code\\': 0,\\n'\n      '    \\'had_hard_timeout\\': False,\\n'\n      '    \\'internal_failure\\': None,\\n'\n      '    \\'outputs_ref\\': {\\n'\n      '      \\'isolated\\': \\'123\\',\\n'\n      '      \\'isolatedserver\\': \\'http://localhost:1\\',\\n'\n      '       \\'namespace\\': \\'default-gzip\\',\\n'\n      '    },\\n'\n      '  }, f)\\n'\n      'sys.stdout.write(\\'hi\\\\n\\')')\n    self.mock(\n        task_runner, 'get_isolated_cmd',\n        lambda _work_dir, _details, isolated_result, min_free_space:\n          [sys.executable, '-u', '-c', SCRIPT_ISOLATED, isolated_result])\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_run_command_fail(self):\n    # This runs the command for real.\n    self.requests(cost_usd=10., exit_code=1)\n    task_details = self.get_task_details(\n        'import sys; print(\\'hi\\'); sys.exit(1)')\n    expected = {\n      u'exit_code': 1,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_run_command_os_error(self):\n    # This runs the command for real.\n    # OS specific error, fix expectation for other OSes.\n    output = (\n      'Command \"executable_that_shouldnt_be_on_your_system '\n      'thus_raising_OSError\" failed to start.\\n'\n      'Error: [Error 2] The system cannot find the file specified'\n      ) if sys.platform == 'win32' else (\n      'Command \"executable_that_shouldnt_be_on_your_system '\n      'thus_raising_OSError\" failed to start.\\n'\n      'Error: [Errno 2] No such file or directory')\n    self.requests(cost_usd=10., exit_code=1, output=output)\n    task_details = task_runner.TaskDetails(\n        {\n          'bot_id': 'localhost',\n          'command': [\n            'executable_that_shouldnt_be_on_your_system',\n            'thus_raising_OSError',\n          ],\n          'env': {},\n          'extra_args': [],\n          'grace_period': 30.,\n          'hard_timeout': 6,\n          'inputs_ref': None,\n          'io_timeout': 6,\n          'task_id': 23,\n        })\n    expected = {\n      u'exit_code': -1,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_run_command_large(self):\n    # Method should have \"self\" as first argument - pylint: disable=E0213\n    class Popen(object):\n      \"\"\"Mocks the process so we can control how data is returned.\"\"\"\n      def __init__(self2, cmd, cwd, env, stdout, stderr, stdin, detached):\n        self.assertEqual(task_details.command, cmd)\n        self.assertEqual(self.work_dir, cwd)\n        expected_env = os.environ.copy()\n        expected_env['foo'] = 'bar'\n        self.assertEqual(expected_env, env)\n        self.assertEqual(subprocess42.PIPE, stdout)\n        self.assertEqual(subprocess42.STDOUT, stderr)\n        self.assertEqual(subprocess42.PIPE, stdin)\n        self.assertEqual(True, detached)\n        self2._out = [\n          'hi!\\n',\n          'hi!\\n',\n          'hi!\\n' * 100000,\n          'hi!\\n',\n        ]\n\n      def yield_any(self2, maxsize, timeout):\n        self.assertLess(0, maxsize)\n        self.assertLess(0, timeout)\n        for i in self2._out:\n          yield 'stdout', i\n\n      @staticmethod\n      def wait():\n        return 0\n\n      @staticmethod\n      def kill():\n        self.fail()\n\n    self.mock(subprocess42, 'Popen', Popen)\n\n    def check_final(kwargs):\n      self.assertEqual(\n          {\n            'data': {\n              # That's because the cost includes the duration starting at start,\n              # not when the process was started.\n              'cost_usd': 10.,\n              'duration': 0.,\n              'exit_code': 0,\n              'hard_timeout': False,\n              'id': 'localhost',\n              'io_timeout': False,\n              'output': base64.b64encode('hi!\\n'),\n              'output_chunk_start': 100002*4,\n              'task_id': 23,\n            },\n          },\n          kwargs)\n\n    requests = [\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        {\n          'data': {\n            'cost_usd': 10.,\n            'id': 'localhost',\n            'task_id': 23,\n          },\n        },\n        {},\n      ),\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        {\n          'data': {\n            'cost_usd': 10.,\n            'id': 'localhost',\n            'output': base64.b64encode('hi!\\n' * 100002),\n            'output_chunk_start': 0,\n            'task_id': 23,\n          },\n        },\n        {},\n      ),\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        check_final,\n        {},\n      ),\n    ]\n    self.expected_requests(requests)\n    task_details = task_runner.TaskDetails(\n        {\n          'bot_id': 'localhost',\n          'command': ['large', 'executable'],\n          'env': {'foo': 'bar'},\n          'extra_args': [],\n          'grace_period': 30.,\n          'hard_timeout': 60,\n          'inputs_ref': None,\n          'io_timeout': 60,\n          'task_id': 23,\n        })\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_main(self):\n    def load_and_run(\n        manifest, swarming_server, cost_usd_hour, start, json_file,\n        min_free_space):\n      self.assertEqual('foo', manifest)\n      self.assertEqual('http://localhost', swarming_server)\n      self.assertEqual(3600., cost_usd_hour)\n      self.assertEqual(time.time(), start)\n      self.assertEqual('task_summary.json', json_file)\n      self.assertEqual(1, min_free_space)\n\n    self.mock(task_runner, 'load_and_run', load_and_run)\n    cmd = [\n      '--swarming-server', 'http://localhost',\n      '--in-file', 'foo',\n      '--out-file', 'task_summary.json',\n      '--cost-usd-hour', '3600',\n      '--start', str(time.time()),\n      '--min-free-space', '1',\n    ]\n    self.assertEqual(0, task_runner.main(cmd))\n\n  def test_main_reboot(self):\n    def load_and_run(\n        manifest, swarming_server, cost_usd_hour, start, json_file,\n        min_free_space):\n      self.assertEqual('foo', manifest)\n      self.assertEqual('http://localhost', swarming_server)\n      self.assertEqual(3600., cost_usd_hour)\n      self.assertEqual(time.time(), start)\n      self.assertEqual('task_summary.json', json_file)\n      self.assertEqual(1, min_free_space)\n\n    self.mock(task_runner, 'load_and_run', load_and_run)\n    cmd = [\n      '--swarming-server', 'http://localhost',\n      '--in-file', 'foo',\n      '--out-file', 'task_summary.json',\n      '--cost-usd-hour', '3600',\n      '--start', str(time.time()),\n      '--min-free-space', '1',\n    ]\n    self.assertEqual(0, task_runner.main(cmd))\n\n\nclass TestTaskRunnerNoTimeMock(TestTaskRunnerBase):\n  # Do not mock time.time() for these tests otherwise it becomes a tricky\n  # implementation detail check.\n  # These test cases run the command for real.\n\n  # TODO(maruel): Calculate this value automatically through iteration?\n  SHORT_TIME_OUT = 0.3\n\n  # Here's a simple script that handles signals properly. Sadly SIGBREAK is not\n  # defined on posix.\n  SCRIPT_SIGNAL = (\n    'import signal, sys, time;\\n'\n    'l = [];\\n'\n    'def handler(signum, _):\\n'\n    '  l.append(signum);\\n'\n    '  print(\\'got signal %%d\\' %% signum);\\n'\n    '  sys.stdout.flush();\\n'\n    'signal.signal(%s, handler);\\n'\n    'print(\\'hi\\');\\n'\n    'sys.stdout.flush();\\n'\n    'while not l:\\n'\n    '  try:\\n'\n    '    time.sleep(0.01);\\n'\n    '  except IOError:\\n'\n    '    pass;\\n'\n    'print(\\'bye\\')') % (\n        'signal.SIGBREAK' if sys.platform == 'win32' else 'signal.SIGTERM')\n\n  SCRIPT_SIGNAL_HANG = (\n    'import signal, sys, time;\\n'\n    'l = [];\\n'\n    'def handler(signum, _):\\n'\n    '  l.append(signum);\\n'\n    '  print(\\'got signal %%d\\' %% signum);\\n'\n    '  sys.stdout.flush();\\n'\n    'signal.signal(%s, handler);\\n'\n    'print(\\'hi\\');\\n'\n    'sys.stdout.flush();\\n'\n    'while not l:\\n'\n    '  try:\\n'\n    '    time.sleep(0.01);\\n'\n    '  except IOError:\\n'\n    '    pass;\\n'\n    'print(\\'bye\\');\\n'\n    'time.sleep(100)') % (\n        'signal.SIGBREAK' if sys.platform == 'win32' else 'signal.SIGTERM')\n\n  SCRIPT_HANG = 'import time; print(\\'hi\\'); time.sleep(100)'\n\n  def get_check_final(\n      self, hard_timeout=False, io_timeout=False, exit_code=None,\n      output='hi\\n'):\n    def check_final(kwargs):\n      if hard_timeout or io_timeout:\n        self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('cost_usd'))\n        self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('duration'))\n      else:\n        self.assertLess(0., kwargs['data'].pop('cost_usd'))\n        self.assertLess(0., kwargs['data'].pop('duration'))\n      # It makes the diffing easier.\n      kwargs['data']['output'] = base64.b64decode(kwargs['data']['output'])\n      self.assertEqual(\n          {\n            'data': {\n              'exit_code': exit_code,\n              'hard_timeout': hard_timeout,\n              'id': 'localhost',\n              'io_timeout': io_timeout,\n              'output': output,\n              'output_chunk_start': 0,\n              'task_id': 23,\n            },\n          },\n          kwargs)\n    return check_final\n\n  def _load_and_run(self, manifest):\n    # Dot not mock time since this test class is testing timeouts.\n    server = 'https://localhost:1'\n    in_file = os.path.join(self.work_dir, 'task_runner_in.json')\n    with open(in_file, 'wb') as f:\n      json.dump(manifest, f)\n    out_file = os.path.join(self.work_dir, 'task_runner_out.json')\n    task_runner.load_and_run(in_file, server, 3600., time.time(), out_file, 1)\n    with open(out_file, 'rb') as f:\n      return json.load(f)\n\n  def _run_command(self, task_details):\n    # Dot not mock time since this test class is testing timeouts.\n    server = 'https://localhost:1'\n    return task_runner.run_command(\n        server, task_details, self.work_dir, 3600., time.time(), 1)\n\n  def test_hard(self):\n    # Actually 0xc000013a\n    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM\n    self.requests(hard_timeout=True, exit_code=sig)\n    task_details = self.get_task_details(\n        self.SCRIPT_HANG, hard_timeout=self.SHORT_TIME_OUT)\n    expected = {\n      u'exit_code': sig,\n      u'hard_timeout': True,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_io(self):\n    # Actually 0xc000013a\n    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM\n    self.requests(io_timeout=True, exit_code=sig)\n    task_details = self.get_task_details(\n        self.SCRIPT_HANG, io_timeout=self.SHORT_TIME_OUT)\n    expected = {\n      u'exit_code': sig,\n      u'hard_timeout': False,\n      u'io_timeout': True,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_hard_signal(self):\n    self.requests(\n        hard_timeout=True,\n        exit_code=0,\n        output='hi\\ngot signal %d\\nbye\\n' % task_runner.SIG_BREAK_OR_TERM)\n    task_details = self.get_task_details(\n        self.SCRIPT_SIGNAL, hard_timeout=self.SHORT_TIME_OUT)\n    # Returns 0 because the process cleaned up itself.\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': True,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_io_signal(self):\n    self.requests(\n        io_timeout=True, exit_code=0,\n        output='hi\\ngot signal %d\\nbye\\n' % task_runner.SIG_BREAK_OR_TERM)\n    task_details = self.get_task_details(\n        self.SCRIPT_SIGNAL, io_timeout=self.SHORT_TIME_OUT)\n    # Returns 0 because the process cleaned up itself.\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': False,\n      u'io_timeout': True,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_hard_no_grace(self):\n    # Actually 0xc000013a\n    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM\n    self.requests(hard_timeout=True, exit_code=sig)\n    task_details = self.get_task_details(\n        self.SCRIPT_HANG, hard_timeout=self.SHORT_TIME_OUT,\n        grace_period=self.SHORT_TIME_OUT)\n    expected = {\n      u'exit_code': sig,\n      u'hard_timeout': True,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_io_no_grace(self):\n    # Actually 0xc000013a\n    sig = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM\n    self.requests(io_timeout=True, exit_code=sig)\n    task_details = self.get_task_details(\n        self.SCRIPT_HANG, io_timeout=self.SHORT_TIME_OUT,\n        grace_period=self.SHORT_TIME_OUT)\n    expected = {\n      u'exit_code': sig,\n      u'hard_timeout': False,\n      u'io_timeout': True,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_hard_signal_no_grace(self):\n    exit_code = 1 if sys.platform == 'win32' else -signal.SIGKILL\n    self.requests(\n        hard_timeout=True, exit_code=exit_code,\n        output='hi\\ngot signal %d\\nbye\\n' % task_runner.SIG_BREAK_OR_TERM)\n    task_details = self.get_task_details(\n        self.SCRIPT_SIGNAL_HANG, hard_timeout=self.SHORT_TIME_OUT,\n        grace_period=self.SHORT_TIME_OUT)\n    # Returns 0 because the process cleaned up itself.\n    expected = {\n      u'exit_code': exit_code,\n      u'hard_timeout': True,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_io_signal_no_grace(self):\n    exit_code = 1 if sys.platform == 'win32' else -signal.SIGKILL\n    self.requests(\n        io_timeout=True, exit_code=exit_code,\n        output='hi\\ngot signal %d\\nbye\\n' % task_runner.SIG_BREAK_OR_TERM)\n    task_details = self.get_task_details(\n        self.SCRIPT_SIGNAL_HANG, io_timeout=self.SHORT_TIME_OUT,\n        grace_period=self.SHORT_TIME_OUT)\n    # Returns 0 because the process cleaned up itself.\n    expected = {\n      u'exit_code': exit_code,\n      u'hard_timeout': False,\n      u'io_timeout': True,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual(expected, self._run_command(task_details))\n\n  def test_isolated_grand_children(self):\n    \"\"\"Runs a normal test involving 3 level deep subprocesses.\"\"\"\n    # Uses load_and_run()\n    files = {\n      'parent.py': (\n        'import subprocess, sys\\n'\n        'sys.exit(subprocess.call([sys.executable,\\'-u\\',\\'children.py\\']))\\n'),\n      'children.py': (\n        'import subprocess, sys\\n'\n        'sys.exit(subprocess.call('\n            '[sys.executable, \\'-u\\', \\'grand_children.py\\']))\\n'),\n      'grand_children.py': 'print \\'hi\\'',\n    }\n\n    def check_final(kwargs):\n      # Warning: this modifies input arguments.\n      self.assertLess(0, kwargs['data'].pop('cost_usd'))\n      self.assertLess(0, kwargs['data'].pop('bot_overhead'))\n      self.assertLess(0, kwargs['data'].pop('duration'))\n      self.assertLess(\n          0., kwargs['data']['isolated_stats']['download'].pop('duration'))\n      # duration==0 can happen on Windows when the clock is in the default\n      # resolution, 15.6ms.\n      self.assertLessEqual(\n          0., kwargs['data']['isolated_stats']['upload'].pop('duration'))\n      # Makes the diffing easier.\n      kwargs['data']['output'] = base64.b64decode(kwargs['data']['output'])\n      for k in ('download', 'upload'):\n        for j in ('items_cold', 'items_hot'):\n          kwargs['data']['isolated_stats'][k][j] = large.unpack(\n              base64.b64decode(kwargs['data']['isolated_stats'][k][j]))\n      self.assertEqual(\n          {\n            'data': {\n              'exit_code': 0,\n              'hard_timeout': False,\n              'id': u'localhost',\n              'io_timeout': False,\n              'isolated_stats': {\n                u'download': {\n                  u'initial_number_items': 0,\n                  u'initial_size': 0,\n                  u'items_cold': [10, 86, 94, 276],\n                  u'items_hot': [],\n                },\n                u'upload': {\n                  u'items_cold': [],\n                  u'items_hot': [],\n                },\n              },\n              'output': 'hi\\n',\n              'output_chunk_start': 0,\n              'task_id': 23,\n            },\n          },\n          kwargs)\n    requests = [\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        self.get_check_first(0.),\n        {},\n      ),\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        check_final,\n        {},\n      ),\n    ]\n    self.expected_requests(requests)\n\n    server = isolateserver_mock.MockIsolateServer()\n    try:\n      isolated = json.dumps({\n        'command': ['python', 'parent.py'],\n        'files': {\n          name: {\n            'h': server.add_content_compressed('default-gzip', content),\n            's': len(content),\n          } for name, content in files.iteritems()\n        },\n      })\n      isolated_digest = server.add_content_compressed('default-gzip', isolated)\n      manifest = get_manifest(\n          inputs_ref={\n            'isolated': isolated_digest,\n            'namespace': 'default-gzip',\n            'isolatedserver': server.url,\n          })\n      expected = {\n        u'exit_code': 0,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure': None,\n        u'version': task_runner.OUT_VERSION,\n      }\n      self.assertEqual(expected, self._load_and_run(manifest))\n    finally:\n      server.close()\n\n  def test_isolated_io_signal_no_grace_grand_children(self):\n    \"\"\"Handles grand-children process hanging and signal management.\n\n    In this case, the I/O timeout is implemented by task_runner. An hard timeout\n    would be implemented by run_isolated (depending on overhead).\n    \"\"\"\n    # Uses load_and_run()\n    # https://msdn.microsoft.com/library/cc704588.aspx\n    # STATUS_CONTROL_C_EXIT=0xC000013A. Python sees it as -1073741510.\n    exit_code = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM\n\n    files = {\n      'parent.py': (\n        'import subprocess, sys\\n'\n        'print(\\'parent\\')\\n'\n        'p = subprocess.Popen([sys.executable, \\'-u\\', \\'children.py\\'])\\n'\n        'print(p.pid)\\n'\n        'p.wait()\\n'\n        'sys.exit(p.returncode)\\n'),\n      'children.py': (\n        'import subprocess, sys\\n'\n        'print(\\'children\\')\\n'\n        'p = subprocess.Popen([sys.executable,\\'-u\\',\\'grand_children.py\\'])\\n'\n        'print(p.pid)\\n'\n        'p.wait()\\n'\n        'sys.exit(p.returncode)\\n'),\n      'grand_children.py': self.SCRIPT_SIGNAL_HANG,\n    }\n    # We need to catch the pid of the grand children to be able to kill it, so\n    # create our own check_final() instead of using self._gen_requests().\n    to_kill = []\n    def check_final(kwargs):\n      self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('cost_usd'))\n      self.assertLess(self.SHORT_TIME_OUT, kwargs['data'].pop('duration'))\n      self.assertLess(0., kwargs['data'].pop('bot_overhead'))\n      self.assertLess(\n          0., kwargs['data']['isolated_stats']['download'].pop('duration'))\n      self.assertLess(\n          0., kwargs['data']['isolated_stats']['upload'].pop('duration'))\n      # Makes the diffing easier.\n      for k in ('download', 'upload'):\n        for j in ('items_cold', 'items_hot'):\n          kwargs['data']['isolated_stats'][k][j] = large.unpack(\n              base64.b64decode(kwargs['data']['isolated_stats'][k][j]))\n      # The command print the pid of this child and grand-child processes, each\n      # on its line.\n      output = base64.b64decode(kwargs['data'].pop('output', ''))\n      for line in output.splitlines():\n        try:\n          to_kill.append(int(line))\n        except ValueError:\n          pass\n      self.assertEqual(\n          {\n            'data': {\n              'exit_code': exit_code,\n              'hard_timeout': False,\n              'id': u'localhost',\n              'io_timeout': True,\n              'isolated_stats': {\n                u'download': {\n                  u'initial_number_items': 0,\n                  u'initial_size': 0,\n                  u'items_cold': [144, 150, 285, 307],\n                  u'items_hot': [],\n                },\n                u'upload': {\n                  u'items_cold': [],\n                  u'items_hot': [],\n                },\n              },\n              'output_chunk_start': 0,\n              'task_id': 23,\n            },\n          },\n          kwargs)\n    requests = [\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        self.get_check_first(0.),\n        {},\n      ),\n      (\n        'https://localhost:1/swarming/api/v1/bot/task_update/23',\n        check_final,\n        {},\n      ),\n    ]\n    self.expected_requests(requests)\n\n    server = isolateserver_mock.MockIsolateServer()\n    try:\n      # TODO(maruel): -u is needed if you don't want python buffering to\n      # interfere.\n      isolated = json.dumps({\n        'command': ['python', '-u', 'parent.py'],\n        'files': {\n          name: {\n            'h': server.add_content_compressed('default-gzip', content),\n            's': len(content),\n          } for name, content in files.iteritems()\n        },\n      })\n      isolated_digest = server.add_content_compressed('default-gzip', isolated)\n      try:\n        manifest = get_manifest(\n            inputs_ref={\n              'isolated': isolated_digest,\n              'namespace': 'default-gzip',\n              'isolatedserver': server.url,\n            },\n            # TODO(maruel): A bit cheezy, we'd want the I/O timeout to be just\n            # enough to have the time for the PID to be printed but not more.\n            io_timeout=1,\n            grace_period=self.SHORT_TIME_OUT)\n        expected = {\n          u'exit_code': exit_code,\n          u'hard_timeout': False,\n          u'io_timeout': True,\n          u'must_signal_internal_failure': None,\n          u'version': task_runner.OUT_VERSION,\n        }\n        self.assertEqual(expected, self._load_and_run(manifest))\n        self.assertEqual(2, len(to_kill))\n      finally:\n        for k in to_kill:\n          try:\n            if sys.platform == 'win32':\n              os.kill(k, signal.SIGTERM)\n            else:\n              os.kill(k, signal.SIGKILL)\n          except OSError:\n            pass\n    finally:\n      server.close()\n\n\nclass TaskRunnerSmoke(unittest.TestCase):\n  # Runs a real process and a real Swarming fake server.\n  def setUp(self):\n    super(TaskRunnerSmoke, self).setUp()\n    self.root_dir = tempfile.mkdtemp(prefix='task_runner')\n    logging.info('Temp: %s', self.root_dir)\n    self._server = fake_swarming.Server(self)\n\n  def tearDown(self):\n    try:\n      self._server.shutdown()\n    finally:\n      try:\n        file_path.rmtree(self.root_dir)\n      except OSError:\n        print >> sys.stderr, 'Failed to delete %s' % self.root_dir\n      finally:\n        super(TaskRunnerSmoke, self).tearDown()\n\n  def test_signal(self):\n    # Tests when task_runner gets a SIGTERM.\n\n    # https://msdn.microsoft.com/library/cc704588.aspx\n    # STATUS_ENTRYPOINT_NOT_FOUND=0xc0000139. Python sees it as -1073741510.\n    exit_code = -1073741510 if sys.platform == 'win32' else -signal.SIGTERM\n\n    os.mkdir(os.path.join(self.root_dir, 'work'))\n    signal_file = os.path.join(self.root_dir, 'work', 'signal')\n    open(signal_file, 'wb').close()\n    manifest = get_manifest(\n        script='import os,time;os.remove(%r);time.sleep(60)' % signal_file,\n        hard_timeout=60., io_timeout=60.)\n    task_in_file = os.path.join(self.root_dir, 'task_runner_in.json')\n    task_result_file = os.path.join(self.root_dir, 'task_runner_out.json')\n    with open(task_in_file, 'wb') as f:\n      json.dump(manifest, f)\n    bot = os.path.join(self.root_dir, 'swarming_bot.1.zip')\n    code, _ = fake_swarming.gen_zip(self._server.url)\n    with open(bot, 'wb') as f:\n      f.write(code)\n    cmd = [\n      sys.executable, bot, 'task_runner',\n      '--swarming-server', self._server.url,\n      '--in-file', task_in_file,\n      '--out-file', task_result_file,\n      '--cost-usd-hour', '1',\n      # Include the time taken to poll the task in the cost.\n      '--start', str(time.time()),\n    ]\n    logging.info('%s', cmd)\n    proc = subprocess42.Popen(cmd, cwd=self.root_dir, detached=True)\n    # Wait for the child process to be alive.\n    while os.path.isfile(signal_file):\n      time.sleep(0.01)\n    # Send SIGTERM to task_runner itself. Ensure the right thing happen.\n    # Note that on Windows, this is actually sending a SIGBREAK since there's no\n    # such thing as SIGTERM.\n    proc.send_signal(signal.SIGTERM)\n    proc.wait()\n    task_runner_log = os.path.join(self.root_dir, 'logs', 'task_runner.log')\n    with open(task_runner_log, 'rb') as f:\n      logging.info('task_runner.log:\\n---\\n%s---', f.read())\n    expected = {\n      u'exit_code': 0,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure': None,\n      u'version': task_runner.OUT_VERSION,\n    }\n    self.assertEqual([], self._server.get_events())\n    tasks = self._server.get_tasks()\n    for task in tasks.itervalues():\n      for event in task:\n        event.pop('cost_usd')\n        event.pop('duration', None)\n        event.pop('bot_overhead', None)\n    expected = {\n      '23': [\n        {\n          u'id': u'localhost',\n          u'task_id': 23,\n        },\n        {\n          u'exit_code': exit_code,\n          u'hard_timeout': False,\n          u'id': u'localhost',\n          u'io_timeout': False,\n          u'task_id': 23,\n        },\n      ],\n    }\n    self.assertEqual(expected, tasks)\n    expected = {\n      'swarming_bot.1.zip',\n      '4e019f31778ba7191f965469dc673280386bbd60-cacert.pem',\n      'work',\n      'logs',\n      # TODO(maruel): Move inside work.\n      'task_runner_in.json',\n      'task_runner_out.json',\n    }\n    self.assertEqual(expected, set(os.listdir(self.root_dir)))\n    expected = {\n      u'exit_code': exit_code,\n      u'hard_timeout': False,\n      u'io_timeout': False,\n      u'must_signal_internal_failure':\n          u'task_runner received signal %d' % task_runner.SIG_BREAK_OR_TERM,\n      u'version': 3,\n    }\n    with open(task_result_file, 'rb') as f:\n      self.assertEqual(expected, json.load(f))\n    self.assertEqual(0, proc.returncode)\n\n\nif __name__ == '__main__':\n  fix_encoding.fix_encoding()\n  if '-v' in sys.argv:\n    unittest.TestCase.maxDiff = None\n  logging_utils.prepare_logging(None)\n  logging_utils.set_console_level(\n      logging.DEBUG if '-v' in sys.argv else logging.CRITICAL+1)\n  # Fix litteral text expectation.\n  os.environ['LANG'] = 'en_US.UTF-8'\n  os.environ['LANGUAGE'] = 'en_US.UTF-8'\n  unittest.main()\n/n/n/nappengine/swarming/swarming_bot/bot_code/xsrf_client.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Wraps URL requests with an XSRF token using components/auth based service.\"\"\"\n\nimport datetime\nimport logging\nimport os\nimport sys\n\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\n\nsys.path.insert(0, os.path.join(THIS_DIR, 'third_party'))\n\nfrom utils import net\n\n\nclass Error(Exception):\n  pass\n\n\ndef _utcnow():\n  \"\"\"So it can be mocked.\"\"\"\n  return datetime.datetime.utcnow()\n\n\nclass XsrfRemote(object):\n  \"\"\"Transparently adds XSRF token to requests.\"\"\"\n  TOKEN_RESOURCE = '/auth/api/v1/accounts/self/xsrf_token'\n\n  def __init__(self, url, token_resource=None):\n    self.url = url.rstrip('/')\n    self.token = None\n    self.token_resource = token_resource or self.TOKEN_RESOURCE\n    self.expiration = None\n    self.xsrf_request_params = {}\n\n  def url_read(self, resource, **kwargs):\n    url = self.url + resource\n    if kwargs.get('data') == None:\n      # No XSRF token for GET.\n      return net.url_read(url, **kwargs)\n\n    if self.need_refresh():\n      self.refresh_token()\n    resp = self._url_read_post(url, **kwargs)\n    if resp is None:\n      raise Error('Failed to connect to %s; %s' % (url, self.expiration))\n    return resp\n\n  def url_read_json(self, resource, **kwargs):\n    url = self.url + resource\n    if kwargs.get('data') == None:\n      # No XSRF token required for GET.\n      return net.url_read_json(url, **kwargs)\n\n    if self.need_refresh():\n      self.refresh_token()\n    resp = self._url_read_json_post(url, **kwargs)\n    if resp is None:\n      raise Error('Failed to connect to %s; %s' % (url, self.expiration))\n    return resp\n\n  def refresh_token(self):\n    \"\"\"Returns a fresh token. Necessary as the token may expire after an hour.\n    \"\"\"\n    url = self.url + self.token_resource\n    resp = net.url_read_json(\n        url,\n        headers={'X-XSRF-Token-Request': '1'},\n        data=self.xsrf_request_params)\n    if resp is None:\n      raise Error('Failed to connect to %s' % url)\n    self.token = resp['xsrf_token']\n    if resp.get('expiration_sec'):\n      exp = resp['expiration_sec']\n      exp -= min(round(exp * 0.1), 600)\n      self.expiration = _utcnow() + datetime.timedelta(seconds=exp)\n    return self.token\n\n  def need_refresh(self):\n    \"\"\"Returns True if the XSRF token needs to be refreshed.\"\"\"\n    return (\n        not self.token or (self.expiration and self.expiration <= _utcnow()))\n\n  def _url_read_post(self, url, **kwargs):\n    headers = (kwargs.pop('headers', None) or {}).copy()\n    headers['X-XSRF-Token'] = self.token\n    return net.url_read(url, headers=headers, **kwargs)\n\n  def _url_read_json_post(self, url, **kwargs):\n    headers = (kwargs.pop('headers', None) or {}).copy()\n    headers['X-XSRF-Token'] = self.token\n    return net.url_read_json(url, headers=headers, **kwargs)\n/n/n/nappengine/swarming/swarming_bot/bot_code/xsrf_client_test.py/n/n#!/usr/bin/env python\n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport datetime\nimport logging\nimport os\nimport sys\nimport time\nimport unittest\n\nimport test_env_bot_code\ntest_env_bot_code.setup_test_env()\n\n# Creates a server mock for functions in net.py.\nimport net_utils\n\nimport xsrf_client\n\n\nclass UrlHelperTest(net_utils.TestCase):\n  def setUp(self):\n    super(UrlHelperTest, self).setUp()\n    self.mock(logging, 'error', lambda *_: None)\n    self.mock(logging, 'exception', lambda *_: None)\n    self.mock(logging, 'info', lambda *_: None)\n    self.mock(logging, 'warning', lambda *_: None)\n    self.mock(time, 'sleep', lambda _: None)\n\n  def testXsrfRemoteGET(self):\n    self.expected_requests([('http://localhost/a', {}, 'foo', None)])\n\n    remote = xsrf_client.XsrfRemote('http://localhost/')\n    self.assertEqual('foo', remote.url_read('/a'))\n\n  def testXsrfRemoteSimple(self):\n    self.expected_requests(\n        [\n          (\n            'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {\n              'expiration_sec': 100,\n              'xsrf_token': 'token',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},\n            'foo',\n            None,\n          ),\n        ])\n\n    remote = xsrf_client.XsrfRemote('http://localhost/')\n    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))\n\n  def testXsrfRemoteRefresh(self):\n    self.expected_requests(\n        [\n          (\n            'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {\n              'expiration_sec': 100,\n              'xsrf_token': 'token',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},\n            'bar',\n            None,\n          ),\n          (\n            'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {\n              'expiration_sec': 100,\n              'xsrf_token': 'token2',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token2'}},\n            'foo',\n            None,\n          ),\n        ])\n\n    now = xsrf_client._utcnow()\n    remote = xsrf_client.XsrfRemote('http://localhost/')\n    remote.url_read('/a', data={'foo': 'bar'})\n    self.mock(\n        xsrf_client, '_utcnow', lambda: now + datetime.timedelta(seconds=91))\n    remote.url_read('/a', data={'foo': 'bar'})\n\n  def testXsrfRemoteCustom(self):\n    # Use the new swarming bot API as an example of custom XSRF request handler.\n    self.expected_requests(\n        [\n          (\n            'http://localhost/swarming/api/v1/bot/handshake',\n            {\n              'data': {'attributes': 'b'},\n              'headers': {'X-XSRF-Token-Request': '1'},\n            },\n            {\n              'expiration_sec': 100,\n              'ignored': True,\n              'xsrf_token': 'token',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},\n            'foo',\n            None,\n          ),\n        ])\n\n    remote = xsrf_client.XsrfRemote(\n        'http://localhost/',\n        '/swarming/api/v1/bot/handshake')\n    remote.xsrf_request_params = {'attributes': 'b'}\n    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))\n\n\nif __name__ == '__main__':\n  logging.basicConfig(level=logging.ERROR)\n  unittest.main()\n/n/n/nclient/tests/net_utils.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport logging\nimport os\nimport sys\nimport threading\n\nTEST_DIR = os.path.dirname(os.path.abspath(__file__))\nROOT_DIR = os.path.dirname(TEST_DIR)\nsys.path.insert(0, ROOT_DIR)\nsys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))\n\nfrom depot_tools import auto_stub\nfrom utils import net\n\n\ndef make_fake_response(content, url, headers=None):\n  \"\"\"Returns HttpResponse with predefined content, useful in tests.\"\"\"\n  headers = dict(headers or {})\n  headers['Content-Length'] = len(content)\n  class _Fake(object):\n    def __init__(self):\n      self.content = content\n    def iter_content(self, chunk_size):\n      c = self.content\n      while c:\n        yield c[:chunk_size]\n        c = c[chunk_size:]\n    def read(self):\n      return self.content\n  return net.HttpResponse(_Fake(), url, headers)\n\n\nclass TestCase(auto_stub.TestCase):\n  \"\"\"Mocks out url_open() calls.\"\"\"\n  def setUp(self):\n    super(TestCase, self).setUp()\n    self.mock(net, 'url_open', self._url_open)\n    self.mock(net, 'url_read_json', self._url_read_json)\n    self.mock(net, 'sleep_before_retry', lambda *_: None)\n    self._lock = threading.Lock()\n    self._requests = []\n\n  def tearDown(self):\n    try:\n      if not self.has_failed():\n        self.assertEqual([], self._requests)\n    finally:\n      super(TestCase, self).tearDown()\n\n  def expected_requests(self, requests):\n    \"\"\"Registers the expected requests along their reponses.\n\n    Arguments:\n      request: list of tuple(url, kwargs, response, headers) for normal requests\n          and tuple(url, kwargs, response) for json requests. kwargs can be a\n          callable. In that case, it's called with the actual kwargs. It's\n          useful when the kwargs values are not deterministic.\n    \"\"\"\n    requests = requests[:]\n    for request in requests:\n      self.assertEqual(tuple, request.__class__)\n      # 3 = json request (url_read_json).\n      # 4 = normal request (url_open).\n      self.assertIn(len(request), (3, 4))\n\n    with self._lock:\n      self.assertEqual([], self._requests)\n      self._requests = requests\n\n  def _url_open(self, url, **kwargs):\n    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])\n    with self._lock:\n      if not self._requests:\n        return None\n      # Ignore 'stream' argument, it's not important for these tests.\n      kwargs.pop('stream', None)\n      for i, n in enumerate(self._requests):\n        if n[0] == url:\n          data = self._requests.pop(i)\n          if len(data) != 4:\n            self.fail('Expected normal request, got json data; %s' % url)\n          _, expected_kwargs, result, headers = data\n          if callable(expected_kwargs):\n            expected_kwargs(kwargs)\n          else:\n            self.assertEqual(expected_kwargs, kwargs)\n          if result is not None:\n            return make_fake_response(result, url, headers)\n          return None\n    self.fail('Unknown request %s' % url)\n\n  def _url_read_json(self, url, **kwargs):\n    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])\n    with self._lock:\n      if not self._requests:\n        return None\n      # Ignore 'stream' argument, it's not important for these tests.\n      kwargs.pop('stream', None)\n      for i, n in enumerate(self._requests):\n        if n[0] == url:\n          data = self._requests.pop(i)\n          if len(data) != 3:\n            self.fail('Expected json request, got normal data; %s' % url)\n          _, expected_kwargs, result = data\n          if callable(expected_kwargs):\n            expected_kwargs(kwargs)\n          else:\n            self.assertEqual(expected_kwargs, kwargs)\n          if result is not None:\n            return result\n          return None\n    self.fail('Unknown request %s %s' % (url, kwargs))\n/n/n/n", "label": 0}, {"id": "c23a5bf6278f55b3f8135e0edab9927599a09236", "code": "/appengine/swarming/handlers_bot.py/n/n# Copyright 2015 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Internal bot API handlers.\"\"\"\n\nimport base64\nimport json\nimport logging\nimport textwrap\n\nimport webob\nimport webapp2\n\nfrom google.appengine.api import app_identity\nfrom google.appengine.api import datastore_errors\nfrom google.appengine.datastore import datastore_query\nfrom google.appengine import runtime\nfrom google.appengine.ext import ndb\n\nfrom components import auth\nfrom components import ereporter2\nfrom components import utils\nfrom server import acl\nfrom server import bot_code\nfrom server import bot_management\nfrom server import stats\nfrom server import task_pack\nfrom server import task_request\nfrom server import task_result\nfrom server import task_scheduler\nfrom server import task_to_run\n\n\ndef has_unexpected_subset_keys(expected_keys, minimum_keys, actual_keys, name):\n  \"\"\"Returns an error if unexpected keys are present or expected keys are\n  missing.\n\n  Accepts optional keys.\n\n  This is important to catch typos.\n  \"\"\"\n  actual_keys = frozenset(actual_keys)\n  superfluous = actual_keys - expected_keys\n  missing = minimum_keys - actual_keys\n  if superfluous or missing:\n    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''\n    msg_superfluous = (\n        (' superfluous: %s' % sorted(superfluous)) if superfluous else '')\n    return 'Unexpected %s%s%s; did you make a typo?' % (\n        name, msg_missing, msg_superfluous)\n\n\ndef has_unexpected_keys(expected_keys, actual_keys, name):\n  \"\"\"Return an error if unexpected keys are present or expected keys are\n  missing.\n  \"\"\"\n  return has_unexpected_subset_keys(\n      expected_keys, expected_keys, actual_keys, name)\n\n\ndef log_unexpected_subset_keys(\n    expected_keys, minimum_keys, actual_keys, request, source, name):\n  \"\"\"Logs an error if unexpected keys are present or expected keys are missing.\n\n  Accepts optional keys.\n\n  This is important to catch typos.\n  \"\"\"\n  message = has_unexpected_subset_keys(\n    expected_keys, minimum_keys, actual_keys, name)\n  if message:\n    ereporter2.log_request(request, source=source, message=message)\n  return message\n\n\ndef log_unexpected_keys(expected_keys, actual_keys, request, source, name):\n  \"\"\"Logs an error if unexpected keys are present or expected keys are missing.\n  \"\"\"\n  return log_unexpected_subset_keys(\n      expected_keys, expected_keys, actual_keys, request, source, name)\n\n\ndef has_missing_keys(minimum_keys, actual_keys, name):\n  \"\"\"Returns an error if expected keys are not present.\n\n  Do not warn about unexpected keys.\n  \"\"\"\n  actual_keys = frozenset(actual_keys)\n  missing = minimum_keys - actual_keys\n  if missing:\n    msg_missing = (' missing: %s' % sorted(missing)) if missing else ''\n    return 'Unexpected %s%s; did you make a typo?' % (name, msg_missing)\n\n\nclass BootstrapHandler(auth.AuthenticatingHandler):\n  \"\"\"Returns python code to run to bootstrap a swarming bot.\"\"\"\n\n  @auth.require(acl.is_bot)\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/x-python'\n    self.response.headers['Content-Disposition'] = (\n        'attachment; filename=\"swarming_bot_bootstrap.py\"')\n    self.response.out.write(\n        bot_code.get_bootstrap(self.request.host_url).content)\n\n\nclass BotCodeHandler(auth.AuthenticatingHandler):\n  \"\"\"Returns a zip file with all the files required by a bot.\n\n  Optionally specify the hash version to download. If so, the returned data is\n  cacheable.\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def get(self, version=None):\n    if version:\n      expected = bot_code.get_bot_version(self.request.host_url)\n      if version != expected:\n        # This can happen when the server is rapidly updated.\n        logging.error('Requested Swarming bot %s, have %s', version, expected)\n        self.abort(404)\n      self.response.headers['Cache-Control'] = 'public, max-age=3600'\n    else:\n      self.response.headers['Cache-Control'] = 'no-cache, no-store'\n    self.response.headers['Content-Type'] = 'application/octet-stream'\n    self.response.headers['Content-Disposition'] = (\n        'attachment; filename=\"swarming_bot.zip\"')\n    self.response.out.write(\n        bot_code.get_swarming_bot_zip(self.request.host_url))\n\n\nclass _BotBaseHandler(auth.ApiHandler):\n  \"\"\"\n  Request body is a JSON dict:\n    {\n      \"dimensions\": <dict of properties>,\n      \"state\": <dict of properties>,\n      \"version\": <sha-1 of swarming_bot.zip uncompressed content>,\n    }\n  \"\"\"\n\n  EXPECTED_KEYS = {u'dimensions', u'state', u'version'}\n  REQUIRED_STATE_KEYS = {u'running_time', u'sleep_streak'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  def _process(self):\n    \"\"\"Returns True if the bot has invalid parameter and should be automatically\n    quarantined.\n\n    Does one DB synchronous GET.\n\n    Returns:\n      tuple(request, bot_id, version, state, dimensions, quarantined_msg)\n    \"\"\"\n    request = self.parse_body()\n    version = request.get('version', None)\n\n    dimensions = request.get('dimensions', {})\n    state = request.get('state', {})\n    bot_id = None\n    if dimensions.get('id'):\n      dimension_id = dimensions['id']\n      if (isinstance(dimension_id, list) and len(dimension_id) == 1\n          and isinstance(dimension_id[0], unicode)):\n        bot_id = dimensions['id'][0]\n\n    # The bot may decide to \"self-quarantine\" itself. Accept both via\n    # dimensions or via state. See bot_management._BotCommon.quarantined for\n    # more details.\n    if (bool(dimensions.get('quarantined')) or\n        bool(state.get('quarantined'))):\n      return request, bot_id, version, state, dimensions, 'Bot self-quarantined'\n\n    quarantined_msg = None\n    # Use a dummy 'for' to be able to break early from the block.\n    for _ in [0]:\n\n      quarantined_msg = has_unexpected_keys(\n          self.EXPECTED_KEYS, request, 'keys')\n      if quarantined_msg:\n        break\n\n      quarantined_msg = has_missing_keys(\n          self.REQUIRED_STATE_KEYS, state, 'state')\n      if quarantined_msg:\n        break\n\n      if not bot_id:\n        quarantined_msg = 'Missing bot id'\n        break\n\n      if not all(\n          isinstance(key, unicode) and\n          isinstance(values, list) and\n          all(isinstance(value, unicode) for value in values)\n          for key, values in dimensions.iteritems()):\n        quarantined_msg = (\n            'Invalid dimensions type:\\n%s' % json.dumps(dimensions,\n              sort_keys=True, indent=2, separators=(',', ': ')))\n        break\n\n      dimensions_count = task_to_run.dimensions_powerset_count(dimensions)\n      if dimensions_count > task_to_run.MAX_DIMENSIONS:\n        quarantined_msg = 'Dimensions product %d is too high' % dimensions_count\n        break\n\n      if not isinstance(\n          state.get('lease_expiration_ts'), (None.__class__, int)):\n        quarantined_msg = (\n            'lease_expiration_ts (%r) must be int or None' % (\n                state['lease_expiration_ts']))\n        break\n\n    if quarantined_msg:\n      line = 'Quarantined Bot\\nhttps://%s/restricted/bot/%s\\n%s' % (\n          app_identity.get_default_version_hostname(), bot_id,\n          quarantined_msg)\n      ereporter2.log_request(self.request, source='bot', message=line)\n      return request, bot_id, version, state, dimensions, quarantined_msg\n\n    # Look for admin enforced quarantine.\n    bot_settings = bot_management.get_settings_key(bot_id).get()\n    if bool(bot_settings and bot_settings.quarantined):\n      return request, bot_id, version, state, dimensions, 'Quarantined by admin'\n\n    return request, bot_id, version, state, dimensions, None\n\n\nclass BotHandshakeHandler(_BotBaseHandler):\n  \"\"\"First request to be called to get initial data like XSRF token.\n\n  The bot is server-controled so the server doesn't have to support multiple API\n  version. When running a task, the bot sync the the version specific URL. Once\n  abot finished its currently running task, it'll be immediately be upgraded\n  after on its next poll.\n\n  This endpoint does not return commands to the bot, for example to upgrade\n  itself. It'll be told so when it does its first poll.\n\n  Response body is a JSON dict:\n    {\n      \"bot_version\": <sha-1 of swarming_bot.zip uncompressed content>,\n      \"server_version\": \"138-193f1f3\",\n      \"xsrf_token\": \"......\",\n    }\n  \"\"\"\n\n  # This handler is called to get XSRF token, there's nothing to enforce yet.\n  xsrf_token_enforce_on = ()\n\n  @auth.require_xsrf_token_request\n  @auth.require(acl.is_bot)\n  def post(self):\n    (_request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    bot_management.bot_event(\n        event_type='bot_connected', bot_id=bot_id,\n        external_ip=self.request.remote_addr, dimensions=dimensions,\n        state=state, version=version, quarantined=bool(quarantined_msg),\n        task_id='', task_name=None, message=quarantined_msg)\n\n    data = {\n      # This access token will be used to validate each subsequent request.\n      'bot_version': bot_code.get_bot_version(self.request.host_url),\n      'expiration_sec': auth.handler.XSRFToken.expiration_sec,\n      'server_version': utils.get_app_version(),\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.send_response(data)\n\n\nclass BotPollHandler(_BotBaseHandler):\n  \"\"\"The bot polls for a task; returns either a task, update command or sleep.\n\n  In case of exception on the bot, this is enough to get it just far enough to\n  eventually self-update to a working version. This is to ensure that coding\n  errors in bot code doesn't kill all the fleet at once, they should still be up\n  just enough to be able to self-update again even if they don't get task\n  assigned anymore.\n  \"\"\"\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    \"\"\"Handles a polling request.\n\n    Be very permissive on missing values. This can happen because of errors\n    on the bot, *we don't want to deny them the capacity to update*, so that the\n    bot code is eventually fixed and the bot self-update to this working code.\n\n    It makes recovery of the fleet in case of catastrophic failure much easier.\n    \"\"\"\n    (_request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    sleep_streak = state.get('sleep_streak', 0)\n    quarantined = bool(quarantined_msg)\n\n    # Note bot existence at two places, one for stats at 1 minute resolution,\n    # the other for the list of known bots.\n    action = 'bot_inactive' if quarantined else 'bot_active'\n    stats.add_entry(action=action, bot_id=bot_id, dimensions=dimensions)\n\n    def bot_event(event_type, task_id=None, task_name=None):\n      bot_management.bot_event(\n          event_type=event_type, bot_id=bot_id,\n          external_ip=self.request.remote_addr, dimensions=dimensions,\n          state=state, version=version, quarantined=quarantined,\n          task_id=task_id, task_name=task_name, message=quarantined_msg)\n\n    # Bot version is host-specific because the host URL is embedded in\n    # swarming_bot.zip\n    expected_version = bot_code.get_bot_version(self.request.host_url)\n    if version != expected_version:\n      bot_event('request_update')\n      self._cmd_update(expected_version)\n      return\n    if quarantined:\n      bot_event('request_sleep')\n      self._cmd_sleep(sleep_streak, quarantined)\n      return\n\n    #\n    # At that point, the bot should be in relatively good shape since it's\n    # running the right version. It is still possible that invalid code was\n    # pushed to the server, so be diligent about it.\n    #\n\n    # Bot may need a reboot if it is running for too long. We do not reboot\n    # quarantined bots.\n    needs_restart, restart_message = bot_management.should_restart_bot(\n        bot_id, state)\n    if needs_restart:\n      bot_event('request_restart')\n      self._cmd_restart(restart_message)\n      return\n\n    # The bot is in good shape. Try to grab a task.\n    try:\n      # This is a fairly complex function call, exceptions are expected.\n      request, run_result = task_scheduler.bot_reap_task(\n          dimensions, bot_id, version, state.get('lease_expiration_ts'))\n      if not request:\n        # No task found, tell it to sleep a bit.\n        bot_event('request_sleep')\n        self._cmd_sleep(sleep_streak, quarantined)\n        return\n\n      try:\n        # This part is tricky since it intentionally runs a transaction after\n        # another one.\n        if request.properties.is_terminate:\n          bot_event('bot_terminate', task_id=run_result.task_id)\n          self._cmd_terminate(run_result.task_id)\n        else:\n          bot_event(\n              'request_task', task_id=run_result.task_id,\n              task_name=request.name)\n          self._cmd_run(request, run_result.key, bot_id)\n      except:\n        logging.exception('Dang, exception after reaping')\n        raise\n    except runtime.DeadlineExceededError:\n      # If the timeout happened before a task was assigned there is no problems.\n      # If the timeout occurred after a task was assigned, that task will\n      # timeout (BOT_DIED) since the bot didn't get the details required to\n      # run it) and it will automatically get retried (TODO) when the task times\n      # out.\n      # TODO(maruel): Note the task if possible and hand it out on next poll.\n      # https://code.google.com/p/swarming/issues/detail?id=130\n      self.abort(500, 'Deadline')\n\n  def _cmd_run(self, request, run_result_key, bot_id):\n    cmd = None\n    if request.properties.commands:\n      cmd = request.properties.commands[0]\n    elif request.properties.command:\n      cmd = request.properties.command\n    out = {\n      'cmd': 'run',\n      'manifest': {\n        'bot_id': bot_id,\n        'command': cmd,\n        'dimensions': request.properties.dimensions,\n        'env': request.properties.env,\n        'extra_args': request.properties.extra_args,\n        'grace_period': request.properties.grace_period_secs,\n        'hard_timeout': request.properties.execution_timeout_secs,\n        'host': utils.get_versioned_hosturl(),\n        'io_timeout': request.properties.io_timeout_secs,\n        'inputs_ref': request.properties.inputs_ref,\n        'task_id': task_pack.pack_run_result_key(run_result_key),\n      },\n    }\n    self.send_response(utils.to_json_encodable(out))\n\n  def _cmd_sleep(self, sleep_streak, quarantined):\n    out = {\n      'cmd': 'sleep',\n      'duration': task_scheduler.exponential_backoff(sleep_streak),\n      'quarantined': quarantined,\n    }\n    self.send_response(out)\n\n  def _cmd_terminate(self, task_id):\n    out = {\n      'cmd': 'terminate',\n      'task_id': task_id,\n    }\n    self.send_response(out)\n\n  def _cmd_update(self, expected_version):\n    out = {\n      'cmd': 'update',\n      'version': expected_version,\n    }\n    self.send_response(out)\n\n  def _cmd_restart(self, message):\n    logging.info('Rebooting bot: %s', message)\n    out = {\n      'cmd': 'restart',\n      'message': message,\n    }\n    self.send_response(out)\n\n\nclass BotEventHandler(_BotBaseHandler):\n  \"\"\"On signal that a bot had an event worth logging.\"\"\"\n\n  EXPECTED_KEYS = _BotBaseHandler.EXPECTED_KEYS | {u'event', u'message'}\n\n  @auth.require(acl.is_bot)\n  def post(self):\n    (request, bot_id, version, state,\n        dimensions, quarantined_msg) = self._process()\n    event = request.get('event')\n    if event not in ('bot_error', 'bot_rebooting', 'bot_shutdown'):\n      self.abort_with_error(400, error='Unsupported event type')\n    message = request.get('message')\n    bot_management.bot_event(\n        event_type=event, bot_id=bot_id, external_ip=self.request.remote_addr,\n        dimensions=dimensions, state=state, version=version,\n        quarantined=bool(quarantined_msg), task_id=None, task_name=None,\n        message=message)\n\n    if event == 'bot_error':\n      line = (\n          'Bot: https://%s/restricted/bot/%s\\n'\n          'Bot error:\\n'\n          '%s') % (\n          app_identity.get_default_version_hostname(), bot_id, message)\n      ereporter2.log_request(self.request, source='bot', message=line)\n    self.send_response({})\n\n\nclass BotTaskUpdateHandler(auth.ApiHandler):\n  \"\"\"Receives updates from a Bot for a task.\n\n  The handler verifies packets are processed in order and will refuse\n  out-of-order packets.\n  \"\"\"\n  ACCEPTED_KEYS = {\n    u'bot_overhead', u'cost_usd', u'duration', u'exit_code',\n    u'hard_timeout', u'id', u'io_timeout', u'isolated_stats', u'output',\n    u'output_chunk_start', u'outputs_ref', u'task_id',\n  }\n  REQUIRED_KEYS = {u'id', u'task_id'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  @auth.require(acl.is_bot)\n  def post(self, task_id=None):\n    # Unlike handshake and poll, we do not accept invalid keys here. This code\n    # path is much more strict.\n    request = self.parse_body()\n    msg = log_unexpected_subset_keys(\n        self.ACCEPTED_KEYS, self.REQUIRED_KEYS, request, self.request, 'bot',\n        'keys')\n    if msg:\n      self.abort_with_error(400, error=msg)\n\n    bot_id = request['id']\n    cost_usd = request['cost_usd']\n    task_id = request['task_id']\n\n    bot_overhead = request.get('bot_overhead')\n    duration = request.get('duration')\n    exit_code = request.get('exit_code')\n    hard_timeout = request.get('hard_timeout')\n    io_timeout = request.get('io_timeout')\n    isolated_stats = request.get('isolated_stats')\n    output = request.get('output')\n    output_chunk_start = request.get('output_chunk_start')\n    outputs_ref = request.get('outputs_ref')\n\n    if bool(isolated_stats) != (bot_overhead is not None):\n      ereporter2.log_request(\n          request=self.request,\n          source='server',\n          category='task_failure',\n          message='Failed to update task: %s' % task_id)\n      self.abort_with_error(\n          400,\n          error='Both bot_overhead and isolated_stats must be set '\n                'simultaneously\\nbot_overhead: %s\\nisolated_stats: %s' %\n                (bot_overhead, isolated_stats))\n\n    run_result_key = task_pack.unpack_run_result_key(task_id)\n    performance_stats = None\n    if isolated_stats:\n      download = isolated_stats['download']\n      upload = isolated_stats['upload']\n      performance_stats = task_result.PerformanceStats(\n          bot_overhead=bot_overhead,\n          isolated_download=task_result.IsolatedOperation(\n              duration=download['duration'],\n              initial_number_items=download['initial_number_items'],\n              initial_size=download['initial_size'],\n              items_cold=base64.b64decode(download['items_cold']),\n              items_hot=base64.b64decode(download['items_hot'])),\n          isolated_upload=task_result.IsolatedOperation(\n              duration=upload['duration'],\n              items_cold=base64.b64decode(upload['items_cold']),\n              items_hot=base64.b64decode(upload['items_hot'])))\n\n    if output is not None:\n      try:\n        output = base64.b64decode(output)\n      except UnicodeEncodeError as e:\n        logging.error('Failed to decode output\\n%s\\n%r', e, output)\n        output = output.encode('ascii', 'replace')\n      except TypeError as e:\n        # Save the output as-is instead. The error will be logged in ereporter2\n        # and returning a HTTP 500 would only force the bot to stay in a retry\n        # loop.\n        logging.error('Failed to decode output\\n%s\\n%r', e, output)\n    if outputs_ref:\n      outputs_ref = task_request.FilesRef(**outputs_ref)\n\n    try:\n      state = task_scheduler.bot_update_task(\n          run_result_key=run_result_key,\n          bot_id=bot_id,\n          output=output,\n          output_chunk_start=output_chunk_start,\n          exit_code=exit_code,\n          duration=duration,\n          hard_timeout=hard_timeout,\n          io_timeout=io_timeout,\n          cost_usd=cost_usd,\n          outputs_ref=outputs_ref,\n          performance_stats=performance_stats)\n      if not state:\n        logging.info('Failed to update, please retry')\n        self.abort_with_error(500, error='Failed to update, please retry')\n\n      if state in (task_result.State.COMPLETED, task_result.State.TIMED_OUT):\n        action = 'task_completed'\n      else:\n        assert state == task_result.State.RUNNING, state\n        action = 'task_update'\n      bot_management.bot_event(\n          event_type=action, bot_id=bot_id,\n          external_ip=self.request.remote_addr, dimensions=None, state=None,\n          version=None, quarantined=None, task_id=task_id, task_name=None)\n    except ValueError as e:\n      ereporter2.log_request(\n          request=self.request,\n          source='server',\n          category='task_failure',\n          message='Failed to update task: %s' % e)\n      self.abort_with_error(400, error=str(e))\n    except webob.exc.HTTPException:\n      raise\n    except Exception as e:\n      logging.exception('Internal error: %s', e)\n      self.abort_with_error(500, error=str(e))\n\n    # TODO(maruel): When a task is canceled, reply with 'DIE' so that the bot\n    # reboots itself to abort the task abruptly. It is useful when a task hangs\n    # and the timeout was set too long or the task was superseded by a newer\n    # task with more recent executable (e.g. a new Try Server job on a newer\n    # patchset on Rietveld).\n    self.send_response({'ok': True})\n\n\nclass BotTaskErrorHandler(auth.ApiHandler):\n  \"\"\"It is a specialized version of ereporter2's /ereporter2/api/v1/on_error\n  that also attaches a task id to it.\n\n  This formally kills the task, marking it as an internal failure. This can be\n  used by bot_main.py to kill the task when task_runner misbehaved.\n  \"\"\"\n\n  EXPECTED_KEYS = {u'id', u'message', u'task_id'}\n\n  # TODO(vadimsh): Remove once bots use X-Whitelisted-Bot-Id or OAuth.\n  xsrf_token_enforce_on = ()\n\n  @auth.require(acl.is_bot)\n  def post(self, task_id=None):\n    request = self.parse_body()\n    bot_id = request.get('id')\n    task_id = request.get('task_id', '')\n    message = request.get('message', 'unknown')\n\n    bot_management.bot_event(\n        event_type='task_error', bot_id=bot_id,\n        external_ip=self.request.remote_addr, dimensions=None, state=None,\n        version=None, quarantined=None, task_id=task_id, task_name=None,\n        message=message)\n    line = (\n        'Bot: https://%s/restricted/bot/%s\\n'\n        'Task failed: https://%s/user/task/%s\\n'\n        '%s') % (\n        app_identity.get_default_version_hostname(), bot_id,\n        app_identity.get_default_version_hostname(), task_id,\n        message)\n    ereporter2.log_request(self.request, source='bot', message=line)\n\n    msg = log_unexpected_keys(\n        self.EXPECTED_KEYS, request, self.request, 'bot', 'keys')\n    if msg:\n      self.abort_with_error(400, error=msg)\n\n    msg = task_scheduler.bot_kill_task(\n        task_pack.unpack_run_result_key(task_id), bot_id)\n    if msg:\n      logging.error(msg)\n      self.abort_with_error(400, error=msg)\n    self.send_response({})\n\n\nclass ServerPingHandler(webapp2.RequestHandler):\n  \"\"\"Handler to ping when checking if the server is up.\n\n  This handler should be extremely lightweight. It shouldn't do any\n  computations, it should just state that the server is up. It's open to\n  everyone for simplicity and performance.\n  \"\"\"\n\n  def get(self):\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.out.write('Server up')\n\n\ndef get_routes():\n  routes = [\n      ('/bootstrap', BootstrapHandler),\n      ('/bot_code', BotCodeHandler),\n      ('/swarming/api/v1/bot/bot_code/<version:[0-9a-f]{40}>', BotCodeHandler),\n      ('/swarming/api/v1/bot/event', BotEventHandler),\n      ('/swarming/api/v1/bot/handshake', BotHandshakeHandler),\n      ('/swarming/api/v1/bot/poll', BotPollHandler),\n      ('/swarming/api/v1/bot/server_ping', ServerPingHandler),\n      ('/swarming/api/v1/bot/task_update', BotTaskUpdateHandler),\n      ('/swarming/api/v1/bot/task_update/<task_id:[a-f0-9]+>',\n          BotTaskUpdateHandler),\n      ('/swarming/api/v1/bot/task_error', BotTaskErrorHandler),\n      ('/swarming/api/v1/bot/task_error/<task_id:[a-f0-9]+>',\n          BotTaskErrorHandler),\n  ]\n  return [webapp2.Route(*i) for i in routes]\n/n/n/n/appengine/swarming/server/bot_archive.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Generates the swarming_bot.zip archive for the bot.\n\nUnlike the other source files, this file can be run from ../tools/bot_archive.py\nstand-alone to generate a swarming_bot.zip for local testing so it doesn't\nimport anything from the AppEngine SDK.\n\nThe hash of the content of the files in the archive is used to define the\ncurrent version of the swarming bot code.\n\"\"\"\n\nimport hashlib\nimport json\nimport logging\nimport os\nimport StringIO\nimport zipfile\n\n\n# List of files needed by the swarming bot.\n# TODO(maruel): Make the list automatically generated?\nFILES = (\n    '__main__.py',\n    'api/__init__.py',\n    'api/bot.py',\n    'api/parallel.py',\n    'api/os_utilities.py',\n    'api/platforms/__init__.py',\n    'api/platforms/android.py',\n    'api/platforms/common.py',\n    'api/platforms/gce.py',\n    'api/platforms/linux.py',\n    'api/platforms/osx.py',\n    'api/platforms/posix.py',\n    'api/platforms/win.py',\n    'bot_code/__init__.py',\n    'bot_code/bot_main.py',\n    'bot_code/common.py',\n    'bot_code/singleton.py',\n    'bot_code/task_runner.py',\n    'bot_code/xsrf_client.py',\n    'client/auth.py',\n    'client/isolated_format.py',\n    'client/isolateserver.py',\n    'client/run_isolated.py',\n    'config/__init__.py',\n    'third_party/__init__.py',\n    'third_party/colorama/__init__.py',\n    'third_party/colorama/ansi.py',\n    'third_party/colorama/ansitowin32.py',\n    'third_party/colorama/initialise.py',\n    'third_party/colorama/win32.py',\n    'third_party/colorama/winterm.py',\n    'third_party/depot_tools/__init__.py',\n    'third_party/depot_tools/fix_encoding.py',\n    'third_party/depot_tools/subcommand.py',\n    'third_party/httplib2/__init__.py',\n    'third_party/httplib2/cacerts.txt',\n    'third_party/httplib2/iri2uri.py',\n    'third_party/httplib2/socks.py',\n    'third_party/oauth2client/__init__.py',\n    'third_party/oauth2client/_helpers.py',\n    'third_party/oauth2client/_openssl_crypt.py',\n    'third_party/oauth2client/_pycrypto_crypt.py',\n    'third_party/oauth2client/client.py',\n    'third_party/oauth2client/clientsecrets.py',\n    'third_party/oauth2client/crypt.py',\n    'third_party/oauth2client/file.py',\n    'third_party/oauth2client/gce.py',\n    'third_party/oauth2client/keyring_storage.py',\n    'third_party/oauth2client/locked_file.py',\n    'third_party/oauth2client/multistore_file.py',\n    'third_party/oauth2client/service_account.py',\n    'third_party/oauth2client/tools.py',\n    'third_party/oauth2client/util.py',\n    'third_party/oauth2client/xsrfutil.py',\n    'third_party/pyasn1/pyasn1/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/ber/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/ber/decoder.py',\n    'third_party/pyasn1/pyasn1/codec/ber/encoder.py',\n    'third_party/pyasn1/pyasn1/codec/ber/eoo.py',\n    'third_party/pyasn1/pyasn1/codec/cer/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/cer/decoder.py',\n    'third_party/pyasn1/pyasn1/codec/cer/encoder.py',\n    'third_party/pyasn1/pyasn1/codec/der/__init__.py',\n    'third_party/pyasn1/pyasn1/codec/der/decoder.py',\n    'third_party/pyasn1/pyasn1/codec/der/encoder.py',\n    'third_party/pyasn1/pyasn1/compat/__init__.py',\n    'third_party/pyasn1/pyasn1/compat/binary.py',\n    'third_party/pyasn1/pyasn1/compat/octets.py',\n    'third_party/pyasn1/pyasn1/debug.py',\n    'third_party/pyasn1/pyasn1/error.py',\n    'third_party/pyasn1/pyasn1/type/__init__.py',\n    'third_party/pyasn1/pyasn1/type/base.py',\n    'third_party/pyasn1/pyasn1/type/char.py',\n    'third_party/pyasn1/pyasn1/type/constraint.py',\n    'third_party/pyasn1/pyasn1/type/error.py',\n    'third_party/pyasn1/pyasn1/type/namedtype.py',\n    'third_party/pyasn1/pyasn1/type/namedval.py',\n    'third_party/pyasn1/pyasn1/type/tag.py',\n    'third_party/pyasn1/pyasn1/type/tagmap.py',\n    'third_party/pyasn1/pyasn1/type/univ.py',\n    'third_party/pyasn1/pyasn1/type/useful.py',\n    'third_party/requests/__init__.py',\n    'third_party/requests/adapters.py',\n    'third_party/requests/api.py',\n    'third_party/requests/auth.py',\n    'third_party/requests/certs.py',\n    'third_party/requests/compat.py',\n    'third_party/requests/cookies.py',\n    'third_party/requests/exceptions.py',\n    'third_party/requests/hooks.py',\n    'third_party/requests/models.py',\n    'third_party/requests/packages/__init__.py',\n    'third_party/requests/packages/urllib3/__init__.py',\n    'third_party/requests/packages/urllib3/_collections.py',\n    'third_party/requests/packages/urllib3/connection.py',\n    'third_party/requests/packages/urllib3/connectionpool.py',\n    'third_party/requests/packages/urllib3/contrib/__init__.py',\n    'third_party/requests/packages/urllib3/contrib/ntlmpool.py',\n    'third_party/requests/packages/urllib3/contrib/pyopenssl.py',\n    'third_party/requests/packages/urllib3/exceptions.py',\n    'third_party/requests/packages/urllib3/fields.py',\n    'third_party/requests/packages/urllib3/filepost.py',\n    'third_party/requests/packages/urllib3/packages/__init__.py',\n    'third_party/requests/packages/urllib3/packages/ordered_dict.py',\n    'third_party/requests/packages/urllib3/packages/six.py',\n    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'\n        '__init__.py',\n    'third_party/requests/packages/urllib3/packages/ssl_match_hostname/'\n        '_implementation.py',\n    'third_party/requests/packages/urllib3/poolmanager.py',\n    'third_party/requests/packages/urllib3/request.py',\n    'third_party/requests/packages/urllib3/response.py',\n    'third_party/requests/packages/urllib3/util/__init__.py',\n    'third_party/requests/packages/urllib3/util/connection.py',\n    'third_party/requests/packages/urllib3/util/request.py',\n    'third_party/requests/packages/urllib3/util/response.py',\n    'third_party/requests/packages/urllib3/util/retry.py',\n    'third_party/requests/packages/urllib3/util/ssl_.py',\n    'third_party/requests/packages/urllib3/util/timeout.py',\n    'third_party/requests/packages/urllib3/util/url.py',\n    'third_party/requests/sessions.py',\n    'third_party/requests/status_codes.py',\n    'third_party/requests/structures.py',\n    'third_party/requests/utils.py',\n    'third_party/rsa/rsa/__init__.py',\n    'third_party/rsa/rsa/_compat.py',\n    'third_party/rsa/rsa/_version133.py',\n    'third_party/rsa/rsa/_version200.py',\n    'third_party/rsa/rsa/asn1.py',\n    'third_party/rsa/rsa/bigfile.py',\n    'third_party/rsa/rsa/cli.py',\n    'third_party/rsa/rsa/common.py',\n    'third_party/rsa/rsa/core.py',\n    'third_party/rsa/rsa/key.py',\n    'third_party/rsa/rsa/parallel.py',\n    'third_party/rsa/rsa/pem.py',\n    'third_party/rsa/rsa/pkcs1.py',\n    'third_party/rsa/rsa/prime.py',\n    'third_party/rsa/rsa/randnum.py',\n    'third_party/rsa/rsa/transform.py',\n    'third_party/rsa/rsa/util.py',\n    'third_party/rsa/rsa/varblock.py',\n    'third_party/six/__init__.py',\n    'utils/__init__.py',\n    'utils/cacert.pem',\n    'utils/file_path.py',\n    'utils/fs.py',\n    'utils/large.py',\n    'utils/logging_utils.py',\n    'utils/lru.py',\n    'utils/net.py',\n    'utils/oauth.py',\n    'utils/on_error.py',\n    'utils/subprocess42.py',\n    'utils/threading_utils.py',\n    'utils/tools.py',\n    'utils/zip_package.py',\n    'adb/__init__.py',\n    'adb/adb_commands.py',\n    'adb/adb_protocol.py',\n    'adb/common.py',\n    'adb/contrib/__init__.py',\n    'adb/contrib/adb_commands_safe.py',\n    'adb/contrib/high.py',\n    'adb/contrib/parallel.py',\n    'adb/fastboot.py',\n    'adb/filesync_protocol.py',\n    'adb/sign_pythonrsa.py',\n    'adb/usb_exceptions.py',\n    'python_libusb1/__init__.py',\n    'python_libusb1/libusb1.py',\n    'python_libusb1/usb1.py',\n)\n\n\ndef is_windows():\n  \"\"\"Returns True if this code is running under Windows.\"\"\"\n  return os.__file__[0] != '/'\n\n\ndef resolve_symlink(path):\n  \"\"\"Processes path containing symlink on Windows.\n\n  This is needed to make ../swarming_bot/main_test.py pass on Windows because\n  git on Windows renders symlinks as normal files.\n  \"\"\"\n  if not is_windows():\n    # Only does this dance on Windows.\n    return path\n  parts = os.path.normpath(path).split(os.path.sep)\n  for i in xrange(2, len(parts)):\n    partial = os.path.sep.join(parts[:i])\n    if os.path.isfile(partial):\n      with open(partial) as f:\n        link = f.read()\n      assert '\\n' not in link and link, link\n      parts[i-1] = link\n  return os.path.normpath(os.path.sep.join(parts))\n\n\ndef yield_swarming_bot_files(root_dir, host, host_version, additionals):\n  \"\"\"Yields all the files to map as tuple(filename, content).\n\n  config.json is injected with json data about the server.\n\n  This function guarantees that the output is sorted by filename.\n  \"\"\"\n  items = {i: None for i in FILES}\n  items.update(additionals)\n  config = {\n    'server': host.rstrip('/'),\n    'server_version': host_version,\n  }\n  items['config/config.json'] = json.dumps(config)\n  for item, content in sorted(items.iteritems()):\n    if content is not None:\n      yield item, content\n    else:\n      with open(resolve_symlink(os.path.join(root_dir, item)), 'rb') as f:\n        yield item, f.read()\n\n\ndef get_swarming_bot_zip(root_dir, host, host_version, additionals):\n  \"\"\"Returns a zipped file of all the files a bot needs to run.\n\n  Arguments:\n    root_dir: directory swarming_bot.\n    additionals: dict(filepath: content) of additional items to put into the zip\n        file, in addition to FILES and MAPPED. In practice, it's going to be a\n        custom bot_config.py.\n  Returns:\n    Tuple(str being the zipped file's content, bot version (SHA-1) it\n    represents).\n  \"\"\"\n  zip_memory_file = StringIO.StringIO()\n  h = hashlib.sha1()\n  with zipfile.ZipFile(zip_memory_file, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n    for name, content in yield_swarming_bot_files(\n        root_dir, host, host_version, additionals):\n      zip_file.writestr(name, content)\n      h.update(str(len(name)))\n      h.update(name)\n      h.update(str(len(content)))\n      h.update(content)\n\n  data = zip_memory_file.getvalue()\n  bot_version = h.hexdigest()\n  logging.info(\n      'get_swarming_bot_zip(%s) is %d bytes; %s',\n      additionals.keys(), len(data), bot_version)\n  return data, bot_version\n\n\ndef get_swarming_bot_version(root_dir, host, host_version, additionals):\n  \"\"\"Returns the SHA1 hash of the bot code, representing the version.\n\n  Arguments:\n    root_dir: directory swarming_bot.\n    additionals: See get_swarming_bot_zip's doc.\n\n  Returns:\n    The SHA1 hash of the bot code.\n  \"\"\"\n  h = hashlib.sha1()\n  try:\n    # TODO(maruel): Deduplicate from zip_package.genereate_version().\n    for name, content in yield_swarming_bot_files(\n        root_dir, host, host_version, additionals):\n      h.update(str(len(name)))\n      h.update(name)\n      h.update(str(len(content)))\n      h.update(content)\n  except IOError:\n    logging.warning('Missing expected file. Hash will be invalid.')\n  bot_version = h.hexdigest()\n  logging.info(\n      'get_swarming_bot_version(%s) = %s', sorted(additionals), bot_version)\n  return bot_version\n/n/n/n/appengine/swarming/swarming_bot/__main__.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Runs either task_runner.py, bot_main.py or bot_config.py.\n\nThe imports are done late so if an ImportError occurs, it is localized to this\ncommand only.\n\"\"\"\n\nimport code\nimport json\nimport logging\nimport os\nimport optparse\nimport shutil\nimport sys\nimport zipfile\n\nfrom bot_code import common\n\n# That's from ../../../client/\nfrom third_party.depot_tools import fix_encoding\nfrom utils import logging_utils\nfrom utils import zip_package\n\n# This file can only be run as a zip.\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n\n# libusb1 expects to be directly in sys.path.\nsys.path.insert(0, os.path.join(THIS_FILE, 'python_libusb1'))\n\n\n# TODO(maruel): Use depot_tools/subcommand.py. The goal here is to have all the\n# sub commands packed into the single .zip file as a swiss army knife (think\n# busybox but worse).\n\n\ndef CMDattributes(_args):\n  \"\"\"Prints out the bot's attributes.\"\"\"\n  from bot_code import bot_main\n  json.dump(\n      bot_main.get_attributes(bot_main.get_bot()), sys.stdout, indent=2,\n      sort_keys=True, separators=(',', ': '))\n  print('')\n  return 0\n\n\ndef CMDconfig(_args):\n  \"\"\"Prints the config.json embedded in this zip.\"\"\"\n  logging_utils.prepare_logging(None)\n  from bot_code import bot_main\n  json.dump(bot_main.get_config(), sys.stdout, indent=2, sort_keys=True)\n  print('')\n  return 0\n\n\ndef CMDis_fine(_args):\n  \"\"\"Just reports that the code doesn't throw.\n\n  That ensures that the bot has minimal viability before transfering control to\n  it. For now, it just imports bot_main but later it'll check the config, etc.\n  \"\"\"\n  # pylint: disable=unused-variable\n  from bot_code import bot_main\n  from config import bot_config\n  # We're #goodenough.\n  return 0\n\n\ndef CMDrestart(_args):\n  \"\"\"Utility subcommand that hides the difference between each OS to reboot\n  the host.\"\"\"\n  logging_utils.prepare_logging(None)\n  import os_utilities\n  # This function doesn't return.\n  os_utilities.restart()\n  # Should never reach here.\n  return 1\n\n\ndef CMDrun_isolated(args):\n  \"\"\"Internal command to run an isolated command.\"\"\"\n  sys.path.insert(0, os.path.join(THIS_FILE, 'client'))\n  # run_isolated setups logging by itself.\n  import run_isolated\n  return run_isolated.main(args)\n\n\ndef CMDsetup(_args):\n  \"\"\"Setup the bot to auto-start but doesn't start the bot.\"\"\"\n  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))\n  from bot_code import bot_main\n  bot_main.setup_bot(True)\n  return 0\n\n\ndef CMDserver(_args):\n  \"\"\"Prints the server url. It's like 'config' but easier to parse.\"\"\"\n  logging_utils.prepare_logging(None)\n  from bot_code import bot_main\n  print bot_main.get_config()['server']\n  return 0\n\n\ndef CMDshell(args):\n  \"\"\"Starts a shell with api.* in..\"\"\"\n  logging_utils.prepare_logging(None)\n  logging_utils.set_console_level(logging.DEBUG)\n\n  from bot_code import bot_main\n  from api import os_utilities\n  from api import platforms\n  local_vars = {\n    'bot_main': bot_main,\n    'json': json,\n    'os_utilities': os_utilities,\n    'platforms': platforms,\n  }\n  # Can't use: from api.platforms import *\n  local_vars.update(\n      (k, v) for k, v in platforms.__dict__.iteritems()\n      if not k.startswith('_'))\n\n  if args:\n    for arg in args:\n      exec code.compile_command(arg) in local_vars\n  else:\n    code.interact(\n        'Locals:\\n  ' + '\\n  '.join( sorted(local_vars)), None, local_vars)\n  return 0\n\n\ndef CMDstart_bot(args):\n  \"\"\"Starts the swarming bot.\"\"\"\n  logging_utils.prepare_logging(os.path.join('logs', 'swarming_bot.log'))\n  logging.info(\n      'importing bot_main: %s, %s', THIS_FILE, zip_package.generate_version())\n  from bot_code import bot_main\n  result = bot_main.main(args)\n  logging.info('bot_main exit code: %d', result)\n  return result\n\n\ndef CMDstart_slave(args):\n  \"\"\"Ill named command that actually sets up the bot then start it.\"\"\"\n  # TODO(maruel): Rename function.\n  logging_utils.prepare_logging(os.path.join('logs', 'bot_config.log'))\n\n  parser = optparse.OptionParser()\n  parser.add_option(\n      '--survive', action='store_true',\n      help='Do not reboot the host even if bot_config.setup_bot() asked to')\n  options, args = parser.parse_args(args)\n\n  try:\n    from bot_code import bot_main\n    bot_main.setup_bot(options.survive)\n  except Exception:\n    logging.exception('bot_main.py failed.')\n\n  logging.info('Starting the bot: %s', THIS_FILE)\n  return common.exec_python([THIS_FILE, 'start_bot'])\n\n\ndef CMDtask_runner(args):\n  \"\"\"Internal command to run a swarming task.\"\"\"\n  logging_utils.prepare_logging(os.path.join('logs', 'task_runner.log'))\n  from bot_code import task_runner\n  return task_runner.main(args)\n\n\ndef CMDversion(_args):\n  \"\"\"Prints the version of this file and the hash of the code.\"\"\"\n  logging_utils.prepare_logging(None)\n  print zip_package.generate_version()\n  return 0\n\n\ndef main():\n  if os.getenv('CHROME_REMOTE_DESKTOP_SESSION') == '1':\n    # Disable itself when run under Google Chrome Remote Desktop, as it's\n    # normally started at the console and starting up via Remote Desktop would\n    # cause multiple bots to run concurrently on the host.\n    print >> sys.stderr, (\n        'Inhibiting Swarming bot under Google Chrome Remote Desktop.')\n    return 0\n\n  # Always make the current working directory the directory containing this\n  # file. It simplifies assumptions.\n  os.chdir(os.path.dirname(THIS_FILE))\n  # Always create the logs dir first thing, before printing anything out.\n  if not os.path.isdir('logs'):\n    os.mkdir('logs')\n\n  # This is necessary so os.path.join() works with unicode path. No kidding.\n  # This must be done here as each of the command take wildly different code\n  # path and this must be run in every case, as it causes really unexpected\n  # issues otherwise, especially in module os.path.\n  fix_encoding.fix_encoding()\n\n  if os.path.basename(THIS_FILE) == 'swarming_bot.zip':\n    # Self-replicate itself right away as swarming_bot.1.zip and restart as it.\n    print >> sys.stderr, 'Self replicating pid:%d.' % os.getpid()\n    if os.path.isfile('swarming_bot.1.zip'):\n      os.remove('swarming_bot.1.zip')\n    shutil.copyfile('swarming_bot.zip', 'swarming_bot.1.zip')\n    cmd = ['swarming_bot.1.zip'] + sys.argv[1:]\n    print >> sys.stderr, 'cmd: %s' % cmd\n    return common.exec_python(cmd)\n\n  # sys.argv[0] is the zip file itself.\n  cmd = 'start_slave'\n  args = []\n  if len(sys.argv) > 1:\n    cmd = sys.argv[1]\n    args = sys.argv[2:]\n\n  fn = getattr(sys.modules[__name__], 'CMD%s' % cmd, None)\n  if fn:\n    try:\n      return fn(args)\n    except ImportError:\n      logging.exception('Failed to run %s', cmd)\n      with zipfile.ZipFile(THIS_FILE, 'r') as f:\n        logging.error('Files in %s:\\n%s', THIS_FILE, f.namelist())\n      return 1\n\n  print >> sys.stderr, 'Unknown command %s' % cmd\n  return 1\n\n\nif __name__ == '__main__':\n  sys.exit(main())\n/n/n/n/appengine/swarming/swarming_bot/api/bot.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Bot interface used in bot_config.py.\"\"\"\n\nimport logging\nimport os\nimport threading\nimport time\n\nimport os_utilities\nfrom utils import zip_package\n\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n# Method could be a function - pylint: disable=R0201\n\n\nclass Bot(object):\n  def __init__(\n      self, remote, attributes, server, server_version, base_dir,\n      shutdown_hook):\n    # Do not expose attributes nor remote for now, as attributes will be\n    # refactored soon and remote would have a lot of side effects if used by\n    # bot_config.\n    self._attributes = attributes\n    self._base_dir = base_dir\n    self._remote = remote\n    self._server = server\n    self._server_version = server_version\n    self._shutdown_hook = shutdown_hook\n    self._timers = []\n    self._timers_dying = False\n    self._timers_lock = threading.Lock()\n\n  @property\n  def base_dir(self):\n    \"\"\"Returns the working directory.\n\n    It is normally the current workind directory, e.g. os.getcwd() but it is\n    preferable to not assume that.\n    \"\"\"\n    return self._base_dir\n\n  @property\n  def dimensions(self):\n    \"\"\"The bot's current dimensions.\n\n    Dimensions are relatively static and not expected to change much. They\n    should change only when it effectively affects the bot's capacity to execute\n    tasks.\n    \"\"\"\n    return self._attributes.get('dimensions', {}).copy()\n\n  @property\n  def id(self):\n    \"\"\"Returns the bot's ID.\"\"\"\n    return self.dimensions.get('id', ['unknown'])[0]\n\n  @property\n  def remote(self):\n    \"\"\"XsrfClient instance to talk to the server.\n\n    Should not be normally used by bot_config.py for now.\n    \"\"\"\n    return self._remote\n\n  @property\n  def server(self):\n    \"\"\"URL of the swarming server this bot is connected to.\n\n    It includes the https:// prefix but without trailing /, so it looks like\n    \"https://foo-bar.appspot.com\".\n    \"\"\"\n    return self._server\n\n  @property\n  def server_version(self):\n    \"\"\"Version of the server's implementation.\n\n    The form is nnn-hhhhhhh for pristine version and nnn-hhhhhhh-tainted-uuuu\n    for non-upstreamed code base:\n      nnn: revision pseudo number\n      hhhhhhh: git commit hash\n      uuuu: username\n    \"\"\"\n    return self._server_version\n\n  @property\n  def state(self):\n    return self._attributes['state']\n\n  @property\n  def swarming_bot_zip(self):\n    \"\"\"Absolute path to the swarming_bot.zip file.\n\n    The bot itself is run as swarming_bot.1.zip or swarming_bot.2.zip. Always\n    return swarming_bot.zip since this is the script that must be used when\n    starting up.\n    \"\"\"\n    return os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip')\n\n  def post_event(self, event_type, message):\n    \"\"\"Posts an event to the server.\"\"\"\n    data = self._attributes.copy()\n    data['event'] = event_type\n    data['message'] = message\n    self._remote.url_read_json('/swarming/api/v1/bot/event', data=data)\n\n  def post_error(self, message):\n    \"\"\"Posts given string as a failure.\n\n    This is used in case of internal code error. It traps exception.\n    \"\"\"\n    logging.error('Error: %s\\n%s', self._attributes, message)\n    try:\n      self.post_event('bot_error', message)\n    except Exception:\n      logging.exception('post_error(%s) failed.', message)\n\n  def restart(self, message):\n    \"\"\"Reboots the machine.\n\n    If the reboot is successful, never returns: the process should just be\n    killed by OS.\n\n    If reboot fails, logs the error to the server and moves the bot to\n    quarantined mode.\n    \"\"\"\n    self.post_event('bot_rebooting', message)\n    self.cancel_all_timers()\n    if self._shutdown_hook:\n      try:\n        self._shutdown_hook(self)\n      except Exception as e:\n        logging.exception('shutdown hook failed: %s', e)\n    # os_utilities.restart should never return, unless restart is not happening.\n    # If restart is taking longer than N minutes, it probably not going to\n    # finish at all. Report this to the server.\n    try:\n      os_utilities.restart(message, timeout=15*60)\n    except LookupError:\n      # This is a special case where OSX is deeply hosed. In that case the disk\n      # is likely in read-only mode and there isn't much that can be done. This\n      # exception is deep inside pickle.py. So notify the server then hang in\n      # there.\n      self.post_error('This host partition is bad; please fix the host')\n      while True:\n        time.sleep(1)\n    self.post_error('Bot is stuck restarting for: %s' % message)\n\n  def call_later(self, delay_sec, callback):\n    \"\"\"Schedules a function to be called later (if bot is still running).\n\n    All calls are executed in a separate internal thread, be careful with what\n    you call from there (Bot object is generally not thread safe).\n\n    Multiple callbacks can be executed concurrently. It is safe to call\n    'call_later' from the callback.\n    \"\"\"\n    timer = None\n\n    def call_wrapper():\n      with self._timers_lock:\n        # Canceled already?\n        if timer not in self._timers:\n          return\n        self._timers.remove(timer)\n      try:\n        callback()\n      except Exception:\n        logging.exception('Timer callback failed')\n\n    with self._timers_lock:\n      if not self._timers_dying:\n        timer = threading.Timer(delay_sec, call_wrapper)\n        self._timers.append(timer)\n        timer.daemon = True\n        timer.start()\n\n  def cancel_all_timers(self):\n    \"\"\"Cancels all pending 'call_later' calls and forbids adding new ones.\"\"\"\n    timers = None\n    with self._timers_lock:\n      self._timers_dying = True\n      for t in self._timers:\n        t.cancel()\n      timers, self._timers = self._timers, []\n    for t in timers:\n      t.join(timeout=5)\n      if t.isAlive():\n        logging.error('Timer thread did not terminate fast enough: %s', t)\n\n  def update_dimensions(self, new_dimensions):\n    \"\"\"Called internally to update Bot.dimensions.\"\"\"\n    self._attributes['dimensions'] = new_dimensions\n\n  def update_state(self, new_state):\n    \"\"\"Called internally to update Bot.state.\"\"\"\n    self._attributes['state'] = new_state\n/n/n/n/appengine/swarming/swarming_bot/api/bot_test.py/n/n#!/usr/bin/env python\n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport os\nimport sys\nimport unittest\nimport threading\n\nTHIS_FILE = os.path.abspath(__file__)\n\nimport test_env_api\ntest_env_api.setup_test_env()\n\nimport bot\n\n\nclass TestBot(unittest.TestCase):\n  def test_bot(self):\n    obj = bot.Bot(\n        None,\n        {'dimensions': {'foo': 'bar'}},\n        'https://localhost:1/',\n        '1234-1a2b3c4-tainted-joe',\n        'base_dir',\n        None)\n    self.assertEqual({'foo': 'bar'}, obj.dimensions)\n    self.assertEqual(\n        os.path.join(os.path.dirname(THIS_FILE), 'swarming_bot.zip'),\n        obj.swarming_bot_zip)\n    self.assertEqual('1234-1a2b3c4-tainted-joe', obj.server_version)\n    self.assertEqual('base_dir', obj.base_dir)\n\n  def test_bot_call_later(self):\n    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',\n                  'base_dir', None)\n    ev = threading.Event()\n    obj.call_later(0.001, ev.set)\n    self.assertTrue(ev.wait(1))\n\n  def test_bot_call_later_cancel(self):\n    obj = bot.Bot(None, {}, 'https://localhost:1/', '1234-1a2b3c4-tainted-joe',\n                  'base_dir', None)\n    ev = threading.Event()\n    obj.call_later(0.1, ev.set)\n    obj.cancel_all_timers()\n    self.assertFalse(ev.wait(0.3))\n\n\nif __name__ == '__main__':\n  if '-v' in sys.argv:\n    unittest.TestCase.maxDiff = None\n  unittest.main()\n/n/n/n/appengine/swarming/swarming_bot/bot_code/bot_main_test.py/n/n#!/usr/bin/env python\n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport json\nimport logging\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nimport zipfile\n\nimport test_env_bot_code\ntest_env_bot_code.setup_test_env()\n\n# Creates a server mock for functions in net.py.\nimport net_utils\n\nimport bot_main\nimport xsrf_client\nfrom api import bot\nfrom api import os_utilities\nfrom depot_tools import fix_encoding\nfrom utils import file_path\nfrom utils import logging_utils\nfrom utils import net\nfrom utils import subprocess42\nfrom utils import zip_package\n\n\n# Access to a protected member XX of a client class - pylint: disable=W0212\n\n\nclass TestBotMain(net_utils.TestCase):\n  maxDiff = 2000\n\n  def setUp(self):\n    super(TestBotMain, self).setUp()\n    os.environ.pop('SWARMING_LOAD_TEST', None)\n    self.root_dir = tempfile.mkdtemp(prefix='bot_main')\n    self.old_cwd = os.getcwd()\n    os.chdir(self.root_dir)\n    # __main__ does it for us.\n    os.mkdir('logs')\n    self.server = xsrf_client.XsrfRemote('https://localhost:1/')\n    self.attributes = {\n      'dimensions': {\n        'foo': ['bar'],\n        'id': ['localhost'],\n        'pool': ['default'],\n      },\n      'state': {\n        'cost_usd_hour': 3600.,\n      },\n      'version': '123',\n    }\n    self.mock(zip_package, 'generate_version', lambda: '123')\n    self.bot = bot.Bot(\n        self.server, self.attributes, 'https://localhost:1/', 'version1',\n        self.root_dir, self.fail)\n    self.mock(self.bot, 'post_error', self.fail)\n    self.mock(self.bot, 'restart', self.fail)\n    self.mock(subprocess42, 'call', self.fail)\n    self.mock(time, 'time', lambda: 100.)\n    config_path = os.path.join(\n        test_env_bot_code.BOT_DIR, 'config', 'config.json')\n    with open(config_path, 'rb') as f:\n      config = json.load(f)\n    self.mock(bot_main, 'get_config', lambda: config)\n    self.mock(\n        bot_main, 'THIS_FILE',\n        os.path.join(test_env_bot_code.BOT_DIR, 'swarming_bot.zip'))\n\n  def tearDown(self):\n    os.environ.pop('SWARMING_BOT_ID', None)\n    os.chdir(self.old_cwd)\n    file_path.rmtree(self.root_dir)\n    super(TestBotMain, self).tearDown()\n\n  def test_get_dimensions(self):\n    dimensions = set(bot_main.get_dimensions(None))\n    dimensions.discard('hidpi')\n    dimensions.discard('zone')  # Only set on GCE bots.\n    expected = {'cores', 'cpu', 'gpu', 'id', 'machine_type', 'os', 'pool'}\n    self.assertEqual(expected, dimensions)\n\n  def test_get_dimensions_load_test(self):\n    os.environ['SWARMING_LOAD_TEST'] = '1'\n    self.assertEqual(['id', 'load_test'], sorted(bot_main.get_dimensions(None)))\n\n  def test_generate_version(self):\n    self.assertEqual('123', bot_main.generate_version())\n\n  def test_get_state(self):\n    self.mock(time, 'time', lambda: 126.0)\n    expected = os_utilities.get_state()\n    expected['sleep_streak'] = 12\n    # During the execution of this test case, the free disk space could have\n    # changed.\n    for disk in expected['disks'].itervalues():\n      self.assertGreater(disk.pop('free_mb'), 1.)\n    actual = bot_main.get_state(None, 12)\n    for disk in actual['disks'].itervalues():\n      self.assertGreater(disk.pop('free_mb'), 1.)\n    self.assertGreater(actual.pop('nb_files_in_temp'), 0)\n    self.assertGreater(expected.pop('nb_files_in_temp'), 0)\n    self.assertGreater(actual.pop('uptime'), 0)\n    self.assertGreater(expected.pop('uptime'), 0)\n    self.assertEqual(sorted(expected.pop('temp', {})),\n                     sorted(actual.pop('temp', {})))\n    self.assertEqual(expected, actual)\n\n  def test_setup_bot(self):\n    self.mock(bot_main, 'get_remote', lambda: self.server)\n    setup_bots = []\n    def setup_bot(_bot):\n      setup_bots.append(1)\n      return False\n    from config import bot_config\n    self.mock(bot_config, 'setup_bot', setup_bot)\n    restarts = []\n    post_event = []\n    self.mock(\n        os_utilities, 'restart', lambda *a, **kw: restarts.append((a, kw)))\n    self.mock(\n        bot.Bot, 'post_event', lambda *a, **kw: post_event.append((a, kw)))\n    self.expected_requests([])\n    bot_main.setup_bot(False)\n    expected = [\n      (('Starting new swarming bot: %s' % bot_main.THIS_FILE,),\n        {'timeout': 900}),\n    ]\n    self.assertEqual(expected, restarts)\n    # It is called twice, one as part of setup_bot(False), another as part of\n    # on_shutdown_hook().\n    self.assertEqual([1, 1], setup_bots)\n    expected = [\n      'Starting new swarming bot: %s' % bot_main.THIS_FILE,\n      'Bot is stuck restarting for: Starting new swarming bot: %s' %\n        bot_main.THIS_FILE,\n    ]\n    self.assertEqual(expected, [i[0][2] for i in post_event])\n\n  def test_post_error_task(self):\n    self.mock(time, 'time', lambda: 126.0)\n    self.mock(logging, 'error', lambda *_, **_kw: None)\n    self.mock(bot_main, 'get_remote', lambda: self.server)\n    # get_state() return value changes over time. Hardcode its value for the\n    # duration of this test.\n    self.mock(os_utilities, 'get_state', lambda : {'foo': 'bar'})\n    expected_attribs = bot_main.get_attributes(None)\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',\n            {\n              'data': expected_attribs,\n              'headers': {'X-XSRF-Token-Request': '1'},\n            },\n            {'xsrf_token': 'token'},\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/task_error/23',\n            {\n              'data': {\n                'id': expected_attribs['dimensions']['id'][0],\n                'message': 'error',\n                'task_id': 23,\n              },\n              'headers': {'X-XSRF-Token': 'token'},\n            },\n            {},\n          ),\n        ])\n    botobj = bot_main.get_bot()\n    bot_main.post_error_task(botobj, 'error', 23)\n\n  def test_run_bot(self):\n    # Test the run_bot() loop. Does not use self.bot.\n    self.mock(time, 'time', lambda: 126.0)\n    class Foo(Exception):\n      pass\n\n    def poll_server(botobj, _):\n      sleep_streak = botobj.state['sleep_streak']\n      self.assertEqual(botobj.remote, self.server)\n      if sleep_streak == 5:\n        raise Exception('Jumping out of the loop')\n      return False\n    self.mock(bot_main, 'poll_server', poll_server)\n\n    def post_error(botobj, e):\n      self.assertEqual(self.server, botobj._remote)\n      lines = e.splitlines()\n      self.assertEqual('Jumping out of the loop', lines[0])\n      self.assertEqual('Traceback (most recent call last):', lines[1])\n      raise Foo('Necessary to get out of the loop')\n    self.mock(bot.Bot, 'post_error', post_error)\n\n    self.mock(bot_main, 'get_remote', lambda: self.server)\n\n    # Method should have \"self\" as first argument - pylint: disable=E0213\n    # pylint: disable=unused-argument\n    class Popen(object):\n      def __init__(\n          self2, cmd, detached, cwd, stdout, stderr, stdin, close_fds):\n        self2.returncode = None\n        expected = [sys.executable, bot_main.THIS_FILE, 'run_isolated']\n        self.assertEqual(expected, cmd[:len(expected)])\n        self.assertEqual(True, detached)\n        self.assertEqual(subprocess42.PIPE, stdout)\n        self.assertEqual(subprocess42.STDOUT, stderr)\n        self.assertEqual(subprocess42.PIPE, stdin)\n        self.assertEqual(sys.platform != 'win32', close_fds)\n\n      def communicate(self2, i):\n        self.assertEqual(None, i)\n        self2.returncode = 0\n        return '', None\n    self.mock(subprocess42, 'Popen', Popen)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/swarming/api/v1/bot/server_ping',\n            {}, 'foo', None,\n          ),\n        ])\n\n    with self.assertRaises(Foo):\n      bot_main.run_bot(None)\n    self.assertEqual(\n        os_utilities.get_hostname_short(), os.environ['SWARMING_BOT_ID'])\n\n  def test_poll_server_sleep(self):\n    slept = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', slept.append)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', self.fail)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {'xsrf_token': 'token'},\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {\n              'data': self.attributes,\n              'headers': {'X-XSRF-Token': 'token'},\n            },\n            {\n              'cmd': 'sleep',\n              'duration': 1.24,\n            },\n          ),\n        ])\n    self.assertFalse(bot_main.poll_server(self.bot, bit))\n    self.assertEqual([1.24], slept)\n\n  def test_poll_server_run(self):\n    manifest = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', lambda *args: manifest.append(args))\n    self.mock(bot_main, 'update_bot', self.fail)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {'xsrf_token': 'token'},\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {\n              'data': self.bot._attributes,\n              'headers': {'X-XSRF-Token': 'token'},\n            },\n            {\n              'cmd': 'run',\n              'manifest': {'foo': 'bar'},\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n    expected = [(self.bot, {'foo': 'bar'}, time.time())]\n    self.assertEqual(expected, manifest)\n\n  def test_poll_server_update(self):\n    update = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', lambda *args: update.append(args))\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {'xsrf_token': 'token'},\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {\n              'data': self.attributes,\n              'headers': {'X-XSRF-Token': 'token'},\n            },\n            {\n              'cmd': 'update',\n              'version': '123',\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n    self.assertEqual([(self.bot, '123')], update)\n\n  def test_poll_server_restart(self):\n    restart = []\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', self.fail)\n    self.mock(self.bot, 'restart', lambda *args: restart.append(args))\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {'xsrf_token': 'token'},\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {\n              'data': self.attributes,\n              'headers': {'X-XSRF-Token': 'token'},\n            },\n            {\n              'cmd': 'restart',\n              'message': 'Please die now',\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n    self.assertEqual([('Please die now',)], restart)\n\n  def test_poll_server_restart_load_test(self):\n    os.environ['SWARMING_LOAD_TEST'] = '1'\n    bit = threading.Event()\n    self.mock(bit, 'wait', self.fail)\n    self.mock(bot_main, 'run_manifest', self.fail)\n    self.mock(bot_main, 'update_bot', self.fail)\n    self.mock(self.bot, 'restart', self.fail)\n\n    self.expected_requests(\n        [\n          (\n            'https://localhost:1/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {'xsrf_token': 'token'},\n          ),\n          (\n            'https://localhost:1/swarming/api/v1/bot/poll',\n            {\n              'data': self.attributes,\n              'headers': {'X-XSRF-Token': 'token'},\n            },\n            {\n              'cmd': 'restart',\n              'message': 'Please die now',\n            },\n          ),\n        ])\n    self.assertTrue(bot_main.poll_server(self.bot, bit))\n\n  def _mock_popen(self, returncode=0, exit_code=0, url='https://localhost:1'):\n    result = {\n      'exit_code': exit_code,\n      'must_signal_internal_failure': None,\n      'version': 3,\n    }\n    # Method should have \"self\" as first argument - pylint: disable=E0213\n    class Popen(object):\n      def __init__(\n          self2, cmd, detached, cwd, env, stdout, stderr, stdin, close_fds):\n        self2.returncode = None\n        self2._out_file = os.path.join(\n            self.root_dir, 'work', 'task_runner_out.json')\n        expected = [\n          sys.executable, bot_main.THIS_FILE, 'task_runner',\n          '--swarming-server', url,\n          '--in-file',\n          os.path.join(self.root_dir, 'work', 'task_runner_in.json'),\n          '--out-file', self2._out_file,\n          '--cost-usd-hour', '3600.0', '--start', '100.0',\n          '--min-free-space',\n          str(int(\n            (os_utilities.get_min_free_space(bot_main.THIS_FILE) + 250.) *\n            1024 * 1024)),\n        ]\n        self.assertEqual(expected, cmd)\n        self.assertEqual(True, detached)\n        self.assertEqual(self.bot.base_dir, cwd)\n        self.assertEqual('24', env['SWARMING_TASK_ID'])\n        self.assertTrue(stdout)\n        self.assertEqual(subprocess42.STDOUT, stderr)\n        self.assertEqual(subprocess42.PIPE, stdin)\n        self.assertEqual(sys.platform != 'win32', close_fds)\n\n      def wait(self2, timeout=None): # pylint: disable=unused-argument\n        self2.returncode = returncode\n        with open(self2._out_file, 'wb') as f:\n          json.dump(result, f)\n        return 0\n\n    self.mock(subprocess42, 'Popen', Popen)\n    return result\n\n  def test_run_manifest(self):\n    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))\n    def call_hook(botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(self.attributes['dimensions'], botobj.dimensions)\n        self.assertEqual(False, failure)\n        self.assertEqual(False, internal_failure)\n        self.assertEqual({'os': 'Amiga', 'pool': 'default'}, dimensions)\n        self.assertEqual(result, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    result = self._mock_popen(url='https://localhost:3')\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'os': 'Amiga', 'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'host': 'https://localhost:3',\n      'task_id': '24',\n    }\n    self.assertEqual(self.root_dir, self.bot.base_dir)\n    bot_main.run_manifest(self.bot, manifest, time.time())\n\n  def test_run_manifest_task_failure(self):\n    self.mock(bot_main, 'post_error_task', lambda *args: self.fail(args))\n    def call_hook(_botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(True, failure)\n        self.assertEqual(False, internal_failure)\n        self.assertEqual({'pool': 'default'}, dimensions)\n        self.assertEqual(result, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    result = self._mock_popen(exit_code=1)\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'io_timeout': 60,\n      'task_id': '24',\n    }\n    bot_main.run_manifest(self.bot, manifest, time.time())\n\n  def test_run_manifest_internal_failure(self):\n    posted = []\n    self.mock(bot_main, 'post_error_task', lambda *args: posted.append(args))\n    def call_hook(_botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(False, failure)\n        self.assertEqual(True, internal_failure)\n        self.assertEqual({'pool': 'default'}, dimensions)\n        self.assertEqual(result, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    result = self._mock_popen(returncode=1)\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'io_timeout': 60,\n      'task_id': '24',\n    }\n    bot_main.run_manifest(self.bot, manifest, time.time())\n    expected = [(self.bot, 'Execution failed: internal error (1).', '24')]\n    self.assertEqual(expected, posted)\n\n  def test_run_manifest_exception(self):\n    posted = []\n    def post_error_task(botobj, msg, task_id):\n      posted.append((botobj, msg.splitlines()[0], task_id))\n    self.mock(bot_main, 'post_error_task', post_error_task)\n    def call_hook(_botobj, name, *args):\n      if name == 'on_after_task':\n        failure, internal_failure, dimensions, summary = args\n        self.assertEqual(False, failure)\n        self.assertEqual(True, internal_failure)\n        self.assertEqual({'pool': 'default'}, dimensions)\n        self.assertEqual({}, summary)\n    self.mock(bot_main, 'call_hook', call_hook)\n    def raiseOSError(*_a, **_k):\n      raise OSError('Dang')\n    self.mock(subprocess42, 'Popen', raiseOSError)\n\n    manifest = {\n      'command': ['echo', 'hi'],\n      'dimensions': {'pool': 'default'},\n      'grace_period': 30,\n      'hard_timeout': 60,\n      'task_id': '24',\n    }\n    bot_main.run_manifest(self.bot, manifest, time.time())\n    expected = [(self.bot, 'Internal exception occured: Dang', '24')]\n    self.assertEqual(expected, posted)\n\n  def test_update_bot(self):\n    # In a real case 'update_bot' never exits and doesn't call 'post_error'.\n    # Under the test however forever-blocking calls finish, and post_error is\n    # called.\n    self.mock(self.bot, 'post_error', lambda *_: None)\n    # Mock the file to download in the temporary directory.\n    self.mock(\n        bot_main, 'THIS_FILE',\n        os.path.join(self.root_dir, 'swarming_bot.1.zip'))\n    new_zip = os.path.join(self.root_dir, 'swarming_bot.2.zip')\n    # This is necessary otherwise zipfile will crash.\n    self.mock(time, 'time', lambda: 1400000000)\n    def url_retrieve(f, url):\n      self.assertEqual(\n          'https://localhost:1/swarming/api/v1/bot/bot_code/123', url)\n      self.assertEqual(new_zip, f)\n      # Create a valid zip that runs properly.\n      with zipfile.ZipFile(f, 'w') as z:\n        z.writestr('__main__.py', 'print(\"hi\")')\n      return True\n    self.mock(net, 'url_retrieve', url_retrieve)\n\n    calls = []\n    def exec_python(args):\n      calls.append(args)\n      return 23\n    self.mock(bot_main.common, 'exec_python', exec_python)\n\n    with self.assertRaises(SystemExit) as e:\n      bot_main.update_bot(self.bot, '123')\n    self.assertEqual(23, e.exception.code)\n\n    self.assertEqual([[new_zip, 'start_slave', '--survive']], calls)\n\n  def test_main(self):\n    def check(x):\n      self.assertEqual(logging.WARNING, x)\n    self.mock(logging_utils, 'set_console_level', check)\n\n    def run_bot(error):\n      self.assertEqual(None, error)\n      return 0\n    self.mock(bot_main, 'run_bot', run_bot)\n\n    class Singleton(object):\n      # pylint: disable=no-self-argument\n      def acquire(self2):\n        return True\n      def release(self2):\n        self.fail()\n    self.mock(bot_main, 'SINGLETON', Singleton())\n\n    self.assertEqual(0, bot_main.main([]))\n\n\nif __name__ == '__main__':\n  fix_encoding.fix_encoding()\n  if '-v' in sys.argv:\n    unittest.TestCase.maxDiff = None\n  logging.basicConfig(\n      level=logging.DEBUG if '-v' in sys.argv else logging.CRITICAL)\n  unittest.main()\n/n/n/n/appengine/swarming/swarming_bot/bot_code/task_runner.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Runs a Swarming task.\n\nDownloads all the necessary files to run the task, executes the command and\nstreams results back to the Swarming server.\n\nThe process exit code is 0 when the task was executed, even if the task itself\nfailed. If there's any failure in the setup or teardown, like invalid packet\nresponse, failure to contact the server, etc, a non zero exit code is used. It's\nup to the calling process (bot_main.py) to signal that there was an internal\nfailure and to cancel this task run and ask the server to retry it.\n\"\"\"\n\nimport base64\nimport json\nimport logging\nimport optparse\nimport os\nimport signal\nimport sys\nimport time\n\nimport xsrf_client\nfrom utils import net\nfrom utils import on_error\nfrom utils import subprocess42\nfrom utils import zip_package\n\n\n# Path to this file or the zip containing this file.\nTHIS_FILE = os.path.abspath(zip_package.get_main_script_path())\n\n\n# Sends a maximum of 100kb of stdout per task_update packet.\nMAX_CHUNK_SIZE = 102400\n\n\n# Maximum wait between task_update packet when there's no output.\nMAX_PACKET_INTERVAL = 30\n\n\n# Minimum wait between task_update packet when there's output.\nMIN_PACKET_INTERNAL = 10\n\n\n# Current task_runner_out version.\nOUT_VERSION = 3\n\n\n# On Windows, SIGTERM is actually sent as SIGBREAK since there's no real\n# SIGTERM.  SIGBREAK is not defined on posix since it's a pure Windows concept.\nSIG_BREAK_OR_TERM = (\n    signal.SIGBREAK if sys.platform == 'win32' else signal.SIGTERM)\n\n\n# Used to implement monotonic_time for a clock that never goes backward.\n_last_now = 0\n\n\ndef monotonic_time():\n  \"\"\"Returns monotonically increasing time.\"\"\"\n  global _last_now\n  now = time.time()\n  if now > _last_now:\n    # TODO(maruel): If delta is large, probably worth alerting via ereporter2.\n    _last_now = now\n  return _last_now\n\n\ndef get_run_isolated():\n  \"\"\"Returns the path to itself to run run_isolated.\n\n  Mocked in test to point to the real run_isolated.py script.\n  \"\"\"\n  return [sys.executable, THIS_FILE, 'run_isolated']\n\n\ndef get_isolated_cmd(\n    work_dir, task_details, isolated_result, min_free_space):\n  \"\"\"Returns the command to call run_isolated. Mocked in tests.\"\"\"\n  bot_dir = os.path.dirname(work_dir)\n  if os.path.isfile(isolated_result):\n    os.remove(isolated_result)\n  cmd = get_run_isolated()\n  cmd.extend(\n      [\n        '--isolated', task_details.inputs_ref['isolated'].encode('utf-8'),\n        '--namespace', task_details.inputs_ref['namespace'].encode('utf-8'),\n        '-I', task_details.inputs_ref['isolatedserver'].encode('utf-8'),\n        '--json', isolated_result,\n        '--log-file', os.path.join(bot_dir, 'logs', 'run_isolated.log'),\n        '--cache', os.path.join(bot_dir, 'cache'),\n        '--root-dir', os.path.join(work_dir, 'isolated'),\n      ])\n  if min_free_space:\n    cmd.extend(('--min-free-space', str(min_free_space)))\n\n  if task_details.hard_timeout:\n    cmd.extend(('--hard-timeout', str(task_details.hard_timeout)))\n  if task_details.grace_period:\n    cmd.extend(('--grace-period', str(task_details.grace_period)))\n  if task_details.extra_args:\n    cmd.append('--')\n    cmd.extend(task_details.extra_args)\n  return cmd\n\n\nclass TaskDetails(object):\n  def __init__(self, data):\n    \"\"\"Loads the raw data.\n\n    It is expected to have at least:\n     - bot_id\n     - command as a list of str\n     - data as a list of urls\n     - env as a dict\n     - hard_timeout\n     - io_timeout\n     - task_id\n    \"\"\"\n    logging.info('TaskDetails(%s)', data)\n    if not isinstance(data, dict):\n      raise ValueError('Expected dict, got %r' % data)\n\n    # Get all the data first so it fails early if the task details is invalid.\n    self.bot_id = data['bot_id']\n\n    # Raw command. Only self.command or self.inputs_ref can be set.\n    self.command = data['command'] or []\n\n    # Isolated command. Is a serialized version of task_request.FilesRef.\n    self.inputs_ref = data['inputs_ref']\n    self.extra_args = data['extra_args']\n\n    self.env = {\n      k.encode('utf-8'): v.encode('utf-8') for k, v in data['env'].iteritems()\n    }\n    self.grace_period = data['grace_period']\n    self.hard_timeout = data['hard_timeout']\n    self.io_timeout = data['io_timeout']\n    self.task_id = data['task_id']\n\n\nclass MustExit(Exception):\n  \"\"\"Raised on signal that the process must exit immediately.\"\"\"\n  def __init__(self, sig):\n    super(MustExit, self).__init__()\n    self.signal = sig\n\n\ndef load_and_run(\n    in_file, swarming_server, cost_usd_hour, start, out_file, min_free_space):\n  \"\"\"Loads the task's metadata and execute it.\n\n  This may throw all sorts of exceptions in case of failure. It's up to the\n  caller to trap them. These shall be considered 'internal_failure' instead of\n  'failure' from a TaskRunResult standpoint.\n  \"\"\"\n  # The work directory is guaranteed to exist since it was created by\n  # bot_main.py and contains the manifest. Temporary files will be downloaded\n  # there. It's bot_main.py that will delete the directory afterward. Tests are\n  # not run from there.\n  task_result = None\n  def handler(sig, _):\n    logging.info('Got signal %s', sig)\n    raise MustExit(sig)\n  work_dir = os.path.dirname(out_file)\n  try:\n    with subprocess42.set_signal_handler([SIG_BREAK_OR_TERM], handler):\n      if not os.path.isdir(work_dir):\n        raise ValueError('%s expected to exist' % work_dir)\n\n      with open(in_file, 'rb') as f:\n        task_details = TaskDetails(json.load(f))\n\n      task_result = run_command(\n          swarming_server, task_details, work_dir, cost_usd_hour, start,\n          min_free_space)\n  except MustExit as e:\n    # This normally means run_command() didn't get the chance to run, as it\n    # itself trap MustExit and will report accordingly. In this case, we want\n    # the parent process to send the message instead.\n    if not task_result:\n      task_result = {\n        u'exit_code': None,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure':\n            u'task_runner received signal %s' % e.signal,\n        u'version': OUT_VERSION,\n      }\n  finally:\n    # We've found tests to delete 'work' when quitting, causing an exception\n    # here. Try to recreate the directory if necessary.\n    if not os.path.isdir(work_dir):\n      os.mkdir(work_dir)\n    with open(out_file, 'wb') as f:\n      json.dump(task_result, f)\n\n\ndef post_update(swarming_server, params, exit_code, stdout, output_chunk_start):\n  \"\"\"Posts task update to task_update.\n\n  Arguments:\n    swarming_server: XsrfRemote instance.\n    params: Default JSON parameters for the POST.\n    exit_code: Process exit code, only when a command completed.\n    stdout: Incremental output since last call, if any.\n    output_chunk_start: Total number of stdout previously sent, for coherency\n        with the server.\n  \"\"\"\n  params = params.copy()\n  if exit_code is not None:\n    params['exit_code'] = exit_code\n  if stdout:\n    # The output_chunk_start is used by the server to make sure that the stdout\n    # chunks are processed and saved in the DB in order.\n    params['output'] = base64.b64encode(stdout)\n    params['output_chunk_start'] = output_chunk_start\n  # TODO(maruel): Support early cancellation.\n  # https://code.google.com/p/swarming/issues/detail?id=62\n  resp = swarming_server.url_read_json(\n      '/swarming/api/v1/bot/task_update/%s' % params['task_id'], data=params)\n  logging.debug('post_update() = %s', resp)\n  if resp.get('error'):\n    # Abandon it. This will force a process exit.\n    raise ValueError(resp.get('error'))\n\n\ndef should_post_update(stdout, now, last_packet):\n  \"\"\"Returns True if it's time to send a task_update packet via post_update().\n\n  Sends a packet when one of this condition is met:\n  - more than MAX_CHUNK_SIZE of stdout is buffered.\n  - last packet was sent more than MIN_PACKET_INTERNAL seconds ago and there was\n    stdout.\n  - last packet was sent more than MAX_PACKET_INTERVAL seconds ago.\n  \"\"\"\n  packet_interval = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL\n  return len(stdout) >= MAX_CHUNK_SIZE or (now - last_packet) > packet_interval\n\n\ndef calc_yield_wait(task_details, start, last_io, timed_out, stdout):\n  \"\"\"Calculates the maximum number of seconds to wait in yield_any().\"\"\"\n  now = monotonic_time()\n  if timed_out:\n    # Give a |grace_period| seconds delay.\n    if task_details.grace_period:\n      return max(now - timed_out - task_details.grace_period, 0.)\n    return 0.\n\n  out = MIN_PACKET_INTERNAL if stdout else MAX_PACKET_INTERVAL\n  if task_details.hard_timeout:\n    out = min(out, start + task_details.hard_timeout - now)\n  if task_details.io_timeout:\n    out = min(out, last_io + task_details.io_timeout - now)\n  out = max(out, 0)\n  logging.debug('calc_yield_wait() = %d', out)\n  return out\n\n\ndef kill_and_wait(proc, grace_period, reason):\n  logging.warning('SIGTERM finally due to %s', reason)\n  proc.terminate()\n  try:\n    proc.wait(grace_period)\n  except subprocess42.TimeoutError:\n    logging.warning('SIGKILL finally due to %s', reason)\n    proc.kill()\n  exit_code = proc.wait()\n  logging.info('Waiting for proces exit in finally - done')\n  return exit_code\n\n\ndef run_command(\n    swarming_server, task_details, work_dir, cost_usd_hour, task_start,\n    min_free_space):\n  \"\"\"Runs a command and sends packets to the server to stream results back.\n\n  Implements both I/O and hard timeouts. Sends the packets numbered, so the\n  server can ensure they are processed in order.\n\n  Returns:\n    Metadata about the command.\n  \"\"\"\n  # TODO(maruel): This function is incomprehensible, split and refactor.\n  # Signal the command is about to be started.\n  last_packet = start = now = monotonic_time()\n  params = {\n    'cost_usd': cost_usd_hour * (now - task_start) / 60. / 60.,\n    'id': task_details.bot_id,\n    'task_id': task_details.task_id,\n  }\n  post_update(swarming_server, params, None, '', 0)\n\n  if task_details.command:\n    # Raw command.\n    cmd = task_details.command\n    isolated_result = None\n  else:\n    # Isolated task.\n    isolated_result = os.path.join(work_dir, 'isolated_result.json')\n    cmd = get_isolated_cmd(\n        work_dir, task_details, isolated_result, min_free_space)\n    # Hard timeout enforcement is deferred to run_isolated. Grace is doubled to\n    # give one 'grace_period' slot to the child process and one slot to upload\n    # the results back.\n    task_details.hard_timeout = 0\n    if task_details.grace_period:\n      task_details.grace_period *= 2\n\n  try:\n    # TODO(maruel): Support both channels independently and display stderr in\n    # red.\n    env = None\n    if task_details.env:\n      env = os.environ.copy()\n      for key, value in task_details.env.iteritems():\n        if not value:\n          env.pop(key, None)\n        else:\n          env[key] = value\n    logging.info('cmd=%s', cmd)\n    logging.info('env=%s', env)\n    try:\n      proc = subprocess42.Popen(\n          cmd,\n          env=env,\n          cwd=work_dir,\n          detached=True,\n          stdout=subprocess42.PIPE,\n          stderr=subprocess42.STDOUT,\n          stdin=subprocess42.PIPE)\n    except OSError as e:\n      stdout = 'Command \"%s\" failed to start.\\nError: %s' % (' '.join(cmd), e)\n      now = monotonic_time()\n      params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.\n      params['duration'] = now - start\n      params['io_timeout'] = False\n      params['hard_timeout'] = False\n      post_update(swarming_server, params, 1, stdout, 0)\n      return {\n        u'exit_code': -1,\n        u'hard_timeout': False,\n        u'io_timeout': False,\n        u'must_signal_internal_failure': None,\n        u'version': OUT_VERSION,\n      }\n\n    output_chunk_start = 0\n    stdout = ''\n    exit_code = None\n    had_hard_timeout = False\n    had_io_timeout = False\n    must_signal_internal_failure = None\n    kill_sent = False\n    timed_out = None\n    try:\n      calc = lambda: calc_yield_wait(\n          task_details, start, last_io, timed_out, stdout)\n      maxsize = lambda: MAX_CHUNK_SIZE - len(stdout)\n      last_io = monotonic_time()\n      for _, new_data in proc.yield_any(maxsize=maxsize, timeout=calc):\n        now = monotonic_time()\n        if new_data:\n          stdout += new_data\n          last_io = now\n\n        # Post update if necessary.\n        if should_post_update(stdout, now, last_packet):\n          last_packet = monotonic_time()\n          params['cost_usd'] = (\n              cost_usd_hour * (last_packet - task_start) / 60. / 60.)\n          post_update(swarming_server, params, None, stdout, output_chunk_start)\n          output_chunk_start += len(stdout)\n          stdout = ''\n\n        # Send signal on timeout if necessary. Both are failures, not\n        # internal_failures.\n        # Eventually kill but return 0 so bot_main.py doesn't cancel the task.\n        if not timed_out:\n          if (task_details.io_timeout and\n              now - last_io > task_details.io_timeout):\n            had_io_timeout = True\n            logging.warning('I/O timeout; sending SIGTERM')\n            proc.terminate()\n            timed_out = monotonic_time()\n          elif (task_details.hard_timeout and\n              now - start > task_details.hard_timeout):\n            had_hard_timeout = True\n            logging.warning('Hard timeout; sending SIGTERM')\n            proc.terminate()\n            timed_out = monotonic_time()\n        else:\n          # During grace period.\n          if not kill_sent and now >= timed_out + task_details.grace_period:\n            # Now kill for real. The user can distinguish between the following\n            # states:\n            # - signal but process exited within grace period,\n            #   (hard_|io_)_timed_out will be set but the process exit code will\n            #   be script provided.\n            # - processed exited late, exit code will be -9 on posix.\n            logging.warning('Grace exhausted; sending SIGKILL')\n            proc.kill()\n            kill_sent = True\n      logging.info('Waiting for proces exit')\n      exit_code = proc.wait()\n    except MustExit as e:\n      # TODO(maruel): Do the send SIGTERM to child process and give it\n      # task_details.grace_period to terminate.\n      must_signal_internal_failure = (\n          u'task_runner received signal %s' % e.signal)\n      exit_code = kill_and_wait(\n          proc, task_details.grace_period, 'signal %d' % e.signal)\n    except (IOError, OSError):\n      # Something wrong happened, try to kill the child process.\n      had_hard_timeout = True\n      exit_code = kill_and_wait(\n          proc, task_details.grace_period, 'exception %s' % e)\n\n    # This is the very last packet for this command. It if was an isolated task,\n    # include the output reference to the archived .isolated file.\n    now = monotonic_time()\n    params['cost_usd'] = cost_usd_hour * (now - task_start) / 60. / 60.\n    params['duration'] = now - start\n    params['io_timeout'] = had_io_timeout\n    params['hard_timeout'] = had_hard_timeout\n    if isolated_result:\n      try:\n        if ((had_io_timeout or had_hard_timeout) and\n            not os.path.isfile(isolated_result)):\n          # It's possible that run_isolated failed to quit quickly enough; it\n          # could be because there was too much data to upload back or something\n          # else. Do not create an internal error, just send back the (partial)\n          # view as task_runner saw it, for example the real exit_code is\n          # unknown.\n          logging.warning('TIMED_OUT and there\\'s no result file')\n          exit_code = -1\n        else:\n          # See run_isolated.py for the format.\n          with open(isolated_result, 'rb') as f:\n            run_isolated_result = json.load(f)\n          logging.debug('run_isolated:\\n%s', run_isolated_result)\n          # TODO(maruel): Grab statistics (cache hit rate, data downloaded,\n          # mapping time, etc) from run_isolated and push them to the server.\n          if run_isolated_result['outputs_ref']:\n            params['outputs_ref'] = run_isolated_result['outputs_ref']\n          had_hard_timeout = (\n              had_hard_timeout or run_isolated_result['had_hard_timeout'])\n          params['hard_timeout'] = had_hard_timeout\n          if not had_io_timeout and not had_hard_timeout:\n            if run_isolated_result['internal_failure']:\n              must_signal_internal_failure = (\n                  run_isolated_result['internal_failure'])\n              logging.error('%s', must_signal_internal_failure)\n            elif exit_code:\n              # TODO(maruel): Grab stdout from run_isolated.\n              must_signal_internal_failure = (\n                  'run_isolated internal failure %d' % exit_code)\n              logging.error('%s', must_signal_internal_failure)\n          exit_code = run_isolated_result['exit_code']\n          if run_isolated_result.get('duration') is not None:\n            # Calculate the real task duration as measured by run_isolated and\n            # calculate the remaining overhead.\n            params['bot_overhead'] = params['duration']\n            params['duration'] = run_isolated_result['duration']\n            params['bot_overhead'] -= params['duration']\n            params['bot_overhead'] -= run_isolated_result.get(\n                'download', {}).get('duration', 0)\n            params['bot_overhead'] -= run_isolated_result.get(\n                'upload', {}).get('duration', 0)\n            if params['bot_overhead'] < 0:\n              params['bot_overhead'] = 0\n          stats = run_isolated_result.get('stats')\n          if stats:\n            params['isolated_stats'] = stats\n      except (IOError, OSError, ValueError) as e:\n        logging.error('Swallowing error: %s', e)\n        if not must_signal_internal_failure:\n          must_signal_internal_failure = str(e)\n    # TODO(maruel): Send the internal failure here instead of sending it through\n    # bot_main, this causes a race condition.\n    if exit_code is None:\n      exit_code = -1\n    post_update(swarming_server, params, exit_code, stdout, output_chunk_start)\n    return {\n      u'exit_code': exit_code,\n      u'hard_timeout': had_hard_timeout,\n      u'io_timeout': had_io_timeout,\n      u'must_signal_internal_failure': must_signal_internal_failure,\n      u'version': OUT_VERSION,\n    }\n  finally:\n    if isolated_result:\n      try:\n        os.remove(isolated_result)\n      except OSError:\n        pass\n\n\ndef main(args):\n  parser = optparse.OptionParser(description=sys.modules[__name__].__doc__)\n  parser.add_option('--in-file', help='Name of the request file')\n  parser.add_option(\n      '--out-file', help='Name of the JSON file to write a task summary to')\n  parser.add_option(\n      '--swarming-server', help='Swarming server to send data back')\n  parser.add_option(\n      '--cost-usd-hour', type='float', help='Cost of this VM in $/h')\n  parser.add_option('--start', type='float', help='Time this task was started')\n  parser.add_option(\n      '--min-free-space', type='int',\n      help='Value to send down to run_isolated')\n\n  options, args = parser.parse_args(args)\n  if not options.in_file or not options.out_file or args:\n    parser.error('task_runner is meant to be used by swarming_bot.')\n\n  on_error.report_on_exception_exit(options.swarming_server)\n\n  logging.info('starting')\n  remote = xsrf_client.XsrfRemote(options.swarming_server)\n\n  now = monotonic_time()\n  if options.start > now:\n    options.start = now\n\n  try:\n    load_and_run(\n        options.in_file, remote, options.cost_usd_hour, options.start,\n        options.out_file, options.min_free_space)\n    return 0\n  finally:\n    logging.info('quitting')\n/n/n/n/appengine/swarming/swarming_bot/bot_code/xsrf_client.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\n\"\"\"Wraps URL requests with an XSRF token using components/auth based service.\"\"\"\n\nimport datetime\nimport logging\nimport os\nimport sys\n\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\n\nsys.path.insert(0, os.path.join(THIS_DIR, 'third_party'))\n\nfrom utils import net\n\n\nclass Error(Exception):\n  pass\n\n\ndef _utcnow():\n  \"\"\"So it can be mocked.\"\"\"\n  return datetime.datetime.utcnow()\n\n\nclass XsrfRemote(object):\n  \"\"\"Transparently adds XSRF token to requests.\"\"\"\n  TOKEN_RESOURCE = '/auth/api/v1/accounts/self/xsrf_token'\n\n  def __init__(self, url, token_resource=None):\n    self.url = url.rstrip('/')\n    self.token = None\n    self.token_resource = token_resource or self.TOKEN_RESOURCE\n    self.expiration = None\n    self.xsrf_request_params = {}\n\n  def url_read(self, resource, **kwargs):\n    url = self.url + resource\n    if kwargs.get('data') == None:\n      # No XSRF token for GET.\n      return net.url_read(url, **kwargs)\n\n    if self.need_refresh():\n      self.refresh_token()\n    resp = self._url_read_post(url, **kwargs)\n    if resp is None:\n      raise Error('Failed to connect to %s; %s' % (url, self.expiration))\n    return resp\n\n  def url_read_json(self, resource, **kwargs):\n    url = self.url + resource\n    if kwargs.get('data') == None:\n      # No XSRF token required for GET.\n      return net.url_read_json(url, **kwargs)\n\n    if self.need_refresh():\n      self.refresh_token()\n    resp = self._url_read_json_post(url, **kwargs)\n    if resp is None:\n      raise Error('Failed to connect to %s; %s' % (url, self.expiration))\n    return resp\n\n  def refresh_token(self):\n    \"\"\"Returns a fresh token. Necessary as the token may expire after an hour.\n    \"\"\"\n    url = self.url + self.token_resource\n    resp = net.url_read_json(\n        url,\n        headers={'X-XSRF-Token-Request': '1'},\n        data=self.xsrf_request_params)\n    if resp is None:\n      raise Error('Failed to connect to %s' % url)\n    self.token = resp['xsrf_token']\n    if resp.get('expiration_sec'):\n      exp = resp['expiration_sec']\n      exp -= min(round(exp * 0.1), 600)\n      self.expiration = _utcnow() + datetime.timedelta(seconds=exp)\n    return self.token\n\n  def need_refresh(self):\n    \"\"\"Returns True if the XSRF token needs to be refreshed.\"\"\"\n    return (\n        not self.token or (self.expiration and self.expiration <= _utcnow()))\n\n  def _url_read_post(self, url, **kwargs):\n    headers = (kwargs.pop('headers', None) or {}).copy()\n    headers['X-XSRF-Token'] = self.token\n    return net.url_read(url, headers=headers, **kwargs)\n\n  def _url_read_json_post(self, url, **kwargs):\n    headers = (kwargs.pop('headers', None) or {}).copy()\n    headers['X-XSRF-Token'] = self.token\n    return net.url_read_json(url, headers=headers, **kwargs)\n/n/n/n/appengine/swarming/swarming_bot/bot_code/xsrf_client_test.py/n/n#!/usr/bin/env python\n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport datetime\nimport logging\nimport os\nimport sys\nimport time\nimport unittest\n\nimport test_env_bot_code\ntest_env_bot_code.setup_test_env()\n\n# Creates a server mock for functions in net.py.\nimport net_utils\n\nimport xsrf_client\n\n\nclass UrlHelperTest(net_utils.TestCase):\n  def setUp(self):\n    super(UrlHelperTest, self).setUp()\n    self.mock(logging, 'error', lambda *_: None)\n    self.mock(logging, 'exception', lambda *_: None)\n    self.mock(logging, 'info', lambda *_: None)\n    self.mock(logging, 'warning', lambda *_: None)\n    self.mock(time, 'sleep', lambda _: None)\n\n  def testXsrfRemoteGET(self):\n    self.expected_requests([('http://localhost/a', {}, 'foo', None)])\n\n    remote = xsrf_client.XsrfRemote('http://localhost/')\n    self.assertEqual('foo', remote.url_read('/a'))\n\n  def testXsrfRemoteSimple(self):\n    self.expected_requests(\n        [\n          (\n            'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {\n              'expiration_sec': 100,\n              'xsrf_token': 'token',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},\n            'foo',\n            None,\n          ),\n        ])\n\n    remote = xsrf_client.XsrfRemote('http://localhost/')\n    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))\n\n  def testXsrfRemoteRefresh(self):\n    self.expected_requests(\n        [\n          (\n            'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {\n              'expiration_sec': 100,\n              'xsrf_token': 'token',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},\n            'bar',\n            None,\n          ),\n          (\n            'http://localhost/auth/api/v1/accounts/self/xsrf_token',\n            {'data': {}, 'headers': {'X-XSRF-Token-Request': '1'}},\n            {\n              'expiration_sec': 100,\n              'xsrf_token': 'token2',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token2'}},\n            'foo',\n            None,\n          ),\n        ])\n\n    now = xsrf_client._utcnow()\n    remote = xsrf_client.XsrfRemote('http://localhost/')\n    remote.url_read('/a', data={'foo': 'bar'})\n    self.mock(\n        xsrf_client, '_utcnow', lambda: now + datetime.timedelta(seconds=91))\n    remote.url_read('/a', data={'foo': 'bar'})\n\n  def testXsrfRemoteCustom(self):\n    # Use the new swarming bot API as an example of custom XSRF request handler.\n    self.expected_requests(\n        [\n          (\n            'http://localhost/swarming/api/v1/bot/handshake',\n            {\n              'data': {'attributes': 'b'},\n              'headers': {'X-XSRF-Token-Request': '1'},\n            },\n            {\n              'expiration_sec': 100,\n              'ignored': True,\n              'xsrf_token': 'token',\n            },\n          ),\n          (\n            'http://localhost/a',\n            {'data': {'foo': 'bar'}, 'headers': {'X-XSRF-Token': 'token'}},\n            'foo',\n            None,\n          ),\n        ])\n\n    remote = xsrf_client.XsrfRemote(\n        'http://localhost/',\n        '/swarming/api/v1/bot/handshake')\n    remote.xsrf_request_params = {'attributes': 'b'}\n    self.assertEqual('foo', remote.url_read('/a', data={'foo': 'bar'}))\n\n\nif __name__ == '__main__':\n  logging.basicConfig(level=logging.ERROR)\n  unittest.main()\n/n/n/n/client/tests/net_utils.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed by the Apache v2.0 license that can be\n# found in the LICENSE file.\n\nimport logging\nimport os\nimport sys\nimport threading\n\nTEST_DIR = os.path.dirname(os.path.abspath(__file__))\nROOT_DIR = os.path.dirname(TEST_DIR)\nsys.path.insert(0, ROOT_DIR)\nsys.path.insert(0, os.path.join(ROOT_DIR, 'third_party'))\n\nfrom depot_tools import auto_stub\nfrom utils import net\n\n\ndef make_fake_response(content, url, headers=None):\n  \"\"\"Returns HttpResponse with predefined content, useful in tests.\"\"\"\n  headers = dict(headers or {})\n  headers['Content-Length'] = len(content)\n  class _Fake(object):\n    def __init__(self):\n      self.content = content\n    def iter_content(self, chunk_size):\n      c = self.content\n      while c:\n        yield c[:chunk_size]\n        c = c[chunk_size:]\n    def read(self):\n      return self.content\n  return net.HttpResponse(_Fake(), url, headers)\n\n\nclass TestCase(auto_stub.TestCase):\n  \"\"\"Mocks out url_open() calls.\"\"\"\n  def setUp(self):\n    super(TestCase, self).setUp()\n    self.mock(net, 'url_open', self._url_open)\n    self.mock(net, 'url_read_json', self._url_read_json)\n    self.mock(net, 'sleep_before_retry', lambda *_: None)\n    self._lock = threading.Lock()\n    self._requests = []\n\n  def tearDown(self):\n    try:\n      if not self.has_failed():\n        self.assertEqual([], self._requests)\n    finally:\n      super(TestCase, self).tearDown()\n\n  def expected_requests(self, requests):\n    \"\"\"Registers the expected requests along their reponses.\n\n    Arguments:\n      request: list of tuple(url, kwargs, response, headers) for normal requests\n          and tuple(url, kwargs, response) for json requests. kwargs can be a\n          callable. In that case, it's called with the actual kwargs. It's\n          useful when the kwargs values are not deterministic.\n    \"\"\"\n    requests = requests[:]\n    for request in requests:\n      self.assertEqual(tuple, request.__class__)\n      # 3 = json request (url_read_json).\n      # 4 = normal request (url_open).\n      self.assertIn(len(request), (3, 4))\n\n    with self._lock:\n      self.assertEqual([], self._requests)\n      self._requests = requests\n\n  def _url_open(self, url, **kwargs):\n    logging.warn('url_open(%s, %s)', url[:500], str(kwargs)[:500])\n    with self._lock:\n      if not self._requests:\n        return None\n      # Ignore 'stream' argument, it's not important for these tests.\n      kwargs.pop('stream', None)\n      for i, n in enumerate(self._requests):\n        if n[0] == url:\n          data = self._requests.pop(i)\n          if len(data) != 4:\n            self.fail('Expected normal request, got json data; %s' % url)\n          _, expected_kwargs, result, headers = data\n          if callable(expected_kwargs):\n            expected_kwargs(kwargs)\n          else:\n            self.assertEqual(expected_kwargs, kwargs)\n          if result is not None:\n            return make_fake_response(result, url, headers)\n          return None\n    self.fail('Unknown request %s' % url)\n\n  def _url_read_json(self, url, **kwargs):\n    logging.warn('url_read_json(%s, %s)', url[:500], str(kwargs)[:500])\n    with self._lock:\n      if not self._requests:\n        return None\n      # Ignore 'stream' argument, it's not important for these tests.\n      kwargs.pop('stream', None)\n      for i, n in enumerate(self._requests):\n        if n[0] == url:\n          data = self._requests.pop(i)\n          if len(data) != 3:\n            self.fail('Expected json request, got normal data; %s' % url)\n          _, expected_kwargs, result = data\n          if callable(expected_kwargs):\n            expected_kwargs(kwargs)\n          else:\n            self.assertEqual(expected_kwargs, kwargs)\n          if result is not None:\n            return result\n          return None\n    self.fail('Unknown request %s' % url)\n/n/n/n", "label": 1}, {"id": "481a3e8120787d449ad7bbc6a627d8450bceb85c", "code": "appengine/components/components/auth/ui/ui.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Auth management UI handlers.\"\"\"\n\nimport functools\nimport json\nimport os\nimport re\nimport webapp2\n\nfrom components import template\nfrom components import utils\n\nfrom . import acl\nfrom . import rest_api\n\nfrom .. import api\nfrom .. import change_log\nfrom .. import handler\nfrom .. import model\nfrom .. import replication\n\n\n# templates/.\nTEMPLATES_DIR = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), 'templates')\n\n\n# Global static configuration set in 'configure_ui'.\n_ui_app_name = 'Unknown'\n_ui_data_callback = None\n_ui_navbar_tabs = ()\n\n\ndef configure_ui(app_name, ui_tabs=None, ui_data_callback=None):\n  \"\"\"Modifies global configuration of Auth UI.\n\n  Args:\n    app_name: name of the service (visible in page headers, titles, etc.)\n    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or\n        None to show the standard set of tabs.\n    ui_data_callback: an argumentless callable that returns a dict with\n        additional data to return to authenticated users. It can be used by\n        server and client side code to render templates. Used by auth_service.\n  \"\"\"\n  global _ui_app_name\n  global _ui_data_callback\n  global _ui_navbar_tabs\n  _ui_app_name = app_name\n  _ui_data_callback = ui_data_callback\n  if ui_tabs is not None:\n    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)\n    _ui_navbar_tabs = tuple(ui_tabs)\n  template.bootstrap({'auth': TEMPLATES_DIR})\n\n\ndef get_ui_routes():\n  \"\"\"Returns a list of routes with auth UI handlers.\"\"\"\n  routes = []\n  if not utils.should_disable_ui_routes():\n    # Routes for registered navbar tabs.\n    for cls in _ui_navbar_tabs:\n      routes.extend(cls.get_webapp2_routes())\n    # Routes for everything else.\n    routes.extend([\n      webapp2.Route(r'/auth', MainHandler),\n      webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),\n      webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),\n      webapp2.Route(r'/auth/link', LinkToPrimaryHandler),\n    ])\n  return routes\n\n\ndef forbid_ui_on_replica(method):\n  \"\"\"Decorator for methods that are not allowed to be called on Replica.\n\n  If such method is called on a service in Replica mode, it would return\n  HTTP 405 \"Method Not Allowed\".\n  \"\"\"\n  @functools.wraps(method)\n  def wrapper(self, *args, **kwargs):\n    assert isinstance(self, webapp2.RequestHandler)\n    if model.is_replica():\n      primary_url = model.get_replication_state().primary_url\n      self.abort(\n          405,\n          detail='Not allowed on a replica, see primary at %s' % primary_url)\n    return method(self, *args, **kwargs)\n  return wrapper\n\n\ndef redirect_ui_on_replica(method):\n  \"\"\"Decorator for methods that redirect to Primary when called on replica.\n\n  If such method is called on a service in Replica mode, it would return\n  HTTP 302 redirect to corresponding method on Primary.\n  \"\"\"\n  @functools.wraps(method)\n  def wrapper(self, *args, **kwargs):\n    assert isinstance(self, webapp2.RequestHandler)\n    assert self.request.method == 'GET'\n    if model.is_replica():\n      primary_url = model.get_replication_state().primary_url\n      protocol = 'http://' if utils.is_local_dev_server() else 'https://'\n      assert primary_url and primary_url.startswith(protocol), primary_url\n      assert self.request.path_qs.startswith('/'), self.request.path_qs\n      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)\n    return method(self, *args, **kwargs)\n  return wrapper\n\n\n################################################################################\n## Admin routes. The use cookies and GAE's \"is_current_user_admin\" for authn.\n\n\nclass AdminPageHandler(handler.AuthenticatingHandler):\n  \"\"\"Base class for handlers involved in bootstrap processes.\"\"\"\n\n  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of\n  # all 'style=...' attributes first.\n  csp_use_script_nonce = True\n\n  @classmethod\n  def get_auth_methods(cls, conf):\n    # This method sets 'is_superuser' bit for GAE-level admins.\n    return [handler.gae_cookie_authentication]\n\n  def reply(self, path, env=None, status=200):\n    \"\"\"Render template |path| to response using given environment.\n\n    Args:\n      path: path to a template, relative to templates/.\n      env: additional environment dict to use when rendering the template.\n      status: HTTP status code to return.\n    \"\"\"\n    full_env = {\n      'app_name': _ui_app_name,\n      'csp_nonce': self.csp_nonce,\n      'identity': api.get_current_identity(),\n      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    full_env.update(env or {})\n    self.response.set_status(status)\n    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'\n    self.response.write(template.render(path, full_env))\n\n  def authentication_error(self, error):\n    \"\"\"Shows 'Access denied' page.\"\"\"\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/admin/access_denied.html', env=env, status=401)\n\n  def authorization_error(self, error):\n    \"\"\"Redirects to login or shows 'Access Denied' page.\"\"\"\n    # Not authenticated or used IP whitelist for auth -> redirect to login.\n    # Bots doesn't use UI, and users should always use real accounts.\n    ident = api.get_current_identity()\n    if ident.is_anonymous or ident.is_bot:\n      self.redirect(self.create_login_url(self.request.url))\n      return\n\n    # Admin group is empty -> redirect to bootstrap procedure to create it.\n    if model.is_empty_group(model.ADMIN_GROUP):\n      self.redirect_to('bootstrap')\n      return\n\n    # No access.\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/admin/access_denied.html', env=env, status=403)\n\n\nclass BootstrapHandler(AdminPageHandler):\n  \"\"\"Creates Administrators group (if necessary) and adds current caller to it.\n\n  Requires Appengine level Admin access for its handlers, since Administrators\n  group may not exist yet.\n\n  Used during bootstrap of a new service instance.\n  \"\"\"\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def get(self):\n    env = {\n      'page_title': 'Bootstrap',\n      'admin_group': model.ADMIN_GROUP,\n      'return_url': self.request.get('r') or '',\n    }\n    self.reply('auth/admin/bootstrap.html', env)\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def post(self):\n    added = model.bootstrap_group(\n        model.ADMIN_GROUP, [api.get_current_identity()],\n        'Users that can manage groups')\n    env = {\n      'page_title': 'Bootstrap',\n      'admin_group': model.ADMIN_GROUP,\n      'added': added,\n      'return_url': self.request.get('return_url') or '',\n    }\n    self.reply('auth/admin/bootstrap_done.html', env)\n\n\nclass BootstrapOAuthHandler(AdminPageHandler):\n  \"\"\"Page to set OAuth2 client ID used by the main web UI.\n\n  Requires Appengine level Admin access for its handlers, since without client\n  ID there's no UI yet to configure Administrators group.\n\n  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is\n  also available after the service is linked to some primary Auth service.\n  \"\"\"\n\n  @api.require(api.is_superuser)\n  def get(self):\n    self.show_page(web_client_id=api.get_web_client_id_uncached())\n\n  @api.require(api.is_superuser)\n  def post(self):\n    web_client_id = self.request.POST['web_client_id']\n    api.set_web_client_id(web_client_id)\n    self.show_page(web_client_id=web_client_id, saved=True)\n\n  def show_page(self, web_client_id, saved=False):\n    env = {\n      'page_title': 'OAuth2 web client ID',\n      'web_client_id': web_client_id or '',\n      'saved': saved,\n    }\n    self.reply('auth/admin/bootstrap_oauth.html', env)\n\n\nclass LinkToPrimaryHandler(AdminPageHandler):\n  \"\"\"A page with confirmation of Primary <-> Replica linking request.\n\n  URL to that page is generated by a Primary service.\n  \"\"\"\n\n  def decode_link_ticket(self):\n    \"\"\"Extracts ServiceLinkTicket from 't' GET parameter.\"\"\"\n    try:\n      return replication.decode_link_ticket(\n          self.request.get('t').encode('ascii'))\n    except (KeyError, ValueError):\n      self.abort(400)\n      return\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def get(self):\n    ticket = self.decode_link_ticket()\n    env = {\n      'generated_by': ticket.generated_by,\n      'page_title': 'Switch',\n      'primary_id': ticket.primary_id,\n      'primary_url': ticket.primary_url,\n    }\n    self.reply('auth/admin/linking.html', env)\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def post(self):\n    ticket = self.decode_link_ticket()\n    success = True\n    error_msg = None\n    try:\n      replication.become_replica(ticket, api.get_current_identity())\n    except replication.ProtocolError as exc:\n      success = False\n      error_msg = exc.message\n    env = {\n      'error_msg': error_msg,\n      'page_title': 'Switch',\n      'primary_id': ticket.primary_id,\n      'primary_url': ticket.primary_url,\n      'success': success,\n    }\n    self.reply('auth/admin/linking_done.html', env)\n\n\n################################################################################\n## Web UI routes.\n\n# TODO(vadimsh): Switch them to use OAuth for authentication.\n\n\nclass UIHandler(handler.AuthenticatingHandler):\n  \"\"\"Renders Jinja templates extending base.html.\"\"\"\n\n  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of\n  # all 'style=...' attributes first.\n  csp_use_script_nonce = True\n\n  def reply(self, path, env=None, status=200):\n    \"\"\"Renders template |path| to the HTTP response using given environment.\n\n    Optional keys from |env| that base.html uses:\n      css_file: URL to a file with page specific styles, relative to site root.\n      js_file: URL to a file with page specific Javascript code, relative to\n          site root. File should define global object named same as a filename,\n          i.e. '/auth/static/js/api.js' should define global object 'api' that\n          incapsulates functionality implemented in the module.\n      navbar_tab_id: id of a navbar tab to highlight.\n      page_title: title of an HTML page.\n\n    Args:\n      path: path to a template, relative to templates/.\n      env: additional environment dict to use when rendering the template.\n      status: HTTP status code to return.\n    \"\"\"\n    env = (env or {}).copy()\n    env.setdefault('css_file', None)\n    env.setdefault('js_file', None)\n    env.setdefault('navbar_tab_id', None)\n    env.setdefault('page_title', 'Untitled')\n\n    # This goes to both Jinja2 env and Javascript config object.\n    user = self.get_current_user()\n    common = {\n      'account_picture': user.picture() if user else None,\n      'auth_service_config_locked': False, # overridden in auth_service\n      'is_admin': api.is_admin(),\n      'login_url': self.create_login_url(self.request.url),\n      'logout_url': self.create_logout_url('/'),\n      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    if _ui_data_callback:\n      common.update(_ui_data_callback())\n\n    # Name of Javascript module with page code.\n    js_module_name = None\n    if env['js_file']:\n      assert env['js_file'].endswith('.js')\n      js_module_name = os.path.basename(env['js_file'])[:-3]\n\n    # This will be accessible from Javascript as global 'config' variable.\n    js_config = {\n      'identity': api.get_current_identity().to_bytes(),\n    }\n    js_config.update(common)\n\n    # Jinja2 environment to use to render a template.\n    full_env = {\n      'app_name': _ui_app_name,\n      'app_revision_url': utils.get_app_revision_url(),\n      'app_version': utils.get_app_version(),\n      'config': json.dumps(js_config),\n      'csp_nonce': self.csp_nonce,\n      'identity': api.get_current_identity(),\n      'js_module_name': js_module_name,\n      'navbar': [\n        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)\n        for cls in _ui_navbar_tabs\n        if cls.is_visible()\n      ],\n    }\n    full_env.update(common)\n    full_env.update(env)\n\n    # Render it.\n    self.response.set_status(status)\n    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'\n    self.response.write(template.render(path, full_env))\n\n  def authentication_error(self, error):\n    \"\"\"Shows 'Access denied' page.\"\"\"\n    # TODO(vadimsh): This will be deleted once we use Google Sign-In.\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/access_denied.html', env=env, status=401)\n\n  def authorization_error(self, error):\n    \"\"\"Redirects to login or shows 'Access Denied' page.\"\"\"\n    # TODO(vadimsh): This will be deleted once we use Google Sign-In.\n    # Not authenticated or used IP whitelist for auth -> redirect to login.\n    # Bots doesn't use UI, and users should always use real accounts.\n    ident = api.get_current_identity()\n    if ident.is_anonymous or ident.is_bot:\n      self.redirect(self.create_login_url(self.request.url))\n      return\n\n    # Admin group is empty -> redirect to bootstrap procedure to create it.\n    if model.is_empty_group(model.ADMIN_GROUP):\n      self.redirect_to('bootstrap')\n      return\n\n    # No access.\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/access_denied.html', env=env, status=403)\n\n\nclass MainHandler(UIHandler):\n  \"\"\"Redirects to first navbar tab.\"\"\"\n  @redirect_ui_on_replica\n  @api.require(acl.has_access)\n  def get(self):\n    assert _ui_navbar_tabs\n    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)\n\n\nclass UINavbarTabHandler(UIHandler):\n  \"\"\"Handler for a navbar tab page.\"\"\"\n  # List of routes to register, default is [navbar_tab_url].\n  routes = []\n  # URL to the tab (relative to site root).\n  navbar_tab_url = None\n  # ID of the tab, will be used in DOM.\n  navbar_tab_id = None\n  # Title of the tab, will be used in tab title and page title.\n  navbar_tab_title = None\n  # Relative URL to CSS file with tab's styles.\n  css_file = None\n  # Relative URL to javascript file with tab's logic.\n  js_file_url = None\n  # Path to a Jinja2 template with tab's markup.\n  template_file = None\n\n  @redirect_ui_on_replica\n  @api.require(acl.has_access)\n  def get(self, **_params):\n    \"\"\"Renders page HTML to HTTP response stream.\"\"\"\n    env = {\n      'css_file': self.css_file,\n      'js_file': self.js_file_url,\n      'navbar_tab_id': self.navbar_tab_id,\n      'page_title': self.navbar_tab_title,\n    }\n    self.reply(self.template_file, env)\n\n  @classmethod\n  def get_webapp2_routes(cls):\n    routes = cls.routes or [cls.navbar_tab_url]\n    return [webapp2.Route(r, cls) for r in routes]\n\n  @classmethod\n  def is_visible(cls):\n    \"\"\"Subclasses may return False to hide the tab from tab bar.\"\"\"\n    return True\n\n\n################################################################################\n## Default tabs.\n\n\nclass GroupsHandler(UINavbarTabHandler):\n  \"\"\"Page with Groups management.\"\"\"\n  routes = [\n    '/auth/groups',\n    '/auth/groups/<group:.*>',  # 'group' is handled by js code\n  ]\n  navbar_tab_url = '/auth/groups'\n  navbar_tab_id = 'groups'\n  navbar_tab_title = 'Groups'\n  css_file = '/auth/static/css/groups.css'\n  js_file_url = '/auth/static/js/groups.js'\n  template_file = 'auth/groups.html'\n\n\nclass ChangeLogHandler(UINavbarTabHandler):\n  \"\"\"Page with a log of changes to some groups.\"\"\"\n  navbar_tab_url = '/auth/change_log'\n  navbar_tab_id = 'change_log'\n  navbar_tab_title = 'Change Log'\n  js_file_url = '/auth/static/js/change_log.js'\n  template_file = 'auth/change_log.html'\n\n  @classmethod\n  def is_visible(cls):\n    # Hide 'Change Log' tab if there are no change log indexes in the datastore.\n    # It happens on services that use components.auth, but do not modify\n    # index.yaml. Don't try too hard to hide the log though. If user happes to\n    # stumble on Change log page (e.g. by using direct URL), it handles\n    # NeedIndexError gracefully (explaining how to configure indexes).\n    return change_log.is_changle_log_indexed()\n\n\nclass OAuthConfigHandler(UINavbarTabHandler):\n  \"\"\"Page with OAuth configuration.\"\"\"\n  navbar_tab_url = '/auth/oauth_config'\n  navbar_tab_id = 'oauth_config'\n  navbar_tab_title = 'OAuth'\n  js_file_url = '/auth/static/js/oauth_config.js'\n  template_file = 'auth/oauth_config.html'\n\n\nclass IPWhitelistsHandler(UINavbarTabHandler):\n  \"\"\"Page with IP whitelists configuration.\"\"\"\n  navbar_tab_url = '/auth/ip_whitelists'\n  navbar_tab_id = 'ip_whitelists'\n  navbar_tab_title = 'IP Whitelists'\n  js_file_url = '/auth/static/js/ip_whitelists.js'\n  template_file = 'auth/ip_whitelists.html'\n\n\nclass ApiDocHandler(UINavbarTabHandler):\n  \"\"\"Page with API documentation extracted from rest_api.py.\"\"\"\n  navbar_tab_url = '/auth/api'\n  navbar_tab_id = 'api'\n  navbar_tab_title = 'API'\n\n  # These can be used as 'request_type' and 'response_type' in api_doc.\n  doc_types = [\n    {\n      'name': 'Status',\n      'doc': 'Outcome of some operation.',\n      'example': {'ok': True},\n    },\n    {\n      'name': 'Self info',\n      'doc': 'Information about the requester.',\n      'example': {\n        'identity': 'user:someone@example.com',\n        'ip': '192.168.0.1',\n      },\n    },\n    {\n      'name': 'Group',\n      'doc': 'Represents a group, as stored in the database.',\n      'example': {\n        'group': {\n          'caller_can_modify': True,\n          'created_by': 'user:someone@example.com',\n          'created_ts': 1409250754978540,\n          'description': 'Some free form description',\n          'globs': ['user:*@example.com'],\n          'members': ['user:a@example.com', 'anonymous:anonymous'],\n          'modified_by': 'user:someone@example.com',\n          'modified_ts': 1470871200558130,\n          'name': 'Some group',\n          'nested': ['Some nested group', 'Another nested group'],\n          'owners': 'Owning group',\n        },\n      },\n    },\n    {\n      'name': 'Group listing',\n      'doc':\n        'All groups, along with their metadata. Does not include members '\n        'listings.',\n      'example': {\n        'groups': [\n          {\n            'caller_can_modify': True,\n            'created_by': 'user:someone@example.com',\n            'created_ts': 1409250754978540,\n            'description': 'Some free form description',\n            'modified_by': 'user:someone@example.com',\n            'modified_ts': 1470871200558130,\n            'name': 'Some group',\n            'owners': 'Owning group',\n          },\n          {\n            'caller_can_modify': True,\n            'created_by': 'user:someone@example.com',\n            'created_ts': 1409250754978540,\n            'description': 'Another description',\n            'modified_by': 'user:someone@example.com',\n            'modified_ts': 1470871200558130,\n            'name': 'Another group',\n            'owners': 'Owning group',\n          },\n        ],\n      },\n    },\n  ]\n\n  @redirect_ui_on_replica\n  @api.require(acl.has_access)\n  def get(self):\n    \"\"\"Extracts API doc for registered webapp2 API routes.\"\"\"\n    doc_types = []\n\n    def add_doc_type(tp):\n      \"\"\"Adds a request or response format definition to the documentation page.\n\n      'tp' can either reference a globally known doc type by name\n      (see ApiDocHandler.doc_types), or can itself be a dict with doc type\n      definition.\n\n      Returns the name of the doc type.\n      \"\"\"\n      if not tp:\n        return None\n      # If referenced by name, try to find it among globally known types.\n      if isinstance(tp, basestring):\n        for d in self.doc_types:\n          if d['name'] == tp:\n            tp = d\n            break\n        else:\n          return tp  # not found, return original name as is\n      # Add, if not already there. Serialize the example first, since doing it\n      # from Jinja is a bit more complicated.\n      if not any(d['name'] == tp['name'] for d in doc_types):\n        tp = tp.copy()\n        tp['example'] = json.dumps(\n            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)\n        doc_types.append(tp)\n      return tp['name']\n\n    api_methods = []\n    for route in rest_api.get_rest_api_routes():\n      # Remove API parameter regexps from route template, they are mostly noise.\n      simplified = re.sub(r'\\:.*\\>', '>', route.template)\n      for doc in getattr(route.handler, 'api_doc', []):\n        path = simplified\n        if 'params' in doc:\n          path += '?' + doc['params']\n        api_methods.append({\n          'verb': doc['verb'],\n          'path': path,\n          'doc': doc['doc'],\n          'request_type': add_doc_type(doc.get('request_type')),\n          'response_type': add_doc_type(doc.get('response_type')),\n        })\n\n    env = {\n      'navbar_tab_id': self.navbar_tab_id,\n      'page_title': self.navbar_tab_title,\n      'api_methods': api_methods,\n      'doc_types': doc_types,\n    }\n    self.reply('auth/api.html', env)\n\n\n# Register them as default tabs. Order is important.\n_ui_navbar_tabs = (\n  GroupsHandler,\n  ChangeLogHandler,\n  OAuthConfigHandler,\n  IPWhitelistsHandler,\n  ApiDocHandler,\n)\n/n/n/nappengine/components/components/ereporter2/handlers.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"HTTP Handlers.\"\"\"\n\nimport datetime\nimport itertools\nimport json\nimport time\n\nimport webapp2\n\nfrom google.appengine.api import app_identity\nfrom google.appengine.datastore import datastore_query\nfrom google.appengine.ext import ndb\n\nfrom components import auth\nfrom components import decorators\nfrom components import template\nfrom components import utils\n\nfrom . import acl\nfrom . import logscraper\nfrom . import models\nfrom . import on_error\nfrom . import ui\n\n\n# Access to a protected member XXX of a client class - pylint: disable=W0212\n\n\n### Admin pages.\n\n\nclass RestrictedEreporter2Report(auth.AuthenticatingHandler):\n  \"\"\"Returns all the recent errors as a web page.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self):\n    \"\"\"Reports the errors logged and ignored.\n\n    Arguments:\n      start: epoch time to start looking at. Defaults to the messages since the\n             last email.\n      end: epoch time to stop looking at. Defaults to now.\n      modules: comma separated modules to look at.\n      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.\n    \"\"\"\n    # TODO(maruel): Be consistent about using either epoch or human readable\n    # formatted datetime.\n    end = int(float(self.request.get('end', 0)) or time.time())\n    start = int(\n        float(self.request.get('start', 0)) or\n        ui._get_default_start_time() or 0)\n    modules = self.request.get('modules')\n    if modules:\n      modules = modules.split(',')\n    tainted = bool(int(self.request.get('tainted', '1')))\n    module_versions = utils.get_module_version_list(modules, tainted)\n    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(\n        start, end, module_versions)\n\n    params = {\n      'errors': errors,\n      'errors_count': sum(len(e.events) for e in errors),\n      'errors_version_count':\n          len(set(itertools.chain.from_iterable(e.versions for e in errors))),\n      'ignored': ignored,\n      'ignored_count': sum(len(i.events) for i in ignored),\n      'ignored_version_count':\n          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    params.update(ui._get_template_env(start, end, module_versions))\n    self.response.write(template.render('ereporter2/requests.html', params))\n\n\nclass RestrictedEreporter2Request(auth.AuthenticatingHandler):\n  \"\"\"Dumps information about single logged request.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self, request_id):\n    data = logscraper._log_request_id(request_id)\n    if not data:\n      self.abort(404, detail='Request id was not found.')\n    self.response.write(\n        template.render('ereporter2/request.html', {'request': data}))\n\n\nclass RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):\n  \"\"\"Dumps information about reported client side errors.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self):\n    limit = int(self.request.get('limit', 100))\n    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))\n    errors_found, cursor, more = models.Error.query().order(\n        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)\n    params = {\n      'cursor': cursor.urlsafe() if cursor and more else None,\n      'errors': errors_found,\n      'limit': limit,\n      'now': utils.utcnow(),\n    }\n    self.response.out.write(template.render('ereporter2/errors.html', params))\n\n\nclass RestrictedEreporter2Error(auth.AuthenticatingHandler):\n  \"\"\"Dumps information about reported client side errors.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self, error_id):\n    error = models.Error.get_by_id(int(error_id))\n    if not error:\n      self.abort(404, 'Error not found')\n    params = {\n      'error': error,\n      'now': utils.utcnow(),\n    }\n    self.response.out.write(template.render('ereporter2/error.html', params))\n\n\nclass RestrictedEreporter2Silence(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self):\n    # Due to historical reasons where created_ts had indexed=False,, do not use\n    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all\n    # objects have been updated.\n    items = models.ErrorReportingMonitoring.query().fetch()\n    items.sort(key=lambda x: x.created_ts)\n    params = {\n      'silenced': items,\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.out.write(template.render('ereporter2/silence.html', params))\n\n  @auth.require(acl.is_ereporter2_editor)\n  def post(self):\n    to_delete = self.request.get('to_delete')\n    if to_delete:\n      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()\n    else:\n      mute_type = self.request.get('mute_type')\n      error = None\n      if mute_type in ('exception_type', 'signature'):\n        error = self.request.get(mute_type)\n      if not error:\n        self.abort(400)\n      silenced = self.request.get('silenced')\n      silenced_until = self.request.get('silenced_until')\n      if silenced_until == 'T':\n        silenced_until = ''\n      threshold = self.request.get('threshold')\n      key = models.ErrorReportingMonitoring.error_to_key(error)\n      if not silenced and not silenced_until and not threshold:\n        key.delete()\n      else:\n        item = models.ErrorReportingMonitoring(key=key, error=error)\n        if silenced:\n          item.silenced = True\n        if silenced_until:\n          item.silenced_until = datetime.datetime.strptime(\n              silenced_until, '%Y-%m-%dT%H:%M')\n        if threshold:\n          item.threshold = int(threshold)\n        item.put()\n\n    self.get()\n\n\n### Cron jobs.\n\n\nclass CronEreporter2Mail(webapp2.RequestHandler):\n  \"\"\"Generate and emails an exception report.\"\"\"\n  @decorators.require_cronjob\n  def get(self):\n    \"\"\"Sends email(s) containing the errors logged.\"\"\"\n    # Do not use self.request.host_url because it will be http:// and will point\n    # to the backend, with an host format that breaks the SSL certificate.\n    # TODO(maruel): On the other hand, Google Apps instances are not hosted on\n    # appspot.com.\n    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()\n    request_id_url = host_url + '/restricted/ereporter2/request/'\n    report_url = host_url + '/restricted/ereporter2/report'\n    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())\n    result = ui._generate_and_email_report(\n        utils.get_module_version_list(None, False),\n        recipients,\n        request_id_url,\n        report_url,\n        {})\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    if result:\n      self.response.write('Success.')\n    else:\n      # Do not HTTP 500 since we do not want it to be retried.\n      self.response.write('Failed.')\n\n\nclass CronEreporter2Cleanup(webapp2.RequestHandler):\n  \"\"\"Deletes old error reports.\"\"\"\n  @decorators.require_cronjob\n  def get(self):\n    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE\n    items = models.Error.query(\n        models.Error.created_ts < old_cutoff,\n        default_options=ndb.QueryOptions(keys_only=True))\n    out = len(ndb.delete_multi(items))\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.write(str(out))\n\n\n### Public API.\n\n\nclass OnErrorHandler(auth.AuthenticatingHandler):\n  \"\"\"Adds an error report.\n\n  This one is open so errors like authentication reports are logged in too.\n  This means we could get spammed a lot about it. Implement DDoS protection by\n  rate limiting once a kid figures out.\n  \"\"\"\n  xsrf_token_enforce_on = ()\n\n  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be\n  # factored out.\n  def parse_body(self):\n    \"\"\"Parse JSON body and verifies it's a dict.\"\"\"\n    expected = ('application/json', 'application/json; charset=utf-8')\n    if self.request.headers.get('Content-Type').lower() not in expected:\n      msg = 'Expecting JSON body with content type \\'application/json\\''\n      self.abort(400, msg)\n    try:\n      body = json.loads(self.request.body)\n      if not isinstance(body, dict):\n        raise ValueError()\n    except ValueError:\n      self.abort(400, 'Not a valid json dict body')\n    return body\n\n  @auth.public\n  def post(self):\n    body = self.parse_body()\n    version = body.get('v')\n    # Do not enforce version for now, just assert it is present.\n    if not version:\n      self.abort(400, 'Missing version')\n\n    report = body.get('r')\n    if not report:\n      self.abort(400, 'Missing report')\n\n    kwargs = dict(\n        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))\n    report_id = on_error.log_request(self.request, add_params=False, **kwargs)\n    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'\n    body = {\n      'id': report_id,\n      'url':\n          '%s/restricted/ereporter2/errors/%d' %\n          (self.request.host_url, report_id),\n    }\n    self.response.write(utils.encode_to_json(body))\n\n\ndef get_frontend_routes():\n  routes = [\n    # Public API.\n    webapp2.Route(\n      '/ereporter2/api/v1/on_error', OnErrorHandler),\n  ]\n  if not utils.should_disable_ui_routes():\n    routes.extend([\n      webapp2.Route(\n        r'/restricted/ereporter2/errors',\n        RestrictedEreporter2ErrorsList),\n      webapp2.Route(\n        r'/restricted/ereporter2/errors/<error_id:\\d+>',\n        RestrictedEreporter2Error),\n      webapp2.Route(\n        r'/restricted/ereporter2/report',\n        RestrictedEreporter2Report),\n      webapp2.Route(\n        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',\n        RestrictedEreporter2Request),\n      webapp2.Route(\n        r'/restricted/ereporter2/silence',\n        RestrictedEreporter2Silence),\n    ])\n\n  return routes\n\n\ndef get_backend_routes():\n  # This requires a cron job to this URL.\n  return [\n    webapp2.Route(\n        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),\n    webapp2.Route(\n        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),\n  ]\n/n/n/nappengine/components/components/utils.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Mixed bag of utilities.\"\"\"\n\n# Disable 'Access to a protected member ...'. NDB uses '_' for other purposes.\n# pylint: disable=W0212\n\n# Disable: 'Method could be a function'. It can't: NDB expects a method.\n# pylint: disable=R0201\n\nimport binascii\nimport datetime\nimport functools\nimport hashlib\nimport inspect\nimport json\nimport logging\nimport os\nimport re\nimport sys\nimport threading\nimport urlparse\n\nfrom email import utils as email_utils\n\nfrom google.appengine import runtime\nfrom google.appengine.api import app_identity\nfrom google.appengine.api import memcache as gae_memcache\nfrom google.appengine.api import modules\nfrom google.appengine.api import taskqueue\nfrom google.appengine.ext import ndb\n\nfrom protorpc import messages\nfrom protorpc.remote import protojson\n\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\n\nDATETIME_FORMAT = u'%Y-%m-%d %H:%M:%S'\nDATE_FORMAT = u'%Y-%m-%d'\nVALID_DATETIME_FORMATS = ('%Y-%m-%d', '%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S')\n\n\n# UTC datetime corresponding to zero Unix timestamp.\nEPOCH = datetime.datetime.utcfromtimestamp(0)\n\n# Module to run task queue tasks on by default. Used by get_task_queue_host\n# function. Can be changed by 'set_task_queue_module' function.\n_task_queue_module = 'backend'\n\n\ndef should_disable_ui_routes():\n    return os.environ.get('LUCI_DISABLE_UI_ROUTES', '0') == '1'\n\n\ndef is_local_dev_server():\n  \"\"\"Returns True if running on local development server or in unit tests.\n\n  This function is safe to run outside the scope of a HTTP request.\n  \"\"\"\n  return os.environ.get('SERVER_SOFTWARE', '').startswith('Development')\n\n\ndef is_dev():\n  \"\"\"Returns True if the server is running a development/staging instance.\n\n  We define a 'development instance' as an instance that has the suffix '-dev'\n  in its instance name.\n\n  This function is safe to run outside the scope of a HTTP request.\n  \"\"\"\n  return os.environ['APPLICATION_ID'].endswith('-dev')\n\n\ndef is_unit_test():\n  \"\"\"Returns True if running in a unit test.\n\n  Don't abuse it, use only if really desperate. For example, in a component that\n  is included by many-many projects across many repos, when mocking some\n  component behavior in all unit tests that indirectly invoke it is infeasible.\n  \"\"\"\n  if not is_local_dev_server():\n    return False\n  # devappserver2 sets up some sort of a sandbox that is not activated for\n  # unit tests. So differentiate based on that.\n  return all(\n      'google.appengine.tools.devappserver2' not in str(p)\n      for p in sys.meta_path)\n\n\ndef get_module_version_list(module_list, tainted):\n  \"\"\"Returns a list of pairs (module name, version name) to fetch logs for.\n\n  Arguments:\n    module_list: list of modules to list, defaults to all modules.\n    tainted: if False, excludes versions with '-tainted' in their name.\n  \"\"\"\n  result = []\n  if not module_list:\n    # If the function it called too often, it'll raise a OverQuotaError. So\n    # cache it for 10 minutes.\n    module_list = gae_memcache.get('modules_list')\n    if not module_list:\n      module_list = modules.get_modules()\n      gae_memcache.set('modules_list', module_list, time=10*60)\n\n  for module in module_list:\n    # If the function it called too often, it'll raise a OverQuotaError.\n    # Versions is a bit more tricky since we'll loose data, since versions are\n    # changed much more often than modules. So cache it for 1 minute.\n    key = 'modules_list-' + module\n    version_list = gae_memcache.get(key)\n    if not version_list:\n      version_list = modules.get_versions(module)\n      gae_memcache.set(key, version_list, time=60)\n    result.extend(\n        (module, v) for v in version_list if tainted or '-tainted' not in v)\n  return result\n\n\ndef get_request_as_int(request, key, default, min_value, max_value):\n  \"\"\"Returns a request value as int.\"\"\"\n  value = request.params.get(key, '')\n  try:\n    value = int(value)\n  except ValueError:\n    return default\n  return min(max_value, max(min_value, value))\n\n\ndef parse_datetime(text):\n  \"\"\"Converts text to datetime.datetime instance or None.\"\"\"\n  for f in VALID_DATETIME_FORMATS:\n    try:\n      return datetime.datetime.strptime(text, f)\n    except ValueError:\n      continue\n  return None\n\n\ndef parse_rfc3339_datetime(value):\n  \"\"\"Parses RFC 3339 datetime string (as used in Timestamp proto JSON encoding).\n\n  Keeps only microsecond precision (dropping nanoseconds).\n\n  Examples of the input:\n    2017-08-17T04:21:32.722952943Z\n    1972-01-01T10:00:20.021-05:00\n\n  Returns:\n    datetime.datetime in UTC (regardless of timezone of the original string).\n\n  Raises:\n    ValueError on errors.\n  \"\"\"\n  # Adapted from protobuf/internal/well_known_types.py Timestamp.FromJsonString.\n  # We can't use the original, since it's marked as internal. Also instantiating\n  # proto messages here to parse a string would been odd.\n  timezone_offset = value.find('Z')\n  if timezone_offset == -1:\n    timezone_offset = value.find('+')\n  if timezone_offset == -1:\n    timezone_offset = value.rfind('-')\n  if timezone_offset == -1:\n    raise ValueError('Failed to parse timestamp: missing valid timezone offset')\n  time_value = value[0:timezone_offset]\n  # Parse datetime and nanos.\n  point_position = time_value.find('.')\n  if point_position == -1:\n    second_value = time_value\n    nano_value = ''\n  else:\n    second_value = time_value[:point_position]\n    nano_value = time_value[point_position + 1:]\n  date_object = datetime.datetime.strptime(second_value, '%Y-%m-%dT%H:%M:%S')\n  td = date_object - EPOCH\n  seconds = td.seconds + td.days * 86400\n  if len(nano_value) > 9:\n    raise ValueError(\n        'Failed to parse timestamp: nanos %r more than 9 fractional digits'\n        % nano_value)\n  if nano_value:\n    nanos = round(float('0.' + nano_value) * 1e9)\n  else:\n    nanos = 0\n  # Parse timezone offsets.\n  if value[timezone_offset] == 'Z':\n    if len(value) != timezone_offset + 1:\n      raise ValueError(\n          'Failed to parse timestamp: invalid trailing data %r' % value)\n  else:\n    timezone = value[timezone_offset:]\n    pos = timezone.find(':')\n    if pos == -1:\n      raise ValueError('Invalid timezone offset value: %r' % timezone)\n    if timezone[0] == '+':\n      seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60\n    else:\n      seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60\n  return timestamp_to_datetime(int(seconds)*1e6 + int(nanos)/1e3)\n\n\ndef constant_time_equals(a, b):\n  \"\"\"Compares two strings in constant time regardless of theirs content.\"\"\"\n  if len(a) != len(b):\n    return False\n  result = 0\n  for x, y in zip(a, b):\n    result |= ord(x) ^ ord(y)\n  return result == 0\n\n\ndef to_units(number):\n  \"\"\"Convert a string to numbers.\"\"\"\n  UNITS = ('', 'k', 'm', 'g', 't', 'p', 'e', 'z', 'y')\n  unit = 0\n  while number >= 1024.:\n    unit += 1\n    number = number / 1024.\n    if unit == len(UNITS) - 1:\n      break\n  if unit:\n    return '%.2f%s' % (number, UNITS[unit])\n  return '%d' % number\n\n\ndef validate_root_service_url(url):\n  \"\"\"Raises ValueError if the URL doesn't look like https://<host>.\"\"\"\n  schemes = ('https', 'http') if is_local_dev_server() else ('https',)\n  parsed = urlparse.urlparse(url)\n  if parsed.scheme not in schemes:\n    raise ValueError('unsupported protocol %r' % str(parsed.scheme))\n  if not parsed.netloc:\n    raise ValueError('missing hostname')\n  stripped = urlparse.urlunparse((parsed[0], parsed[1], '', '', '', ''))\n  if stripped != url:\n    raise ValueError('expecting root host URL, e.g. %r)' % str(stripped))\n\n\n### Time\n\n\ndef utcnow():\n  \"\"\"Returns datetime.utcnow(), used for testing.\n\n  Use this function so it can be mocked everywhere.\n  \"\"\"\n  return datetime.datetime.utcnow()\n\n\ndef time_time():\n  \"\"\"Returns the equivalent of time.time() as mocked if applicable.\"\"\"\n  return (utcnow() - EPOCH).total_seconds()\n\n\ndef milliseconds_since_epoch(now):\n  \"\"\"Returns the number of milliseconds since unix epoch as an int.\"\"\"\n  now = now or utcnow()\n  return int(round((now - EPOCH).total_seconds() * 1000.))\n\n\ndef datetime_to_rfc2822(dt):\n  \"\"\"datetime -> string value for Last-Modified header as defined by RFC2822.\"\"\"\n  if not isinstance(dt, datetime.datetime):\n    raise TypeError(\n        'Expecting datetime object, got %s instead' % type(dt).__name__)\n  assert dt.tzinfo is None, 'Expecting UTC timestamp: %s' % dt\n  return email_utils.formatdate(datetime_to_timestamp(dt) / 1000000.0)\n\n\ndef datetime_to_timestamp(value):\n  \"\"\"Converts UTC datetime to integer timestamp in microseconds since epoch.\"\"\"\n  if not isinstance(value, datetime.datetime):\n    raise ValueError(\n        'Expecting datetime object, got %s instead' % type(value).__name__)\n  if value.tzinfo is not None:\n    raise ValueError('Only UTC datetime is supported')\n  dt = value - EPOCH\n  return dt.microseconds + 1000 * 1000 * (dt.seconds + 24 * 3600 * dt.days)\n\n\ndef timestamp_to_datetime(value):\n  \"\"\"Converts integer timestamp in microseconds since epoch to UTC datetime.\"\"\"\n  if not isinstance(value, (int, long, float)):\n    raise ValueError(\n        'Expecting a number, got %s instead' % type(value).__name__)\n  return EPOCH + datetime.timedelta(microseconds=value)\n\n\n### Cache\n\n\nclass _Cache(object):\n  \"\"\"Holds state of a cache for cache_with_expiration and cache decorators.\n\n  May call func more than once.\n  Thread- and NDB tasklet-safe.\n  \"\"\"\n\n  def __init__(self, func, expiration_sec):\n    self.func = func\n    self.expiration_sec = expiration_sec\n    self.lock = threading.Lock()\n    self.value = None\n    self.value_is_set = False\n    self.expires = None\n\n  def get_value(self):\n    \"\"\"Returns a cached value refreshing it if it has expired.\"\"\"\n    with self.lock:\n      if self.value_is_set and (not self.expires or time_time() < self.expires):\n        return self.value\n\n    new_value = self.func()\n\n    with self.lock:\n      self.value = new_value\n      self.value_is_set = True\n      if self.expiration_sec:\n        self.expires = time_time() + self.expiration_sec\n\n    return self.value\n\n  def clear(self):\n    \"\"\"Clears stored cached value.\"\"\"\n    with self.lock:\n      self.value = None\n      self.value_is_set = False\n      self.expires = None\n\n  def get_wrapper(self):\n    \"\"\"Returns a callable object that can be used in place of |func|.\n\n    It's basically self.get_value, updated by functools.wraps to look more like\n    original function.\n    \"\"\"\n    # functools.wraps doesn't like 'instancemethod', use lambda as a proxy.\n    # pylint: disable=W0108\n    wrapper = functools.wraps(self.func)(lambda: self.get_value())\n    wrapper.__parent_cache__ = self\n    return wrapper\n\n\ndef cache(func):\n  \"\"\"Decorator that implements permanent cache of a zero-parameter function.\"\"\"\n  return _Cache(func, None).get_wrapper()\n\n\ndef cache_with_expiration(expiration_sec):\n  \"\"\"Decorator that implements in-memory cache for a zero-parameter function.\"\"\"\n  def decorator(func):\n    return _Cache(func, expiration_sec).get_wrapper()\n  return decorator\n\n\ndef clear_cache(func):\n  \"\"\"Given a function decorated with @cache, resets cached value.\"\"\"\n  func.__parent_cache__.clear()\n\n\n# ignore time parameter warning | pylint: disable=redefined-outer-name\ndef memcache_async(key, key_args=None, time=None):\n  \"\"\"Decorator that implements memcache-based cache for a function.\n\n  The generated cache key contains current application version and values of\n  |key_args| arguments converted to string using `repr`.\n\n  Args:\n    key (str): unique string that will be used as a part of cache key.\n    key_args (list of str): list of function argument names to include\n      in the generated cache key.\n    time (int): optional expiration time.\n\n  Example:\n    @memcache('f', ['a', 'b'])\n    def f(a, b=2, not_used_in_cache_key=6):\n      # Heavy computation\n      return 42\n\n  Decorator raises:\n    NotImplementedError if function uses varargs or kwargs.\n  \"\"\"\n  assert isinstance(key, basestring), key\n  key_args = key_args or []\n  assert isinstance(key_args, list), key_args\n  assert all(isinstance(a, basestring) for a in key_args), key_args\n  assert all(key_args), key_args\n\n  memcache_set_kwargs = {}\n  if time is not None:\n    memcache_set_kwargs['time'] = time\n\n  def decorator(func):\n    unwrapped = func\n    while True:\n      deeper = getattr(unwrapped, '__wrapped__', None)\n      if not deeper:\n        break\n      unwrapped = deeper\n\n    argspec = inspect.getargspec(unwrapped)\n    if argspec.varargs:\n      raise NotImplementedError(\n          'varargs in memcached functions are not supported')\n    if argspec.keywords:\n      raise NotImplementedError(\n          'kwargs in memcached functions are not supported')\n\n    # List of arg names and indexes. Has same order as |key_args|.\n    arg_indexes = []\n    for name in key_args:\n      try:\n        i = argspec.args.index(name)\n      except ValueError:\n        raise KeyError(\n            'key_format expects \"%s\" parameter, but it was not found among '\n            'function parameters' % name)\n      arg_indexes.append((name, i))\n\n    @functools.wraps(func)\n    @ndb.tasklet\n    def decorated(*args, **kwargs):\n      arg_values = []\n      for name, i in arg_indexes:\n        if i < len(args):\n          arg_value = args[i]\n        elif name in kwargs:\n          arg_value = kwargs[name]\n        else:\n          # argspec.defaults contains _last_ default values, so we need to shift\n          # |i| left.\n          default_value_index = i - (len(argspec.args) - len(argspec.defaults))\n          if default_value_index < 0:\n            # Parameter not provided. Call function to cause TypeError\n            func(*args, **kwargs)\n            assert False, 'Function call did not fail'\n          arg_value = argspec.defaults[default_value_index]\n        arg_values.append(arg_value)\n\n      # Instead of putting a raw value to memcache, put tuple (value,)\n      # so we can distinguish a cached None value and absence of the value.\n\n      cache_key = 'utils.memcache/%s/%s%s' % (\n          get_app_version(), key, repr(arg_values))\n\n      ctx = ndb.get_context()\n      result = yield ctx.memcache_get(cache_key)\n      if isinstance(result, tuple) and len(result) == 1:\n        raise ndb.Return(result[0])\n\n      result = func(*args, **kwargs)\n      if isinstance(result, ndb.Future):\n        result = yield result\n      yield ctx.memcache_set(cache_key, (result,), **memcache_set_kwargs)\n      raise ndb.Return(result)\n\n    return decorated\n  return decorator\n\n\ndef memcache(*args, **kwargs):\n  \"\"\"Blocking version of memcache_async.\"\"\"\n  decorator_async = memcache_async(*args, **kwargs)\n  def decorator(func):\n    decorated_async = decorator_async(func)\n    @functools.wraps(func)\n    def decorated(*args, **kwargs):\n      return decorated_async(*args, **kwargs).get_result()\n    return decorated\n  return decorator\n\n\n@cache\ndef get_app_version():\n  \"\"\"Returns currently running version (not necessary a default one).\"\"\"\n  # Sadly, this causes an RPC and when called too frequently, throws quota\n  # errors.\n  return modules.get_current_version_name() or 'N/A'\n\n\n@cache\ndef get_versioned_hosturl():\n  \"\"\"Returns the url hostname of this instance locked to the currently running\n  version.\n\n  This function hides the fact that app_identity.get_default_version_hostname()\n  returns None on the dev server and modules.get_hostname() returns incorrectly\n  qualified hostname for HTTPS usage on the prod server. <3\n  \"\"\"\n  if is_local_dev_server():\n    # TODO(maruel): It'd be nice if it were easier to use a ephemeral SSL\n    # certificate here and not assume unsecured connection.\n    return 'http://' + modules.get_hostname()\n\n  return 'https://%s-dot-%s' % (\n      get_app_version(), app_identity.get_default_version_hostname())\n\n\n@cache\ndef get_urlfetch_service_id():\n  \"\"\"Returns a value for X-URLFetch-Service-Id header for GAE <-> GAE calls.\n\n  Usually it can be omitted. It is required in certain environments.\n  \"\"\"\n  if is_local_dev_server():\n    return 'LOCAL'\n  hostname = app_identity.get_default_version_hostname().split('.')\n  return hostname[-2].upper() if len(hostname) >= 3 else 'APPSPOT'\n\n\n@cache\ndef get_app_revision_url():\n  \"\"\"Returns URL of a git revision page for currently running app version.\n\n  Works only for non-tainted versions uploaded with tools/update.py: app version\n  should look like '162-efaec47'. Assumes all services that use 'components'\n  live in a single repository.\n\n  Returns None if a version is tainted or has unexpected name.\n  \"\"\"\n  rev = re.match(r'\\d+-([a-f0-9]+)$', get_app_version())\n  template = 'https://chromium.googlesource.com/infra/luci/luci-py/+/%s'\n  return template % rev.group(1) if rev else None\n\n\n@cache\ndef get_service_account_name():\n  \"\"\"Same as app_identity.get_service_account_name(), but caches the result.\n\n  app_identity.get_service_account_name() does an RPC on each call, yet the\n  result is always the same.\n  \"\"\"\n  return app_identity.get_service_account_name()\n\n\n### Task queue\n\n\n@cache\ndef get_task_queue_host():\n  \"\"\"Returns domain name of app engine instance to run a task queue task on.\n\n  By default will use 'backend' module. Can be changed by calling\n  set_task_queue_module during application startup.\n\n  This domain name points to a matching version of appropriate app engine\n  module - <version>.<module>.<app-id>.appspot.com where:\n    version: version of the module that is calling this function.\n    module: app engine module to execute task on.\n\n  That way a task enqueued from version 'A' of default module would be executed\n  on same version 'A' of backend module.\n  \"\"\"\n  # modules.get_hostname sometimes fails with unknown internal error.\n  # Cache its result in a memcache to avoid calling it too often.\n  cache_key = 'task_queue_host:%s:%s' % (_task_queue_module, get_app_version())\n  value = gae_memcache.get(cache_key)\n  if not value:\n    value = modules.get_hostname(module=_task_queue_module)\n    gae_memcache.set(cache_key, value)\n  return value\n\n\ndef set_task_queue_module(module):\n  \"\"\"Changes a module used by get_task_queue_host() function.\n\n  Should be called during application initialization if default 'backend' module\n  is not appropriate.\n  \"\"\"\n  global _task_queue_module\n  _task_queue_module = module\n  clear_cache(get_task_queue_host)\n\n\n@ndb.tasklet\ndef enqueue_task_async(\n    url,\n    queue_name,\n    params=None,\n    payload=None,\n    name=None,\n    countdown=None,\n    use_dedicated_module=True,\n    transactional=False):\n  \"\"\"Adds a task to a task queue.\n\n  If |use_dedicated_module| is True (default) the task will be executed by\n  a separate backend module instance that runs same version as currently\n  executing instance. Otherwise it will run on a current version of default\n  module.\n\n  Returns True if the task was successfully added or a task with such name\n  existed before (i.e. on TombstonedTaskError exception): deduplicated task is\n  not a error.\n\n  Logs an error and returns False if task queue is acting up.\n  \"\"\"\n  try:\n    headers = None\n    if use_dedicated_module:\n      headers = {'Host': get_task_queue_host()}\n    # Note that just using 'target=module' here would redirect task request to\n    # a default version of a module, not the curently executing one.\n    task = taskqueue.Task(\n        url=url,\n        params=params,\n        payload=payload,\n        name=name,\n        countdown=countdown,\n        headers=headers)\n    yield task.add_async(queue_name=queue_name, transactional=transactional)\n    raise ndb.Return(True)\n  except (taskqueue.TombstonedTaskError, taskqueue.TaskAlreadyExistsError):\n    logging.info(\n        'Task %r deduplicated (already exists in queue %r)',\n        name, queue_name)\n    raise ndb.Return(True)\n  except (\n      taskqueue.Error,\n      runtime.DeadlineExceededError,\n      runtime.apiproxy_errors.CancelledError,\n      runtime.apiproxy_errors.DeadlineExceededError,\n      runtime.apiproxy_errors.OverQuotaError) as e:\n    logging.warning(\n        'Problem adding task %r to task queue %r (%s): %s',\n        url, queue_name, e.__class__.__name__, e)\n    raise ndb.Return(False)\n\n\ndef enqueue_task(*args, **kwargs):\n  \"\"\"Adds a task to a task queue.\n\n  Returns:\n    True if the task was enqueued, False otherwise.\n  \"\"\"\n  return enqueue_task_async(*args, **kwargs).get_result()\n\n\n## JSON\n\n\ndef to_json_encodable(data):\n  \"\"\"Converts data into json-compatible data.\"\"\"\n  if isinstance(data, messages.Message):\n    # protojson.encode_message returns a string that is already encoded json.\n    # Load it back into a json-compatible representation of the data.\n    return json.loads(protojson.encode_message(data))\n  if isinstance(data, unicode) or data is None:\n    return data\n  if isinstance(data, str):\n    return data.decode('utf-8')\n  if isinstance(data, (int, float, long)):\n    # Note: overflowing is an issue with int and long.\n    return data\n  if isinstance(data, (list, set, tuple)):\n    return [to_json_encodable(i) for i in data]\n  if isinstance(data, dict):\n    assert all(isinstance(k, basestring) for k in data), data\n    return {\n      to_json_encodable(k): to_json_encodable(v) for k, v in data.iteritems()\n    }\n\n  if isinstance(data, datetime.datetime):\n    # Convert datetime objects into a string, stripping off milliseconds. Only\n    # accept naive objects.\n    if data.tzinfo is not None:\n      raise ValueError('Can only serialize naive datetime instance')\n    return data.strftime(DATETIME_FORMAT)\n  if isinstance(data, datetime.date):\n    return data.strftime(DATE_FORMAT)\n  if isinstance(data, datetime.timedelta):\n    # Convert timedelta into seconds, stripping off milliseconds.\n    return int(data.total_seconds())\n\n  if hasattr(data, 'to_dict') and callable(data.to_dict):\n    # This takes care of ndb.Model.\n    return to_json_encodable(data.to_dict())\n\n  if hasattr(data, 'urlsafe') and callable(data.urlsafe):\n    # This takes care of ndb.Key.\n    return to_json_encodable(data.urlsafe())\n\n  if inspect.isgenerator(data) or isinstance(data, xrange):\n    # Handle it like a list. Sadly, xrange is not a proper generator so it has\n    # to be checked manually.\n    return [to_json_encodable(i) for i in data]\n\n  assert False, 'Don\\'t know how to handle %r' % data\n\n\ndef encode_to_json(data):\n  \"\"\"Converts any data as a json string.\"\"\"\n  return json.dumps(\n      to_json_encodable(data),\n      sort_keys=True,\n      separators=(',', ':'),\n      encoding='utf-8')\n\n\n## General\n\n\ndef get_token_fingerprint(blob):\n  \"\"\"Given a blob with a token returns first 16 bytes of its SHA256 as hex.\n\n  It can be used to identify this particular token in logs without revealing it.\n  \"\"\"\n  assert isinstance(blob, basestring)\n  if isinstance(blob, unicode):\n    blob = blob.encode('ascii', 'ignore')\n  return binascii.hexlify(hashlib.sha256(blob).digest()[:16])\n\n\n## Hacks\n\n\ndef fix_protobuf_package():\n  \"\"\"Modifies 'google' package to include path to 'google.protobuf' package.\n\n  Prefer our own proto package on the server. Note that this functions is not\n  used on the Swarming bot nor any other client.\n  \"\"\"\n  # google.__path__[0] will be google_appengine/google.\n  import google\n  if len(google.__path__) > 1:\n    return\n\n  # We do not mind what 'google' get used, inject protobuf in there.\n  path = os.path.join(THIS_DIR, 'third_party', 'protobuf', 'google')\n  google.__path__.append(path)\n\n  # six is needed for oauth2client and webtest (local testing).\n  six_path = os.path.join(THIS_DIR, 'third_party', 'six')\n  if six_path not in sys.path:\n    sys.path.insert(0, six_path)\n\n\ndef import_jinja2():\n  \"\"\"Remove any existing jinja2 package and add ours.\"\"\"\n  for i in sys.path[:]:\n    if os.path.basename(i) == 'jinja2':\n      sys.path.remove(i)\n  sys.path.append(os.path.join(THIS_DIR, 'third_party'))\n\n\ndef sync_of(async_fn):\n  \"\"\"Returns a synchronous version of an asynchronous function.\"\"\"\n  is_static_method = isinstance(async_fn, staticmethod)\n  is_class_method = isinstance(async_fn, classmethod)\n  if is_static_method or is_class_method:\n    async_fn = async_fn.__func__\n\n  @functools.wraps(async_fn)\n  def sync(*args, **kwargs):\n    return async_fn(*args, **kwargs).get_result()\n\n  if is_static_method:\n    sync = staticmethod(sync)\n  elif is_class_method:\n    sync = classmethod(sync)\n  return sync\n/n/n/nappengine/isolate/handlers_frontend.py/n/n# Copyright 2012 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"This module defines Isolate Server frontend url handlers.\"\"\"\n\nimport collections\nimport datetime\nimport json\nimport logging\n\nimport webapp2\n\nimport cloudstorage\nfrom google.appengine.api import modules\n\nimport acl\nimport config\nimport gcs\nimport handlers_endpoints_v1\nimport mapreduce_jobs\nimport model\nimport stats\nimport template\nfrom components import auth\nfrom components import stats_framework\nfrom components import stats_framework_gviz\nfrom components import utils\nfrom gviz import gviz_api\n\n\n# GViz data description.\n_GVIZ_DESCRIPTION = {\n  'failures': ('number', 'Failures'),\n  'requests': ('number', 'Total'),\n  'other_requests': ('number', 'Other'),\n  'uploads': ('number', 'Uploads'),\n  'uploads_bytes': ('number', 'Uploaded'),\n  'downloads': ('number', 'Downloads'),\n  'downloads_bytes': ('number', 'Downloaded'),\n  'contains_requests': ('number', 'Lookups'),\n  'contains_lookups': ('number', 'Items looked up'),\n}\n\n# Warning: modifying the order here requires updating templates/stats.html.\n_GVIZ_COLUMNS_ORDER = (\n  'key',\n  'requests',\n  'other_requests',\n  'failures',\n  'uploads',\n  'downloads',\n  'contains_requests',\n  'uploads_bytes',\n  'downloads_bytes',\n  'contains_lookups',\n)\n\n_ISOLATED_ROOT_MEMBERS = (\n  'algo',\n  'command',\n  'files',\n  'includes',\n  'read_only',\n  'relative_cwd',\n  'version',\n)\n\n\n### Restricted handlers\n\n\nclass RestrictedConfigHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(auth.is_admin)\n  def get(self):\n    self.common(None)\n\n  @staticmethod\n  def cast_to_type(param_name, value):\n    def to_bool(value):\n      if type(value) is bool:\n        return value\n      return {'True': True, 'False': False}.get(value, False)\n\n    cast = {\n        'enable_ts_monitoring': to_bool,\n    }.get(param_name, str)\n    return cast(value)\n\n  @auth.require(auth.is_admin)\n  def post(self):\n    # Convert MultiDict into a dict.\n    params = {\n      k: self.cast_to_type(k, self.request.params.getone(k))\n      for k in self.request.params\n      if k not in ('keyid', 'xsrf_token')\n    }\n    cfg = config.settings(fresh=True)\n    keyid = int(self.request.get('keyid', '0'))\n    if cfg.key.integer_id() != keyid:\n      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))\n      return\n    cfg.populate(**params)\n    try:\n      # Ensure key is correct, it's easy to make a mistake when creating it.\n      gcs.URLSigner.load_private_key(cfg.gs_private_key)\n    except Exception as exc:\n      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)\n      self.response.write('Bad private key: %s' % exc)\n      return\n    cfg.store(updated_by=auth.get_current_identity().to_bytes())\n    self.common('Settings updated')\n\n  def common(self, note):\n    params = config.settings_info()\n    params.update({\n        'note': note,\n        'path': self.request.path,\n        'xsrf_token': self.generate_xsrf_token(),\n    })\n    self.response.write(\n        template.render('isolate/restricted_config.html', params))\n\n\nclass RestrictedPurgeHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(auth.is_admin)\n  def get(self):\n    params = {\n      'digest': '',\n      'message': '',\n      'namespace': '',\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.write(\n        template.render('isolate/restricted_purge.html', params))\n\n  @auth.require(auth.is_admin)\n  def post(self):\n    namespace = self.request.get('namespace')\n    digest = self.request.get('digest')\n    params = {\n      'digest': digest,\n      'message': '',\n      'namespace': namespace,\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    try:\n      key = model.get_entry_key(namespace, digest)\n    except ValueError as e:\n      params['message'] = 'Invalid entry: %s' % e\n      key = None\n    if key:\n      model.delete_entry_and_gs_entry([key])\n      params['message'] = 'Done'\n    self.response.write(\n        template.render('isolate/restricted_purge.html', params))\n\n\n### Mapreduce related handlers\n\n\nclass RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):\n  \"\"\"Enqueues a task to start a map reduce job on the backend module.\n\n  A tree of map reduce jobs inherits module and version of a handler that\n  launched it. All UI handlers are executes by 'default' module. So to run a\n  map reduce on a backend module one needs to pass a request to a task running\n  on backend module.\n  \"\"\"\n\n  @auth.require(auth.is_admin)\n  def post(self):\n    job_id = self.request.get('job_id')\n    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS\n    # Do not use 'backend' module when running from dev appserver. Mapreduce\n    # generates URLs that are incompatible with dev appserver URL routing when\n    # using custom modules.\n    success = utils.enqueue_task(\n        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,\n        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,\n        use_dedicated_module=not utils.is_local_dev_server())\n    # New tasks should show up on the status page.\n    if success:\n      self.redirect('/mapreduce/status')\n    else:\n      self.abort(500, 'Failed to launch the job')\n\n\n### Non-restricted handlers\n\n\nclass BrowseHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.isolate_readable)\n  def get(self):\n    namespace = self.request.get('namespace', 'default-gzip')\n    # Support 'hash' for compatibility with old links. To remove eventually.\n    digest = self.request.get('digest', '') or self.request.get('hash', '')\n    save_as = self.request.get('as', '')\n    params = {\n      u'as': unicode(save_as),\n      u'digest': unicode(digest),\n      u'namespace': unicode(namespace),\n    }\n    # Check for existence of element, so we can 400/404\n    if digest and namespace:\n      try:\n        model.get_content(namespace, digest)\n      except ValueError:\n        self.abort(400, 'Invalid key')\n      except LookupError:\n        self.abort(404, 'Unable to retrieve the entry')\n    self.response.write(template.render('isolate/browse.html', params))\n\n  def get_content_security_policy(self):\n    csp = super(BrowseHandler, self).get_content_security_policy()\n    csp.setdefault('child-src', []).append(\"'self'\")\n    return csp\n\n\nclass ContentHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.isolate_readable)\n  def get(self):\n    namespace = self.request.get('namespace', 'default-gzip')\n    digest = self.request.get('digest', '')\n    content = None\n    if not digest:\n      self.abort(400, 'Missing digest')\n    if not namespace:\n      self.abort(400, 'Missing namespace')\n\n    try:\n      raw_data, entity = model.get_content(namespace, digest)\n    except ValueError:\n      self.abort(400, 'Invalid key')\n    except LookupError:\n      self.abort(404, 'Unable to retrieve the entry')\n\n    logging.info('%s', entity)\n    if not raw_data:\n      try:\n        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())\n        content = ''.join(model.expand_content(namespace, stream))\n      except cloudstorage.NotFoundError:\n        logging.error('Entity in DB but not in GCS: deleting entity in DB')\n        entity.key.delete()\n        self.abort(404, 'Unable to retrieve the file from GCS')\n    else:\n      content = ''.join(model.expand_content(namespace, [raw_data]))\n\n    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    # We delete Content-Type before storing to it to avoid having two (yes,\n    # two) Content-Type headers.\n    del self.response.headers['Content-Type']\n\n    # Apparently, setting the content type to text/plain encourages the\n    # browser (Chrome, at least) to sniff the mime type and display\n    # things like images.  Images are autowrapped in <img> and text is\n    # wrapped in <pre>.\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n\n    # App Engine puts a limit of 33554432 bytes on a request, which includes\n    # headers. Headers are ~150 bytes.  If the content + headers might\n    # exceed that limit, we give the user an option to workround getting\n    # their file.\n    if len(content) > 33554000:\n      host = modules.get_hostname(module='default', version='default')\n      # host is something like default.default.myisolateserver.appspot.com\n      host = host.replace('default.default.','')\n      sizeInMib = len(content) / (1024.0 * 1024.0)\n      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'\n      ' App Engine limit.\\nTo work around this, run the following command:\\n'\n      '    python isolateserver.py download -I %s --namespace %s -f %s %s'\n      % (sizeInMib, host, namespace, digest, digest))\n    else:\n      self.response.headers['Content-Disposition'] = str(\n        'filename=%s' % self.request.get('as') or digest)\n      try:\n        json_data = json.loads(content)\n        if self._is_isolated_format(json_data):\n          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'\n          json_data['files'] = collections.OrderedDict(\n            sorted(\n              json_data['files'].items(),\n              key=lambda (filepath, data): filepath))\n          params = {\n            'namespace': namespace,\n            'isolated': json_data,\n          }\n          content = template.render('isolate/isolated.html', params)\n      except ValueError:\n        pass\n\n    self.response.write(content)\n\n  @staticmethod\n  def _is_isolated_format(json_data):\n    \"\"\"Checks if json_data is a valid .isolated format.\"\"\"\n    if not isinstance(json_data, dict):\n      return False\n    actual = set(json_data)\n    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual\n\n\nclass StatsHandler(webapp2.RequestHandler):\n  \"\"\"Returns the statistics web page.\"\"\"\n  def get(self):\n    \"\"\"Presents nice recent statistics.\n\n    It fetches data from the 'JSON' API.\n    \"\"\"\n    # Preloads the data to save a complete request.\n    resolution = self.request.params.get('resolution', 'hours')\n    if resolution not in ('days', 'hours', 'minutes'):\n      resolution = 'hours'\n    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)\n\n    description = _GVIZ_DESCRIPTION.copy()\n    description.update(stats_framework_gviz.get_description_key(resolution))\n    table = stats_framework.get_stats(\n        stats.STATS_HANDLER, resolution, None, duration, True)\n    params = {\n      'duration': duration,\n      'initial_data': gviz_api.DataTable(description, table).ToJSon(\n          columns_order=_GVIZ_COLUMNS_ORDER),\n      'now': datetime.datetime.utcnow(),\n      'resolution': resolution,\n    }\n    self.response.write(template.render('isolate/stats.html', params))\n\n\nclass StatsGvizHandlerBase(webapp2.RequestHandler):\n  RESOLUTION = None\n\n  def get(self):\n    description = _GVIZ_DESCRIPTION.copy()\n    description.update(\n        stats_framework_gviz.get_description_key(self.RESOLUTION))\n    try:\n      stats_framework_gviz.get_json(\n          self.request,\n          self.response,\n          stats.STATS_HANDLER,\n          self.RESOLUTION,\n          description,\n          _GVIZ_COLUMNS_ORDER)\n    except ValueError as e:\n      self.abort(400, str(e))\n\n\nclass StatsGvizDaysHandler(StatsGvizHandlerBase):\n  RESOLUTION = 'days'\n\n\nclass StatsGvizHoursHandler(StatsGvizHandlerBase):\n  RESOLUTION = 'hours'\n\n\nclass StatsGvizMinutesHandler(StatsGvizHandlerBase):\n  RESOLUTION = 'minutes'\n\n\n###  Public pages.\n\n\nclass RootHandler(auth.AuthenticatingHandler):\n  \"\"\"Tells the user to RTM.\"\"\"\n\n  @auth.public\n  def get(self):\n    params = {\n      'is_admin': auth.is_admin(),\n      'is_user': acl.isolate_readable(),\n      'mapreduce_jobs': [],\n      'user_type': acl.get_user_type(),\n    }\n    if auth.is_admin():\n      params['mapreduce_jobs'] = [\n        {'id': job_id, 'name': job_def['job_name']}\n        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()\n      ]\n      params['xsrf_token'] = self.generate_xsrf_token()\n    self.response.write(template.render('isolate/root.html', params))\n\n\nclass UIHandler(auth.AuthenticatingHandler):\n  \"\"\"Serves the landing page for the new UI of the requested page.\n\n  This landing page is stamped with the OAuth 2.0 client id from the\n  configuration.\n  \"\"\"\n  @auth.public\n  def get(self):\n    params = {\n      'client_id': config.settings().ui_client_id,\n    }\n    # Can cache for 1 week, because the only thing that would change in this\n    # template is the oauth client id, which changes very infrequently.\n    self.response.cache_control.no_cache = None\n    self.response.cache_control.public = True\n    self.response.cache_control.max_age = 604800\n    try:\n      self.response.write(template.render(\n        'isolate/public_isolate_index.html', params))\n    except template.TemplateNotFound:\n      self.abort(404, 'Page not found.')\n\n\nclass WarmupHandler(webapp2.RequestHandler):\n  def get(self):\n    config.warmup()\n    auth.warmup()\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.write('ok')\n\n\nclass EmailHandler(webapp2.RequestHandler):\n  \"\"\"Blackhole any email sent.\"\"\"\n  def post(self, to):\n    pass\n\n\ndef get_routes():\n  routes = [\n      # AppEngine-specific urls:\n      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),\n      webapp2.Route(r'/_ah/warmup', WarmupHandler),\n  ]\n  if not utils.should_disable_ui_routes():\n    routes.extend([\n      # Administrative urls.\n      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),\n      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),\n\n      # Mapreduce related urls.\n      webapp2.Route(\n          r'/restricted/launch_mapreduce',\n          RestrictedLaunchMapReduceJob),\n\n      # User web pages.\n      webapp2.Route(r'/browse', BrowseHandler),\n      webapp2.Route(r'/content', ContentHandler),\n      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz\n      # is just too sorry.\n      #webapp2.Route(r'/stats', StatsHandler),\n      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),\n      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),\n      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),\n      webapp2.Route(r'/', RootHandler),\n      webapp2.Route(r'/newui', UIHandler),\n    ])\n  routes.extend(handlers_endpoints_v1.get_routes())\n  return routes\n\n\ndef create_application(debug):\n  \"\"\"Creates the url router.\n\n  The basic layouts is as follow:\n  - /restricted/.* requires being an instance administrator.\n  - /stats/.* has statistics.\n  \"\"\"\n  acl.bootstrap()\n  template.bootstrap()\n  return webapp2.WSGIApplication(get_routes(), debug=debug)\n/n/n/nappengine/machine_provider/handlers_frontend.py/n/n# Copyright 2016 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Front-end UI.\"\"\"\n\nimport logging\nimport os\n\nimport webapp2\n\nfrom components import auth\nfrom components import datastore_utils\nfrom components import template\nfrom components import utils\n\nimport handlers_endpoints\nimport models\n\n\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\n\n\nclass CatalogHandler(auth.AuthenticatingHandler):\n  \"\"\"Catalog handler.\"\"\"\n\n  @auth.require(auth.is_admin)\n  def get(self, machine_id=None):\n    params = {\n        'machines': [],\n        'next_page_token': None,\n    }\n    if machine_id:\n      machine = models.CatalogMachineEntry.get_by_id(machine_id)\n      if not machine:\n        self.abort(404)\n      params['machines'] = [machine]\n    else:\n      query = models.CatalogMachineEntry.query().order(\n          models.CatalogMachineEntry.dimensions.hostname)\n      page_token = self.request.get('page_token') or ''\n      params['machines'], params['next_page_token'] = (\n          datastore_utils.fetch_page(query, 50, page_token))\n\n    self.response.write(\n        template.render('templates/catalog.html', params=params))\n\n\nclass LeaseRequestHandler(auth.AuthenticatingHandler):\n  \"\"\"Lease request handler.\"\"\"\n\n  @auth.require(auth.is_admin)\n  def get(self, lease_id=None):\n    params = {\n        'lease_requests': [],\n        'next_page_token': None,\n        'now_ts': utils.time_time(),\n    }\n    if lease_id:\n      lease_request = models.LeaseRequest.get_by_id(lease_id)\n      if not lease_request:\n        self.abort(404)\n      params['lease_requests'] = [lease_request]\n    else:\n      query = models.LeaseRequest.query().order(\n          -models.LeaseRequest.last_modified_ts)\n      page_token = self.request.get('page_token') or ''\n      params['lease_requests'], params['next_page_token'] = (\n          datastore_utils.fetch_page(query, 50, page_token))\n\n    self.response.write(template.render('templates/leases.html', params=params))\n\n\nclass RootHandler(auth.AuthenticatingHandler):\n  \"\"\"Root handler.\"\"\"\n\n  @auth.public\n  def get(self):\n    params = {\n        'is_admin': auth.is_admin(),\n    }\n\n    self.response.write(template.render('templates/root.html', params=params))\n\n\ndef get_routes():\n  return [\n      webapp2.Route('/', handler=RootHandler),\n      webapp2.Route('/catalog', handler=CatalogHandler),\n      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),\n      webapp2.Route('/leases', handler=LeaseRequestHandler),\n      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),\n  ]\n\n\ndef create_frontend_app():\n  template.bootstrap({\n      'templates': os.path.join(THIS_DIR, 'templates'),\n  })\n  routes = []\n  if not utils.should_disable_ui_routes():\n    routes.extend(get_routes())\n  routes.extend(handlers_endpoints.get_routes())\n  return webapp2.WSGIApplication(routes)\n/n/n/nappengine/swarming/handlers_frontend.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Main entry point for Swarming service.\n\nThis file contains the URL handlers for all the Swarming service URLs,\nimplemented using the webapp2 framework.\n\"\"\"\n\nimport collections\nimport os\n\nimport webapp2\n\nimport handlers_bot\nimport handlers_endpoints\nimport mapreduce_jobs\nimport template\nfrom components import auth\nfrom components import utils\nfrom server import acl\nfrom server import bot_code\nfrom server import config\n\n\nROOT_DIR = os.path.dirname(os.path.abspath(__file__))\n\n\n# Helper class for displaying the sort options in html templates.\nSortOptions = collections.namedtuple('SortOptions', ['key', 'name'])\n\n\n### is_admin pages.\n\n\nclass RestrictedConfigHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.can_view_config)\n  def get(self):\n    # Template parameters schema matches settings_info() return value.\n    self.response.write(template.render(\n        'swarming/restricted_config.html', config.settings_info()))\n\n\nclass UploadBotConfigHandler(auth.AuthenticatingHandler):\n  \"\"\"Stores a new bot_config.py script.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.can_view_config)\n  def get(self):\n    bot_config = bot_code.get_bot_config()\n    params = {\n      'content': bot_config.content.decode('utf-8'),\n      'path': self.request.path,\n      'version': bot_config.version,\n      'when': bot_config.when,\n      'who': bot_config.who or 'N/A',\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.write(\n        template.render('swarming/restricted_upload_bot_config.html', params))\n\n  @auth.require(acl.can_edit_config)\n  def post(self):\n    script = self.request.get('script', '')\n    if not script:\n      self.abort(400, 'No script uploaded')\n\n    # Make sure the script is valid utf-8. For some odd reason, the script\n    # instead may or may not be an unicode instance. This depends if it is on\n    # AppEngine production or not.\n    if isinstance(script, str):\n      script = script.decode('utf-8', 'replace')\n    script = script.encode('utf-8')\n    bot_code.store_bot_config(self.request.host_url, script)\n    self.get()\n\n\nclass UploadBootstrapHandler(auth.AuthenticatingHandler):\n  \"\"\"Stores a new bootstrap.py script.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.can_view_config)\n  def get(self):\n    bootstrap = bot_code.get_bootstrap(self.request.host_url)\n    params = {\n      'content': bootstrap.content.decode('utf-8'),\n      'path': self.request.path,\n      'version': bootstrap.version,\n      'when': bootstrap.when,\n      'who': bootstrap.who or 'N/A',\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.write(\n        template.render('swarming/restricted_upload_bootstrap.html', params))\n\n  @auth.require(acl.can_edit_config)\n  def post(self):\n    script = self.request.get('script', '')\n    if not script:\n      self.abort(400, 'No script uploaded')\n\n    # Make sure the script is valid utf-8. For some odd reason, the script\n    # instead may or may not be an unicode instance. This depends if it is on\n    # AppEngine production or not.\n    if isinstance(script, str):\n      script = script.decode('utf-8', 'replace')\n    script = script.encode('utf-8')\n    bot_code.store_bootstrap(script)\n    self.get()\n\n\n### Mapreduce related handlers\n\n\nclass RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):\n  \"\"\"Enqueues a task to start a map reduce job on the backend module.\n\n  A tree of map reduce jobs inherits module and version of a handler that\n  launched it. All UI handlers are executes by 'default' module. So to run a\n  map reduce on a backend module one needs to pass a request to a task running\n  on backend module.\n  \"\"\"\n\n  @auth.require(acl.can_edit_config)\n  def post(self):\n    job_id = self.request.get('job_id')\n    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS\n    success = utils.enqueue_task(\n        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,\n        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,\n        use_dedicated_module=False)\n    # New tasks should show up on the status page.\n    if success:\n      self.redirect('/restricted/mapreduce/status')\n    else:\n      self.abort(500, 'Failed to launch the job')\n\n\n### Redirectors.\n\n\nclass BotsListHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a list of known bots.\"\"\"\n\n  @auth.public\n  def get(self):\n    limit = int(self.request.get('limit', 100))\n\n    dimensions = (\n      l.strip() for l in self.request.get('dimensions', '').splitlines()\n    )\n    dimensions = [i for i in dimensions if i]\n\n    new_ui_link = '/botlist?l=%d' % limit\n    if dimensions:\n      new_ui_link += '&f=' + '&f='.join(dimensions)\n\n    self.redirect(new_ui_link)\n\n\nclass BotHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a page about the bot, including last tasks and events.\"\"\"\n\n  @auth.public\n  def get(self, bot_id):\n    self.redirect('/bot?id=%s' % bot_id)\n\n\nclass TasksHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a list of all task requests.\"\"\"\n\n  @auth.public\n  def get(self):\n    limit = int(self.request.get('limit', 100))\n    task_tags = [\n      line for line in self.request.get('task_tag', '').splitlines() if line\n    ]\n\n    new_ui_link = '/tasklist?l=%d' % limit\n    if task_tags:\n      new_ui_link += '&f=' + '&f='.join(task_tags)\n\n    self.redirect(new_ui_link)\n\n\nclass TaskHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a page containing task request and result.\"\"\"\n\n  @auth.public\n  def get(self, task_id):\n    self.redirect('/task?id=%s' % task_id)\n\n\n### Public pages.\n\n\nclass UIHandler(auth.AuthenticatingHandler):\n  \"\"\"Serves the landing page for the new UI of the requested page.\n\n  This landing page is stamped with the OAuth 2.0 client id from the\n  configuration.\"\"\"\n  @auth.public\n  def get(self, page):\n    if not page:\n      page = 'swarming'\n\n    params = {\n      'client_id': config.settings().ui_client_id,\n    }\n    # Can cache for 1 week, because the only thing that would change in this\n    # template is the oauth client id, which changes very infrequently.\n    self.response.cache_control.no_cache = None\n    self.response.cache_control.public = True\n    self.response.cache_control.max_age = 604800\n    try:\n      self.response.write(template.render(\n        'swarming/public_%s_index.html' % page, params))\n    except template.TemplateNotFound:\n      self.abort(404, 'Page not found.')\n\n  def get_content_security_policy(self):\n    # We use iframes to display pages at display_server_url_template. Need to\n    # allow it in CSP.\n    csp = super(UIHandler, self).get_content_security_policy()\n    tmpl = config.settings().display_server_url_template\n    if tmpl:\n      if tmpl.startswith('/'):\n        csp['child-src'].append(\"'self'\")\n      else:\n        # We assume the template specifies '%s' in its last path component.\n        # We strip it to get a \"parent\" path that we can put into CSP. Note that\n        # whitelisting an entire display server domain is unnecessary wide.\n        assert tmpl.startswith('https://'), tmpl\n        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])\n    return csp\n\n\nclass WarmupHandler(webapp2.RequestHandler):\n  def get(self):\n    auth.warmup()\n    bot_code.get_swarming_bot_zip(self.request.host_url)\n    utils.get_module_version_list(None, None)\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.write('ok')\n\n\nclass EmailHandler(webapp2.RequestHandler):\n  \"\"\"Blackhole any email sent.\"\"\"\n  def post(self, to):\n    pass\n\n\ndef get_routes():\n  routes = [\n      ('/_ah/mail/<to:.+>', EmailHandler),\n      ('/_ah/warmup', WarmupHandler),\n  ]\n\n  if not utils.should_disable_ui_routes():\n    routes.extend([\n      # Frontend pages. They return HTML.\n      # Public pages.\n      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),\n\n      # Redirects to Polymer UI\n      ('/user/tasks', TasksHandler),\n      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),\n      ('/restricted/bots', BotsListHandler),\n      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),\n\n      # Admin pages.\n      # TODO(maruel): Get rid of them.\n      ('/restricted/config', RestrictedConfigHandler),\n      ('/restricted/upload/bot_config', UploadBotConfigHandler),\n      ('/restricted/upload/bootstrap', UploadBootstrapHandler),\n\n      # Mapreduce related urls.\n      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),\n    ])\n\n  return [webapp2.Route(*i) for i in routes]\n\n\ndef create_application(debug):\n  routes = []\n  routes.extend(get_routes())\n  routes.extend(handlers_bot.get_routes())\n  routes.extend(handlers_endpoints.get_routes())\n  return webapp2.WSGIApplication(routes, debug=debug)\n/n/n/n", "label": 0}, {"id": "481a3e8120787d449ad7bbc6a627d8450bceb85c", "code": "/appengine/components/components/auth/ui/ui.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Auth management UI handlers.\"\"\"\n\nimport functools\nimport json\nimport os\nimport re\nimport webapp2\n\nfrom components import template\nfrom components import utils\n\nfrom . import acl\nfrom . import rest_api\n\nfrom .. import api\nfrom .. import change_log\nfrom .. import handler\nfrom .. import model\nfrom .. import replication\n\n\n# templates/.\nTEMPLATES_DIR = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)), 'templates')\n\n\n# Global static configuration set in 'configure_ui'.\n_ui_app_name = 'Unknown'\n_ui_data_callback = None\n_ui_navbar_tabs = ()\n\n\ndef configure_ui(app_name, ui_tabs=None, ui_data_callback=None):\n  \"\"\"Modifies global configuration of Auth UI.\n\n  Args:\n    app_name: name of the service (visible in page headers, titles, etc.)\n    ui_tabs: list of UINavbarTabHandler subclasses that define tabs to show, or\n        None to show the standard set of tabs.\n    ui_data_callback: an argumentless callable that returns a dict with\n        additional data to return to authenticated users. It can be used by\n        server and client side code to render templates. Used by auth_service.\n  \"\"\"\n  global _ui_app_name\n  global _ui_data_callback\n  global _ui_navbar_tabs\n  _ui_app_name = app_name\n  _ui_data_callback = ui_data_callback\n  if ui_tabs is not None:\n    assert all(issubclass(cls, UINavbarTabHandler) for cls in ui_tabs)\n    _ui_navbar_tabs = tuple(ui_tabs)\n  template.bootstrap({'auth': TEMPLATES_DIR})\n\n\ndef get_ui_routes():\n  \"\"\"Returns a list of routes with auth UI handlers.\"\"\"\n  # Routes for registered navbar tabs.\n  routes = []\n  for cls in _ui_navbar_tabs:\n    routes.extend(cls.get_webapp2_routes())\n  # Routes for everything else.\n  routes.extend([\n    webapp2.Route(r'/auth', MainHandler),\n    webapp2.Route(r'/auth/bootstrap', BootstrapHandler, name='bootstrap'),\n    webapp2.Route(r'/auth/bootstrap/oauth', BootstrapOAuthHandler),\n    webapp2.Route(r'/auth/link', LinkToPrimaryHandler),\n  ])\n  return routes\n\n\ndef forbid_ui_on_replica(method):\n  \"\"\"Decorator for methods that are not allowed to be called on Replica.\n\n  If such method is called on a service in Replica mode, it would return\n  HTTP 405 \"Method Not Allowed\".\n  \"\"\"\n  @functools.wraps(method)\n  def wrapper(self, *args, **kwargs):\n    assert isinstance(self, webapp2.RequestHandler)\n    if model.is_replica():\n      primary_url = model.get_replication_state().primary_url\n      self.abort(\n          405,\n          detail='Not allowed on a replica, see primary at %s' % primary_url)\n    return method(self, *args, **kwargs)\n  return wrapper\n\n\ndef redirect_ui_on_replica(method):\n  \"\"\"Decorator for methods that redirect to Primary when called on replica.\n\n  If such method is called on a service in Replica mode, it would return\n  HTTP 302 redirect to corresponding method on Primary.\n  \"\"\"\n  @functools.wraps(method)\n  def wrapper(self, *args, **kwargs):\n    assert isinstance(self, webapp2.RequestHandler)\n    assert self.request.method == 'GET'\n    if model.is_replica():\n      primary_url = model.get_replication_state().primary_url\n      protocol = 'http://' if utils.is_local_dev_server() else 'https://'\n      assert primary_url and primary_url.startswith(protocol), primary_url\n      assert self.request.path_qs.startswith('/'), self.request.path_qs\n      self.redirect(primary_url.rstrip('/') + self.request.path_qs, abort=True)\n    return method(self, *args, **kwargs)\n  return wrapper\n\n\n################################################################################\n## Admin routes. The use cookies and GAE's \"is_current_user_admin\" for authn.\n\n\nclass AdminPageHandler(handler.AuthenticatingHandler):\n  \"\"\"Base class for handlers involved in bootstrap processes.\"\"\"\n\n  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of\n  # all 'style=...' attributes first.\n  csp_use_script_nonce = True\n\n  @classmethod\n  def get_auth_methods(cls, conf):\n    # This method sets 'is_superuser' bit for GAE-level admins.\n    return [handler.gae_cookie_authentication]\n\n  def reply(self, path, env=None, status=200):\n    \"\"\"Render template |path| to response using given environment.\n\n    Args:\n      path: path to a template, relative to templates/.\n      env: additional environment dict to use when rendering the template.\n      status: HTTP status code to return.\n    \"\"\"\n    full_env = {\n      'app_name': _ui_app_name,\n      'csp_nonce': self.csp_nonce,\n      'identity': api.get_current_identity(),\n      'logout_url': json.dumps(self.create_logout_url('/')), # see base.html\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    full_env.update(env or {})\n    self.response.set_status(status)\n    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'\n    self.response.write(template.render(path, full_env))\n\n  def authentication_error(self, error):\n    \"\"\"Shows 'Access denied' page.\"\"\"\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/admin/access_denied.html', env=env, status=401)\n\n  def authorization_error(self, error):\n    \"\"\"Redirects to login or shows 'Access Denied' page.\"\"\"\n    # Not authenticated or used IP whitelist for auth -> redirect to login.\n    # Bots doesn't use UI, and users should always use real accounts.\n    ident = api.get_current_identity()\n    if ident.is_anonymous or ident.is_bot:\n      self.redirect(self.create_login_url(self.request.url))\n      return\n\n    # Admin group is empty -> redirect to bootstrap procedure to create it.\n    if model.is_empty_group(model.ADMIN_GROUP):\n      self.redirect_to('bootstrap')\n      return\n\n    # No access.\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/admin/access_denied.html', env=env, status=403)\n\n\nclass BootstrapHandler(AdminPageHandler):\n  \"\"\"Creates Administrators group (if necessary) and adds current caller to it.\n\n  Requires Appengine level Admin access for its handlers, since Administrators\n  group may not exist yet.\n\n  Used during bootstrap of a new service instance.\n  \"\"\"\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def get(self):\n    env = {\n      'page_title': 'Bootstrap',\n      'admin_group': model.ADMIN_GROUP,\n      'return_url': self.request.get('r') or '',\n    }\n    self.reply('auth/admin/bootstrap.html', env)\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def post(self):\n    added = model.bootstrap_group(\n        model.ADMIN_GROUP, [api.get_current_identity()],\n        'Users that can manage groups')\n    env = {\n      'page_title': 'Bootstrap',\n      'admin_group': model.ADMIN_GROUP,\n      'added': added,\n      'return_url': self.request.get('return_url') or '',\n    }\n    self.reply('auth/admin/bootstrap_done.html', env)\n\n\nclass BootstrapOAuthHandler(AdminPageHandler):\n  \"\"\"Page to set OAuth2 client ID used by the main web UI.\n\n  Requires Appengine level Admin access for its handlers, since without client\n  ID there's no UI yet to configure Administrators group.\n\n  Used during bootstrap of a new service instance. Unlike /auth/bootstrap, it is\n  also available after the service is linked to some primary Auth service.\n  \"\"\"\n\n  @api.require(api.is_superuser)\n  def get(self):\n    self.show_page(web_client_id=api.get_web_client_id_uncached())\n\n  @api.require(api.is_superuser)\n  def post(self):\n    web_client_id = self.request.POST['web_client_id']\n    api.set_web_client_id(web_client_id)\n    self.show_page(web_client_id=web_client_id, saved=True)\n\n  def show_page(self, web_client_id, saved=False):\n    env = {\n      'page_title': 'OAuth2 web client ID',\n      'web_client_id': web_client_id or '',\n      'saved': saved,\n    }\n    self.reply('auth/admin/bootstrap_oauth.html', env)\n\n\nclass LinkToPrimaryHandler(AdminPageHandler):\n  \"\"\"A page with confirmation of Primary <-> Replica linking request.\n\n  URL to that page is generated by a Primary service.\n  \"\"\"\n\n  def decode_link_ticket(self):\n    \"\"\"Extracts ServiceLinkTicket from 't' GET parameter.\"\"\"\n    try:\n      return replication.decode_link_ticket(\n          self.request.get('t').encode('ascii'))\n    except (KeyError, ValueError):\n      self.abort(400)\n      return\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def get(self):\n    ticket = self.decode_link_ticket()\n    env = {\n      'generated_by': ticket.generated_by,\n      'page_title': 'Switch',\n      'primary_id': ticket.primary_id,\n      'primary_url': ticket.primary_url,\n    }\n    self.reply('auth/admin/linking.html', env)\n\n  @forbid_ui_on_replica\n  @api.require(api.is_superuser)\n  def post(self):\n    ticket = self.decode_link_ticket()\n    success = True\n    error_msg = None\n    try:\n      replication.become_replica(ticket, api.get_current_identity())\n    except replication.ProtocolError as exc:\n      success = False\n      error_msg = exc.message\n    env = {\n      'error_msg': error_msg,\n      'page_title': 'Switch',\n      'primary_id': ticket.primary_id,\n      'primary_url': ticket.primary_url,\n      'success': success,\n    }\n    self.reply('auth/admin/linking_done.html', env)\n\n\n################################################################################\n## Web UI routes.\n\n# TODO(vadimsh): Switch them to use OAuth for authentication.\n\n\nclass UIHandler(handler.AuthenticatingHandler):\n  \"\"\"Renders Jinja templates extending base.html.\"\"\"\n\n  # TODO(vadimsh): Enable CSP nonce for styles too. We'll need to get rid of\n  # all 'style=...' attributes first.\n  csp_use_script_nonce = True\n\n  def reply(self, path, env=None, status=200):\n    \"\"\"Renders template |path| to the HTTP response using given environment.\n\n    Optional keys from |env| that base.html uses:\n      css_file: URL to a file with page specific styles, relative to site root.\n      js_file: URL to a file with page specific Javascript code, relative to\n          site root. File should define global object named same as a filename,\n          i.e. '/auth/static/js/api.js' should define global object 'api' that\n          incapsulates functionality implemented in the module.\n      navbar_tab_id: id of a navbar tab to highlight.\n      page_title: title of an HTML page.\n\n    Args:\n      path: path to a template, relative to templates/.\n      env: additional environment dict to use when rendering the template.\n      status: HTTP status code to return.\n    \"\"\"\n    env = (env or {}).copy()\n    env.setdefault('css_file', None)\n    env.setdefault('js_file', None)\n    env.setdefault('navbar_tab_id', None)\n    env.setdefault('page_title', 'Untitled')\n\n    # This goes to both Jinja2 env and Javascript config object.\n    user = self.get_current_user()\n    common = {\n      'account_picture': user.picture() if user else None,\n      'auth_service_config_locked': False, # overridden in auth_service\n      'is_admin': api.is_admin(),\n      'login_url': self.create_login_url(self.request.url),\n      'logout_url': self.create_logout_url('/'),\n      'using_gae_auth': self.auth_method == handler.gae_cookie_authentication,\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    if _ui_data_callback:\n      common.update(_ui_data_callback())\n\n    # Name of Javascript module with page code.\n    js_module_name = None\n    if env['js_file']:\n      assert env['js_file'].endswith('.js')\n      js_module_name = os.path.basename(env['js_file'])[:-3]\n\n    # This will be accessible from Javascript as global 'config' variable.\n    js_config = {\n      'identity': api.get_current_identity().to_bytes(),\n    }\n    js_config.update(common)\n\n    # Jinja2 environment to use to render a template.\n    full_env = {\n      'app_name': _ui_app_name,\n      'app_revision_url': utils.get_app_revision_url(),\n      'app_version': utils.get_app_version(),\n      'config': json.dumps(js_config),\n      'csp_nonce': self.csp_nonce,\n      'identity': api.get_current_identity(),\n      'js_module_name': js_module_name,\n      'navbar': [\n        (cls.navbar_tab_id, cls.navbar_tab_title, cls.navbar_tab_url)\n        for cls in _ui_navbar_tabs\n        if cls.is_visible()\n      ],\n    }\n    full_env.update(common)\n    full_env.update(env)\n\n    # Render it.\n    self.response.set_status(status)\n    self.response.headers['Content-Type'] = 'text/html; charset=utf-8'\n    self.response.write(template.render(path, full_env))\n\n  def authentication_error(self, error):\n    \"\"\"Shows 'Access denied' page.\"\"\"\n    # TODO(vadimsh): This will be deleted once we use Google Sign-In.\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/access_denied.html', env=env, status=401)\n\n  def authorization_error(self, error):\n    \"\"\"Redirects to login or shows 'Access Denied' page.\"\"\"\n    # TODO(vadimsh): This will be deleted once we use Google Sign-In.\n    # Not authenticated or used IP whitelist for auth -> redirect to login.\n    # Bots doesn't use UI, and users should always use real accounts.\n    ident = api.get_current_identity()\n    if ident.is_anonymous or ident.is_bot:\n      self.redirect(self.create_login_url(self.request.url))\n      return\n\n    # Admin group is empty -> redirect to bootstrap procedure to create it.\n    if model.is_empty_group(model.ADMIN_GROUP):\n      self.redirect_to('bootstrap')\n      return\n\n    # No access.\n    env = {\n      'page_title': 'Access Denied',\n      'error': error,\n    }\n    self.reply('auth/access_denied.html', env=env, status=403)\n\n\nclass MainHandler(UIHandler):\n  \"\"\"Redirects to first navbar tab.\"\"\"\n  @redirect_ui_on_replica\n  @api.require(acl.has_access)\n  def get(self):\n    assert _ui_navbar_tabs\n    self.redirect(_ui_navbar_tabs[0].navbar_tab_url)\n\n\nclass UINavbarTabHandler(UIHandler):\n  \"\"\"Handler for a navbar tab page.\"\"\"\n  # List of routes to register, default is [navbar_tab_url].\n  routes = []\n  # URL to the tab (relative to site root).\n  navbar_tab_url = None\n  # ID of the tab, will be used in DOM.\n  navbar_tab_id = None\n  # Title of the tab, will be used in tab title and page title.\n  navbar_tab_title = None\n  # Relative URL to CSS file with tab's styles.\n  css_file = None\n  # Relative URL to javascript file with tab's logic.\n  js_file_url = None\n  # Path to a Jinja2 template with tab's markup.\n  template_file = None\n\n  @redirect_ui_on_replica\n  @api.require(acl.has_access)\n  def get(self, **_params):\n    \"\"\"Renders page HTML to HTTP response stream.\"\"\"\n    env = {\n      'css_file': self.css_file,\n      'js_file': self.js_file_url,\n      'navbar_tab_id': self.navbar_tab_id,\n      'page_title': self.navbar_tab_title,\n    }\n    self.reply(self.template_file, env)\n\n  @classmethod\n  def get_webapp2_routes(cls):\n    routes = cls.routes or [cls.navbar_tab_url]\n    return [webapp2.Route(r, cls) for r in routes]\n\n  @classmethod\n  def is_visible(cls):\n    \"\"\"Subclasses may return False to hide the tab from tab bar.\"\"\"\n    return True\n\n\n################################################################################\n## Default tabs.\n\n\nclass GroupsHandler(UINavbarTabHandler):\n  \"\"\"Page with Groups management.\"\"\"\n  routes = [\n    '/auth/groups',\n    '/auth/groups/<group:.*>',  # 'group' is handled by js code\n  ]\n  navbar_tab_url = '/auth/groups'\n  navbar_tab_id = 'groups'\n  navbar_tab_title = 'Groups'\n  css_file = '/auth/static/css/groups.css'\n  js_file_url = '/auth/static/js/groups.js'\n  template_file = 'auth/groups.html'\n\n\nclass ChangeLogHandler(UINavbarTabHandler):\n  \"\"\"Page with a log of changes to some groups.\"\"\"\n  navbar_tab_url = '/auth/change_log'\n  navbar_tab_id = 'change_log'\n  navbar_tab_title = 'Change Log'\n  js_file_url = '/auth/static/js/change_log.js'\n  template_file = 'auth/change_log.html'\n\n  @classmethod\n  def is_visible(cls):\n    # Hide 'Change Log' tab if there are no change log indexes in the datastore.\n    # It happens on services that use components.auth, but do not modify\n    # index.yaml. Don't try too hard to hide the log though. If user happes to\n    # stumble on Change log page (e.g. by using direct URL), it handles\n    # NeedIndexError gracefully (explaining how to configure indexes).\n    return change_log.is_changle_log_indexed()\n\n\nclass OAuthConfigHandler(UINavbarTabHandler):\n  \"\"\"Page with OAuth configuration.\"\"\"\n  navbar_tab_url = '/auth/oauth_config'\n  navbar_tab_id = 'oauth_config'\n  navbar_tab_title = 'OAuth'\n  js_file_url = '/auth/static/js/oauth_config.js'\n  template_file = 'auth/oauth_config.html'\n\n\nclass IPWhitelistsHandler(UINavbarTabHandler):\n  \"\"\"Page with IP whitelists configuration.\"\"\"\n  navbar_tab_url = '/auth/ip_whitelists'\n  navbar_tab_id = 'ip_whitelists'\n  navbar_tab_title = 'IP Whitelists'\n  js_file_url = '/auth/static/js/ip_whitelists.js'\n  template_file = 'auth/ip_whitelists.html'\n\n\nclass ApiDocHandler(UINavbarTabHandler):\n  \"\"\"Page with API documentation extracted from rest_api.py.\"\"\"\n  navbar_tab_url = '/auth/api'\n  navbar_tab_id = 'api'\n  navbar_tab_title = 'API'\n\n  # These can be used as 'request_type' and 'response_type' in api_doc.\n  doc_types = [\n    {\n      'name': 'Status',\n      'doc': 'Outcome of some operation.',\n      'example': {'ok': True},\n    },\n    {\n      'name': 'Self info',\n      'doc': 'Information about the requester.',\n      'example': {\n        'identity': 'user:someone@example.com',\n        'ip': '192.168.0.1',\n      },\n    },\n    {\n      'name': 'Group',\n      'doc': 'Represents a group, as stored in the database.',\n      'example': {\n        'group': {\n          'caller_can_modify': True,\n          'created_by': 'user:someone@example.com',\n          'created_ts': 1409250754978540,\n          'description': 'Some free form description',\n          'globs': ['user:*@example.com'],\n          'members': ['user:a@example.com', 'anonymous:anonymous'],\n          'modified_by': 'user:someone@example.com',\n          'modified_ts': 1470871200558130,\n          'name': 'Some group',\n          'nested': ['Some nested group', 'Another nested group'],\n          'owners': 'Owning group',\n        },\n      },\n    },\n    {\n      'name': 'Group listing',\n      'doc':\n        'All groups, along with their metadata. Does not include members '\n        'listings.',\n      'example': {\n        'groups': [\n          {\n            'caller_can_modify': True,\n            'created_by': 'user:someone@example.com',\n            'created_ts': 1409250754978540,\n            'description': 'Some free form description',\n            'modified_by': 'user:someone@example.com',\n            'modified_ts': 1470871200558130,\n            'name': 'Some group',\n            'owners': 'Owning group',\n          },\n          {\n            'caller_can_modify': True,\n            'created_by': 'user:someone@example.com',\n            'created_ts': 1409250754978540,\n            'description': 'Another description',\n            'modified_by': 'user:someone@example.com',\n            'modified_ts': 1470871200558130,\n            'name': 'Another group',\n            'owners': 'Owning group',\n          },\n        ],\n      },\n    },\n  ]\n\n  @redirect_ui_on_replica\n  @api.require(acl.has_access)\n  def get(self):\n    \"\"\"Extracts API doc for registered webapp2 API routes.\"\"\"\n    doc_types = []\n\n    def add_doc_type(tp):\n      \"\"\"Adds a request or response format definition to the documentation page.\n\n      'tp' can either reference a globally known doc type by name\n      (see ApiDocHandler.doc_types), or can itself be a dict with doc type\n      definition.\n\n      Returns the name of the doc type.\n      \"\"\"\n      if not tp:\n        return None\n      # If referenced by name, try to find it among globally known types.\n      if isinstance(tp, basestring):\n        for d in self.doc_types:\n          if d['name'] == tp:\n            tp = d\n            break\n        else:\n          return tp  # not found, return original name as is\n      # Add, if not already there. Serialize the example first, since doing it\n      # from Jinja is a bit more complicated.\n      if not any(d['name'] == tp['name'] for d in doc_types):\n        tp = tp.copy()\n        tp['example'] = json.dumps(\n            tp['example'], sort_keys=True, separators=(', ', ': '), indent=2)\n        doc_types.append(tp)\n      return tp['name']\n\n    api_methods = []\n    for route in rest_api.get_rest_api_routes():\n      # Remove API parameter regexps from route template, they are mostly noise.\n      simplified = re.sub(r'\\:.*\\>', '>', route.template)\n      for doc in getattr(route.handler, 'api_doc', []):\n        path = simplified\n        if 'params' in doc:\n          path += '?' + doc['params']\n        api_methods.append({\n          'verb': doc['verb'],\n          'path': path,\n          'doc': doc['doc'],\n          'request_type': add_doc_type(doc.get('request_type')),\n          'response_type': add_doc_type(doc.get('response_type')),\n        })\n\n    env = {\n      'navbar_tab_id': self.navbar_tab_id,\n      'page_title': self.navbar_tab_title,\n      'api_methods': api_methods,\n      'doc_types': doc_types,\n    }\n    self.reply('auth/api.html', env)\n\n\n# Register them as default tabs. Order is important.\n_ui_navbar_tabs = (\n  GroupsHandler,\n  ChangeLogHandler,\n  OAuthConfigHandler,\n  IPWhitelistsHandler,\n  ApiDocHandler,\n)\n/n/n/n/appengine/components/components/ereporter2/handlers.py/n/n# Copyright 2014 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"HTTP Handlers.\"\"\"\n\nimport datetime\nimport itertools\nimport json\nimport time\n\nimport webapp2\n\nfrom google.appengine.api import app_identity\nfrom google.appengine.datastore import datastore_query\nfrom google.appengine.ext import ndb\n\nfrom components import auth\nfrom components import decorators\nfrom components import template\nfrom components import utils\n\nfrom . import acl\nfrom . import logscraper\nfrom . import models\nfrom . import on_error\nfrom . import ui\n\n\n# Access to a protected member XXX of a client class - pylint: disable=W0212\n\n\n### Admin pages.\n\n\nclass RestrictedEreporter2Report(auth.AuthenticatingHandler):\n  \"\"\"Returns all the recent errors as a web page.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self):\n    \"\"\"Reports the errors logged and ignored.\n\n    Arguments:\n      start: epoch time to start looking at. Defaults to the messages since the\n             last email.\n      end: epoch time to stop looking at. Defaults to now.\n      modules: comma separated modules to look at.\n      tainted: 0 or 1, specifying if desiring tainted versions. Defaults to 1.\n    \"\"\"\n    # TODO(maruel): Be consistent about using either epoch or human readable\n    # formatted datetime.\n    end = int(float(self.request.get('end', 0)) or time.time())\n    start = int(\n        float(self.request.get('start', 0)) or\n        ui._get_default_start_time() or 0)\n    modules = self.request.get('modules')\n    if modules:\n      modules = modules.split(',')\n    tainted = bool(int(self.request.get('tainted', '1')))\n    module_versions = utils.get_module_version_list(modules, tainted)\n    errors, ignored, _end_time = logscraper.scrape_logs_for_errors(\n        start, end, module_versions)\n\n    params = {\n      'errors': errors,\n      'errors_count': sum(len(e.events) for e in errors),\n      'errors_version_count':\n          len(set(itertools.chain.from_iterable(e.versions for e in errors))),\n      'ignored': ignored,\n      'ignored_count': sum(len(i.events) for i in ignored),\n      'ignored_version_count':\n          len(set(itertools.chain.from_iterable(i.versions for i in ignored))),\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    params.update(ui._get_template_env(start, end, module_versions))\n    self.response.write(template.render('ereporter2/requests.html', params))\n\n\nclass RestrictedEreporter2Request(auth.AuthenticatingHandler):\n  \"\"\"Dumps information about single logged request.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self, request_id):\n    data = logscraper._log_request_id(request_id)\n    if not data:\n      self.abort(404, detail='Request id was not found.')\n    self.response.write(\n        template.render('ereporter2/request.html', {'request': data}))\n\n\nclass RestrictedEreporter2ErrorsList(auth.AuthenticatingHandler):\n  \"\"\"Dumps information about reported client side errors.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self):\n    limit = int(self.request.get('limit', 100))\n    cursor = datastore_query.Cursor(urlsafe=self.request.get('cursor'))\n    errors_found, cursor, more = models.Error.query().order(\n        -models.Error.created_ts).fetch_page(limit, start_cursor=cursor)\n    params = {\n      'cursor': cursor.urlsafe() if cursor and more else None,\n      'errors': errors_found,\n      'limit': limit,\n      'now': utils.utcnow(),\n    }\n    self.response.out.write(template.render('ereporter2/errors.html', params))\n\n\nclass RestrictedEreporter2Error(auth.AuthenticatingHandler):\n  \"\"\"Dumps information about reported client side errors.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self, error_id):\n    error = models.Error.get_by_id(int(error_id))\n    if not error:\n      self.abort(404, 'Error not found')\n    params = {\n      'error': error,\n      'now': utils.utcnow(),\n    }\n    self.response.out.write(template.render('ereporter2/error.html', params))\n\n\nclass RestrictedEreporter2Silence(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.is_ereporter2_viewer)\n  def get(self):\n    # Due to historical reasons where created_ts had indexed=False,, do not use\n    # .order(models.ErrorReportingMonitoring.created_ts) yet. Fix this once all\n    # objects have been updated.\n    items = models.ErrorReportingMonitoring.query().fetch()\n    items.sort(key=lambda x: x.created_ts)\n    params = {\n      'silenced': items,\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.out.write(template.render('ereporter2/silence.html', params))\n\n  @auth.require(acl.is_ereporter2_editor)\n  def post(self):\n    to_delete = self.request.get('to_delete')\n    if to_delete:\n      ndb.Key(models.ErrorReportingMonitoring, to_delete).delete()\n    else:\n      mute_type = self.request.get('mute_type')\n      error = None\n      if mute_type in ('exception_type', 'signature'):\n        error = self.request.get(mute_type)\n      if not error:\n        self.abort(400)\n      silenced = self.request.get('silenced')\n      silenced_until = self.request.get('silenced_until')\n      if silenced_until == 'T':\n        silenced_until = ''\n      threshold = self.request.get('threshold')\n      key = models.ErrorReportingMonitoring.error_to_key(error)\n      if not silenced and not silenced_until and not threshold:\n        key.delete()\n      else:\n        item = models.ErrorReportingMonitoring(key=key, error=error)\n        if silenced:\n          item.silenced = True\n        if silenced_until:\n          item.silenced_until = datetime.datetime.strptime(\n              silenced_until, '%Y-%m-%dT%H:%M')\n        if threshold:\n          item.threshold = int(threshold)\n        item.put()\n\n    self.get()\n\n\n### Cron jobs.\n\n\nclass CronEreporter2Mail(webapp2.RequestHandler):\n  \"\"\"Generate and emails an exception report.\"\"\"\n  @decorators.require_cronjob\n  def get(self):\n    \"\"\"Sends email(s) containing the errors logged.\"\"\"\n    # Do not use self.request.host_url because it will be http:// and will point\n    # to the backend, with an host format that breaks the SSL certificate.\n    # TODO(maruel): On the other hand, Google Apps instances are not hosted on\n    # appspot.com.\n    host_url = 'https://%s.appspot.com' % app_identity.get_application_id()\n    request_id_url = host_url + '/restricted/ereporter2/request/'\n    report_url = host_url + '/restricted/ereporter2/report'\n    recipients = self.request.get('recipients', acl.get_ereporter2_recipients())\n    result = ui._generate_and_email_report(\n        utils.get_module_version_list(None, False),\n        recipients,\n        request_id_url,\n        report_url,\n        {})\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    if result:\n      self.response.write('Success.')\n    else:\n      # Do not HTTP 500 since we do not want it to be retried.\n      self.response.write('Failed.')\n\n\nclass CronEreporter2Cleanup(webapp2.RequestHandler):\n  \"\"\"Deletes old error reports.\"\"\"\n  @decorators.require_cronjob\n  def get(self):\n    old_cutoff = utils.utcnow() - on_error.ERROR_TIME_TO_LIVE\n    items = models.Error.query(\n        models.Error.created_ts < old_cutoff,\n        default_options=ndb.QueryOptions(keys_only=True))\n    out = len(ndb.delete_multi(items))\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.write(str(out))\n\n\n### Public API.\n\n\nclass OnErrorHandler(auth.AuthenticatingHandler):\n  \"\"\"Adds an error report.\n\n  This one is open so errors like authentication reports are logged in too.\n  This means we could get spammed a lot about it. Implement DDoS protection by\n  rate limiting once a kid figures out.\n  \"\"\"\n  xsrf_token_enforce_on = ()\n\n  # TODO(maruel): This was copied from ../../auth/ui/rest_api.py and needs to be\n  # factored out.\n  def parse_body(self):\n    \"\"\"Parse JSON body and verifies it's a dict.\"\"\"\n    expected = ('application/json', 'application/json; charset=utf-8')\n    if self.request.headers.get('Content-Type').lower() not in expected:\n      msg = 'Expecting JSON body with content type \\'application/json\\''\n      self.abort(400, msg)\n    try:\n      body = json.loads(self.request.body)\n      if not isinstance(body, dict):\n        raise ValueError()\n    except ValueError:\n      self.abort(400, 'Not a valid json dict body')\n    return body\n\n  @auth.public\n  def post(self):\n    body = self.parse_body()\n    version = body.get('v')\n    # Do not enforce version for now, just assert it is present.\n    if not version:\n      self.abort(400, 'Missing version')\n\n    report = body.get('r')\n    if not report:\n      self.abort(400, 'Missing report')\n\n    kwargs = dict(\n        (k, report[k]) for k in on_error.VALID_ERROR_KEYS if report.get(k))\n    report_id = on_error.log_request(self.request, add_params=False, **kwargs)\n    self.response.headers['Content-Type'] = 'application/json; charset=utf-8'\n    body = {\n      'id': report_id,\n      'url':\n          '%s/restricted/ereporter2/errors/%d' %\n          (self.request.host_url, report_id),\n    }\n    self.response.write(utils.encode_to_json(body))\n\n\ndef get_frontend_routes():\n  return [\n    webapp2.Route(\n        r'/restricted/ereporter2/errors',\n        RestrictedEreporter2ErrorsList),\n    webapp2.Route(\n        r'/restricted/ereporter2/errors/<error_id:\\d+>',\n        RestrictedEreporter2Error),\n    webapp2.Route(\n        r'/restricted/ereporter2/report',\n        RestrictedEreporter2Report),\n    webapp2.Route(\n        r'/restricted/ereporter2/request/<request_id:[0-9a-fA-F]+>',\n        RestrictedEreporter2Request),\n    webapp2.Route(\n        r'/restricted/ereporter2/silence',\n        RestrictedEreporter2Silence),\n\n    # Public API.\n    webapp2.Route(\n      '/ereporter2/api/v1/on_error', OnErrorHandler),\n  ]\n\n\ndef get_backend_routes():\n  # This requires a cron job to this URL.\n  return [\n    webapp2.Route(\n        r'/internal/cron/ereporter2/cleanup', CronEreporter2Cleanup),\n    webapp2.Route(\n        r'/internal/cron/ereporter2/mail', CronEreporter2Mail),\n  ]\n/n/n/n/appengine/isolate/handlers_frontend.py/n/n# Copyright 2012 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"This module defines Isolate Server frontend url handlers.\"\"\"\n\nimport collections\nimport datetime\nimport json\nimport logging\n\nimport webapp2\n\nimport cloudstorage\nfrom google.appengine.api import modules\n\nimport acl\nimport config\nimport gcs\nimport handlers_endpoints_v1\nimport mapreduce_jobs\nimport model\nimport stats\nimport template\nfrom components import auth\nfrom components import stats_framework\nfrom components import stats_framework_gviz\nfrom components import utils\nfrom gviz import gviz_api\n\n\n# GViz data description.\n_GVIZ_DESCRIPTION = {\n  'failures': ('number', 'Failures'),\n  'requests': ('number', 'Total'),\n  'other_requests': ('number', 'Other'),\n  'uploads': ('number', 'Uploads'),\n  'uploads_bytes': ('number', 'Uploaded'),\n  'downloads': ('number', 'Downloads'),\n  'downloads_bytes': ('number', 'Downloaded'),\n  'contains_requests': ('number', 'Lookups'),\n  'contains_lookups': ('number', 'Items looked up'),\n}\n\n# Warning: modifying the order here requires updating templates/stats.html.\n_GVIZ_COLUMNS_ORDER = (\n  'key',\n  'requests',\n  'other_requests',\n  'failures',\n  'uploads',\n  'downloads',\n  'contains_requests',\n  'uploads_bytes',\n  'downloads_bytes',\n  'contains_lookups',\n)\n\n_ISOLATED_ROOT_MEMBERS = (\n  'algo',\n  'command',\n  'files',\n  'includes',\n  'read_only',\n  'relative_cwd',\n  'version',\n)\n\n\n### Restricted handlers\n\n\nclass RestrictedConfigHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(auth.is_admin)\n  def get(self):\n    self.common(None)\n\n  @staticmethod\n  def cast_to_type(param_name, value):\n    def to_bool(value):\n      if type(value) is bool:\n        return value\n      return {'True': True, 'False': False}.get(value, False)\n\n    cast = {\n        'enable_ts_monitoring': to_bool,\n    }.get(param_name, str)\n    return cast(value)\n\n  @auth.require(auth.is_admin)\n  def post(self):\n    # Convert MultiDict into a dict.\n    params = {\n      k: self.cast_to_type(k, self.request.params.getone(k))\n      for k in self.request.params\n      if k not in ('keyid', 'xsrf_token')\n    }\n    cfg = config.settings(fresh=True)\n    keyid = int(self.request.get('keyid', '0'))\n    if cfg.key.integer_id() != keyid:\n      self.common('Update conflict %s != %s' % (cfg.key.integer_id(), keyid))\n      return\n    cfg.populate(**params)\n    try:\n      # Ensure key is correct, it's easy to make a mistake when creating it.\n      gcs.URLSigner.load_private_key(cfg.gs_private_key)\n    except Exception as exc:\n      # TODO(maruel): Handling Exception is too generic. And add self.abort(400)\n      self.response.write('Bad private key: %s' % exc)\n      return\n    cfg.store(updated_by=auth.get_current_identity().to_bytes())\n    self.common('Settings updated')\n\n  def common(self, note):\n    params = config.settings_info()\n    params.update({\n        'note': note,\n        'path': self.request.path,\n        'xsrf_token': self.generate_xsrf_token(),\n    })\n    self.response.write(\n        template.render('isolate/restricted_config.html', params))\n\n\nclass RestrictedPurgeHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(auth.is_admin)\n  def get(self):\n    params = {\n      'digest': '',\n      'message': '',\n      'namespace': '',\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.write(\n        template.render('isolate/restricted_purge.html', params))\n\n  @auth.require(auth.is_admin)\n  def post(self):\n    namespace = self.request.get('namespace')\n    digest = self.request.get('digest')\n    params = {\n      'digest': digest,\n      'message': '',\n      'namespace': namespace,\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    try:\n      key = model.get_entry_key(namespace, digest)\n    except ValueError as e:\n      params['message'] = 'Invalid entry: %s' % e\n      key = None\n    if key:\n      model.delete_entry_and_gs_entry([key])\n      params['message'] = 'Done'\n    self.response.write(\n        template.render('isolate/restricted_purge.html', params))\n\n\n### Mapreduce related handlers\n\n\nclass RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):\n  \"\"\"Enqueues a task to start a map reduce job on the backend module.\n\n  A tree of map reduce jobs inherits module and version of a handler that\n  launched it. All UI handlers are executes by 'default' module. So to run a\n  map reduce on a backend module one needs to pass a request to a task running\n  on backend module.\n  \"\"\"\n\n  @auth.require(auth.is_admin)\n  def post(self):\n    job_id = self.request.get('job_id')\n    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS\n    # Do not use 'backend' module when running from dev appserver. Mapreduce\n    # generates URLs that are incompatible with dev appserver URL routing when\n    # using custom modules.\n    success = utils.enqueue_task(\n        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,\n        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,\n        use_dedicated_module=not utils.is_local_dev_server())\n    # New tasks should show up on the status page.\n    if success:\n      self.redirect('/mapreduce/status')\n    else:\n      self.abort(500, 'Failed to launch the job')\n\n\n### Non-restricted handlers\n\n\nclass BrowseHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.isolate_readable)\n  def get(self):\n    namespace = self.request.get('namespace', 'default-gzip')\n    # Support 'hash' for compatibility with old links. To remove eventually.\n    digest = self.request.get('digest', '') or self.request.get('hash', '')\n    save_as = self.request.get('as', '')\n    params = {\n      u'as': unicode(save_as),\n      u'digest': unicode(digest),\n      u'namespace': unicode(namespace),\n    }\n    # Check for existence of element, so we can 400/404\n    if digest and namespace:\n      try:\n        model.get_content(namespace, digest)\n      except ValueError:\n        self.abort(400, 'Invalid key')\n      except LookupError:\n        self.abort(404, 'Unable to retrieve the entry')\n    self.response.write(template.render('isolate/browse.html', params))\n\n  def get_content_security_policy(self):\n    csp = super(BrowseHandler, self).get_content_security_policy()\n    csp.setdefault('child-src', []).append(\"'self'\")\n    return csp\n\n\nclass ContentHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.isolate_readable)\n  def get(self):\n    namespace = self.request.get('namespace', 'default-gzip')\n    digest = self.request.get('digest', '')\n    content = None\n    if not digest:\n      self.abort(400, 'Missing digest')\n    if not namespace:\n      self.abort(400, 'Missing namespace')\n\n    try:\n      raw_data, entity = model.get_content(namespace, digest)\n    except ValueError:\n      self.abort(400, 'Invalid key')\n    except LookupError:\n      self.abort(404, 'Unable to retrieve the entry')\n\n    logging.info('%s', entity)\n    if not raw_data:\n      try:\n        stream = gcs.read_file(config.settings().gs_bucket, entity.key.id())\n        content = ''.join(model.expand_content(namespace, stream))\n      except cloudstorage.NotFoundError:\n        logging.error('Entity in DB but not in GCS: deleting entity in DB')\n        entity.key.delete()\n        self.abort(404, 'Unable to retrieve the file from GCS')\n    else:\n      content = ''.join(model.expand_content(namespace, [raw_data]))\n\n    self.response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    # We delete Content-Type before storing to it to avoid having two (yes,\n    # two) Content-Type headers.\n    del self.response.headers['Content-Type']\n\n    # Apparently, setting the content type to text/plain encourages the\n    # browser (Chrome, at least) to sniff the mime type and display\n    # things like images.  Images are autowrapped in <img> and text is\n    # wrapped in <pre>.\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n\n    # App Engine puts a limit of 33554432 bytes on a request, which includes\n    # headers. Headers are ~150 bytes.  If the content + headers might\n    # exceed that limit, we give the user an option to workround getting\n    # their file.\n    if len(content) > 33554000:\n      host = modules.get_hostname(module='default', version='default')\n      # host is something like default.default.myisolateserver.appspot.com\n      host = host.replace('default.default.','')\n      sizeInMib = len(content) / (1024.0 * 1024.0)\n      content = ('Sorry, your file is %1.1f MiB big, which exceeds the 32 MiB'\n      ' App Engine limit.\\nTo work around this, run the following command:\\n'\n      '    python isolateserver.py download -I %s --namespace %s -f %s %s'\n      % (sizeInMib, host, namespace, digest, digest))\n    else:\n      self.response.headers['Content-Disposition'] = str(\n        'filename=%s' % self.request.get('as') or digest)\n      try:\n        json_data = json.loads(content)\n        if self._is_isolated_format(json_data):\n          self.response.headers['Content-Type'] = 'text/html; charset=utf-8'\n          json_data['files'] = collections.OrderedDict(\n            sorted(\n              json_data['files'].items(),\n              key=lambda (filepath, data): filepath))\n          params = {\n            'namespace': namespace,\n            'isolated': json_data,\n          }\n          content = template.render('isolate/isolated.html', params)\n      except ValueError:\n        pass\n\n    self.response.write(content)\n\n  @staticmethod\n  def _is_isolated_format(json_data):\n    \"\"\"Checks if json_data is a valid .isolated format.\"\"\"\n    if not isinstance(json_data, dict):\n      return False\n    actual = set(json_data)\n    return actual.issubset(_ISOLATED_ROOT_MEMBERS) and 'files' in actual\n\n\nclass StatsHandler(webapp2.RequestHandler):\n  \"\"\"Returns the statistics web page.\"\"\"\n  def get(self):\n    \"\"\"Presents nice recent statistics.\n\n    It fetches data from the 'JSON' API.\n    \"\"\"\n    # Preloads the data to save a complete request.\n    resolution = self.request.params.get('resolution', 'hours')\n    if resolution not in ('days', 'hours', 'minutes'):\n      resolution = 'hours'\n    duration = utils.get_request_as_int(self.request, 'duration', 120, 1, 1000)\n\n    description = _GVIZ_DESCRIPTION.copy()\n    description.update(stats_framework_gviz.get_description_key(resolution))\n    table = stats_framework.get_stats(\n        stats.STATS_HANDLER, resolution, None, duration, True)\n    params = {\n      'duration': duration,\n      'initial_data': gviz_api.DataTable(description, table).ToJSon(\n          columns_order=_GVIZ_COLUMNS_ORDER),\n      'now': datetime.datetime.utcnow(),\n      'resolution': resolution,\n    }\n    self.response.write(template.render('isolate/stats.html', params))\n\n\nclass StatsGvizHandlerBase(webapp2.RequestHandler):\n  RESOLUTION = None\n\n  def get(self):\n    description = _GVIZ_DESCRIPTION.copy()\n    description.update(\n        stats_framework_gviz.get_description_key(self.RESOLUTION))\n    try:\n      stats_framework_gviz.get_json(\n          self.request,\n          self.response,\n          stats.STATS_HANDLER,\n          self.RESOLUTION,\n          description,\n          _GVIZ_COLUMNS_ORDER)\n    except ValueError as e:\n      self.abort(400, str(e))\n\n\nclass StatsGvizDaysHandler(StatsGvizHandlerBase):\n  RESOLUTION = 'days'\n\n\nclass StatsGvizHoursHandler(StatsGvizHandlerBase):\n  RESOLUTION = 'hours'\n\n\nclass StatsGvizMinutesHandler(StatsGvizHandlerBase):\n  RESOLUTION = 'minutes'\n\n\n###  Public pages.\n\n\nclass RootHandler(auth.AuthenticatingHandler):\n  \"\"\"Tells the user to RTM.\"\"\"\n\n  @auth.public\n  def get(self):\n    params = {\n      'is_admin': auth.is_admin(),\n      'is_user': acl.isolate_readable(),\n      'mapreduce_jobs': [],\n      'user_type': acl.get_user_type(),\n    }\n    if auth.is_admin():\n      params['mapreduce_jobs'] = [\n        {'id': job_id, 'name': job_def['job_name']}\n        for job_id, job_def in mapreduce_jobs.MAPREDUCE_JOBS.iteritems()\n      ]\n      params['xsrf_token'] = self.generate_xsrf_token()\n    self.response.write(template.render('isolate/root.html', params))\n\n\nclass UIHandler(auth.AuthenticatingHandler):\n  \"\"\"Serves the landing page for the new UI of the requested page.\n\n  This landing page is stamped with the OAuth 2.0 client id from the\n  configuration.\n  \"\"\"\n  @auth.public\n  def get(self):\n    params = {\n      'client_id': config.settings().ui_client_id,\n    }\n    # Can cache for 1 week, because the only thing that would change in this\n    # template is the oauth client id, which changes very infrequently.\n    self.response.cache_control.no_cache = None\n    self.response.cache_control.public = True\n    self.response.cache_control.max_age = 604800\n    try:\n      self.response.write(template.render(\n        'isolate/public_isolate_index.html', params))\n    except template.TemplateNotFound:\n      self.abort(404, 'Page not found.')\n\n\nclass WarmupHandler(webapp2.RequestHandler):\n  def get(self):\n    config.warmup()\n    auth.warmup()\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.write('ok')\n\n\nclass EmailHandler(webapp2.RequestHandler):\n  \"\"\"Blackhole any email sent.\"\"\"\n  def post(self, to):\n    pass\n\n\ndef get_routes():\n  routes = [\n      # Administrative urls.\n      webapp2.Route(r'/restricted/config', RestrictedConfigHandler),\n      webapp2.Route(r'/restricted/purge', RestrictedPurgeHandler),\n\n      # Mapreduce related urls.\n      webapp2.Route(\n          r'/restricted/launch_mapreduce',\n          RestrictedLaunchMapReduceJob),\n\n      # User web pages.\n      webapp2.Route(r'/browse', BrowseHandler),\n      webapp2.Route(r'/content', ContentHandler),\n      # TODO(maruel): These really need to be migrated to Cloud Endpoints, gviz\n      # is just too sorry.\n      #webapp2.Route(r'/stats', StatsHandler),\n      #webapp2.Route(r'/isolate/api/v1/stats/days', StatsGvizDaysHandler),\n      #webapp2.Route(r'/isolate/api/v1/stats/hours', StatsGvizHoursHandler),\n      #webapp2.Route(r'/isolate/api/v1/stats/minutes', StatsGvizMinutesHandler),\n      webapp2.Route(r'/', RootHandler),\n      webapp2.Route(r'/newui', UIHandler),\n\n      # AppEngine-specific urls:\n      webapp2.Route(r'/_ah/mail/<to:.+>', EmailHandler),\n      webapp2.Route(r'/_ah/warmup', WarmupHandler),\n  ]\n  routes.extend(handlers_endpoints_v1.get_routes())\n  return routes\n\n\ndef create_application(debug):\n  \"\"\"Creates the url router.\n\n  The basic layouts is as follow:\n  - /restricted/.* requires being an instance administrator.\n  - /stats/.* has statistics.\n  \"\"\"\n  acl.bootstrap()\n  template.bootstrap()\n  return webapp2.WSGIApplication(get_routes(), debug=debug)\n/n/n/n/appengine/machine_provider/handlers_frontend.py/n/n# Copyright 2016 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Front-end UI.\"\"\"\n\nimport logging\nimport os\n\nimport webapp2\n\nfrom components import auth\nfrom components import datastore_utils\nfrom components import template\nfrom components import utils\n\nimport handlers_endpoints\nimport models\n\n\nTHIS_DIR = os.path.dirname(os.path.abspath(__file__))\n\n\nclass CatalogHandler(auth.AuthenticatingHandler):\n  \"\"\"Catalog handler.\"\"\"\n\n  @auth.require(auth.is_admin)\n  def get(self, machine_id=None):\n    params = {\n        'machines': [],\n        'next_page_token': None,\n    }\n    if machine_id:\n      machine = models.CatalogMachineEntry.get_by_id(machine_id)\n      if not machine:\n        self.abort(404)\n      params['machines'] = [machine]\n    else:\n      query = models.CatalogMachineEntry.query().order(\n          models.CatalogMachineEntry.dimensions.hostname)\n      page_token = self.request.get('page_token') or ''\n      params['machines'], params['next_page_token'] = (\n          datastore_utils.fetch_page(query, 50, page_token))\n\n    self.response.write(\n        template.render('templates/catalog.html', params=params))\n\n\nclass LeaseRequestHandler(auth.AuthenticatingHandler):\n  \"\"\"Lease request handler.\"\"\"\n\n  @auth.require(auth.is_admin)\n  def get(self, lease_id=None):\n    params = {\n        'lease_requests': [],\n        'next_page_token': None,\n        'now_ts': utils.time_time(),\n    }\n    if lease_id:\n      lease_request = models.LeaseRequest.get_by_id(lease_id)\n      if not lease_request:\n        self.abort(404)\n      params['lease_requests'] = [lease_request]\n    else:\n      query = models.LeaseRequest.query().order(\n          -models.LeaseRequest.last_modified_ts)\n      page_token = self.request.get('page_token') or ''\n      params['lease_requests'], params['next_page_token'] = (\n          datastore_utils.fetch_page(query, 50, page_token))\n\n    self.response.write(template.render('templates/leases.html', params=params))\n\n\nclass RootHandler(auth.AuthenticatingHandler):\n  \"\"\"Root handler.\"\"\"\n\n  @auth.public\n  def get(self):\n    params = {\n        'is_admin': auth.is_admin(),\n    }\n\n    self.response.write(template.render('templates/root.html', params=params))\n\n\ndef get_routes():\n  return [\n      webapp2.Route('/', handler=RootHandler),\n      webapp2.Route('/catalog', handler=CatalogHandler),\n      webapp2.Route('/catalog/<machine_id>', handler=CatalogHandler),\n      webapp2.Route('/leases', handler=LeaseRequestHandler),\n      webapp2.Route('/leases/<lease_id>', handler=LeaseRequestHandler),\n  ]\n\n\ndef create_frontend_app():\n  template.bootstrap({\n      'templates': os.path.join(THIS_DIR, 'templates'),\n  })\n  routes = get_routes()\n  routes.extend(handlers_endpoints.get_routes())\n  return webapp2.WSGIApplication(routes)\n/n/n/n/appengine/swarming/handlers_frontend.py/n/n# Copyright 2013 The LUCI Authors. All rights reserved.\n# Use of this source code is governed under the Apache License, Version 2.0\n# that can be found in the LICENSE file.\n\n\"\"\"Main entry point for Swarming service.\n\nThis file contains the URL handlers for all the Swarming service URLs,\nimplemented using the webapp2 framework.\n\"\"\"\n\nimport collections\nimport os\n\nimport webapp2\n\nimport handlers_bot\nimport handlers_endpoints\nimport mapreduce_jobs\nimport template\nfrom components import auth\nfrom components import utils\nfrom server import acl\nfrom server import bot_code\nfrom server import config\n\n\nROOT_DIR = os.path.dirname(os.path.abspath(__file__))\n\n\n# Helper class for displaying the sort options in html templates.\nSortOptions = collections.namedtuple('SortOptions', ['key', 'name'])\n\n\n### is_admin pages.\n\n\nclass RestrictedConfigHandler(auth.AuthenticatingHandler):\n  @auth.autologin\n  @auth.require(acl.can_view_config)\n  def get(self):\n    # Template parameters schema matches settings_info() return value.\n    self.response.write(template.render(\n        'swarming/restricted_config.html', config.settings_info()))\n\n\nclass UploadBotConfigHandler(auth.AuthenticatingHandler):\n  \"\"\"Stores a new bot_config.py script.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.can_view_config)\n  def get(self):\n    bot_config = bot_code.get_bot_config()\n    params = {\n      'content': bot_config.content.decode('utf-8'),\n      'path': self.request.path,\n      'version': bot_config.version,\n      'when': bot_config.when,\n      'who': bot_config.who or 'N/A',\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.write(\n        template.render('swarming/restricted_upload_bot_config.html', params))\n\n  @auth.require(acl.can_edit_config)\n  def post(self):\n    script = self.request.get('script', '')\n    if not script:\n      self.abort(400, 'No script uploaded')\n\n    # Make sure the script is valid utf-8. For some odd reason, the script\n    # instead may or may not be an unicode instance. This depends if it is on\n    # AppEngine production or not.\n    if isinstance(script, str):\n      script = script.decode('utf-8', 'replace')\n    script = script.encode('utf-8')\n    bot_code.store_bot_config(self.request.host_url, script)\n    self.get()\n\n\nclass UploadBootstrapHandler(auth.AuthenticatingHandler):\n  \"\"\"Stores a new bootstrap.py script.\"\"\"\n\n  @auth.autologin\n  @auth.require(acl.can_view_config)\n  def get(self):\n    bootstrap = bot_code.get_bootstrap(self.request.host_url)\n    params = {\n      'content': bootstrap.content.decode('utf-8'),\n      'path': self.request.path,\n      'version': bootstrap.version,\n      'when': bootstrap.when,\n      'who': bootstrap.who or 'N/A',\n      'xsrf_token': self.generate_xsrf_token(),\n    }\n    self.response.write(\n        template.render('swarming/restricted_upload_bootstrap.html', params))\n\n  @auth.require(acl.can_edit_config)\n  def post(self):\n    script = self.request.get('script', '')\n    if not script:\n      self.abort(400, 'No script uploaded')\n\n    # Make sure the script is valid utf-8. For some odd reason, the script\n    # instead may or may not be an unicode instance. This depends if it is on\n    # AppEngine production or not.\n    if isinstance(script, str):\n      script = script.decode('utf-8', 'replace')\n    script = script.encode('utf-8')\n    bot_code.store_bootstrap(script)\n    self.get()\n\n\n### Mapreduce related handlers\n\n\nclass RestrictedLaunchMapReduceJob(auth.AuthenticatingHandler):\n  \"\"\"Enqueues a task to start a map reduce job on the backend module.\n\n  A tree of map reduce jobs inherits module and version of a handler that\n  launched it. All UI handlers are executes by 'default' module. So to run a\n  map reduce on a backend module one needs to pass a request to a task running\n  on backend module.\n  \"\"\"\n\n  @auth.require(acl.can_edit_config)\n  def post(self):\n    job_id = self.request.get('job_id')\n    assert job_id in mapreduce_jobs.MAPREDUCE_JOBS\n    success = utils.enqueue_task(\n        url='/internal/taskqueue/mapreduce/launch/%s' % job_id,\n        queue_name=mapreduce_jobs.MAPREDUCE_TASK_QUEUE,\n        use_dedicated_module=False)\n    # New tasks should show up on the status page.\n    if success:\n      self.redirect('/restricted/mapreduce/status')\n    else:\n      self.abort(500, 'Failed to launch the job')\n\n\n### Redirectors.\n\n\nclass BotsListHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a list of known bots.\"\"\"\n\n  @auth.public\n  def get(self):\n    limit = int(self.request.get('limit', 100))\n\n    dimensions = (\n      l.strip() for l in self.request.get('dimensions', '').splitlines()\n    )\n    dimensions = [i for i in dimensions if i]\n\n    new_ui_link = '/botlist?l=%d' % limit\n    if dimensions:\n      new_ui_link += '&f=' + '&f='.join(dimensions)\n\n    self.redirect(new_ui_link)\n\n\nclass BotHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a page about the bot, including last tasks and events.\"\"\"\n\n  @auth.public\n  def get(self, bot_id):\n    self.redirect('/bot?id=%s' % bot_id)\n\n\nclass TasksHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a list of all task requests.\"\"\"\n\n  @auth.public\n  def get(self):\n    limit = int(self.request.get('limit', 100))\n    task_tags = [\n      line for line in self.request.get('task_tag', '').splitlines() if line\n    ]\n\n    new_ui_link = '/tasklist?l=%d' % limit\n    if task_tags:\n      new_ui_link += '&f=' + '&f='.join(task_tags)\n\n    self.redirect(new_ui_link)\n\n\nclass TaskHandler(auth.AuthenticatingHandler):\n  \"\"\"Redirects to a page containing task request and result.\"\"\"\n\n  @auth.public\n  def get(self, task_id):\n    self.redirect('/task?id=%s' % task_id)\n\n\n### Public pages.\n\n\nclass UIHandler(auth.AuthenticatingHandler):\n  \"\"\"Serves the landing page for the new UI of the requested page.\n\n  This landing page is stamped with the OAuth 2.0 client id from the\n  configuration.\"\"\"\n  @auth.public\n  def get(self, page):\n    if not page:\n      page = 'swarming'\n\n    params = {\n      'client_id': config.settings().ui_client_id,\n    }\n    # Can cache for 1 week, because the only thing that would change in this\n    # template is the oauth client id, which changes very infrequently.\n    self.response.cache_control.no_cache = None\n    self.response.cache_control.public = True\n    self.response.cache_control.max_age = 604800\n    try:\n      self.response.write(template.render(\n        'swarming/public_%s_index.html' % page, params))\n    except template.TemplateNotFound:\n      self.abort(404, 'Page not found.')\n\n  def get_content_security_policy(self):\n    # We use iframes to display pages at display_server_url_template. Need to\n    # allow it in CSP.\n    csp = super(UIHandler, self).get_content_security_policy()\n    tmpl = config.settings().display_server_url_template\n    if tmpl:\n      if tmpl.startswith('/'):\n        csp['child-src'].append(\"'self'\")\n      else:\n        # We assume the template specifies '%s' in its last path component.\n        # We strip it to get a \"parent\" path that we can put into CSP. Note that\n        # whitelisting an entire display server domain is unnecessary wide.\n        assert tmpl.startswith('https://'), tmpl\n        csp['child-src'].append(tmpl[:tmpl.rfind('/')+1])\n    return csp\n\n\nclass WarmupHandler(webapp2.RequestHandler):\n  def get(self):\n    auth.warmup()\n    bot_code.get_swarming_bot_zip(self.request.host_url)\n    utils.get_module_version_list(None, None)\n    self.response.headers['Content-Type'] = 'text/plain; charset=utf-8'\n    self.response.write('ok')\n\n\nclass EmailHandler(webapp2.RequestHandler):\n  \"\"\"Blackhole any email sent.\"\"\"\n  def post(self, to):\n    pass\n\n\ndef get_routes():\n  routes = [\n      # Frontend pages. They return HTML.\n      # Public pages.\n      ('/<page:(bot|botlist|task|tasklist|)>', UIHandler),\n\n      # Redirects to Polymer UI\n      ('/user/tasks', TasksHandler),\n      ('/user/task/<task_id:[0-9a-fA-F]+>', TaskHandler),\n      ('/restricted/bots', BotsListHandler),\n      ('/restricted/bot/<bot_id:[^/]+>', BotHandler),\n\n      # Admin pages.\n      # TODO(maruel): Get rid of them.\n      ('/restricted/config', RestrictedConfigHandler),\n      ('/restricted/upload/bot_config', UploadBotConfigHandler),\n      ('/restricted/upload/bootstrap', UploadBootstrapHandler),\n\n      # Mapreduce related urls.\n      (r'/restricted/launch_mapreduce', RestrictedLaunchMapReduceJob),\n\n      ('/_ah/mail/<to:.+>', EmailHandler),\n      ('/_ah/warmup', WarmupHandler),\n  ]\n  return [webapp2.Route(*i) for i in routes]\n\n\ndef create_application(debug):\n  routes = []\n  routes.extend(get_routes())\n  routes.extend(handlers_bot.get_routes())\n  routes.extend(handlers_endpoints.get_routes())\n  return webapp2.WSGIApplication(routes, debug=debug)\n/n/n/n", "label": 1}, {"id": "2b70b391b0792c90ed71fd23ab36a6b7c60fb1e5", "code": "src/veil/backend/redis/client/client.py/n/nfrom __future__ import unicode_literals, print_function, division, absolute_import\nfrom redis.client import Redis\nfrom logging import getLogger\nfrom veil.environment.setting import *\nfrom veil.development.test import *\n\nLOGGER = getLogger(__name__)\n\nregistry = {} # purpose => get_redis_options\ninstances = {} # purpose => instance (a.k.a Redis class instance)\n\ndef register_redis(purpose):\n    if purpose not in registry:\n        registry[purpose] = register_redis_options(purpose)\n    return lambda: require_redis(purpose)\n\n\ndef register_redis_options(purpose):\n    section = '{}_redis'.format(purpose) # for example cache_redis\n    get_redis_host = register_option(section, 'host')\n    get_redis_port = register_option(section, 'port', int)\n    get_redis_password = register_option(section, 'password')\n\n    def get_redis_options():\n        return {\n            'host': get_redis_host(),\n            'port': get_redis_port(),\n            'password': get_redis_password()\n        }\n\n    return get_redis_options\n\n\ndef require_redis(purpose):\n    if purpose not in registry:\n        raise Exception('redis for purpose {} is not registered'.format(purpose))\n    if purpose not in instances:\n        get_redis_options = registry[purpose]\n        instances[purpose] = Redis(**get_redis_options())\n    executing_test = get_executing_test(optional=True)\n    if executing_test:\n        executing_test.addCleanup(lambda :instances[purpose].flushall())\n    return instances[purpose]\n/n/n/nsrc/veil/development/browser/browser.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport logging\nimport threading\nimport time\nimport traceback\nimport lxml.html\nimport os.path\nimport spynner\nimport selenium.webdriver\nimport os\nfrom veil.utility.path import *\nfrom veil.development.test import *\nfrom veil.profile.web import *\nfrom veil.frontend.web.static_file import *\n\nLOGGER = logging.getLogger(__name__)\nlatest_page = None\n\ndef start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):\n    @route('POST', '/-test/stop', website=website)\n    def stop_test():\n        stop_browser()\n\n    @route('POST', '/-test/fail', website=website)\n    def fail_test():\n        message = get_http_argument('message')\n        LOGGER.error(message)\n        get_executing_test().error = message\n\n    @route('POST', '/-test/log', website=website)\n    def log_from_test():\n        LOGGER.info(get_http_argument('message'))\n\n    @route('GET', '/-test/veil-test.js', website=website)\n    def veil_test_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'veil-test.js').text()\n\n    @route('GET', '/-test/jquery.js', website=website)\n    def jquery_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'jquery.js').text()\n\n    @route('GET', '/-test/jquery-cookie.js', website=website)\n    def jquery_cookie_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()\n\n    @route('GET', '/-test/veil.js', website=website)\n    def veil_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'veil.js').text()\n\n    page_interactions = list(reversed(page_interactions))\n    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))\n    http_server = start_test_website(website)\n    domain = get_website_option(website, 'domain')\n    if domain:\n        url = 'http://{}{}'.format(domain, path)\n    else:\n        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)\n    threading.Thread(target=lambda: execute_io_loop(timeout)).start()\n    start_browser(url, browser)\n\n\ndef execute_io_loop(timeout):\n    get_executing_test().addCleanup(require_io_loop_executor().stop)\n    try:\n        require_io_loop_executor().execute(timeout=timeout)\n    except:\n        get_executing_test().error = traceback.format_exc()\n        raise\n\n\ndef start_browser(url, browser_type):\n    if os.getenv('VEIL_REMOTE_BROWSER'):\n        browser_type = 'remote'\n    get_executing_test().browser_type = browser_type\n    test = get_executing_test()\n    test.addCleanup(stop_browser)\n    if 'spynner' == browser_type:\n        start_spynner_browser(url)\n    elif 'chrome' == browser_type:\n        start_chrome_browser(url)\n    elif 'remote' == browser_type:\n        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))\n        start_remote_browser(url, command_executor)\n    else:\n        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))\n\n\ndef start_spynner_browser(url, visible=False):\n    test = get_executing_test()\n    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)\n    if visible:\n        test.spynner_browser.show(maximized=False)\n    try:\n        test.spynner_browser.load(url)\n    except:\n        pass\n    while test.spynner_browser:\n        try:\n            test.spynner_browser._events_loop()\n        except KeyboardInterrupt:\n            test.error = 'keyboard interrupt'\n        check_is_test_failed(test)\n\n\ndef start_chrome_browser(url):\n    test = get_executing_test()\n    old_cwd = os.getcwd()\n    os.chdir('/tmp')\n    test.webdriver = selenium.webdriver.Chrome()\n    os.chdir(old_cwd)\n    test.webdriver.get(url)\n    while test.webdriver:\n        try:\n            time.sleep(0.1)\n        except KeyboardInterrupt:\n            test.error = 'keyboard interrupt'\n        check_is_test_failed(test)\n\n\ndef start_remote_browser(url, command_executor):\n    test = get_executing_test()\n    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER\n    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)\n    test.webdriver.get(url)\n    while test.webdriver:\n        try:\n            time.sleep(0.1)\n        except KeyboardInterrupt:\n            test.error = 'keyboard interrupt'\n        check_is_test_failed(test)\n\n\ndef check_is_test_failed(test):\n    message = getattr(test, 'error', None)\n    if message is not None:\n        stop_browser()\n        LOGGER.info('Latest page: {}'.format(latest_page))\n        test.fail(message)\n\n\ndef stop_browser():\n    test = get_executing_test()\n    if 'spynner' == test.browser_type:\n        stop_spynner_browser()\n    elif test.browser_type in ['chrome', 'remote']:\n        stop_webdriver()\n    else:\n        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))\n\n\ndef stop_spynner_browser():\n    test = get_executing_test()\n    browser = test.spynner_browser\n    if browser:\n        test.spynner_browser = None\n        browser.close()\n\n\ndef stop_webdriver():\n    test = get_executing_test()\n    webdriver = getattr(test, 'webdriver', None)\n    if webdriver:\n        test.webdriver = None\n        webdriver.close()\n\n\ndef inject_page_interaction(html, page_interactions):\n    global latest_page\n    request = get_current_http_request()\n    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):\n        return html\n    if request.path.startswith('/-test/'):\n        return html\n    if not page_interactions:\n        return html\n    fragment = lxml.html.document_fromstring(html)\n    script = fragment.makeelement(\n        'script', attrib={\n            'type': 'text/javascript',\n            'src': '/-test/veil-test.js'\n        })\n    fragment.find('body').append(script)\n    script = fragment.makeelement(\n        'script', attrib={'type': 'text/javascript'})\n    script.text =\\\n    \"\"\"\n    $(document).ready(function() {\n        %s\n    });\n    \"\"\" % page_interactions.pop()\n    fragment.find('body').append(script)\n    latest_page = open_closed_tags(lxml.html.tostring(fragment, method='xml'))\n    return latest_page/n/n/nsrc/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport contextlib\nimport httplib\nimport uuid\nfrom logging import getLogger\nfrom markupsafe import Markup\nfrom veil.frontend.template import template_utility\nfrom veil.frontend.web.tornado import *\nfrom tornado.escape import xhtml_escape\n\nLOGGER = getLogger(__name__)\n\n@contextlib.contextmanager\ndef prevent_xsrf():\n    request = get_current_http_request()\n    response = get_current_http_response()\n    if not hasattr(request, '_xsrf_token'):\n        token = get_cookie(name='_xsrf', request=request)\n        if not token:\n            token = uuid.uuid4().get_hex()\n            LOGGER.debug('assign XSRF token {} from {} {}'.format(token, request.method, request.path))\n        request._xsrf_token = token\n    if 'GET' != request.method.upper():\n        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)\n        if not token:\n            response.status_code = httplib.FORBIDDEN\n            LOGGER.warn('XSRF token missing, request: {}'.format(request))\n            raise HTTPError(403, 'XSRF token missing')\n        expected_token = xsrf_token()\n        if expected_token != token:\n            LOGGER.debug('expected token: {}'.format(expected_token))\n            LOGGER.debug('actual token: {}'.format(token))\n            LOGGER.warn('XSRF token invalid, request: {}'.format(request))\n            raise HTTPError(403, 'XSRF token invalid')\n    request.arguments.pop('_xsrf', None)\n    yield\n\n\n@template_utility\ndef xsrf_token(request=None):\n    request = request or get_current_http_request()\n    assert request._xsrf_token is not None\n    return request._xsrf_token\n\n\n@template_utility\ndef xsrf_field():\n    return Markup('<input type=\"hidden\" name=\"_xsrf\" value=\"{}\"/>'.format(xhtml_escape(xsrf_token())))/n/n/nsrc/veil/model/binding/__init__.py/n/nimport veil.component\n\nwith veil.component.init_component(__name__):\n    from .invalid import Invalid\n    from .field_binder import not_empty\n    from .field_binder import one_of\n    from .field_binder import clamp_length\n    from .field_binder import clamp\n    from .field_binder import not_duplicate\n    from .field_binder import anything\n    from .field_binder import is_not\n    from .field_binder import is_email\n    from .field_binder import is_mobile\n    from .field_binder import is_landline\n    from .field_binder import is_list\n    from .field_binder import to_integer\n    from .field_binder import to_float\n    from .field_binder import to_bool\n    from .field_binder import to_date\n    from .field_binder import to_time\n    from .field_binder import to_datetime\n    from .field_binder import to_datetime_via_parse\n    from .field_binder import to_datetime_with_minute_precision_from_iso8601\n    from .field_binder import to_timezone\n    from .binder_maker import each\n    from .binder_maker import optional\n    from .object_binder import ObjectBinder\n\n    __all__ = [\n        # from invalid\n        Invalid.__name__,\n        # from field_binder\n        not_empty.__name__,\n        one_of.__name__,\n        clamp_length.__name__,\n        clamp.__name__,\n        not_duplicate.__name__,\n        anything.__name__,\n        is_not.__name__,\n        is_email.__name__,\n        is_mobile.__name__,\n        is_landline.__name__,\n        is_list.__name__,\n        to_integer.__name__,\n        to_float.__name__,\n        to_bool.__name__,\n        to_date.__name__,\n        to_time.__name__,\n        to_datetime.__name__,\n        to_datetime_via_parse.__name__,\n        to_datetime_with_minute_precision_from_iso8601.__name__,\n        to_timezone.__name__,\n        # from binder_maker\n        each.__name__,\n        optional.__name__,\n        # from object_binder\n        ObjectBinder.__name__\n    ]\n/n/n/nsrc/veil/model/binding/field_binder.py/n/n# -*- coding: utf-8 -*-\n\"\"\"\nfield binder takes single value and returns transformed single value in expected case\notherwise throw Invalid exception\n\"\"\"\nfrom __future__ import unicode_literals, print_function, division\nimport re\nfrom datetime import datetime, time\nimport pytz\nfrom pytz import timezone, UnknownTimeZoneError\nfrom dateutil.parser import parse\nfrom veil.model.binding.invalid import Invalid\n\n\n_EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9_=%.+-]+@([a-zA-Z0-9_=%+-]+\\.)+[a-zA-Z]{2,6}$')\n\n# reference to http://www.cnfgg.com/article/Asp/Asp_phoneCheck.htm\n_MOBILE_PATTERN = re.compile(r'^0?1[3458]\\d{9}$')\n_LANDLIINE_PATTERN = re.compile(r'^(\\d{2,4}[-.\\s_\uff0d\u2014]?)?\\d{3,8}([-.\\s_\uff0d\u2014]?\\d{3,8})?([-.\\s_\uff0d\u2014]?\\d{1,7})?$')\n\n\ndef anything(value):\n    return value\n\n\ndef is_not(v):\n    def bind(value):\n        if value == bind.v:\n            raise Invalid('{}{}'.format(_('\u4e0d\u80fd\u662f\uff1a'), bind.v))\n        return value\n    bind.v = v\n    return bind\n\n\ndef not_empty(value):\n    if value is not None and value != '':\n        return value\n    raise Invalid(_('\u4e0d\u80fd\u4e3a\u7a7a'))\n\n\ndef is_list(value):\n    if isinstance(value, (list, tuple)):\n        return value\n    raise Invalid(_('\u503c\u4e0d\u4e3a\u5217\u8868'))\n\n\ndef one_of(seq):\n    assert seq is not None\n    def bind(value):\n        if value not in bind.seq:\n            raise Invalid(_('\u503c\u4e0d\u5728\u8303\u56f4\u4e4b\u5185'))\n        return value\n    bind.seq = seq\n    return bind\n\n\ndef is_email(value):\n    if _EMAIL_PATTERN.match(value) is None:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u7535\u5b50\u90ae\u4ef6\u5730\u5740'))\n    return value\n\n\ndef is_mobile(value):\n    if _MOBILE_PATTERN.match(value) is None:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u79fb\u52a8\u7535\u8bdd\u53f7\u7801'))\n    return value\n\n\ndef is_landline(value):\n    if _LANDLIINE_PATTERN.match(value) is None:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u5ea7\u673a\u53f7\u7801'))\n    return value\n\n\ndef to_integer(value):\n    try:\n        return int(value)\n    except (TypeError, ValueError):\n        raise Invalid(_('\u4e0d\u662f\u6574\u6570'))\n\n\ndef to_float(value):\n    try:\n        return float(value)\n    except (TypeError, ValueError):\n        raise Invalid(_('\u4e0d\u662f\u5c0f\u6570'))\n\n\ndef to_bool(value):\n    if value in ['0', 'false', 'False']:\n        return False\n    return bool(value)\n\n\ndef to_time(value):\n    try:\n        dt = datetime.strptime(value, '%I:%M %p')\n    except ValueError:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u65f6\u95f4'))\n    else:\n        return time(dt.hour, dt.minute)\n\n\ndef to_date(format='%Y-%m-%d'):\n    def bind(value):\n        if isinstance(value, datetime):\n            return value.date()\n        try:\n            dt = datetime.strptime(value, bind.format)\n        except ValueError:\n            raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u65e5\u671f'))\n        else:\n            return dt.date()\n    bind.format = format\n    return bind\n\n\ndef to_datetime_via_parse(value):\n    try:\n        return parse(value, yearfirst=True)\n    except ValueError:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u65e5\u671f\u65f6\u95f4'))\n\n\ndef to_datetime(format='%Y-%m-%d %H:%M:%S'):\n    def bind(value):\n        if isinstance(value, datetime):\n            return value\n        else:\n            try:\n                return datetime.strptime(value, bind.format)\n            except ValueError:\n                raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u65e5\u671f\u65f6\u95f4'))\n    bind.format = format\n    return bind\n\n\nISO8601_REGEX = re.compile(r'(?P<year>[0-9]{4})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2}) (?P<hour>[0-9]{2}):(?P<minute>[0-9]{2}) ?(?P<prefix>[+-])(?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})')\n\ndef to_datetime_with_minute_precision_from_iso8601(value):\n    \"\"\"\n    Valid formats:\n        YYYY-MM-DD hh:mm \u00b1hh:mm\n        YYYY-MM-DD hh:mm \u00b1hhmm\n        YYYY-MM-DD hh:mm\u00b1hhmm\n    \"\"\"\n    try:\n        m = ISO8601_REGEX.match(value)\n        if not m:\n            raise Exception('Unable to parse date string %r' % value)\n        groups = m.groupdict()\n        hours, minutes = int(groups['hours']), int(groups['minutes'])\n        if groups['prefix'] == '-':\n            hours = -hours\n            minutes = -minutes\n        tz = pytz.FixedOffset(hours * 60 + minutes)\n        return datetime(int(groups['year']), int(groups['month']), int(groups['day']), int(groups['hour']),\n            int(groups['minute']), tzinfo=tz)\n    except:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u65e5\u671f\u65f6\u95f4'))\n\n\ndef to_timezone(value):\n    try:\n        return timezone(value)\n    except UnknownTimeZoneError:\n        raise Invalid(_('\u4e0d\u662f\u6709\u6548\u7684\u65f6\u533a'))\n\n\ndef clamp_length(min=None, max=None):\n    \"\"\"\n    clamp a value between minimum and maximum lengths (either\n    of which are optional).\n    \"\"\"\n    def bind(value):\n        value_length = len(value)\n        if bind.min is not None and value_length < bind.min:\n            raise Invalid(_('\u503c\u8d85\u51fa\u8303\u56f4'))\n        if bind.max is not None and value_length > bind.max:\n            raise Invalid(_('\u503c\u8d85\u51fa\u8303\u56f4'))\n        return value\n    bind.min = min\n    bind.max = max\n    return bind\n\ndef clamp(min=None, max=None):\n    \"\"\"\n    clamp a value between minimum and maximum lengths (either\n    of which are optional).\n    \"\"\"\n    def bind(value):\n        if bind.min is not None and value < bind.min:\n            raise Invalid(_('\u503c\u8d85\u51fa\u8303\u56f4'))\n        if bind.max is not None and value > bind.max:\n            raise Invalid(_('\u503c\u8d85\u51fa\u8303\u56f4'))\n        return value\n    bind.min = min\n    bind.max = max\n    return bind\n\n\ndef not_duplicate(value):\n    if len(set(value)) != len(value):\n        raise Invalid(_('\u6709\u91cd\u590d\u503c'))\n    return value/n/n/n", "label": 0}, {"id": "2b70b391b0792c90ed71fd23ab36a6b7c60fb1e5", "code": "/src/veil/development/browser/browser.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport logging\nimport threading\nimport time\nimport traceback\nimport lxml.html\nimport os.path\nimport spynner\nimport selenium.webdriver\nimport os\nfrom veil.utility.path import *\nfrom veil.development.test import *\nfrom veil.profile.web import *\nfrom veil.frontend.web.static_file import *\n\nLOGGER = logging.getLogger(__name__)\n\ndef start_website_and_browser(website, path, page_interactions, timeout=60, browser='spynner'):\n    @route('POST', '/-test/stop', website=website)\n    def stop_test():\n        stop_browser()\n\n    @route('POST', '/-test/fail', website=website)\n    def fail_test():\n        message = get_http_argument('message')\n        LOGGER.error(message)\n        get_executing_test().error = message\n\n    @route('POST', '/-test/log', website=website)\n    def log_from_test():\n        LOGGER.info(get_http_argument('message'))\n\n    @route('GET', '/-test/veil-test.js', website=website)\n    def veil_test_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'veil-test.js').text()\n\n    @route('GET', '/-test/jquery.js', website=website)\n    def jquery_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'jquery.js').text()\n\n    @route('GET', '/-test/jquery-cookie.js', website=website)\n    def jquery_cookie_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'jquery-cookie.js').text()\n\n    @route('GET', '/-test/veil.js', website=website)\n    def veil_js():\n        get_current_http_response().set_header('Content-Type', 'text/javascript; charset=utf-8')\n        return (as_path(__file__).dirname() / 'veil.js').text()\n\n    page_interactions = list(reversed(page_interactions))\n    register_page_post_processor(lambda page_handler, html: inject_page_interaction(html, page_interactions))\n    http_server = start_test_website(website)\n    domain = get_website_option(website, 'domain')\n    if domain:\n        url = 'http://{}{}'.format(domain, path)\n    else:\n        url = 'http://{}:{}{}'.format(http_server.host, http_server.port, path)\n    threading.Thread(target=lambda: execute_io_loop(timeout)).start()\n    start_browser(url, browser)\n\n\ndef execute_io_loop(timeout):\n    get_executing_test().addCleanup(require_io_loop_executor().stop)\n    try:\n        require_io_loop_executor().execute(timeout=timeout)\n    except:\n        get_executing_test().error = traceback.format_exc()\n        raise\n\n\ndef start_browser(url, browser_type):\n    if os.getenv('VEIL_REMOTE_BROWSER'):\n        browser_type = 'remote'\n    get_executing_test().browser_type = browser_type\n    test = get_executing_test()\n    test.addCleanup(stop_browser)\n    if 'spynner' == browser_type:\n        start_spynner_browser(url)\n    elif 'chrome' == browser_type:\n        start_chrome_browser(url)\n    elif 'remote' == browser_type:\n        command_executor = 'http://{}:4444/wd/hub'.format(os.getenv('VEIL_REMOTE_BROWSER'))\n        start_remote_browser(url, command_executor)\n    else:\n        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))\n\n\ndef start_spynner_browser(url, visible=False):\n    test = get_executing_test()\n    test.spynner_browser = spynner.Browser(debug_level=spynner.DEBUG)\n    if visible:\n        test.spynner_browser.show(maximized=False)\n    try:\n        test.spynner_browser.load(url)\n    except:\n        pass\n    while test.spynner_browser:\n        try:\n            test.spynner_browser._events_loop()\n        except KeyboardInterrupt:\n            test.error = 'keyboard interrupt'\n        check_is_test_failed(test)\n\n\ndef start_chrome_browser(url):\n    test = get_executing_test()\n    old_cwd = os.getcwd()\n    os.chdir('/tmp')\n    test.webdriver = selenium.webdriver.Chrome()\n    os.chdir(old_cwd)\n    test.webdriver.get(url)\n    while test.webdriver:\n        try:\n            time.sleep(0.1)\n        except KeyboardInterrupt:\n            test.error = 'keyboard interrupt'\n        check_is_test_failed(test)\n\n\ndef start_remote_browser(url, command_executor):\n    test = get_executing_test()\n    capabilities = selenium.webdriver.DesiredCapabilities.INTERNETEXPLORER\n    test.webdriver = selenium.webdriver.Remote(command_executor, desired_capabilities=capabilities)\n    test.webdriver.get(url)\n    while test.webdriver:\n        try:\n            time.sleep(0.1)\n        except KeyboardInterrupt:\n            test.error = 'keyboard interrupt'\n        check_is_test_failed(test)\n\n\ndef check_is_test_failed(test):\n    message = getattr(test, 'error', None)\n    if message is not None:\n        stop_browser()\n        test.fail(message)\n\n\ndef stop_browser():\n    test = get_executing_test()\n    if 'spynner' == test.browser_type:\n        stop_spynner_browser()\n    elif test.browser_type in ['chrome', 'remote']:\n        stop_webdriver()\n    else:\n        raise NotImplementedError('unknown browser type: {}'.format(test.browser_type))\n\n\ndef stop_spynner_browser():\n    test = get_executing_test()\n    browser = test.spynner_browser\n    if browser:\n        test.spynner_browser = None\n        browser.close()\n\n\ndef stop_webdriver():\n    test = get_executing_test()\n    webdriver = getattr(test, 'webdriver', None)\n    if webdriver:\n        test.webdriver = None\n        webdriver.close()\n\n\ndef inject_page_interaction(html, page_interactions):\n    request = get_current_http_request()\n    if 'XMLHttpRequest' == request.headers.get('X-Requested-With', None):\n        return html\n    if request.path.startswith('/-test/'):\n        return html\n    if not page_interactions:\n        return html\n    fragment = lxml.html.document_fromstring(html)\n    script = fragment.makeelement(\n        'script', attrib={\n            'type': 'text/javascript',\n            'src': '/-test/veil-test.js'\n        })\n    fragment.find('body').append(script)\n    script = fragment.makeelement(\n        'script', attrib={'type': 'text/javascript'})\n    script.text =\\\n    \"\"\"\n    $(document).ready(function() {\n        %s\n    });\n    \"\"\" % page_interactions.pop()\n    fragment.find('body').append(script)\n    return open_closed_tags(lxml.html.tostring(fragment, method='xml'))/n/n/n", "label": 1}, {"id": "87009916aaa8086704dd5d9bd99dd858278c1234", "code": "src/veil/frontend/web/website_launcher.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport logging\nimport argparse\nfrom jinja2.loaders import FileSystemLoader\nfrom veil.frontend.template import *\nfrom veil.frontend.cli import *\nfrom veil.environment import *\nfrom veil.environment.setting import *\nfrom .tornado import *\nfrom .locale import *\nfrom .routing import  *\nfrom .static_file import *\nfrom .xsrf import *\nfrom .web_installer import load_website_config\n\nLOGGER = logging.getLogger(__name__)\n\nadditional_context_managers = {}\n\ndef register_website_context_manager(website, context_manager):\n    additional_context_managers.setdefault(website.lower(), []).append(context_manager)\n\n\n@script('up')\ndef bring_up_website(*argv):\n    argument_parser = argparse.ArgumentParser('Website')\n    argument_parser.add_argument('purpose', help='which website to bring up')\n    argument_parser.add_argument('--dependency', type=str,\n        help='where @periodic_job is defined', nargs='+', dest='dependencies')\n    args = argument_parser.parse_args(argv)\n    for dependency in args.dependencies:\n        __import__(dependency)\n    start_website(args.purpose)\n\n\ndef start_test_website(purpose, **kwargs):\n    config = load_website_config(purpose)\n    http_handler = create_website_http_handler(purpose, config, **kwargs)\n    http_server = start_test_http_server(\n        http_handler,\n        host=config.host,\n        port=config.port)\n    http_server.purpose = purpose\n    return http_server\n\n\ndef start_website(purpose):\n    config = load_website_config(purpose)\n    http_handler = create_website_http_handler(purpose, config)\n    io_loop = IOLoop.instance()\n    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))\n    start_http_server(\n        http_handler, io_loop=io_loop,\n        host=config.host, port=config.port)\n\n\ndef create_website_http_handler(purpose, config):\n    locale_provider = lambda: None\n    if config.secure_cookie_salt:\n        set_secure_cookie_salt(config.secure_cookie_salt)\n    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')\n    set_external_static_files_directory(VEIL_HOME / 'static')\n    master_template_directory = config.master_template_directory\n    if master_template_directory:\n        register_template_loader('master', FileSystemLoader(master_template_directory))\n    website_context_managers = [create_stack_context(install_translations, locale_provider)]\n    if config.prevents_xsrf:\n        register_page_post_processor(set_xsrf_cookie_for_page)\n        website_context_managers.append(prevent_xsrf)\n    if config.recalculates_static_file_hash:\n        website_context_managers.append(clear_static_file_hashes)\n    if config.clears_template_cache:\n        website_context_managers.append(clear_template_caches)\n    website_context_managers.extend(additional_context_managers.get(purpose, []))\n    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)\n/n/n/n", "label": 0}, {"id": "87009916aaa8086704dd5d9bd99dd858278c1234", "code": "/src/veil/frontend/web/website_launcher.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport logging\nimport argparse\nfrom jinja2.loaders import FileSystemLoader\nfrom veil.frontend.template import *\nfrom veil.frontend.cli import *\nfrom veil.environment import *\nfrom veil.environment.setting import *\nfrom .tornado import *\nfrom .locale import *\nfrom .routing import  *\nfrom .static_file import *\nfrom .xsrf import *\nfrom .web_installer import load_website_config\n\nLOGGER = logging.getLogger(__name__)\n\nadditional_context_managers = {}\n\ndef register_website_context_manager(website, context_manager):\n    additional_context_managers.setdefault(website.lower(), []).append(context_manager)\n\n\n@script('up')\ndef bring_up_website(*argv):\n    argument_parser = argparse.ArgumentParser('Website')\n    argument_parser.add_argument('purpose', help='which website to bring up')\n    argument_parser.add_argument('--dependency', type=str,\n        help='where @periodic_job is defined', nargs='+', dest='dependencies')\n    args = argument_parser.parse_args(argv)\n    for dependency in args.dependencies:\n        __import__(dependency)\n    start_website(args.purpose)\n\n\ndef start_test_website(purpose, **kwargs):\n    config = load_website_config(purpose)\n    http_handler = create_website_http_handler(purpose, **kwargs)\n    http_server = start_test_http_server(\n        http_handler,\n        host=config.host,\n        port=config.port)\n    http_server.purpose = purpose\n    return http_server\n\n\ndef start_website(purpose):\n    config = load_website_config(purpose)\n    http_handler = create_website_http_handler(purpose, config)\n    io_loop = IOLoop.instance()\n    io_loop.add_callback(lambda: LOGGER.info('started website {}'.format(purpose)))\n    start_http_server(\n        http_handler, io_loop=io_loop,\n        host=config.host, port=config.port)\n\n\ndef create_website_http_handler(purpose, config):\n    locale_provider = lambda: None\n    if config.secure_cookie_salt:\n        set_secure_cookie_salt(config.secure_cookie_salt)\n    set_inline_static_files_directory(VEIL_VAR_DIR / 'inline-static-files')\n    set_external_static_files_directory(VEIL_HOME / 'static')\n    master_template_directory = config.master_template_directory\n    if master_template_directory:\n        register_template_loader('master', FileSystemLoader(master_template_directory))\n    website_context_managers = [create_stack_context(install_translations, locale_provider)]\n    if config.prevents_xsrf:\n        register_page_post_processor(set_xsrf_cookie_for_page)\n        website_context_managers.append(prevent_xsrf)\n    if config.recalculates_static_file_hash:\n        website_context_managers.append(clear_static_file_hashes)\n    if config.clears_template_cache:\n        website_context_managers.append(clear_template_caches)\n    website_context_managers.extend(additional_context_managers.get(purpose, []))\n    return RoutingHTTPHandler(get_routes(purpose), website_context_managers)\n/n/n/n", "label": 1}, {"id": "21a72f4ce71f05b6e574f2f3e564c087870f7314", "code": "src/veil/frontend/web/__init__.py/n/nimport veil_component\n\nwith veil_component.init_component(__name__):\n    from .website_launcher import start_website\n    from .website_launcher import start_test_website\n    from .website_launcher import register_website_context_manager\n    from .website_installer import get_website_url_prefix\n    from .website_installer import website_resource\n    from .client import start_website_and_client\n    from .routing import route\n    from .routing import route_for\n    from .routing import async_route\n    from .routing import public_route\n    from .routing import is_public_route\n    from .routing import RoutingHTTPHandler\n    from .routing import get_routes\n    from .routing import register_page_post_processor\n    from .routing import TAG_NO_POST_PROCESS\n    from .routing import publish_new_website_event\n    from .static_file import static_url\n    from .static_file import process_script_elements\n    from .tornado import get_current_http_context\n    from .tornado import get_current_http_request\n    from .tornado import get_current_http_response\n    from .tornado import start_http_server\n    from .tornado import start_test_http_server\n    from .tornado import create_stack_context\n    from .tornado import set_http_status_code\n    from .tornado import HTTPError\n    from .tornado import end_http_request_processing\n    from .tornado import get_secure_cookie\n    from .tornado import set_secure_cookie\n    from .tornado import get_cookies\n    from .tornado import get_cookie\n    from .tornado import clear_cookies\n    from .tornado import clear_cookie\n    from .tornado import set_cookie\n    from .tornado import redirect_to\n    from .tornado import get_http_argument\n    from .tornado import get_http_arguments\n    from .tornado import get_http_file\n    from .tornado import get_http_files\n    from .tornado import delete_http_argument\n    from .tornado import clear_http_arguments\n    from .tornado import require_io_loop_executor\n    from .xsrf import xsrf_token\n    from .xsrf import TAG_NO_XSRF_CHECK\n\n    __all__ = [\n        # from website\n        start_website.__name__,\n        start_test_website.__name__,\n        register_website_context_manager.__name__,\n        # from website_installer\n        get_website_url_prefix.__name__,\n        website_resource.__name__,\n        # from client\n        start_website_and_client.__name__,\n        # from routing\n        route.__name__,\n        route_for.__name__,\n        async_route.__name__,\n        public_route.__name__,\n        is_public_route.__name__,\n        RoutingHTTPHandler.__name__,\n        get_routes.__name__,\n        register_page_post_processor.__name__,\n        'TAG_NO_POST_PROCESS',\n        publish_new_website_event.__name__,\n        # from static_file\n        static_url.__name__,\n        process_script_elements.__name__,\n        # from tornado\n        get_current_http_context.__name__,\n        get_current_http_request.__name__,\n        get_current_http_response.__name__,\n        start_http_server.__name__,\n        start_test_http_server.__name__,\n        create_stack_context.__name__,\n        set_http_status_code.__name__,\n        HTTPError.__name__,\n        end_http_request_processing.__name__,\n        get_secure_cookie.__name__,\n        set_secure_cookie.__name__,\n        get_cookies.__name__,\n        get_cookie.__name__,\n        clear_cookies.__name__,\n        clear_cookie.__name__,\n        set_cookie.__name__,\n        redirect_to.__name__,\n        get_http_argument.__name__,\n        get_http_arguments.__name__,\n        get_http_file.__name__,\n        get_http_files.__name__,\n        delete_http_argument.__name__,\n        clear_http_arguments.__name__,\n        require_io_loop_executor.__name__,\n        # from xsrf\n        xsrf_token.__name__,\n        'TAG_NO_XSRF_CHECK'\n    ]\n/n/n/nsrc/veil/frontend/web/xsrf/__init__.py/n/nimport veil_component\n\nwith veil_component.init_component(__name__):\n    from .xsrf import xsrf_token\n    from .xsrf import prevent_xsrf\n    from .xsrf import set_xsrf_cookie_for_page\n    from .xsrf import TAG_NO_XSRF_CHECK\n\n    __all__ = [\n        # from xsrf\n        xsrf_token.__name__,\n        prevent_xsrf.__name__,\n        set_xsrf_cookie_for_page.__name__,\n        'TAG_NO_XSRF_CHECK'\n    ]/n/n/nsrc/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport contextlib\nimport httplib\nimport uuid\nfrom logging import getLogger\nfrom markupsafe import Markup\nfrom tornado.escape import xhtml_escape\nfrom veil.frontend.template import template_utility\nfrom veil.frontend.web.tornado import *\n\nLOGGER = getLogger(__name__)\nTAG_NO_XSRF_CHECK = 'NO-XSRF'\n\n@contextlib.contextmanager\ndef prevent_xsrf():\n    request = get_current_http_request()\n    response = get_current_http_response()\n    if not hasattr(request, '_xsrf_token'):\n        token = get_cookie(name='_xsrf', request=request)\n        request.is_new_xsrf_token = False\n        if not token:\n            request.is_new_xsrf_token = True\n            token = uuid.uuid4().get_hex()\n            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {\n                'token': token,\n                'method': request.method,\n                'path': request.path\n            })\n        request._xsrf_token = token\n    if 'GET' != request.method.upper() and TAG_NO_XSRF_CHECK not in get_current_http_context().route.tags:\n        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)\n        if not token:\n            response.status_code = httplib.FORBIDDEN\n            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})\n            raise HTTPError(403, 'XSRF token missing')\n        expected_token = xsrf_token()\n        if expected_token != token:\n            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {\n                'request': request,\n                'expected_token': expected_token,\n                'token': token\n            })\n            raise HTTPError(403, 'XSRF token invalid')\n    request.arguments.pop('_xsrf', None)\n    yield\n\n\ndef set_xsrf_cookie_for_page(route_handler, data):\n    if get_current_http_request().is_new_xsrf_token:\n        if data and '<html' in data.lower():\n            # only set to page to avoid concurrent http request issue\n            set_cookie(name='_xsrf', value=xsrf_token())\n    return data\n\n\n@template_utility\ndef xsrf_token(request=None):\n    request = request or get_current_http_request()\n    assert request._xsrf_token is not None\n    return request._xsrf_token\n\n\n@template_utility\ndef xsrf_field():\n    return Markup('<input type=\"hidden\" name=\"_xsrf\" value=\"{}\"/>'.format(xhtml_escape(xsrf_token())))/n/n/n", "label": 0}, {"id": "21a72f4ce71f05b6e574f2f3e564c087870f7314", "code": "/src/veil/frontend/web/__init__.py/n/nimport veil_component\n\nwith veil_component.init_component(__name__):\n    from .website_launcher import start_website\n    from .website_launcher import start_test_website\n    from .website_launcher import register_website_context_manager\n    from .website_installer import get_website_url_prefix\n    from .website_installer import website_resource\n    from .client import start_website_and_client\n    from .routing import route\n    from .routing import route_for\n    from .routing import async_route\n    from .routing import public_route\n    from .routing import is_public_route\n    from .routing import RoutingHTTPHandler\n    from .routing import get_routes\n    from .routing import register_page_post_processor\n    from .routing import TAG_NO_POST_PROCESS\n    from .routing import publish_new_website_event\n    from .static_file import static_url\n    from .static_file import process_script_elements\n    from .tornado import get_current_http_context\n    from .tornado import get_current_http_request\n    from .tornado import get_current_http_response\n    from .tornado import start_http_server\n    from .tornado import start_test_http_server\n    from .tornado import create_stack_context\n    from .tornado import set_http_status_code\n    from .tornado import HTTPError\n    from .tornado import end_http_request_processing\n    from .tornado import get_secure_cookie\n    from .tornado import set_secure_cookie\n    from .tornado import get_cookies\n    from .tornado import get_cookie\n    from .tornado import clear_cookies\n    from .tornado import clear_cookie\n    from .tornado import set_cookie\n    from .tornado import redirect_to\n    from .tornado import get_http_argument\n    from .tornado import get_http_arguments\n    from .tornado import get_http_file\n    from .tornado import get_http_files\n    from .tornado import delete_http_argument\n    from .tornado import clear_http_arguments\n    from .tornado import require_io_loop_executor\n    from .xsrf import xsrf_token\n\n    __all__ = [\n        # from website\n        start_website.__name__,\n        start_test_website.__name__,\n        register_website_context_manager.__name__,\n        # from website_installer\n        get_website_url_prefix.__name__,\n        website_resource.__name__,\n        # from client\n        start_website_and_client.__name__,\n        # from routing\n        route.__name__,\n        route_for.__name__,\n        async_route.__name__,\n        public_route.__name__,\n        is_public_route.__name__,\n        RoutingHTTPHandler.__name__,\n        get_routes.__name__,\n        register_page_post_processor.__name__,\n        'TAG_NO_POST_PROCESS',\n        publish_new_website_event.__name__,\n        # from static_file\n        static_url.__name__,\n        process_script_elements.__name__,\n        # from tornado\n        get_current_http_context.__name__,\n        get_current_http_request.__name__,\n        get_current_http_response.__name__,\n        start_http_server.__name__,\n        start_test_http_server.__name__,\n        create_stack_context.__name__,\n        set_http_status_code.__name__,\n        HTTPError.__name__,\n        end_http_request_processing.__name__,\n        get_secure_cookie.__name__,\n        set_secure_cookie.__name__,\n        get_cookies.__name__,\n        get_cookie.__name__,\n        clear_cookies.__name__,\n        clear_cookie.__name__,\n        set_cookie.__name__,\n        redirect_to.__name__,\n        get_http_argument.__name__,\n        get_http_arguments.__name__,\n        get_http_file.__name__,\n        get_http_files.__name__,\n        delete_http_argument.__name__,\n        clear_http_arguments.__name__,\n        require_io_loop_executor.__name__,\n        # from xsrf\n        xsrf_token.__name__\n    ]\n/n/n/n/src/veil/frontend/web/xsrf/__init__.py/n/nimport veil_component\n\nwith veil_component.init_component(__name__):\n    from .xsrf import xsrf_token\n    from .xsrf import prevent_xsrf\n    from .xsrf import set_xsrf_cookie_for_page\n\n    __all__ = [\n        # from xsrf\n        xsrf_token.__name__,\n        prevent_xsrf.__name__,\n        set_xsrf_cookie_for_page.__name__\n    ]/n/n/n/src/veil/frontend/web/xsrf/xsrf.py/n/nfrom __future__ import unicode_literals, print_function, division\nimport contextlib\nimport httplib\nimport uuid\nfrom logging import getLogger\nfrom markupsafe import Markup\nfrom tornado.escape import xhtml_escape\nfrom veil.frontend.template import template_utility\nfrom veil.frontend.web.tornado import *\n\nLOGGER = getLogger(__name__)\n\n@contextlib.contextmanager\ndef prevent_xsrf():\n    request = get_current_http_request()\n    response = get_current_http_response()\n    if not hasattr(request, '_xsrf_token'):\n        token = get_cookie(name='_xsrf', request=request)\n        request.is_new_xsrf_token = False\n        if not token:\n            request.is_new_xsrf_token = True\n            token = uuid.uuid4().get_hex()\n            LOGGER.debug('assigned XSRF token: %(token)s from %(method)s %(path)s', {\n                'token': token,\n                'method': request.method,\n                'path': request.path\n            })\n        request._xsrf_token = token\n    if 'GET' != request.method.upper():\n        token = get_http_argument('_xsrf', optional=True) or request.headers.get('X-XSRF', None)\n        if not token:\n            response.status_code = httplib.FORBIDDEN\n            LOGGER.warn('XSRF token not found: request is %(request)s', {'request': str(request)})\n            raise HTTPError(403, 'XSRF token missing')\n        expected_token = xsrf_token()\n        if expected_token != token:\n            LOGGER.warn('XSRF token invalid: request is %(request)s, expected is %(expected_token)s, actual is %(token)s', {\n                'request': request,\n                'expected_token': expected_token,\n                'token': token\n            })\n            raise HTTPError(403, 'XSRF token invalid')\n    request.arguments.pop('_xsrf', None)\n    yield\n\n\ndef set_xsrf_cookie_for_page(route_handler, data):\n    if get_current_http_request().is_new_xsrf_token:\n        if data and '<html' in data.lower():\n            # only set to page to avoid concurrent http request issue\n            set_cookie(name='_xsrf', value=xsrf_token())\n    return data\n\n\n@template_utility\ndef xsrf_token(request=None):\n    request = request or get_current_http_request()\n    assert request._xsrf_token is not None\n    return request._xsrf_token\n\n\n@template_utility\ndef xsrf_field():\n    return Markup('<input type=\"hidden\" name=\"_xsrf\" value=\"{}\"/>'.format(xhtml_escape(xsrf_token())))/n/n/n", "label": 1}]